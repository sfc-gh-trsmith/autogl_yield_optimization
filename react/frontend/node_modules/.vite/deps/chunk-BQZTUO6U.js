import {
  Buffer,
  ComputePipeline,
  Log,
  RenderPipeline,
  Sampler,
  Shader,
  Stats,
  Texture,
  TextureView,
  UniformStore,
  WebGLDevice,
  getAttributeInfosFromLayouts,
  getDataType,
  getTypedArrayConstructor,
  getVertexFormatFromAttribute,
  log,
  luma,
  webgl2Adapter
} from "./chunk-DMWPRPWZ.js";
import {
  __commonJS,
  __export,
  __publicField,
  __toESM
} from "./chunk-DC5AMYBS.js";

// browser-external:child_process
var require_child_process = __commonJS({
  "browser-external:child_process"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "child_process" has been externalized for browser compatibility. Cannot access "child_process.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@deck.gl/core/dist/utils/log.js
var defaultLogger = new Log({ id: "deck" });
var log_default = defaultLogger;

// node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-glsl.js
var lightingUniformsGLSL = (
  /* glsl */
  `precision highp int;

// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  vec3 color;
};

struct PointLight {
  vec3 color;
  vec3 position;
  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform lightingUniforms {
  int enabled;
  int lightType;

  int directionalLightCount;
  int pointLightCount;

  vec3 ambientColor;

  vec3 lightColor0;
  vec3 lightPosition0;
  vec3 lightDirection0;
  vec3 lightAttenuation0;

  vec3 lightColor1;
  vec3 lightPosition1;
  vec3 lightDirection1;
  vec3 lightAttenuation1;

  vec3 lightColor2;
  vec3 lightPosition2;
  vec3 lightDirection2;
  vec3 lightAttenuation2;
} lighting;

PointLight lighting_getPointLight(int index) {
  switch (index) {
    case 0:
      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);
    case 1:
      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);
    case 2:
    default:  
      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);
  }
}

DirectionalLight lighting_getDirectionalLight(int index) {
  switch (index) {
    case 0:
      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);
    case 1:
      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);
    case 2:
    default:   
      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);
  }
} 

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

// #endif
`
);

// node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-wgsl.js
var lightingUniformsWGSL = (
  /* wgsl */
  `// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  color: vec3<f32>,
};

struct PointLight {
  color: vec3<f32>,
  position: vec3<f32>,
  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  color: vec3<f32>,
  direction: vec3<f32>,
};

struct lightingUniforms {
  enabled: i32,
  pointLightCount: i32,
  directionalLightCount: i32,

  ambientColor: vec3<f32>,

  // TODO - support multiple lights by uncommenting arrays below
  lightType: i32,
  lightColor: vec3<f32>,
  lightDirection: vec3<f32>,
  lightPosition: vec3<f32>,
  lightAttenuation: vec3<f32>,

  // AmbientLight ambientLight;
  // PointLight pointLight[MAX_LIGHTS];
  // DirectionalLight directionalLight[MAX_LIGHTS];
};

// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)
@binding(1) @group(0) var<uniform> lighting : lightingUniforms;

fn lighting_getPointLight(index: i32) -> PointLight {
  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);
}

fn lighting_getDirectionalLight(index: i32) -> DirectionalLight {
  return DirectionalLight(lighting.lightColor, lighting.lightDirection);
} 

fn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}
`
);

// node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting.js
var MAX_LIGHTS = 5;
var COLOR_FACTOR = 255;
var LIGHT_TYPE;
(function(LIGHT_TYPE2) {
  LIGHT_TYPE2[LIGHT_TYPE2["POINT"] = 0] = "POINT";
  LIGHT_TYPE2[LIGHT_TYPE2["DIRECTIONAL"] = 1] = "DIRECTIONAL";
})(LIGHT_TYPE || (LIGHT_TYPE = {}));
var lighting = {
  props: {},
  uniforms: {},
  name: "lighting",
  defines: {
    // MAX_LIGHTS
  },
  uniformTypes: {
    enabled: "i32",
    lightType: "i32",
    directionalLightCount: "i32",
    pointLightCount: "i32",
    ambientColor: "vec3<f32>",
    // TODO define as arrays once we have appropriate uniformTypes
    lightColor0: "vec3<f32>",
    lightPosition0: "vec3<f32>",
    // TODO - could combine direction and attenuation
    lightDirection0: "vec3<f32>",
    lightAttenuation0: "vec3<f32>",
    lightColor1: "vec3<f32>",
    lightPosition1: "vec3<f32>",
    lightDirection1: "vec3<f32>",
    lightAttenuation1: "vec3<f32>",
    lightColor2: "vec3<f32>",
    lightPosition2: "vec3<f32>",
    lightDirection2: "vec3<f32>",
    lightAttenuation2: "vec3<f32>"
  },
  defaultUniforms: {
    enabled: 1,
    lightType: LIGHT_TYPE.POINT,
    directionalLightCount: 0,
    pointLightCount: 0,
    ambientColor: [0.1, 0.1, 0.1],
    lightColor0: [1, 1, 1],
    lightPosition0: [1, 1, 2],
    // TODO - could combine direction and attenuation
    lightDirection0: [1, 1, 1],
    lightAttenuation0: [1, 0, 0],
    lightColor1: [1, 1, 1],
    lightPosition1: [1, 1, 2],
    lightDirection1: [1, 1, 1],
    lightAttenuation1: [1, 0, 0],
    lightColor2: [1, 1, 1],
    lightPosition2: [1, 1, 2],
    lightDirection2: [1, 1, 1],
    lightAttenuation2: [1, 0, 0]
  },
  source: lightingUniformsWGSL,
  vs: lightingUniformsGLSL,
  fs: lightingUniformsGLSL,
  getUniforms
};
function getUniforms(props, prevUniforms = {}) {
  props = props ? { ...props } : props;
  if (!props) {
    return { ...lighting.defaultUniforms };
  }
  if (props.lights) {
    props = { ...props, ...extractLightTypes(props.lights), lights: void 0 };
  }
  const { ambientLight, pointLights, directionalLights } = props || {};
  const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;
  if (!hasLights) {
    return { ...lighting.defaultUniforms, enabled: 0 };
  }
  const uniforms = {
    ...lighting.defaultUniforms,
    ...prevUniforms,
    ...getLightSourceUniforms({ ambientLight, pointLights, directionalLights })
  };
  if (props.enabled !== void 0) {
    uniforms.enabled = props.enabled ? 1 : 0;
  }
  return uniforms;
}
function getLightSourceUniforms({ ambientLight, pointLights = [], directionalLights = [] }) {
  const lightSourceUniforms = {};
  lightSourceUniforms.ambientColor = convertColor(ambientLight);
  let currentLight = 0;
  for (const pointLight of pointLights) {
    lightSourceUniforms.lightType = LIGHT_TYPE.POINT;
    const i2 = currentLight;
    lightSourceUniforms[`lightColor${i2}`] = convertColor(pointLight);
    lightSourceUniforms[`lightPosition${i2}`] = pointLight.position;
    lightSourceUniforms[`lightAttenuation${i2}`] = pointLight.attenuation || [1, 0, 0];
    currentLight++;
  }
  for (const directionalLight of directionalLights) {
    lightSourceUniforms.lightType = LIGHT_TYPE.DIRECTIONAL;
    const i2 = currentLight;
    lightSourceUniforms[`lightColor${i2}`] = convertColor(directionalLight);
    lightSourceUniforms[`lightDirection${i2}`] = directionalLight.direction;
    currentLight++;
  }
  if (currentLight > MAX_LIGHTS) {
    log.warn("MAX_LIGHTS exceeded")();
  }
  lightSourceUniforms.directionalLightCount = directionalLights.length;
  lightSourceUniforms.pointLightCount = pointLights.length;
  return lightSourceUniforms;
}
function extractLightTypes(lights) {
  var _a3, _b;
  const lightSources = { pointLights: [], directionalLights: [] };
  for (const light of lights || []) {
    switch (light.type) {
      case "ambient":
        lightSources.ambientLight = light;
        break;
      case "directional":
        (_a3 = lightSources.directionalLights) == null ? void 0 : _a3.push(light);
        break;
      case "point":
        (_b = lightSources.pointLights) == null ? void 0 : _b.push(light);
        break;
      default:
    }
  }
  return lightSources;
}
function convertColor(colorDef = {}) {
  const { color = [0, 0, 0], intensity = 1 } = colorDef;
  return color.map((component) => component * intensity / COLOR_FACTOR);
}

// node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-shaders-glsl.js
var PHONG_VS = (
  /* glsl */
  `uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;
`
);
var PHONG_FS = (
  /* glsl */
  `#define MAX_LIGHTS 3

uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
  vec3 halfway_direction = normalize(light_direction + view_direction);
  float lambertian = dot(light_direction, normal_worldspace);
  float specular = 0.0;
  if (lambertian > 0.0) {
    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, material.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  vec3 view_direction = normalize(cameraPosition - position_worldspace);
  lightColor = material.ambient * surfaceColor * lighting.ambientColor;

  for (int i = 0; i < lighting.pointLightCount; i++) {
    PointLight pointLight = lighting_getPointLight(i);
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);
  }

  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);
  for (int i = lighting.pointLightCount; i < totalLights; i++) {
    DirectionalLight directionalLight = lighting_getDirectionalLight(i);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
}
`
);

// node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-shaders-wgsl.js
var PHONG_WGSL = (
  /* wgsl */
  `struct phongMaterialUniforms {
  ambient: f32,
  diffuse: f32,
  shininess: f32,
  specularColor: vec3<f32>,
};

@binding(2) @group(0) var<uniform> phongMaterial : phongMaterialUniforms;

fn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {
  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);
  var lambertian: f32 = dot(light_direction, normal_worldspace);
  var specular: f32 = 0.0;
  if (lambertian > 0.0) {
    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, phongMaterial.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * phongMaterial.diffuse * surfaceColor + specular * phongMaterial.specularColor) * color;
}

fn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {
  var lightColor: vec3<f32> = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);
  lightColor = phongMaterial.ambient * surfaceColor * lighting.ambientColor;

  if (lighting.lightType == 0) {
    let pointLight: PointLight  = lighting_getPointLight(0);
    let light_position_worldspace: vec3<f32> = pointLight.position;
    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  } else if (lighting.lightType == 1) {
    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
  /*
  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.pointLightCount) {
      break;
    }
    PointLight pointLight = lighting.pointLight[i];
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  }

  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.directionalLightCount) {
      break;
    }
    DirectionalLight directionalLight = lighting.directionalLight[i];
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  */
}

fn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{
  var lightColor = vec3<f32>(0, 0, 0);
  let surfaceColor = vec3<f32>(0, 0, 0);

  if (lighting.enabled == 0) {
    let view_direction = normalize(cameraPosition - position_worldspace);

    switch (lighting.lightType) {
      case 0, default: {
        let pointLight: PointLight = lighting_getPointLight(0);
        let light_position_worldspace: vec3<f32> = pointLight.position;
        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
      }
      case 1: {
        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
      }
    }
  }
  return lightColor;
}
`
);

// node_modules/@luma.gl/shadertools/dist/modules/lighting/gouraud-material/gouraud-material.js
var gouraudMaterial = {
  props: {},
  name: "gouraudMaterial",
  // Note these are switched between phong and gouraud
  vs: PHONG_FS.replace("phongMaterial", "gouraudMaterial"),
  fs: PHONG_VS.replace("phongMaterial", "gouraudMaterial"),
  source: PHONG_WGSL.replaceAll("phongMaterial", "gouraudMaterial"),
  defines: {
    LIGHTING_VERTEX: true
  },
  dependencies: [lighting],
  uniformTypes: {
    ambient: "f32",
    diffuse: "f32",
    shininess: "f32",
    specularColor: "vec3<f32>"
  },
  defaultUniforms: {
    ambient: 0.35,
    diffuse: 0.6,
    shininess: 32,
    specularColor: [0.15, 0.15, 0.15]
  },
  getUniforms(props) {
    const uniforms = { ...props };
    if (uniforms.specularColor) {
      uniforms.specularColor = uniforms.specularColor.map((x2) => x2 / 255);
    }
    return { ...gouraudMaterial.defaultUniforms, ...uniforms };
  }
};

// node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-material.js
var phongMaterial = {
  name: "phongMaterial",
  dependencies: [lighting],
  // Note these are switched between phong and gouraud
  source: PHONG_WGSL,
  vs: PHONG_VS,
  fs: PHONG_FS,
  defines: {
    LIGHTING_FRAGMENT: true
  },
  uniformTypes: {
    ambient: "f32",
    diffuse: "f32",
    shininess: "f32",
    specularColor: "vec3<f32>"
  },
  defaultUniforms: {
    ambient: 0.35,
    diffuse: 0.6,
    shininess: 32,
    specularColor: [0.15, 0.15, 0.15]
  },
  getUniforms(props) {
    const uniforms = { ...props };
    if (uniforms.specularColor) {
      uniforms.specularColor = uniforms.specularColor.map((x2) => x2 / 255);
    }
    return { ...phongMaterial.defaultUniforms, ...uniforms };
  }
};

// node_modules/@luma.gl/shadertools/dist/lib/utils/assert.js
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "shadertools: assertion failed.");
  }
}

// node_modules/@luma.gl/shadertools/dist/lib/filters/prop-types.js
var DEFAULT_PROP_VALIDATORS = {
  number: {
    type: "number",
    validate(value, propType) {
      return Number.isFinite(value) && typeof propType === "object" && (propType.max === void 0 || value <= propType.max) && (propType.min === void 0 || value >= propType.min);
    }
  },
  array: {
    type: "array",
    validate(value, propType) {
      return Array.isArray(value) || ArrayBuffer.isView(value);
    }
  }
};
function makePropValidators(propTypes) {
  const propValidators = {};
  for (const [name, propType] of Object.entries(propTypes)) {
    propValidators[name] = makePropValidator(propType);
  }
  return propValidators;
}
function makePropValidator(propType) {
  let type = getTypeOf(propType);
  if (type !== "object") {
    return { value: propType, ...DEFAULT_PROP_VALIDATORS[type], type };
  }
  if (typeof propType === "object") {
    if (!propType) {
      return { type: "object", value: null };
    }
    if (propType.type !== void 0) {
      return { ...propType, ...DEFAULT_PROP_VALIDATORS[propType.type], type: propType.type };
    }
    if (propType.value === void 0) {
      return { type: "object", value: propType };
    }
    type = getTypeOf(propType.value);
    return { ...propType, ...DEFAULT_PROP_VALIDATORS[type], type };
  }
  throw new Error("props");
}
function getTypeOf(value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return "array";
  }
  return typeof value;
}

// node_modules/@luma.gl/shadertools/dist/module-injectors.js
var MODULE_INJECTORS_VS = (
  /* glsl */
  `#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif
`
);
var MODULE_INJECTORS_FS = (
  /* glsl */
  `#ifdef MODULE_MATERIAL
  fragColor = material_filterColor(fragColor);
#endif

#ifdef MODULE_LIGHTING
  fragColor = lighting_filterColor(fragColor);
#endif

#ifdef MODULE_FOG
  fragColor = fog_filterColor(fragColor);
#endif

#ifdef MODULE_PICKING
  fragColor = picking_filterHighlightColor(fragColor);
  fragColor = picking_filterPickingColor(fragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth();
#endif
`
);

// node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-injections.js
var MODULE_INJECTORS = {
  vertex: MODULE_INJECTORS_VS,
  fragment: MODULE_INJECTORS_FS
};
var REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
var REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
var fragments = [];
var DECLARATION_INJECT_MARKER = "__LUMA_INJECT_DECLARATIONS__";
function normalizeInjections(injections) {
  const result = { vertex: {}, fragment: {} };
  for (const hook in injections) {
    let injection = injections[hook];
    const stage = getHookStage(hook);
    if (typeof injection === "string") {
      injection = {
        order: 0,
        injection
      };
    }
    result[stage][hook] = injection;
  }
  return result;
}
function getHookStage(hook) {
  const type = hook.slice(0, 2);
  switch (type) {
    case "vs":
      return "vertex";
    case "fs":
      return "fragment";
    default:
      throw new Error(type);
  }
}
function injectShader(source6, stage, inject, injectStandardStubs = false) {
  const isVertex = stage === "vertex";
  for (const key in inject) {
    const fragmentData = inject[key];
    fragmentData.sort((a2, b2) => a2.order - b2.order);
    fragments.length = fragmentData.length;
    for (let i2 = 0, len5 = fragmentData.length; i2 < len5; ++i2) {
      fragments[i2] = fragmentData[i2].injection;
    }
    const fragmentString = `${fragments.join("\n")}
`;
    switch (key) {
      case "vs:#decl":
        if (isVertex) {
          source6 = source6.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }
        break;
      case "vs:#main-start":
        if (isVertex) {
          source6 = source6.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
        }
        break;
      case "vs:#main-end":
        if (isVertex) {
          source6 = source6.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
        }
        break;
      case "fs:#decl":
        if (!isVertex) {
          source6 = source6.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }
        break;
      case "fs:#main-start":
        if (!isVertex) {
          source6 = source6.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
        }
        break;
      case "fs:#main-end":
        if (!isVertex) {
          source6 = source6.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
        }
        break;
      default:
        source6 = source6.replace(key, (match) => match + fragmentString);
    }
  }
  source6 = source6.replace(DECLARATION_INJECT_MARKER, "");
  if (injectStandardStubs) {
    source6 = source6.replace(/\}\s*$/, (match) => match + MODULE_INJECTORS[stage]);
  }
  return source6;
}

// node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module.js
function initializeShaderModules(modules) {
  modules.map((module) => initializeShaderModule(module));
}
function initializeShaderModule(module) {
  if (module.instance) {
    return;
  }
  initializeShaderModules(module.dependencies || []);
  const {
    propTypes = {},
    deprecations = [],
    // defines = {},
    inject = {}
  } = module;
  const instance = {
    normalizedInjections: normalizeInjections(inject),
    parsedDeprecations: parseDeprecationDefinitions(deprecations)
  };
  if (propTypes) {
    instance.propValidators = makePropValidators(propTypes);
  }
  module.instance = instance;
  let defaultProps3 = {};
  if (propTypes) {
    defaultProps3 = Object.entries(propTypes).reduce((obj, [key, propType]) => {
      const value = propType == null ? void 0 : propType.value;
      if (value) {
        obj[key] = value;
      }
      return obj;
    }, {});
  }
  module.defaultUniforms = { ...module.defaultUniforms, ...defaultProps3 };
}
function checkShaderModuleDeprecations(shaderModule, shaderSource, log4) {
  var _a3;
  (_a3 = shaderModule.deprecations) == null ? void 0 : _a3.forEach((def) => {
    var _a4;
    if ((_a4 = def.regex) == null ? void 0 : _a4.test(shaderSource)) {
      if (def.deprecated) {
        log4.deprecated(def.old, def.new)();
      } else {
        log4.removed(def.old, def.new)();
      }
    }
  });
}
function parseDeprecationDefinitions(deprecations) {
  deprecations.forEach((def) => {
    switch (def.type) {
      case "function":
        def.regex = new RegExp(`\\b${def.old}\\(`);
        break;
      default:
        def.regex = new RegExp(`${def.type} ${def.old};`);
    }
  });
  return deprecations;
}

// node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module-dependencies.js
function getShaderModuleDependencies(modules) {
  initializeShaderModules(modules);
  const moduleMap = {};
  const moduleDepth = {};
  getDependencyGraph({ modules, level: 0, moduleMap, moduleDepth });
  const dependencies = Object.keys(moduleDepth).sort((a2, b2) => moduleDepth[b2] - moduleDepth[a2]).map((name) => moduleMap[name]);
  initializeShaderModules(dependencies);
  return dependencies;
}
function getDependencyGraph(options) {
  const { modules, level, moduleMap, moduleDepth } = options;
  if (level >= 5) {
    throw new Error("Possible loop in shader dependency graph");
  }
  for (const module of modules) {
    moduleMap[module.name] = module;
    if (moduleDepth[module.name] === void 0 || moduleDepth[module.name] < level) {
      moduleDepth[module.name] = level;
    }
  }
  for (const module of modules) {
    if (module.dependencies) {
      getDependencyGraph({ modules: module.dependencies, level: level + 1, moduleMap, moduleDepth });
    }
  }
}

// node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/platform-defines.js
function getPlatformShaderDefines(platformInfo) {
  switch (platformInfo == null ? void 0 : platformInfo.gpu.toLowerCase()) {
    case "apple":
      return (
        /* glsl */
        `#define APPLE_GPU
// Apple optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
      );
    case "nvidia":
      return (
        /* glsl */
        `#define NVIDIA_GPU
// Nvidia optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`
      );
    case "intel":
      return (
        /* glsl */
        `#define INTEL_GPU
// Intel optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
      );
    case "amd":
      return (
        /* glsl */
        `#define AMD_GPU
`
      );
    default:
      return (
        /* glsl */
        `#define DEFAULT_GPU
// Prevent driver from optimizing away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Headless Chrome's software shader 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// If the GPU doesn't have full 32 bits precision, will causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
      );
  }
}

// node_modules/@luma.gl/shadertools/dist/lib/shader-transpiler/transpile-glsl-shader.js
function transpileGLSLShader(source6, stage) {
  var _a3;
  const sourceGLSLVersion = Number(((_a3 = source6.match(/^#version[ \t]+(\d+)/m)) == null ? void 0 : _a3[1]) || 100);
  if (sourceGLSLVersion !== 300) {
    throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");
  }
  switch (stage) {
    case "vertex":
      source6 = convertShader(source6, ES300_VERTEX_REPLACEMENTS);
      return source6;
    case "fragment":
      source6 = convertShader(source6, ES300_FRAGMENT_REPLACEMENTS);
      return source6;
    default:
      throw new Error(stage);
  }
}
var ES300_REPLACEMENTS = [
  // Fix poorly formatted version directive
  [/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, "#version 300 es\n"],
  // The individual `texture...()` functions were replaced with `texture()` overloads
  [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("],
  [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]
];
var ES300_VERTEX_REPLACEMENTS = [
  ...ES300_REPLACEMENTS,
  // `attribute` keyword replaced with `in`
  [makeVariableTextRegExp("attribute"), "in $1"],
  // `varying` keyword replaced with `out`
  [makeVariableTextRegExp("varying"), "out $1"]
];
var ES300_FRAGMENT_REPLACEMENTS = [
  ...ES300_REPLACEMENTS,
  // `varying` keyword replaced with `in`
  [makeVariableTextRegExp("varying"), "in $1"]
];
function convertShader(source6, replacements) {
  for (const [pattern, replacement] of replacements) {
    source6 = source6.replace(pattern, replacement);
  }
  return source6;
}
function makeVariableTextRegExp(qualifier) {
  return new RegExp(`\\b${qualifier}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g");
}

// node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-hooks.js
function getShaderHooks(hookFunctions, hookInjections) {
  let result = "";
  for (const hookName in hookFunctions) {
    const hookFunction = hookFunctions[hookName];
    result += `void ${hookFunction.signature} {
`;
    if (hookFunction.header) {
      result += `  ${hookFunction.header}`;
    }
    if (hookInjections[hookName]) {
      const injections = hookInjections[hookName];
      injections.sort((a2, b2) => a2.order - b2.order);
      for (const injection of injections) {
        result += `  ${injection.injection}
`;
      }
    }
    if (hookFunction.footer) {
      result += `  ${hookFunction.footer}`;
    }
    result += "}\n";
  }
  return result;
}
function normalizeShaderHooks(hookFunctions) {
  const result = { vertex: {}, fragment: {} };
  for (const hookFunction of hookFunctions) {
    let opts;
    let hook;
    if (typeof hookFunction !== "string") {
      opts = hookFunction;
      hook = opts.hook;
    } else {
      opts = {};
      hook = hookFunction;
    }
    hook = hook.trim();
    const [shaderStage, signature] = hook.split(":");
    const name = hook.replace(/\(.+/, "");
    const normalizedHook = Object.assign(opts, { signature });
    switch (shaderStage) {
      case "vs":
        result.vertex[name] = normalizedHook;
        break;
      case "fs":
        result.fragment[name] = normalizedHook;
        break;
      default:
        throw new Error(shaderStage);
    }
  }
  return result;
}

// node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/get-shader-info.js
function getShaderInfo(source6, defaultName) {
  return {
    name: getShaderName(source6, defaultName),
    language: "glsl",
    version: getShaderVersion(source6)
  };
}
function getShaderName(shader, defaultName = "unnamed") {
  const SHADER_NAME_REGEXP = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/;
  const match = SHADER_NAME_REGEXP.exec(shader);
  return match ? match[1] : defaultName;
}
function getShaderVersion(source6) {
  let version2 = 100;
  const words = source6.match(/[^\s]+/g);
  if (words && words.length >= 2 && words[0] === "#version") {
    const parsedVersion = parseInt(words[1], 10);
    if (Number.isFinite(parsedVersion)) {
      version2 = parsedVersion;
    }
  }
  if (version2 !== 100 && version2 !== 300) {
    throw new Error(`Invalid GLSL version ${version2}`);
  }
  return version2;
}

// node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/assemble-shaders.js
var INJECT_SHADER_DECLARATIONS = `

${DECLARATION_INJECT_MARKER}
`;
var FRAGMENT_SHADER_PROLOGUE = (
  /* glsl */
  `precision highp float;
`
);
function assembleWGSLShader(options) {
  const modules = getShaderModuleDependencies(options.modules || []);
  return {
    source: assembleShaderWGSL(options.platformInfo, {
      ...options,
      source: options.source,
      stage: "vertex",
      modules
    }),
    getUniforms: assembleGetUniforms(modules)
  };
}
function assembleGLSLShaderPair(options) {
  const { vs: vs10, fs: fs8 } = options;
  const modules = getShaderModuleDependencies(options.modules || []);
  return {
    vs: assembleShaderGLSL(options.platformInfo, {
      ...options,
      source: vs10,
      stage: "vertex",
      modules
    }),
    fs: assembleShaderGLSL(options.platformInfo, {
      ...options,
      // @ts-expect-error
      source: fs8,
      stage: "fragment",
      modules
    }),
    getUniforms: assembleGetUniforms(modules)
  };
}
function assembleShaderWGSL(platformInfo, options) {
  var _a3;
  const {
    // id,
    source: source6,
    stage,
    modules,
    // defines = {},
    hookFunctions = [],
    inject = {},
    log: log4
  } = options;
  assert(typeof source6 === "string", "shader source must be a string");
  const coreSource = source6;
  let assembledSource = "";
  const hookFunctionMap = normalizeShaderHooks(hookFunctions);
  const hookInjections = {};
  const declInjections = {};
  const mainInjections = {};
  for (const key in inject) {
    const injection = typeof inject[key] === "string" ? { injection: inject[key], order: 0 } : inject[key];
    const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
    if (match) {
      const hash = match[2];
      const name = match[3];
      if (hash) {
        if (name === "decl") {
          declInjections[key] = [injection];
        } else {
          mainInjections[key] = [injection];
        }
      } else {
        hookInjections[key] = [injection];
      }
    } else {
      mainInjections[key] = [injection];
    }
  }
  const modulesToInject = modules;
  for (const module of modulesToInject) {
    if (log4) {
      checkShaderModuleDeprecations(module, coreSource, log4);
    }
    const moduleSource = getShaderModuleSource(module, "wgsl");
    assembledSource += moduleSource;
    const injections = ((_a3 = module.injections) == null ? void 0 : _a3[stage]) || {};
    for (const key in injections) {
      const match = /^(v|f)s:#([\w-]+)$/.exec(key);
      if (match) {
        const name = match[2];
        const injectionType = name === "decl" ? declInjections : mainInjections;
        injectionType[key] = injectionType[key] || [];
        injectionType[key].push(injections[key]);
      } else {
        hookInjections[key] = hookInjections[key] || [];
        hookInjections[key].push(injections[key]);
      }
    }
  }
  assembledSource += INJECT_SHADER_DECLARATIONS;
  assembledSource = injectShader(assembledSource, stage, declInjections);
  assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);
  assembledSource += coreSource;
  assembledSource = injectShader(assembledSource, stage, mainInjections);
  return assembledSource;
}
function assembleShaderGLSL(platformInfo, options) {
  var _a3;
  const { source: source6, stage, language = "glsl", modules, defines: defines2 = {}, hookFunctions = [], inject = {}, prologue = true, log: log4 } = options;
  assert(typeof source6 === "string", "shader source must be a string");
  const sourceVersion = language === "glsl" ? getShaderInfo(source6).version : -1;
  const targetVersion = platformInfo.shaderLanguageVersion;
  const sourceVersionDirective = sourceVersion === 100 ? "#version 100" : "#version 300 es";
  const sourceLines = source6.split("\n");
  const coreSource = sourceLines.slice(1).join("\n");
  const allDefines = {};
  modules.forEach((module) => {
    Object.assign(allDefines, module.defines);
  });
  Object.assign(allDefines, defines2);
  let assembledSource = "";
  switch (language) {
    case "wgsl":
      break;
    case "glsl":
      assembledSource = prologue ? `${sourceVersionDirective}

// ----- PROLOGUE -------------------------
${`#define SHADER_TYPE_${stage.toUpperCase()}`}

${getPlatformShaderDefines(platformInfo)}
${stage === "fragment" ? FRAGMENT_SHADER_PROLOGUE : ""}

// ----- APPLICATION DEFINES -------------------------

${getApplicationDefines(allDefines)}

` : `${sourceVersionDirective}
`;
      break;
  }
  const hookFunctionMap = normalizeShaderHooks(hookFunctions);
  const hookInjections = {};
  const declInjections = {};
  const mainInjections = {};
  for (const key in inject) {
    const injection = typeof inject[key] === "string" ? { injection: inject[key], order: 0 } : inject[key];
    const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
    if (match) {
      const hash = match[2];
      const name = match[3];
      if (hash) {
        if (name === "decl") {
          declInjections[key] = [injection];
        } else {
          mainInjections[key] = [injection];
        }
      } else {
        hookInjections[key] = [injection];
      }
    } else {
      mainInjections[key] = [injection];
    }
  }
  for (const module of modules) {
    if (log4) {
      checkShaderModuleDeprecations(module, coreSource, log4);
    }
    const moduleSource = getShaderModuleSource(module, stage);
    assembledSource += moduleSource;
    const injections = ((_a3 = module.instance) == null ? void 0 : _a3.normalizedInjections[stage]) || {};
    for (const key in injections) {
      const match = /^(v|f)s:#([\w-]+)$/.exec(key);
      if (match) {
        const name = match[2];
        const injectionType = name === "decl" ? declInjections : mainInjections;
        injectionType[key] = injectionType[key] || [];
        injectionType[key].push(injections[key]);
      } else {
        hookInjections[key] = hookInjections[key] || [];
        hookInjections[key].push(injections[key]);
      }
    }
  }
  assembledSource += "// ----- MAIN SHADER SOURCE -------------------------";
  assembledSource += INJECT_SHADER_DECLARATIONS;
  assembledSource = injectShader(assembledSource, stage, declInjections);
  assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);
  assembledSource += coreSource;
  assembledSource = injectShader(assembledSource, stage, mainInjections);
  if (language === "glsl" && sourceVersion !== targetVersion) {
    assembledSource = transpileGLSLShader(assembledSource, stage);
  }
  return assembledSource.trim();
}
function assembleGetUniforms(modules) {
  return function getUniforms5(opts) {
    var _a3;
    const uniforms = {};
    for (const module of modules) {
      const moduleUniforms = (_a3 = module.getUniforms) == null ? void 0 : _a3.call(module, opts, uniforms);
      Object.assign(uniforms, moduleUniforms);
    }
    return uniforms;
  };
}
function getApplicationDefines(defines2 = {}) {
  let sourceText = "";
  for (const define in defines2) {
    const value = defines2[define];
    if (value || Number.isFinite(value)) {
      sourceText += `#define ${define.toUpperCase()} ${defines2[define]}
`;
    }
  }
  return sourceText;
}
function getShaderModuleSource(module, stage) {
  let moduleSource;
  switch (stage) {
    case "vertex":
      moduleSource = module.vs || "";
      break;
    case "fragment":
      moduleSource = module.fs || "";
      break;
    case "wgsl":
      moduleSource = module.source || "";
      break;
    default:
      assert(false);
  }
  if (!module.name) {
    throw new Error("Shader module must have a name");
  }
  const moduleName = module.name.toUpperCase().replace(/[^0-9a-z]/gi, "_");
  let source6 = `// ----- MODULE ${module.name} ---------------

`;
  if (stage !== "wgsl") {
    source6 += `#define MODULE_${moduleName}
`;
  }
  source6 += `${moduleSource}
`;
  return source6;
}

// node_modules/@luma.gl/shadertools/dist/lib/preprocessor/preprocessor.js
var IFDEF_REGEXP = /^\s*\#\s*ifdef\s*([a-zA-Z_]+)\s*$/;
var ENDIF_REGEXP = /^\s*\#\s*endif\s*$/;
function preprocess(source6, options) {
  var _a3;
  const lines = source6.split("\n");
  const output = [];
  let conditional = true;
  let currentDefine = null;
  for (const line of lines) {
    const matchIf = line.match(IFDEF_REGEXP);
    const matchEnd = line.match(ENDIF_REGEXP);
    if (matchIf) {
      currentDefine = matchIf[1];
      conditional = Boolean((_a3 = options == null ? void 0 : options.defines) == null ? void 0 : _a3[currentDefine]);
    } else if (matchEnd) {
      conditional = true;
    } else if (conditional) {
      output.push(line);
    }
  }
  return output.join("\n");
}

// node_modules/@luma.gl/shadertools/dist/lib/shader-assembler.js
var _ShaderAssembler = class _ShaderAssembler {
  constructor() {
    /** Hook functions */
    __publicField(this, "_hookFunctions", []);
    /** Shader modules */
    __publicField(this, "_defaultModules", []);
  }
  /**
   * A default shader assembler instance - the natural place to register default modules and hooks
   * @returns
   */
  static getDefaultShaderAssembler() {
    _ShaderAssembler.defaultShaderAssembler = _ShaderAssembler.defaultShaderAssembler || new _ShaderAssembler();
    return _ShaderAssembler.defaultShaderAssembler;
  }
  /**
   * Add a default module that does not have to be provided with every call to assembleShaders()
   */
  addDefaultModule(module) {
    if (!this._defaultModules.find((m2) => m2.name === (typeof module === "string" ? module : module.name))) {
      this._defaultModules.push(module);
    }
  }
  /**
   * Remove a default module
   */
  removeDefaultModule(module) {
    const moduleName = typeof module === "string" ? module : module.name;
    this._defaultModules = this._defaultModules.filter((m2) => m2.name !== moduleName);
  }
  /**
   * Register a shader hook
   * @param hook
   * @param opts
   */
  addShaderHook(hook, opts) {
    if (opts) {
      hook = Object.assign(opts, { hook });
    }
    this._hookFunctions.push(hook);
  }
  /**
   * Assemble a WGSL unified shader
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleWGSLShader(props) {
    const modules = this._getModuleList(props.modules);
    const hookFunctions = this._hookFunctions;
    const { source: source6, getUniforms: getUniforms5 } = assembleWGSLShader({
      ...props,
      // @ts-expect-error
      source: props.source,
      modules,
      hookFunctions
    });
    const preprocessedSource = props.platformInfo.shaderLanguage === "wgsl" ? preprocess(source6) : source6;
    return { source: preprocessedSource, getUniforms: getUniforms5, modules };
  }
  /**
   * Assemble a pair of shaders into a single shader program
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleGLSLShaderPair(props) {
    const modules = this._getModuleList(props.modules);
    const hookFunctions = this._hookFunctions;
    const assembled = assembleGLSLShaderPair({
      ...props,
      // @ts-expect-error
      vs: props.vs,
      // @ts-expect-error
      fs: props.fs,
      modules,
      hookFunctions
    });
    return { ...assembled, modules };
  }
  /**
   * Dedupe and combine with default modules
   */
  _getModuleList(appModules = []) {
    const modules = new Array(this._defaultModules.length + appModules.length);
    const seen = {};
    let count2 = 0;
    for (let i2 = 0, len5 = this._defaultModules.length; i2 < len5; ++i2) {
      const module = this._defaultModules[i2];
      const name = module.name;
      modules[count2++] = module;
      seen[name] = true;
    }
    for (let i2 = 0, len5 = appModules.length; i2 < len5; ++i2) {
      const module = appModules[i2];
      const name = module.name;
      if (!seen[name]) {
        modules[count2++] = module;
        seen[name] = true;
      }
    }
    modules.length = count2;
    initializeShaderModules(modules);
    return modules;
  }
};
/** Default ShaderAssembler instance */
__publicField(_ShaderAssembler, "defaultShaderAssembler");
var ShaderAssembler = _ShaderAssembler;

// node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/shader-utils.js
var FS_GLES = (
  /* glsl */
  `out vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`
);
var FS300 = `#version 300 es
${FS_GLES}`;
function getPassthroughFS(options) {
  const { input, inputChannels, output } = options || {};
  if (!input) {
    return FS300;
  }
  if (!inputChannels) {
    throw new Error("inputChannels");
  }
  const inputType = channelCountToType(inputChannels);
  const outputValue = convertToVec4(input, inputChannels);
  return `#version 300 es
in ${inputType} ${input};
out vec4 ${output};
void main() {
  ${output} = ${outputValue};
}`;
}
function channelCountToType(channels) {
  switch (channels) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`invalid channels: ${channels}`);
  }
}
function convertToVec4(variable, channels) {
  switch (channels) {
    case 1:
      return `vec4(${variable}, 0.0, 0.0, 1.0)`;
    case 2:
      return `vec4(${variable}, 0.0, 1.0)`;
    case 3:
      return `vec4(${variable}, 1.0)`;
    case 4:
      return variable;
    default:
      throw new Error(`invalid channels: ${channels}`);
  }
}

// node_modules/wgsl_reflect/wgsl_reflect.module.js
var e = class {
  constructor(e3, t2) {
    this.name = e3, this.attributes = t2, this.size = 0;
  }
  get isArray() {
    return false;
  }
  get isStruct() {
    return false;
  }
  get isTemplate() {
    return false;
  }
  get isPointer() {
    return false;
  }
  getTypeName() {
    return this.name;
  }
};
var t = class {
  constructor(e3, t2, n2) {
    this.name = e3, this.type = t2, this.attributes = n2, this.offset = 0, this.size = 0;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray || this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
};
var n = class extends e {
  constructor(e3, t2) {
    super(e3, t2), this.members = [], this.align = 0, this.startLine = -1, this.endLine = -1, this.inUse = false;
  }
  get isStruct() {
    return true;
  }
};
var s = class extends e {
  constructor(e3, t2) {
    super(e3, t2), this.count = 0, this.stride = 0;
  }
  get isArray() {
    return true;
  }
  getTypeName() {
    return `array<${this.format.getTypeName()}, ${this.count}>`;
  }
};
var r = class extends e {
  constructor(e3, t2, n2) {
    super(e3, n2), this.format = t2;
  }
  get isPointer() {
    return true;
  }
  getTypeName() {
    return `&${this.format.getTypeName()}`;
  }
};
var a = class extends e {
  constructor(e3, t2, n2, s2) {
    super(e3, n2), this.format = t2, this.access = s2;
  }
  get isTemplate() {
    return true;
  }
  getTypeName() {
    let e3 = this.name;
    if (null !== this.format) {
      if ("vec2" === e3 || "vec3" === e3 || "vec4" === e3 || "mat2x2" === e3 || "mat2x3" === e3 || "mat2x4" === e3 || "mat3x2" === e3 || "mat3x3" === e3 || "mat3x4" === e3 || "mat4x2" === e3 || "mat4x3" === e3 || "mat4x4" === e3) {
        if ("f32" === this.format.name) return e3 += "f", e3;
        if ("i32" === this.format.name) return e3 += "i", e3;
        if ("u32" === this.format.name) return e3 += "u", e3;
        if ("bool" === this.format.name) return e3 += "b", e3;
        if ("f16" === this.format.name) return e3 += "h", e3;
      }
      e3 += `<${this.format.name}>`;
    } else if ("vec2" === e3 || "vec3" === e3 || "vec4" === e3) return e3;
    return e3;
  }
};
var i;
((e3) => {
  e3[e3.Uniform = 0] = "Uniform", e3[e3.Storage = 1] = "Storage", e3[e3.Texture = 2] = "Texture", e3[e3.Sampler = 3] = "Sampler", e3[e3.StorageTexture = 4] = "StorageTexture";
})(i || (i = {}));
var o = class {
  constructor(e3, t2, n2, s2, r2, a2, i2) {
    this.name = e3, this.type = t2, this.group = n2, this.binding = s2, this.attributes = r2, this.resourceType = a2, this.access = i2;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get size() {
    return this.type.size;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray || this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
};
var c = class {
  constructor(e3, t2) {
    this.name = e3, this.type = t2;
  }
};
var l = class {
  constructor(e3, t2, n2, s2) {
    this.name = e3, this.type = t2, this.locationType = n2, this.location = s2, this.interpolation = null;
  }
};
var u = class {
  constructor(e3, t2, n2, s2) {
    this.name = e3, this.type = t2, this.locationType = n2, this.location = s2;
  }
};
var h = class {
  constructor(e3, t2, n2, s2) {
    this.name = e3, this.type = t2, this.attributes = n2, this.id = s2;
  }
};
var f = class {
  constructor(e3, t2, n2) {
    this.name = e3, this.type = t2, this.attributes = n2;
  }
};
var p = class {
  constructor(e3, t2 = null, n2) {
    this.stage = null, this.inputs = [], this.outputs = [], this.arguments = [], this.returnType = null, this.resources = [], this.overrides = [], this.startLine = -1, this.endLine = -1, this.inUse = false, this.calls = /* @__PURE__ */ new Set(), this.name = e3, this.stage = t2, this.attributes = n2;
  }
};
var d = class {
  constructor() {
    this.vertex = [], this.fragment = [], this.compute = [];
  }
};
function m(e3) {
  var t2 = (32768 & e3) >> 15, n2 = (31744 & e3) >> 10, s2 = 1023 & e3;
  return 0 == n2 ? (t2 ? -1 : 1) * Math.pow(2, -14) * (s2 / Math.pow(2, 10)) : 31 == n2 ? s2 ? NaN : 1 / 0 * (t2 ? -1 : 1) : (t2 ? -1 : 1) * Math.pow(2, n2 - 15) * (1 + s2 / Math.pow(2, 10));
}
var g = new Float32Array(1);
var _ = new Int32Array(g.buffer);
var x = new Uint16Array(1);
function y(e3) {
  g[0] = e3;
  const t2 = _[0], n2 = t2 >> 31 & 1;
  let s2 = t2 >> 23 & 255, r2 = 8388607 & t2;
  if (255 === s2) return x[0] = n2 << 15 | 31744 | (0 !== r2 ? 512 : 0), x[0];
  if (0 === s2) {
    if (0 === r2) return x[0] = n2 << 15, x[0];
    r2 |= 8388608;
    let e4 = 113;
    for (; !(8388608 & r2); ) r2 <<= 1, e4--;
    return s2 = 127 - e4, r2 &= 8388607, s2 > 0 ? (r2 = (r2 >> 126 - s2) + (r2 >> 127 - s2 & 1), x[0] = n2 << 15 | s2 << 10 | r2 >> 13, x[0]) : (x[0] = n2 << 15, x[0]);
  }
  return s2 = s2 - 127 + 15, s2 >= 31 ? (x[0] = n2 << 15 | 31744, x[0]) : s2 <= 0 ? s2 < -10 ? (x[0] = n2 << 15, x[0]) : (r2 = (8388608 | r2) >> 1 - s2, x[0] = n2 << 15 | r2 >> 13, x[0]) : (r2 >>= 13, x[0] = n2 << 15 | s2 << 10 | r2, x[0]);
}
var b = new Uint32Array(1);
var v = new Float32Array(b.buffer, 0, 1);
function w(e3) {
  const t2 = 112 + (e3 >> 6 & 31) << 23 | (63 & e3) << 17;
  return b[0] = t2, v[0];
}
function k(e3, t2, n2, s2, r2, a2, i2, o2, c2) {
  const l2 = s2 * (i2 >>= r2) * (a2 >>= r2) + n2 * i2 + t2 * o2;
  switch (c2) {
    case "r8unorm":
      return [I(e3, l2, "8unorm", 1)[0]];
    case "r8snorm":
      return [I(e3, l2, "8snorm", 1)[0]];
    case "r8uint":
      return [I(e3, l2, "8uint", 1)[0]];
    case "r8sint":
      return [I(e3, l2, "8sint", 1)[0]];
    case "rg8unorm": {
      const t3 = I(e3, l2, "8unorm", 2);
      return [t3[0], t3[1]];
    }
    case "rg8snorm": {
      const t3 = I(e3, l2, "8snorm", 2);
      return [t3[0], t3[1]];
    }
    case "rg8uint": {
      const t3 = I(e3, l2, "8uint", 2);
      return [t3[0], t3[1]];
    }
    case "rg8sint": {
      const t3 = I(e3, l2, "8sint", 2);
      return [t3[0], t3[1]];
    }
    case "rgba8unorm-srgb":
    case "rgba8unorm": {
      const t3 = I(e3, l2, "8unorm", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rgba8snorm": {
      const t3 = I(e3, l2, "8snorm", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rgba8uint": {
      const t3 = I(e3, l2, "8uint", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rgba8sint": {
      const t3 = I(e3, l2, "8sint", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "bgra8unorm-srgb":
    case "bgra8unorm": {
      const t3 = I(e3, l2, "8unorm", 4);
      return [t3[2], t3[1], t3[0], t3[3]];
    }
    case "r16uint":
      return [I(e3, l2, "16uint", 1)[0]];
    case "r16sint":
      return [I(e3, l2, "16sint", 1)[0]];
    case "r16float":
      return [I(e3, l2, "16float", 1)[0]];
    case "rg16uint": {
      const t3 = I(e3, l2, "16uint", 2);
      return [t3[0], t3[1]];
    }
    case "rg16sint": {
      const t3 = I(e3, l2, "16sint", 2);
      return [t3[0], t3[1]];
    }
    case "rg16float": {
      const t3 = I(e3, l2, "16float", 2);
      return [t3[0], t3[1]];
    }
    case "rgba16uint": {
      const t3 = I(e3, l2, "16uint", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rgba16sint": {
      const t3 = I(e3, l2, "16sint", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rgba16float": {
      const t3 = I(e3, l2, "16float", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "r32uint":
      return [I(e3, l2, "32uint", 1)[0]];
    case "r32sint":
      return [I(e3, l2, "32sint", 1)[0]];
    case "depth16unorm":
    case "depth24plus":
    case "depth24plus-stencil8":
    case "depth32float":
    case "depth32float-stencil8":
    case "r32float":
      return [I(e3, l2, "32float", 1)[0]];
    case "rg32uint": {
      const t3 = I(e3, l2, "32uint", 2);
      return [t3[0], t3[1]];
    }
    case "rg32sint": {
      const t3 = I(e3, l2, "32sint", 2);
      return [t3[0], t3[1]];
    }
    case "rg32float": {
      const t3 = I(e3, l2, "32float", 2);
      return [t3[0], t3[1]];
    }
    case "rgba32uint": {
      const t3 = I(e3, l2, "32uint", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rgba32sint": {
      const t3 = I(e3, l2, "32sint", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rgba32float": {
      const t3 = I(e3, l2, "32float", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rg11b10ufloat": {
      const t3 = new Uint32Array(e3.buffer, l2, 1)[0], n3 = (4192256 & t3) >> 11, s3 = (4290772992 & t3) >> 22;
      return [w(2047 & t3), w(n3), function(e4) {
        const t4 = 112 + (e4 >> 5 & 31) << 23 | (31 & e4) << 18;
        return b[0] = t4, v[0];
      }(s3), 1];
    }
  }
  return null;
}
function I(e3, t2, n2, s2) {
  const r2 = [0, 0, 0, 0];
  for (let a2 = 0; a2 < s2; ++a2) switch (n2) {
    case "8unorm":
      r2[a2] = e3[t2] / 255, t2++;
      break;
    case "8snorm":
      r2[a2] = e3[t2] / 255 * 2 - 1, t2++;
      break;
    case "8uint":
      r2[a2] = e3[t2], t2++;
      break;
    case "8sint":
      r2[a2] = e3[t2] - 127, t2++;
      break;
    case "16uint":
      r2[a2] = e3[t2] | e3[t2 + 1] << 8, t2 += 2;
      break;
    case "16sint":
      r2[a2] = (e3[t2] | e3[t2 + 1] << 8) - 32768, t2 += 2;
      break;
    case "16float":
      r2[a2] = m(e3[t2] | e3[t2 + 1] << 8), t2 += 2;
      break;
    case "32uint":
    case "32sint":
      r2[a2] = e3[t2] | e3[t2 + 1] << 8 | e3[t2 + 2] << 16 | e3[t2 + 3] << 24, t2 += 4;
      break;
    case "32float":
      r2[a2] = new Float32Array(e3.buffer, t2, 1)[0], t2 += 4;
  }
  return r2;
}
function T(e3, t2, n2, s2, r2) {
  for (let a2 = 0; a2 < s2; ++a2) switch (n2) {
    case "8unorm":
      e3[t2] = 255 * r2[a2], t2++;
      break;
    case "8snorm":
      e3[t2] = 0.5 * (r2[a2] + 1) * 255, t2++;
      break;
    case "8uint":
      e3[t2] = r2[a2], t2++;
      break;
    case "8sint":
      e3[t2] = r2[a2] + 127, t2++;
      break;
    case "16uint":
      new Uint16Array(e3.buffer, t2, 1)[0] = r2[a2], t2 += 2;
      break;
    case "16sint":
      new Int16Array(e3.buffer, t2, 1)[0] = r2[a2], t2 += 2;
      break;
    case "16float": {
      const n3 = y(r2[a2]);
      new Uint16Array(e3.buffer, t2, 1)[0] = n3, t2 += 2;
      break;
    }
    case "32uint":
      new Uint32Array(e3.buffer, t2, 1)[0] = r2[a2], t2 += 4;
      break;
    case "32sint":
      new Int32Array(e3.buffer, t2, 1)[0] = r2[a2], t2 += 4;
      break;
    case "32float":
      new Float32Array(e3.buffer, t2, 1)[0] = r2[a2], t2 += 4;
  }
  return r2;
}
var S = { r8unorm: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, r8snorm: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, r8uint: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, r8sint: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, rg8unorm: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rg8snorm: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rg8uint: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rg8sint: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rgba8unorm: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, "rgba8unorm-srgb": { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgba8snorm: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgba8uint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgba8sint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, bgra8unorm: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, "bgra8unorm-srgb": { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, r16uint: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, r16sint: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, r16float: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, rg16uint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rg16sint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rg16float: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rgba16uint: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgba16sint: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgba16float: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, r32uint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, r32sint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, r32float: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, rg32uint: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rg32sint: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rg32float: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rgba32uint: { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgba32sint: { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgba32float: { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgb10a2uint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgb10a2unorm: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rg11b10ufloat: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, stencil8: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: false, isDepthStencil: true, hasDepth: false, hasStencil: true, channels: 1 }, depth16unorm: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, isDepthStencil: true, hasDepth: true, hasStencil: false, channels: 1 }, depth24plus: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, isDepthStencil: true, hasDepth: true, hasStencil: false, depthOnlyFormat: "depth32float", channels: 1 }, "depth24plus-stencil8": { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, isDepthStencil: true, hasDepth: true, hasStencil: true, depthOnlyFormat: "depth32float", channels: 1 }, depth32float: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, isDepthStencil: true, hasDepth: true, hasStencil: false, channels: 1 }, "depth32float-stencil8": { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, isDepthStencil: true, hasDepth: true, hasStencil: true, stencilOnlyFormat: "depth32float", channels: 1 }, rgb9e5ufloat: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, "bc1-rgba-unorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc1-rgba-unorm-srgb": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc2-rgba-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc2-rgba-unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc3-rgba-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc3-rgba-unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc4-r-unorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 1 }, "bc4-r-snorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 1 }, "bc5-rg-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 2 }, "bc5-rg-snorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 2 }, "bc6h-rgb-ufloat": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc6h-rgb-float": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc7-rgba-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc7-rgba-unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "etc2-rgb8unorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "etc2-rgb8unorm-srgb": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "etc2-rgb8a1unorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "etc2-rgb8a1unorm-srgb": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "etc2-rgba8unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "etc2-rgba8unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "eac-r11unorm": { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: true, channels: 1 }, "eac-r11snorm": { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: true, channels: 1 }, "eac-rg11unorm": { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: true, channels: 2 }, "eac-rg11snorm": { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: true, channels: 2 }, "astc-4x4-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "astc-4x4-unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "astc-5x4-unorm": { bytesPerBlock: 16, blockWidth: 5, blockHeight: 4, isCompressed: true, channels: 4 }, "astc-5x4-unorm-srgb": { bytesPerBlock: 16, blockWidth: 5, blockHeight: 4, isCompressed: true, channels: 4 }, "astc-5x5-unorm": { bytesPerBlock: 16, blockWidth: 5, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-5x5-unorm-srgb": { bytesPerBlock: 16, blockWidth: 5, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-6x5-unorm": { bytesPerBlock: 16, blockWidth: 6, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-6x5-unorm-srgb": { bytesPerBlock: 16, blockWidth: 6, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-6x6-unorm": { bytesPerBlock: 16, blockWidth: 6, blockHeight: 6, isCompressed: true, channels: 4 }, "astc-6x6-unorm-srgb": { bytesPerBlock: 16, blockWidth: 6, blockHeight: 6, isCompressed: true, channels: 4 }, "astc-8x5-unorm": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-8x5-unorm-srgb": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-8x6-unorm": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 6, isCompressed: true, channels: 4 }, "astc-8x6-unorm-srgb": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 6, isCompressed: true, channels: 4 }, "astc-8x8-unorm": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 8, isCompressed: true, channels: 4 }, "astc-8x8-unorm-srgb": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 8, isCompressed: true, channels: 4 }, "astc-10x5-unorm": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-10x5-unorm-srgb": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-10x6-unorm": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 6, isCompressed: true, channels: 4 }, "astc-10x6-unorm-srgb": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 6, isCompressed: true, channels: 4 }, "astc-10x8-unorm": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 8, isCompressed: true, channels: 4 }, "astc-10x8-unorm-srgb": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 8, isCompressed: true, channels: 4 }, "astc-10x10-unorm": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 10, isCompressed: true, channels: 4 }, "astc-10x10-unorm-srgb": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 10, isCompressed: true, channels: 4 }, "astc-12x10-unorm": { bytesPerBlock: 16, blockWidth: 12, blockHeight: 10, isCompressed: true, channels: 4 }, "astc-12x10-unorm-srgb": { bytesPerBlock: 16, blockWidth: 12, blockHeight: 10, isCompressed: true, channels: 4 }, "astc-12x12-unorm": { bytesPerBlock: 16, blockWidth: 12, blockHeight: 12, isCompressed: true, channels: 4 }, "astc-12x12-unorm-srgb": { bytesPerBlock: 16, blockWidth: 12, blockHeight: 12, isCompressed: true, channels: 4 } };
var A = class _A {
  constructor() {
    this.id = _A._id++, this.line = 0;
  }
  get isAstNode() {
    return true;
  }
  get astNodeType() {
    return "";
  }
  search(e3) {
    e3(this);
  }
  searchBlock(e3, t2) {
    if (e3) {
      t2(E.instance);
      for (const n2 of e3) n2 instanceof Array ? this.searchBlock(n2, t2) : n2.search(t2);
      t2($.instance);
    }
  }
  constEvaluate(e3, t2) {
    throw new Error("Cannot evaluate node");
  }
  constEvaluateString(e3) {
    return this.constEvaluate(e3).toString();
  }
};
A._id = 0;
var E = class extends A {
};
E.instance = new E();
var $ = class extends A {
};
$.instance = new $();
var L = /* @__PURE__ */ new Set(["all", "all", "any", "select", "arrayLength", "abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "clamp", "cos", "cosh", "countLeadingZeros", "countOneBits", "countTrailingZeros", "cross", "degrees", "determinant", "distance", "dot", "dot4U8Packed", "dot4I8Packed", "exp", "exp2", "extractBits", "faceForward", "firstLeadingBit", "firstTrailingBit", "floor", "fma", "fract", "frexp", "insertBits", "inverseSqrt", "ldexp", "length", "log", "log2", "max", "min", "mix", "modf", "normalize", "pow", "quantizeToF16", "radians", "reflect", "refract", "reverseBits", "round", "saturate", "sign", "sin", "sinh", "smoothStep", "sqrt", "step", "tan", "tanh", "transpose", "trunc", "dpdx", "dpdxCoarse", "dpdxFine", "dpdy", "dpdyCoarse", "dpdyFine", "fwidth", "fwidthCoarse", "fwidthFine", "textureDimensions", "textureGather", "textureGatherCompare", "textureLoad", "textureNumLayers", "textureNumLevels", "textureNumSamples", "textureSample", "textureSampleBias", "textureSampleCompare", "textureSampleCompareLevel", "textureSampleGrad", "textureSampleLevel", "textureSampleBaseClampToEdge", "textureStore", "atomicLoad", "atomicStore", "atomicAdd", "atomicSub", "atomicMax", "atomicMin", "atomicAnd", "atomicOr", "atomicXor", "atomicExchange", "atomicCompareExchangeWeak", "pack4x8snorm", "pack4x8unorm", "pack4xI8", "pack4xU8", "pack4x8Clamp", "pack4xU8Clamp", "pack2x16snorm", "pack2x16unorm", "pack2x16float", "unpack4x8snorm", "unpack4x8unorm", "unpack4xI8", "unpack4xU8", "unpack2x16snorm", "unpack2x16unorm", "unpack2x16float", "storageBarrier", "textureBarrier", "workgroupBarrier", "workgroupUniformLoad", "subgroupAdd", "subgroupExclusiveAdd", "subgroupInclusiveAdd", "subgroupAll", "subgroupAnd", "subgroupAny", "subgroupBallot", "subgroupBroadcast", "subgroupBroadcastFirst", "subgroupElect", "subgroupMax", "subgroupMin", "subgroupMul", "subgroupExclusiveMul", "subgroupInclusiveMul", "subgroupOr", "subgroupShuffle", "subgroupShuffleDown", "subgroupShuffleUp", "subgroupShuffleXor", "subgroupXor", "quadBroadcast", "quadSwapDiagonal", "quadSwapX", "quadSwapY"]);
var C = class extends A {
  constructor() {
    super();
  }
};
var D = class extends C {
  constructor(e3, t2, n2, s2, r2, a2) {
    super(), this.calls = /* @__PURE__ */ new Set(), this.name = e3, this.args = t2, this.returnType = n2, this.body = s2, this.startLine = r2, this.endLine = a2;
  }
  get astNodeType() {
    return "function";
  }
  search(e3) {
    if (this.attributes) for (const t2 of this.attributes) e3(t2);
    e3(this);
    for (const t2 of this.args) e3(t2);
    this.searchBlock(this.body, e3);
  }
};
var N = class extends C {
  constructor(e3) {
    super(), this.expression = e3;
  }
  get astNodeType() {
    return "staticAssert";
  }
  search(e3) {
    this.expression.search(e3);
  }
};
var V = class extends C {
  constructor(e3, t2) {
    super(), this.condition = e3, this.body = t2;
  }
  get astNodeType() {
    return "while";
  }
  search(e3) {
    this.condition.search(e3), this.searchBlock(this.body, e3);
  }
};
var O = class extends C {
  constructor(e3, t2) {
    super(), this.body = e3, this.loopId = t2;
  }
  get astNodeType() {
    return "continuing";
  }
  search(e3) {
    this.searchBlock(this.body, e3);
  }
};
var B = class extends C {
  constructor(e3, t2, n2, s2) {
    super(), this.init = e3, this.condition = t2, this.increment = n2, this.body = s2;
  }
  get astNodeType() {
    return "for";
  }
  search(e3) {
    var t2, n2, s2;
    null === (t2 = this.init) || void 0 === t2 || t2.search(e3), null === (n2 = this.condition) || void 0 === n2 || n2.search(e3), null === (s2 = this.increment) || void 0 === s2 || s2.search(e3), this.searchBlock(this.body, e3);
  }
};
var F = class extends C {
  constructor(e3, t2, n2, s2, r2) {
    super(), this.attributes = null, this.name = e3, this.type = t2, this.storage = n2, this.access = s2, this.value = r2;
  }
  get astNodeType() {
    return "var";
  }
  search(e3) {
    var t2;
    e3(this), null === (t2 = this.value) || void 0 === t2 || t2.search(e3);
  }
};
var M = class extends C {
  constructor(e3, t2, n2) {
    super(), this.attributes = null, this.name = e3, this.type = t2, this.value = n2;
  }
  get astNodeType() {
    return "override";
  }
  search(e3) {
    var t2;
    null === (t2 = this.value) || void 0 === t2 || t2.search(e3);
  }
};
var U = class extends C {
  constructor(e3, t2, n2, s2, r2) {
    super(), this.attributes = null, this.name = e3, this.type = t2, this.storage = n2, this.access = s2, this.value = r2;
  }
  get astNodeType() {
    return "let";
  }
  search(e3) {
    var t2;
    e3(this), null === (t2 = this.value) || void 0 === t2 || t2.search(e3);
  }
};
var P = class extends C {
  constructor(e3, t2, n2, s2, r2) {
    super(), this.attributes = null, this.name = e3, this.type = t2, this.storage = n2, this.access = s2, this.value = r2;
  }
  get astNodeType() {
    return "const";
  }
  constEvaluate(e3, t2) {
    return this.value.constEvaluate(e3, t2);
  }
  search(e3) {
    var t2;
    e3(this), null === (t2 = this.value) || void 0 === t2 || t2.search(e3);
  }
};
var W;
var q;
var H;
var z;
((e3) => {
  e3.increment = "++", e3.decrement = "--";
})(W || (W = {})), ((e3) => {
  e3.parse = function(t2) {
    const n2 = t2;
    if ("parse" == n2) throw new Error("Invalid value for IncrementOperator");
    return e3[n2];
  };
})(W || (W = {}));
var R = class extends C {
  constructor(e3, t2) {
    super(), this.operator = e3, this.variable = t2;
  }
  get astNodeType() {
    return "increment";
  }
  search(e3) {
    this.variable.search(e3);
  }
};
((e3) => {
  e3.assign = "=", e3.addAssign = "+=", e3.subtractAssin = "-=", e3.multiplyAssign = "*=", e3.divideAssign = "/=", e3.moduloAssign = "%=", e3.andAssign = "&=", e3.orAssign = "|=", e3.xorAssign = "^=", e3.shiftLeftAssign = "<<=", e3.shiftRightAssign = ">>=";
})(q || (q = {})), ((e3) => {
  e3.parse = function(e4) {
    const t2 = e4;
    if ("parse" == t2) throw new Error("Invalid value for AssignOperator");
    return t2;
  };
})(q || (q = {}));
var G = class extends C {
  constructor(e3, t2, n2) {
    super(), this.operator = e3, this.variable = t2, this.value = n2;
  }
  get astNodeType() {
    return "assign";
  }
  search(e3) {
    this.variable.search(e3), this.value.search(e3);
  }
};
var X = class extends C {
  constructor(e3, t2) {
    super(), this.name = e3, this.args = t2;
  }
  get astNodeType() {
    return "call";
  }
  isBuiltin() {
    return L.has(this.name);
  }
  search(e3) {
    for (const t2 of this.args) t2.search(e3);
    e3(this);
  }
};
var j = class extends C {
  constructor(e3, t2) {
    super(), this.body = e3, this.continuing = t2;
  }
  get astNodeType() {
    return "loop";
  }
  search(e3) {
    var t2;
    this.searchBlock(this.body, e3), null === (t2 = this.continuing) || void 0 === t2 || t2.search(e3);
  }
};
var Z = class extends C {
  constructor(e3, t2) {
    super(), this.condition = e3, this.cases = t2;
  }
  get astNodeType() {
    return "switch";
  }
  search(e3) {
    e3(this);
    for (const t2 of this.cases) t2.search(e3);
  }
};
var Q = class extends C {
  constructor(e3, t2, n2, s2) {
    super(), this.condition = e3, this.body = t2, this.elseif = n2, this.else = s2;
  }
  get astNodeType() {
    return "if";
  }
  search(e3) {
    this.condition.search(e3), this.searchBlock(this.body, e3), this.searchBlock(this.elseif, e3), this.searchBlock(this.else, e3);
  }
};
var Y = class extends C {
  constructor(e3) {
    super(), this.value = e3;
  }
  get astNodeType() {
    return "return";
  }
  search(e3) {
    var t2;
    null === (t2 = this.value) || void 0 === t2 || t2.search(e3);
  }
};
var K = class extends C {
  constructor(e3) {
    super(), this.name = e3;
  }
  get astNodeType() {
    return "enable";
  }
};
var J = class extends C {
  constructor(e3) {
    super(), this.extensions = e3;
  }
  get astNodeType() {
    return "requires";
  }
};
var ee = class extends C {
  constructor(e3, t2) {
    super(), this.severity = e3, this.rule = t2;
  }
  get astNodeType() {
    return "diagnostic";
  }
};
var te = class extends C {
  constructor(e3, t2) {
    super(), this.name = e3, this.type = t2;
  }
  get astNodeType() {
    return "alias";
  }
};
var ne = class extends C {
  constructor() {
    super();
  }
  get astNodeType() {
    return "discard";
  }
};
var se = class extends C {
  constructor() {
    super(), this.condition = null, this.loopId = -1;
  }
  get astNodeType() {
    return "break";
  }
};
var re = class extends C {
  constructor() {
    super(), this.loopId = -1;
  }
  get astNodeType() {
    return "continue";
  }
};
var ae = class _ae extends C {
  constructor(e3) {
    super(), this.attributes = null, this.name = e3;
  }
  get astNodeType() {
    return "type";
  }
  get isStruct() {
    return false;
  }
  get isArray() {
    return false;
  }
  static maxFormatType(e3) {
    let t2 = e3[0];
    if ("f32" === t2.name) return t2;
    for (let n2 = 1; n2 < e3.length; ++n2) {
      const s2 = _ae._priority.get(t2.name);
      _ae._priority.get(e3[n2].name) < s2 && (t2 = e3[n2]);
    }
    return "x32" === t2.name ? _ae.i32 : t2;
  }
  getTypeName() {
    return this.name;
  }
};
ae.x32 = new ae("x32"), ae.f32 = new ae("f32"), ae.i32 = new ae("i32"), ae.u32 = new ae("u32"), ae.f16 = new ae("f16"), ae.bool = new ae("bool"), ae.void = new ae("void"), ae._priority = /* @__PURE__ */ new Map([["f32", 0], ["f16", 1], ["u32", 2], ["i32", 3], ["x32", 3]]);
var ie = class extends ae {
  constructor(e3) {
    super(e3);
  }
};
var oe = class extends ae {
  constructor(e3, t2, n2, s2) {
    super(e3), this.members = t2, this.startLine = n2, this.endLine = s2;
  }
  get astNodeType() {
    return "struct";
  }
  get isStruct() {
    return true;
  }
  getMemberIndex(e3) {
    for (let t2 = 0; t2 < this.members.length; t2++) if (this.members[t2].name == e3) return t2;
    return -1;
  }
  search(e3) {
    for (const t2 of this.members) e3(t2);
  }
};
var ce = class extends ae {
  constructor(e3, t2, n2) {
    super(e3), this.format = t2, this.access = n2;
  }
  get astNodeType() {
    return "template";
  }
  getTypeName() {
    let e3 = this.name;
    if (null !== this.format) {
      if ("vec2" === e3 || "vec3" === e3 || "vec4" === e3 || "mat2x2" === e3 || "mat2x3" === e3 || "mat2x4" === e3 || "mat3x2" === e3 || "mat3x3" === e3 || "mat3x4" === e3 || "mat4x2" === e3 || "mat4x3" === e3 || "mat4x4" === e3) {
        if ("f32" === this.format.name) return e3 += "f", e3;
        if ("i32" === this.format.name) return e3 += "i", e3;
        if ("u32" === this.format.name) return e3 += "u", e3;
        if ("bool" === this.format.name) return e3 += "b", e3;
        if ("f16" === this.format.name) return e3 += "h", e3;
      }
      e3 += `<${this.format.name}>`;
    } else if ("vec2" === e3 || "vec3" === e3 || "vec4" === e3) return e3;
    return e3;
  }
};
ce.vec2f = new ce("vec2", ae.f32, null), ce.vec3f = new ce("vec3", ae.f32, null), ce.vec4f = new ce("vec4", ae.f32, null), ce.vec2i = new ce("vec2", ae.i32, null), ce.vec3i = new ce("vec3", ae.i32, null), ce.vec4i = new ce("vec4", ae.i32, null), ce.vec2u = new ce("vec2", ae.u32, null), ce.vec3u = new ce("vec3", ae.u32, null), ce.vec4u = new ce("vec4", ae.u32, null), ce.vec2h = new ce("vec2", ae.f16, null), ce.vec3h = new ce("vec3", ae.f16, null), ce.vec4h = new ce("vec4", ae.f16, null), ce.vec2b = new ce("vec2", ae.bool, null), ce.vec3b = new ce("vec3", ae.bool, null), ce.vec4b = new ce("vec4", ae.bool, null), ce.mat2x2f = new ce("mat2x2", ae.f32, null), ce.mat2x3f = new ce("mat2x3", ae.f32, null), ce.mat2x4f = new ce("mat2x4", ae.f32, null), ce.mat3x2f = new ce("mat3x2", ae.f32, null), ce.mat3x3f = new ce("mat3x3", ae.f32, null), ce.mat3x4f = new ce("mat3x4", ae.f32, null), ce.mat4x2f = new ce("mat4x2", ae.f32, null), ce.mat4x3f = new ce("mat4x3", ae.f32, null), ce.mat4x4f = new ce("mat4x4", ae.f32, null), ce.mat2x2h = new ce("mat2x2", ae.f16, null), ce.mat2x3h = new ce("mat2x3", ae.f16, null), ce.mat2x4h = new ce("mat2x4", ae.f16, null), ce.mat3x2h = new ce("mat3x2", ae.f16, null), ce.mat3x3h = new ce("mat3x3", ae.f16, null), ce.mat3x4h = new ce("mat3x4", ae.f16, null), ce.mat4x2h = new ce("mat4x2", ae.f16, null), ce.mat4x3h = new ce("mat4x3", ae.f16, null), ce.mat4x4h = new ce("mat4x4", ae.f16, null), ce.mat2x2i = new ce("mat2x2", ae.i32, null), ce.mat2x3i = new ce("mat2x3", ae.i32, null), ce.mat2x4i = new ce("mat2x4", ae.i32, null), ce.mat3x2i = new ce("mat3x2", ae.i32, null), ce.mat3x3i = new ce("mat3x3", ae.i32, null), ce.mat3x4i = new ce("mat3x4", ae.i32, null), ce.mat4x2i = new ce("mat4x2", ae.i32, null), ce.mat4x3i = new ce("mat4x3", ae.i32, null), ce.mat4x4i = new ce("mat4x4", ae.i32, null), ce.mat2x2u = new ce("mat2x2", ae.u32, null), ce.mat2x3u = new ce("mat2x3", ae.u32, null), ce.mat2x4u = new ce("mat2x4", ae.u32, null), ce.mat3x2u = new ce("mat3x2", ae.u32, null), ce.mat3x3u = new ce("mat3x3", ae.u32, null), ce.mat3x4u = new ce("mat3x4", ae.u32, null), ce.mat4x2u = new ce("mat4x2", ae.u32, null), ce.mat4x3u = new ce("mat4x3", ae.u32, null), ce.mat4x4u = new ce("mat4x4", ae.u32, null);
var le = class extends ae {
  constructor(e3, t2, n2, s2) {
    super(e3), this.storage = t2, this.type = n2, this.access = s2;
  }
  get astNodeType() {
    return "pointer";
  }
};
var ue = class extends ae {
  constructor(e3, t2, n2, s2) {
    super(e3), this.attributes = t2, this.format = n2, this.count = s2;
  }
  get astNodeType() {
    return "array";
  }
  get isArray() {
    return true;
  }
};
var he = class extends ae {
  constructor(e3, t2, n2) {
    super(e3), this.format = t2, this.access = n2;
  }
  get astNodeType() {
    return "sampler";
  }
};
var fe = class extends A {
  constructor() {
    super(), this.postfix = null;
  }
};
var pe = class extends fe {
  constructor(e3) {
    super(), this.value = e3;
  }
  get astNodeType() {
    return "stringExpr";
  }
  toString() {
    return this.value;
  }
  constEvaluateString() {
    return this.value;
  }
};
var de = class extends fe {
  constructor(e3, t2) {
    super(), this.type = e3, this.args = t2;
  }
  get astNodeType() {
    return "createExpr";
  }
  search(e3) {
    if (e3(this), this.args) for (const t2 of this.args) t2.search(e3);
  }
  constEvaluate(e3, t2) {
    return t2 && (t2[0] = this.type), e3.evalExpression(this, e3.context);
  }
};
var me = class extends fe {
  constructor(e3, t2) {
    super(), this.cachedReturnValue = null, this.name = e3, this.args = t2;
  }
  get astNodeType() {
    return "callExpr";
  }
  setCachedReturnValue(e3) {
    this.cachedReturnValue = e3;
  }
  get isBuiltin() {
    return L.has(this.name);
  }
  constEvaluate(e3, t2) {
    return e3.evalExpression(this, e3.context);
  }
  search(e3) {
    for (const t2 of this.args) t2.search(e3);
    e3(this);
  }
};
var ge = class extends fe {
  constructor(e3) {
    super(), this.name = e3;
  }
  get astNodeType() {
    return "varExpr";
  }
  search(e3) {
    e3(this), this.postfix && this.postfix.search(e3);
  }
  constEvaluate(e3, t2) {
    return e3.evalExpression(this, e3.context);
  }
};
var _e = class extends fe {
  constructor(e3, t2) {
    super(), this.name = e3, this.initializer = t2;
  }
  get astNodeType() {
    return "constExpr";
  }
  constEvaluate(e3, t2) {
    if (this.initializer) {
      const t3 = e3.evalExpression(this.initializer, e3.context);
      return null !== t3 && this.postfix ? t3.getSubData(e3, this.postfix, e3.context) : t3;
    }
    return null;
  }
  search(e3) {
    this.initializer.search(e3);
  }
};
var xe = class extends fe {
  constructor(e3, t2) {
    super(), this.value = e3, this.type = t2;
  }
  get astNodeType() {
    return "literalExpr";
  }
  constEvaluate(e3, t2) {
    return void 0 !== t2 && (t2[0] = this.type), this.value;
  }
  get isScalar() {
    return this.value instanceof Be;
  }
  get isVector() {
    return this.value instanceof Me || this.value instanceof Ue;
  }
  get scalarValue() {
    return this.value instanceof Be ? this.value.value : (console.error("Value is not scalar."), 0);
  }
  get vectorValue() {
    return this.value instanceof Me || this.value instanceof Ue ? this.value.data : (console.error("Value is not a vector or matrix."), new Float32Array(0));
  }
};
var ye = class extends fe {
  constructor(e3, t2) {
    super(), this.type = e3, this.value = t2;
  }
  get astNodeType() {
    return "bitcastExpr";
  }
  search(e3) {
    this.value.search(e3);
  }
};
var ve = class extends fe {
  constructor(e3) {
    super(), this.index = e3;
  }
  search(e3) {
    this.index.search(e3);
  }
};
var we = class extends fe {
  constructor() {
    super();
  }
};
var ke = class extends we {
  constructor(e3, t2) {
    super(), this.operator = e3, this.right = t2;
  }
  get astNodeType() {
    return "unaryOp";
  }
  constEvaluate(e3, t2) {
    return e3.evalExpression(this, e3.context);
  }
  search(e3) {
    this.right.search(e3);
  }
};
var Ie = class extends we {
  constructor(e3, t2, n2) {
    super(), this.operator = e3, this.left = t2, this.right = n2;
  }
  get astNodeType() {
    return "binaryOp";
  }
  _getPromotedType(e3, t2) {
    return e3.name === t2.name ? e3 : "f32" === e3.name || "f32" === t2.name ? ae.f32 : "u32" === e3.name || "u32" === t2.name ? ae.u32 : ae.i32;
  }
  constEvaluate(e3, t2) {
    return e3.evalExpression(this, e3.context);
  }
  search(e3) {
    this.left.search(e3), this.right.search(e3);
  }
};
var Te = class extends A {
  constructor(e3) {
    super(), this.body = e3;
  }
  search(e3) {
    e3(this), this.searchBlock(this.body, e3);
  }
};
var Se = class extends fe {
  constructor() {
    super();
  }
  get astNodeType() {
    return "default";
  }
};
var Ae = class extends Te {
  constructor(e3, t2) {
    super(t2), this.selectors = e3;
  }
  get astNodeType() {
    return "case";
  }
  search(e3) {
    this.searchBlock(this.body, e3);
  }
};
var Ee = class extends Te {
  constructor(e3) {
    super(e3);
  }
  get astNodeType() {
    return "default";
  }
  search(e3) {
    this.searchBlock(this.body, e3);
  }
};
var $e = class extends A {
  constructor(e3, t2, n2) {
    super(), this.name = e3, this.type = t2, this.attributes = n2;
  }
  get astNodeType() {
    return "argument";
  }
};
var Le = class extends A {
  constructor(e3, t2) {
    super(), this.condition = e3, this.body = t2;
  }
  get astNodeType() {
    return "elseif";
  }
  search(e3) {
    this.condition.search(e3), this.searchBlock(this.body, e3);
  }
};
var Ce = class extends A {
  constructor(e3, t2, n2) {
    super(), this.name = e3, this.type = t2, this.attributes = n2;
  }
  get astNodeType() {
    return "member";
  }
};
var De = class extends A {
  constructor(e3, t2) {
    super(), this.name = e3, this.value = t2;
  }
  get astNodeType() {
    return "attribute";
  }
};
var Ne = class _Ne {
  constructor(e3, t2) {
    this.parent = null, this.typeInfo = e3, this.parent = t2, this.id = _Ne._id++;
  }
  clone() {
    throw `Clone: Not implemented for ${this.constructor.name}`;
  }
  setDataValue(e3, t2, n2, s2) {
    console.error(`SetDataValue: Not implemented for ${this.constructor.name}`);
  }
  getSubData(e3, t2, n2) {
    return console.error(`GetDataValue: Not implemented for ${this.constructor.name}`), null;
  }
  toString() {
    return `<${this.typeInfo.getTypeName()}>`;
  }
};
Ne._id = 0;
var Ve = class extends Ne {
  constructor() {
    super(new e("void", null), null);
  }
  toString() {
    return "void";
  }
};
Ve.void = new Ve();
var Oe = class extends Ne {
  constructor(e3) {
    super(new r("pointer", e3.typeInfo, null), null), this.reference = e3;
  }
  clone() {
    return this;
  }
  setDataValue(e3, t2, n2, s2) {
    this.reference.setDataValue(e3, t2, n2, s2);
  }
  getSubData(e3, t2, n2) {
    return t2 ? this.reference.getSubData(e3, t2, n2) : this;
  }
  toString() {
    return `&${this.reference.toString()}`;
  }
};
var Be = class _Be extends Ne {
  constructor(e3, t2, n2 = null) {
    super(t2, n2), e3 instanceof Int32Array || e3 instanceof Uint32Array || e3 instanceof Float32Array ? this.data = e3 : "x32" === this.typeInfo.name ? e3 - Math.floor(e3) !== 0 ? this.data = new Float32Array([e3]) : this.data = e3 >= 0 ? new Uint32Array([e3]) : new Int32Array([e3]) : "i32" === this.typeInfo.name || "bool" === this.typeInfo.name ? this.data = new Int32Array([e3]) : "u32" === this.typeInfo.name ? this.data = new Uint32Array([e3]) : "f32" === this.typeInfo.name || "f16" === this.typeInfo.name ? this.data = new Float32Array([e3]) : console.error("ScalarData2: Invalid type", t2);
  }
  clone() {
    if (this.data instanceof Float32Array) return new _Be(new Float32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Int32Array) return new _Be(new Int32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Uint32Array) return new _Be(new Uint32Array(this.data), this.typeInfo, null);
    throw "ScalarData: Invalid data type";
  }
  get value() {
    return this.data[0];
  }
  set value(e3) {
    this.data[0] = e3;
  }
  setDataValue(e3, t2, n2, s2) {
    if (n2) return void console.error("SetDataValue: Scalar data does not support postfix", n2);
    if (!(t2 instanceof _Be)) return void console.error("SetDataValue: Invalid value", t2);
    let r2 = t2.data[0];
    "i32" === this.typeInfo.name || "u32" === this.typeInfo.name ? r2 = Math.floor(r2) : "bool" === this.typeInfo.name && (r2 = r2 ? 1 : 0), this.data[0] = r2;
  }
  getSubData(e3, t2, n2) {
    return t2 ? (console.error("getSubData: Scalar data does not support postfix", t2), null) : this;
  }
  toString() {
    return `${this.value}`;
  }
};
function Fe(e3, t2, n2) {
  const s2 = t2.length;
  return 2 === s2 ? "f32" === n2 ? new Me(new Float32Array(t2), e3.getTypeInfo("vec2f")) : "i32" === n2 || "bool" === n2 ? new Me(new Int32Array(t2), e3.getTypeInfo("vec2i")) : "u32" === n2 ? new Me(new Uint32Array(t2), e3.getTypeInfo("vec2u")) : "f16" === n2 ? new Me(new Float32Array(t2), e3.getTypeInfo("vec2h")) : (console.error(`getSubData: Unknown format ${n2}`), null) : 3 === s2 ? "f32" === n2 ? new Me(new Float32Array(t2), e3.getTypeInfo("vec3f")) : "i32" === n2 || "bool" === n2 ? new Me(new Int32Array(t2), e3.getTypeInfo("vec3i")) : "u32" === n2 ? new Me(new Uint32Array(t2), e3.getTypeInfo("vec3u")) : "f16" === n2 ? new Me(new Float32Array(t2), e3.getTypeInfo("vec3h")) : (console.error(`getSubData: Unknown format ${n2}`), null) : 4 === s2 ? "f32" === n2 ? new Me(new Float32Array(t2), e3.getTypeInfo("vec4f")) : "i32" === n2 || "bool" === n2 ? new Me(new Int32Array(t2), e3.getTypeInfo("vec4i")) : "u32" === n2 ? new Me(new Uint32Array(t2), e3.getTypeInfo("vec4u")) : "f16" === n2 ? new Me(new Float32Array(t2), e3.getTypeInfo("vec4h")) : (console.error(`getSubData: Unknown format ${n2}`), null) : (console.error(`getSubData: Invalid vector size ${t2.length}`), null);
}
var Me = class _Me extends Ne {
  constructor(e3, t2, n2 = null) {
    if (super(t2, n2), e3 instanceof Float32Array || e3 instanceof Uint32Array || e3 instanceof Int32Array) this.data = e3;
    else {
      const t3 = this.typeInfo.name;
      "vec2f" === t3 || "vec3f" === t3 || "vec4f" === t3 ? this.data = new Float32Array(e3) : "vec2i" === t3 || "vec3i" === t3 || "vec4i" === t3 ? this.data = new Int32Array(e3) : "vec2u" === t3 || "vec3u" === t3 || "vec4u" === t3 ? this.data = new Uint32Array(e3) : "vec2h" === t3 || "vec3h" === t3 || "vec4h" === t3 ? this.data = new Float32Array(e3) : "vec2b" === t3 || "vec3b" === t3 || "vec4b" === t3 ? this.data = new Int32Array(e3) : "vec2" === t3 || "vec3" === t3 || "vec4" === t3 ? this.data = new Float32Array(e3) : console.error(`VectorData: Invalid type ${t3}`);
    }
  }
  clone() {
    if (this.data instanceof Float32Array) return new _Me(new Float32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Int32Array) return new _Me(new Int32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Uint32Array) return new _Me(new Uint32Array(this.data), this.typeInfo, null);
    throw "VectorData: Invalid data type";
  }
  setDataValue(e3, t2, n2, s2) {
    n2 instanceof pe ? console.error("TODO: Set vector postfix") : t2 instanceof _Me ? this.data = t2.data : console.error("SetDataValue: Invalid value", t2);
  }
  getSubData(e3, t2, n2) {
    if (null === t2) return this;
    let s2 = e3.getTypeInfo("f32");
    if (this.typeInfo instanceof a) s2 = this.typeInfo.format || s2;
    else {
      const t3 = this.typeInfo.name;
      "vec2f" === t3 || "vec3f" === t3 || "vec4f" === t3 ? s2 = e3.getTypeInfo("f32") : "vec2i" === t3 || "vec3i" === t3 || "vec4i" === t3 ? s2 = e3.getTypeInfo("i32") : "vec2b" === t3 || "vec3b" === t3 || "vec4b" === t3 ? s2 = e3.getTypeInfo("bool") : "vec2u" === t3 || "vec3u" === t3 || "vec4u" === t3 ? s2 = e3.getTypeInfo("u32") : "vec2h" === t3 || "vec3h" === t3 || "vec4h" === t3 ? s2 = e3.getTypeInfo("f16") : console.error(`GetSubData: Unknown type ${t3}`);
    }
    let r2 = this;
    for (; null !== t2 && null !== r2; ) {
      if (t2 instanceof ve) {
        const a2 = t2.index;
        let i2 = -1;
        if (a2 instanceof xe) {
          if (!(a2.value instanceof Be)) return console.error(`GetSubData: Invalid array index ${a2.value}`), null;
          i2 = a2.value.value;
        } else {
          const t3 = e3.evalExpression(a2, n2);
          if (!(t3 instanceof Be)) return console.error("GetSubData: Unknown index type", a2), null;
          i2 = t3.value;
        }
        if (i2 < 0 || i2 >= r2.data.length) return console.error("GetSubData: Index out of range", i2), null;
        if (r2.data instanceof Float32Array) {
          const e4 = new Float32Array(r2.data.buffer, r2.data.byteOffset + 4 * i2, 1);
          return new Be(e4, s2);
        }
        if (r2.data instanceof Int32Array) {
          const e4 = new Int32Array(r2.data.buffer, r2.data.byteOffset + 4 * i2, 1);
          return new Be(e4, s2);
        }
        if (r2.data instanceof Uint32Array) {
          const e4 = new Uint32Array(r2.data.buffer, r2.data.byteOffset + 4 * i2, 1);
          return new Be(e4, s2);
        }
        throw "GetSubData: Invalid data type";
      }
      if (!(t2 instanceof pe)) return console.error("GetSubData: Unknown postfix", t2), null;
      {
        const n3 = t2.value.toLowerCase();
        if (1 === n3.length) {
          let e4 = 0;
          if ("x" === n3 || "r" === n3) e4 = 0;
          else if ("y" === n3 || "g" === n3) e4 = 1;
          else if ("z" === n3 || "b" === n3) e4 = 2;
          else {
            if ("w" !== n3 && "a" !== n3) return console.error(`GetSubData: Unknown member ${n3}`), null;
            e4 = 3;
          }
          if (this.data instanceof Float32Array) {
            let t3 = new Float32Array(this.data.buffer, this.data.byteOffset + 4 * e4, 1);
            return new Be(t3, s2, this);
          }
          if (this.data instanceof Int32Array) {
            let t3 = new Int32Array(this.data.buffer, this.data.byteOffset + 4 * e4, 1);
            return new Be(t3, s2, this);
          }
          if (this.data instanceof Uint32Array) {
            let t3 = new Uint32Array(this.data.buffer, this.data.byteOffset + 4 * e4, 1);
            return new Be(t3, s2, this);
          }
        }
        const a2 = [];
        for (const e4 of n3) "x" === e4 || "r" === e4 ? a2.push(this.data[0]) : "y" === e4 || "g" === e4 ? a2.push(this.data[1]) : "z" === e4 || "b" === e4 ? a2.push(this.data[2]) : "w" === e4 || "a" === e4 ? a2.push(this.data[3]) : console.error(`GetDataValue: Unknown member ${e4}`);
        r2 = Fe(e3, a2, s2.name);
      }
      t2 = t2.postfix;
    }
    return r2;
  }
  toString() {
    let e3 = `${this.data[0]}`;
    for (let t2 = 1; t2 < this.data.length; ++t2) e3 += `, ${this.data[t2]}`;
    return e3;
  }
};
var Ue = class _Ue extends Ne {
  constructor(e3, t2, n2 = null) {
    super(t2, n2), e3 instanceof Float32Array ? this.data = e3 : this.data = new Float32Array(e3);
  }
  clone() {
    return new _Ue(new Float32Array(this.data), this.typeInfo, null);
  }
  setDataValue(e3, t2, n2, s2) {
    n2 instanceof pe ? console.error("TODO: Set matrix postfix") : t2 instanceof _Ue ? this.data = t2.data : console.error("SetDataValue: Invalid value", t2);
  }
  getSubData(e3, t2, n2) {
    if (null === t2) return this;
    const s2 = this.typeInfo.name;
    if (e3.getTypeInfo("f32"), this.typeInfo instanceof a) this.typeInfo.format;
    else if (s2.endsWith("f")) e3.getTypeInfo("f32");
    else if (s2.endsWith("i")) e3.getTypeInfo("i32");
    else if (s2.endsWith("u")) e3.getTypeInfo("u32");
    else {
      if (!s2.endsWith("h")) return console.error(`GetDataValue: Unknown type ${s2}`), null;
      e3.getTypeInfo("f16");
    }
    if (t2 instanceof ve) {
      const r2 = t2.index;
      let a2 = -1;
      if (r2 instanceof xe) {
        if (!(r2.value instanceof Be)) return console.error(`GetDataValue: Invalid array index ${r2.value}`), null;
        a2 = r2.value.value;
      } else {
        const t3 = e3.evalExpression(r2, n2);
        if (!(t3 instanceof Be)) return console.error("GetDataValue: Unknown index type", r2), null;
        a2 = t3.value;
      }
      if (a2 < 0 || a2 >= this.data.length) return console.error("GetDataValue: Index out of range", a2), null;
      const i2 = s2.endsWith("h") ? "h" : "f";
      let o2;
      if ("mat2x2" === s2 || "mat2x2f" === s2 || "mat2x2h" === s2 || "mat3x2" === s2 || "mat3x2f" === s2 || "mat3x2h" === s2 || "mat4x2" === s2 || "mat4x2f" === s2 || "mat4x2h" === s2) o2 = new Me(new Float32Array(this.data.buffer, this.data.byteOffset + 2 * a2 * 4, 2), e3.getTypeInfo(`vec2${i2}`));
      else if ("mat2x3" === s2 || "mat2x3f" === s2 || "mat2x3h" === s2 || "mat3x3" === s2 || "mat3x3f" === s2 || "mat3x3h" === s2 || "mat4x3" === s2 || "mat4x3f" === s2 || "mat4x3h" === s2) o2 = new Me(new Float32Array(this.data.buffer, this.data.byteOffset + 3 * a2 * 4, 3), e3.getTypeInfo(`vec3${i2}`));
      else {
        if ("mat2x4" !== s2 && "mat2x4f" !== s2 && "mat2x4h" !== s2 && "mat3x4" !== s2 && "mat3x4f" !== s2 && "mat3x4h" !== s2 && "mat4x4" !== s2 && "mat4x4f" !== s2 && "mat4x4h" !== s2) return console.error(`GetDataValue: Unknown type ${s2}`), null;
        o2 = new Me(new Float32Array(this.data.buffer, this.data.byteOffset + 4 * a2 * 4, 4), e3.getTypeInfo(`vec4${i2}`));
      }
      return t2.postfix ? o2.getSubData(e3, t2.postfix, n2) : o2;
    }
    return console.error("GetDataValue: Invalid postfix", t2), null;
  }
  toString() {
    let e3 = `${this.data[0]}`;
    for (let t2 = 1; t2 < this.data.length; ++t2) e3 += `, ${this.data[t2]}`;
    return e3;
  }
};
var Pe = class _Pe extends Ne {
  constructor(e3, t2, n2 = 0, s2 = null) {
    super(t2, s2), this.buffer = e3 instanceof ArrayBuffer ? e3 : e3.buffer, this.offset = n2;
  }
  clone() {
    const e3 = new Uint8Array(new Uint8Array(this.buffer, this.offset, this.typeInfo.size));
    return new _Pe(e3.buffer, this.typeInfo, 0, null);
  }
  setDataValue(t2, r2, a2, i2) {
    if (null === r2) return void console.log("setDataValue: NULL data.");
    let o2 = this.offset, c2 = this.typeInfo;
    for (; a2; ) {
      if (a2 instanceof ve) if (c2 instanceof s) {
        const e3 = a2.index;
        if (e3 instanceof xe) {
          if (!(e3.value instanceof Be)) return void console.error(`SetDataValue: Invalid index type ${e3.value}`);
          o2 += e3.value.value * c2.stride;
        } else {
          const n2 = t2.evalExpression(e3, i2);
          if (!(n2 instanceof Be)) return void console.error("SetDataValue: Unknown index type", e3);
          o2 += n2.value * c2.stride;
        }
        c2 = c2.format;
      } else console.error(`SetDataValue: Type ${c2.getTypeName()} is not an array`);
      else {
        if (!(a2 instanceof pe)) return void console.error("SetDataValue: Unknown postfix type", a2);
        {
          const t3 = a2.value;
          if (c2 instanceof n) {
            let e3 = false;
            for (const n2 of c2.members) if (n2.name === t3) {
              o2 += n2.offset, c2 = n2.type, e3 = true;
              break;
            }
            if (!e3) return void console.error(`SetDataValue: Member ${t3} not found`);
          } else if (c2 instanceof e) {
            const e3 = c2.getTypeName();
            let n2 = 0;
            if ("x" === t3 || "r" === t3) n2 = 0;
            else if ("y" === t3 || "g" === t3) n2 = 1;
            else if ("z" === t3 || "b" === t3) n2 = 2;
            else {
              if ("w" !== t3 && "a" !== t3) return void console.error(`SetDataValue: Unknown member ${t3}`);
              n2 = 3;
            }
            if (!(r2 instanceof Be)) return void console.error("SetDataValue: Invalid value", r2);
            const s2 = r2.value;
            return "vec2f" === e3 ? void (new Float32Array(this.buffer, o2, 2)[n2] = s2) : "vec3f" === e3 ? void (new Float32Array(this.buffer, o2, 3)[n2] = s2) : "vec4f" === e3 ? void (new Float32Array(this.buffer, o2, 4)[n2] = s2) : "vec2i" === e3 ? void (new Int32Array(this.buffer, o2, 2)[n2] = s2) : "vec3i" === e3 ? void (new Int32Array(this.buffer, o2, 3)[n2] = s2) : "vec4i" === e3 ? void (new Int32Array(this.buffer, o2, 4)[n2] = s2) : "vec2u" === e3 ? void (new Uint32Array(this.buffer, o2, 2)[n2] = s2) : "vec3u" === e3 ? void (new Uint32Array(this.buffer, o2, 3)[n2] = s2) : "vec4u" === e3 ? void (new Uint32Array(this.buffer, o2, 4)[n2] = s2) : void console.error(`SetDataValue: Type ${e3} is not a struct`);
          }
        }
      }
      a2 = a2.postfix;
    }
    this.setData(t2, r2, c2, o2, i2);
  }
  setData(e3, t2, n2, s2, r2) {
    const a2 = n2.getTypeName();
    if ("f32" !== a2 && "f16" !== a2) if ("i32" !== a2 && "atomic<i32>" !== a2 && "x32" !== a2) if ("u32" !== a2 && "atomic<u32>" !== a2) if ("bool" !== a2) {
      if ("vec2f" === a2 || "vec2h" === a2) {
        const e4 = new Float32Array(this.buffer, s2, 2);
        return void (t2 instanceof Me ? (e4[0] = t2.data[0], e4[1] = t2.data[1]) : (e4[0] = t2[0], e4[1] = t2[1]));
      }
      if ("vec3f" === a2 || "vec3h" === a2) {
        const e4 = new Float32Array(this.buffer, s2, 3);
        return void (t2 instanceof Me ? (e4[0] = t2.data[0], e4[1] = t2.data[1], e4[2] = t2.data[2]) : (e4[0] = t2[0], e4[1] = t2[1], e4[2] = t2[2]));
      }
      if ("vec4f" === a2 || "vec4h" === a2) {
        const e4 = new Float32Array(this.buffer, s2, 4);
        return void (t2 instanceof Me ? (e4[0] = t2.data[0], e4[1] = t2.data[1], e4[2] = t2.data[2], e4[3] = t2.data[3]) : (e4[0] = t2[0], e4[1] = t2[1], e4[2] = t2[2], e4[3] = t2[3]));
      }
      if ("vec2i" === a2) {
        const e4 = new Int32Array(this.buffer, s2, 2);
        return void (t2 instanceof Me ? (e4[0] = t2.data[0], e4[1] = t2.data[1]) : (e4[0] = t2[0], e4[1] = t2[1]));
      }
      if ("vec3i" === a2) {
        const e4 = new Int32Array(this.buffer, s2, 3);
        return void (t2 instanceof Me ? (e4[0] = t2.data[0], e4[1] = t2.data[1], e4[2] = t2.data[2]) : (e4[0] = t2[0], e4[1] = t2[1], e4[2] = t2[2]));
      }
      if ("vec4i" === a2) {
        const e4 = new Int32Array(this.buffer, s2, 4);
        return void (t2 instanceof Me ? (e4[0] = t2.data[0], e4[1] = t2.data[1], e4[2] = t2.data[2], e4[3] = t2.data[3]) : (e4[0] = t2[0], e4[1] = t2[1], e4[2] = t2[2], e4[3] = t2[3]));
      }
      if ("vec2u" === a2) {
        const e4 = new Uint32Array(this.buffer, s2, 2);
        return void (t2 instanceof Me ? (e4[0] = t2.data[0], e4[1] = t2.data[1]) : (e4[0] = t2[0], e4[1] = t2[1]));
      }
      if ("vec3u" === a2) {
        const e4 = new Uint32Array(this.buffer, s2, 3);
        return void (t2 instanceof Me ? (e4[0] = t2.data[0], e4[1] = t2.data[1], e4[2] = t2.data[2]) : (e4[0] = t2[0], e4[1] = t2[1], e4[2] = t2[2]));
      }
      if ("vec4u" === a2) {
        const e4 = new Uint32Array(this.buffer, s2, 4);
        return void (t2 instanceof Me ? (e4[0] = t2.data[0], e4[1] = t2.data[1], e4[2] = t2.data[2], e4[3] = t2.data[3]) : (e4[0] = t2[0], e4[1] = t2[1], e4[2] = t2[2], e4[3] = t2[3]));
      }
      if ("vec2b" === a2) {
        const e4 = new Uint32Array(this.buffer, s2, 2);
        return void (t2 instanceof Me ? (e4[0] = t2.data[0], e4[1] = t2.data[1]) : (e4[0] = t2[0], e4[1] = t2[1]));
      }
      if ("vec3b" === a2) {
        const e4 = new Uint32Array(this.buffer, s2, 3);
        return void (t2 instanceof Me ? (e4[0] = t2.data[0], e4[1] = t2.data[1], e4[2] = t2.data[2]) : (e4[0] = t2[0], e4[1] = t2[1], e4[2] = t2[2]));
      }
      if ("vec4b" === a2) {
        const e4 = new Uint32Array(this.buffer, s2, 4);
        return void (t2 instanceof Me ? (e4[0] = t2.data[0], e4[1] = t2.data[1], e4[2] = t2.data[2], e4[3] = t2.data[3]) : (e4[0] = t2[0], e4[1] = t2[1], e4[2] = t2[2], e4[3] = t2[3]));
      }
      if ("mat2x2f" === a2 || "mat2x2h" === a2) {
        const e4 = new Float32Array(this.buffer, s2, 4);
        return void (t2 instanceof Ue ? (e4[0] = t2.data[0], e4[1] = t2.data[1], e4[2] = t2.data[2], e4[3] = t2.data[3]) : (e4[0] = t2[0], e4[1] = t2[1], e4[2] = t2[2], e4[3] = t2[3]));
      }
      if ("mat2x3f" === a2 || "mat2x3h" === a2) {
        const e4 = new Float32Array(this.buffer, s2, 6);
        return void (t2 instanceof Ue ? (e4[0] = t2.data[0], e4[1] = t2.data[1], e4[2] = t2.data[2], e4[3] = t2.data[3], e4[4] = t2.data[4], e4[5] = t2.data[5]) : (e4[0] = t2[0], e4[1] = t2[1], e4[2] = t2[2], e4[3] = t2[3], e4[4] = t2[4], e4[5] = t2[5]));
      }
      if ("mat2x4f" === a2 || "mat2x4h" === a2) {
        const e4 = new Float32Array(this.buffer, s2, 8);
        return void (t2 instanceof Ue ? (e4[0] = t2.data[0], e4[1] = t2.data[1], e4[2] = t2.data[2], e4[3] = t2.data[3], e4[4] = t2.data[4], e4[5] = t2.data[5], e4[6] = t2.data[6], e4[7] = t2.data[7]) : (e4[0] = t2[0], e4[1] = t2[1], e4[2] = t2[2], e4[3] = t2[3], e4[4] = t2[4], e4[5] = t2[5], e4[6] = t2[6], e4[7] = t2[7]));
      }
      if ("mat3x2f" === a2 || "mat3x2h" === a2) {
        const e4 = new Float32Array(this.buffer, s2, 6);
        return void (t2 instanceof Ue ? (e4[0] = t2.data[0], e4[1] = t2.data[1], e4[2] = t2.data[2], e4[3] = t2.data[3], e4[4] = t2.data[4], e4[5] = t2.data[5]) : (e4[0] = t2[0], e4[1] = t2[1], e4[2] = t2[2], e4[3] = t2[3], e4[4] = t2[4], e4[5] = t2[5]));
      }
      if ("mat3x3f" === a2 || "mat3x3h" === a2) {
        const e4 = new Float32Array(this.buffer, s2, 9);
        return void (t2 instanceof Ue ? (e4[0] = t2.data[0], e4[1] = t2.data[1], e4[2] = t2.data[2], e4[3] = t2.data[3], e4[4] = t2.data[4], e4[5] = t2.data[5], e4[6] = t2.data[6], e4[7] = t2.data[7], e4[8] = t2.data[8]) : (e4[0] = t2[0], e4[1] = t2[1], e4[2] = t2[2], e4[3] = t2[3], e4[4] = t2[4], e4[5] = t2[5], e4[6] = t2[6], e4[7] = t2[7], e4[8] = t2[8]));
      }
      if ("mat3x4f" === a2 || "mat3x4h" === a2) {
        const e4 = new Float32Array(this.buffer, s2, 12);
        return void (t2 instanceof Ue ? (e4[0] = t2.data[0], e4[1] = t2.data[1], e4[2] = t2.data[2], e4[3] = t2.data[3], e4[4] = t2.data[4], e4[5] = t2.data[5], e4[6] = t2.data[6], e4[7] = t2.data[7], e4[8] = t2.data[8], e4[9] = t2.data[9], e4[10] = t2.data[10], e4[11] = t2.data[11]) : (e4[0] = t2[0], e4[1] = t2[1], e4[2] = t2[2], e4[3] = t2[3], e4[4] = t2[4], e4[5] = t2[5], e4[6] = t2[6], e4[7] = t2[7], e4[8] = t2[8], e4[9] = t2[9], e4[10] = t2[10], e4[11] = t2[11]));
      }
      if ("mat4x2f" === a2 || "mat4x2h" === a2) {
        const e4 = new Float32Array(this.buffer, s2, 8);
        return void (t2 instanceof Ue ? (e4[0] = t2.data[0], e4[1] = t2.data[1], e4[2] = t2.data[2], e4[3] = t2.data[3], e4[4] = t2.data[4], e4[5] = t2.data[5], e4[6] = t2.data[6], e4[7] = t2.data[7]) : (e4[0] = t2[0], e4[1] = t2[1], e4[2] = t2[2], e4[3] = t2[3], e4[4] = t2[4], e4[5] = t2[5], e4[6] = t2[6], e4[7] = t2[7]));
      }
      if ("mat4x3f" === a2 || "mat4x3h" === a2) {
        const e4 = new Float32Array(this.buffer, s2, 12);
        return void (t2 instanceof Ue ? (e4[0] = t2.data[0], e4[1] = t2.data[1], e4[2] = t2.data[2], e4[3] = t2.data[3], e4[4] = t2.data[4], e4[5] = t2.data[5], e4[6] = t2.data[6], e4[7] = t2.data[7], e4[8] = t2.data[8], e4[9] = t2.data[9], e4[10] = t2.data[10], e4[11] = t2.data[11]) : (e4[0] = t2[0], e4[1] = t2[1], e4[2] = t2[2], e4[3] = t2[3], e4[4] = t2[4], e4[5] = t2[5], e4[6] = t2[6], e4[7] = t2[7], e4[8] = t2[8], e4[9] = t2[9], e4[10] = t2[10], e4[11] = t2[11]));
      }
      if ("mat4x4f" === a2 || "mat4x4h" === a2) {
        const e4 = new Float32Array(this.buffer, s2, 16);
        return void (t2 instanceof Ue ? (e4[0] = t2.data[0], e4[1] = t2.data[1], e4[2] = t2.data[2], e4[3] = t2.data[3], e4[4] = t2.data[4], e4[5] = t2.data[5], e4[6] = t2.data[6], e4[7] = t2.data[7], e4[8] = t2.data[8], e4[9] = t2.data[9], e4[10] = t2.data[10], e4[11] = t2.data[11], e4[12] = t2.data[12], e4[13] = t2.data[13], e4[14] = t2.data[14], e4[15] = t2.data[15]) : (e4[0] = t2[0], e4[1] = t2[1], e4[2] = t2[2], e4[3] = t2[3], e4[4] = t2[4], e4[5] = t2[5], e4[6] = t2[6], e4[7] = t2[7], e4[8] = t2[8], e4[9] = t2[9], e4[10] = t2[10], e4[11] = t2[11], e4[12] = t2[12], e4[13] = t2[13], e4[14] = t2[14], e4[15] = t2[15]));
      }
      if (t2 instanceof _Pe) {
        if (n2 === t2.typeInfo) {
          return void new Uint8Array(this.buffer, s2, t2.buffer.byteLength).set(new Uint8Array(t2.buffer));
        }
        console.error("SetDataValue: Type mismatch", a2, t2.typeInfo.getTypeName());
      } else console.error(`SetData: Unknown type ${a2}`);
    } else t2 instanceof Be && (new Int32Array(this.buffer, s2, 1)[0] = t2.value);
    else t2 instanceof Be && (new Uint32Array(this.buffer, s2, 1)[0] = t2.value);
    else t2 instanceof Be && (new Int32Array(this.buffer, s2, 1)[0] = t2.value);
    else t2 instanceof Be && (new Float32Array(this.buffer, s2, 1)[0] = t2.value);
  }
  getSubData(t2, r2, i2) {
    var o2, c2, l2;
    if (null === r2) return this;
    let u2 = this.offset, h2 = this.typeInfo;
    for (; r2; ) {
      if (r2 instanceof ve) {
        const e3 = r2.index, n2 = e3 instanceof fe ? t2.evalExpression(e3, i2) : e3;
        let a2 = 0;
        if (n2 instanceof Be ? a2 = n2.value : "number" == typeof n2 ? a2 = n2 : console.error("GetDataValue: Invalid index type", e3), h2 instanceof s) u2 += a2 * h2.stride, h2 = h2.format;
        else {
          const e4 = h2.getTypeName();
          "mat4x4" === e4 || "mat4x4f" === e4 || "mat4x4h" === e4 ? (u2 += 16 * a2, h2 = t2.getTypeInfo("vec4f")) : console.error(`getDataValue: Type ${h2.getTypeName()} is not an array`);
        }
      } else {
        if (!(r2 instanceof pe)) return console.error("GetDataValue: Unknown postfix type", r2), null;
        {
          const s2 = r2.value;
          if (h2 instanceof n) {
            let e3 = false;
            for (const t3 of h2.members) if (t3.name === s2) {
              u2 += t3.offset, h2 = t3.type, e3 = true;
              break;
            }
            if (!e3) return console.error(`GetDataValue: Member ${s2} not found`), null;
          } else if (h2 instanceof e) {
            const e3 = h2.getTypeName();
            if ("vec2f" === e3 || "vec3f" === e3 || "vec4f" === e3 || "vec2i" === e3 || "vec3i" === e3 || "vec4i" === e3 || "vec2u" === e3 || "vec3u" === e3 || "vec4u" === e3 || "vec2b" === e3 || "vec3b" === e3 || "vec4b" === e3 || "vec2h" === e3 || "vec3h" === e3 || "vec4h" === e3 || "vec2" === e3 || "vec3" === e3 || "vec4" === e3) {
              if (s2.length > 0 && s2.length < 5) {
                let n2 = "f";
                const r3 = [];
                for (let a2 = 0; a2 < s2.length; ++a2) {
                  const i3 = s2[a2].toLowerCase();
                  let o3 = 0;
                  if ("x" === i3 || "r" === i3) o3 = 0;
                  else if ("y" === i3 || "g" === i3) o3 = 1;
                  else if ("z" === i3 || "b" === i3) o3 = 2;
                  else {
                    if ("w" !== i3 && "a" !== i3) return console.error(`Unknown member ${s2}`), null;
                    o3 = 3;
                  }
                  if (1 === s2.length) {
                    if (e3.endsWith("f")) return this.buffer.byteLength < u2 + 4 * o3 + 4 ? (console.log("Insufficient buffer data"), null) : new Be(new Float32Array(this.buffer, u2 + 4 * o3, 1), t2.getTypeInfo("f32"), this);
                    if (e3.endsWith("h")) return new Be(new Float32Array(this.buffer, u2 + 4 * o3, 1), t2.getTypeInfo("f16"), this);
                    if (e3.endsWith("i")) return new Be(new Int32Array(this.buffer, u2 + 4 * o3, 1), t2.getTypeInfo("i32"), this);
                    if (e3.endsWith("b")) return new Be(new Int32Array(this.buffer, u2 + 4 * o3, 1), t2.getTypeInfo("bool"), this);
                    if (e3.endsWith("u")) return new Be(new Uint32Array(this.buffer, u2 + 4 * o3, 1), t2.getTypeInfo("i32"), this);
                  }
                  if ("vec2f" === e3) r3.push(new Float32Array(this.buffer, u2, 2)[o3]);
                  else if ("vec3f" === e3) {
                    if (u2 + 12 >= this.buffer.byteLength) return console.log("Insufficient buffer data"), null;
                    const e4 = new Float32Array(this.buffer, u2, 3);
                    r3.push(e4[o3]);
                  } else if ("vec4f" === e3) r3.push(new Float32Array(this.buffer, u2, 4)[o3]);
                  else if ("vec2i" === e3) n2 = "i", r3.push(new Int32Array(this.buffer, u2, 2)[o3]);
                  else if ("vec3i" === e3) n2 = "i", r3.push(new Int32Array(this.buffer, u2, 3)[o3]);
                  else if ("vec4i" === e3) n2 = "i", r3.push(new Int32Array(this.buffer, u2, 4)[o3]);
                  else if ("vec2u" === e3) {
                    n2 = "u";
                    const e4 = new Uint32Array(this.buffer, u2, 2);
                    r3.push(e4[o3]);
                  } else "vec3u" === e3 ? (n2 = "u", r3.push(new Uint32Array(this.buffer, u2, 3)[o3])) : "vec4u" === e3 && (n2 = "u", r3.push(new Uint32Array(this.buffer, u2, 4)[o3]));
                }
                return 2 === r3.length ? h2 = t2.getTypeInfo(`vec2${n2}`) : 3 === r3.length ? h2 = t2.getTypeInfo(`vec3${n2}`) : 4 === r3.length ? h2 = t2.getTypeInfo(`vec4${n2}`) : console.error(`GetDataValue: Invalid vector length ${r3.length}`), new Me(r3, h2, null);
              }
              return console.error(`GetDataValue: Unknown member ${s2}`), null;
            }
            return console.error(`GetDataValue: Type ${e3} is not a struct`), null;
          }
        }
      }
      r2 = r2.postfix;
    }
    const f2 = h2.getTypeName();
    return "f32" === f2 ? new Be(new Float32Array(this.buffer, u2, 1), h2, this) : "i32" === f2 ? new Be(new Int32Array(this.buffer, u2, 1), h2, this) : "u32" === f2 ? new Be(new Uint32Array(this.buffer, u2, 1), h2, this) : "vec2f" === f2 ? new Me(new Float32Array(this.buffer, u2, 2), h2, this) : "vec3f" === f2 ? new Me(new Float32Array(this.buffer, u2, 3), h2, this) : "vec4f" === f2 ? new Me(new Float32Array(this.buffer, u2, 4), h2, this) : "vec2i" === f2 ? new Me(new Int32Array(this.buffer, u2, 2), h2, this) : "vec3i" === f2 ? new Me(new Int32Array(this.buffer, u2, 3), h2, this) : "vec4i" === f2 ? new Me(new Int32Array(this.buffer, u2, 4), h2, this) : "vec2u" === f2 ? new Me(new Uint32Array(this.buffer, u2, 2), h2, this) : "vec3u" === f2 ? new Me(new Uint32Array(this.buffer, u2, 3), h2, this) : "vec4u" === f2 ? new Me(new Uint32Array(this.buffer, u2, 4), h2, this) : h2 instanceof a && "atomic" === h2.name ? "u32" === (null === (o2 = h2.format) || void 0 === o2 ? void 0 : o2.name) ? new Be(new Uint32Array(this.buffer, u2, 1)[0], h2.format, this) : "i32" === (null === (c2 = h2.format) || void 0 === c2 ? void 0 : c2.name) ? new Be(new Int32Array(this.buffer, u2, 1)[0], h2.format, this) : (console.error(`GetDataValue: Invalid atomic format ${null === (l2 = h2.format) || void 0 === l2 ? void 0 : l2.name}`), null) : new _Pe(this.buffer, h2, u2, this);
  }
  toString() {
    let e3 = "";
    if (this.typeInfo instanceof s) if ("f32" === this.typeInfo.format.name) {
      const t2 = new Float32Array(this.buffer, this.offset);
      e3 = `[${t2[0]}`;
      for (let n2 = 1; n2 < t2.length; ++n2) e3 += `, ${t2[n2]}`;
    } else if ("i32" === this.typeInfo.format.name) {
      const t2 = new Int32Array(this.buffer, this.offset);
      e3 = `[${t2[0]}`;
      for (let n2 = 1; n2 < t2.length; ++n2) e3 += `, ${t2[n2]}`;
    } else if ("u32" === this.typeInfo.format.name) {
      const t2 = new Uint32Array(this.buffer, this.offset);
      e3 = `[${t2[0]}`;
      for (let n2 = 1; n2 < t2.length; ++n2) e3 += `, ${t2[n2]}`;
    } else if ("vec2f" === this.typeInfo.format.name) {
      const t2 = new Float32Array(this.buffer, this.offset);
      e3 = `[${t2[0]}, ${t2[1]}]`;
      for (let n2 = 1; n2 < t2.length / 2; ++n2) e3 += `, [${t2[2 * n2]}, ${t2[2 * n2 + 1]}]`;
    } else if ("vec3f" === this.typeInfo.format.name) {
      const t2 = new Float32Array(this.buffer, this.offset);
      e3 = `[${t2[0]}, ${t2[1]}, ${t2[2]}]`;
      for (let n2 = 4; n2 < t2.length; n2 += 4) e3 += `, [${t2[n2]}, ${t2[n2 + 1]}, ${t2[n2 + 2]}]`;
    } else if ("vec4f" === this.typeInfo.format.name) {
      const t2 = new Float32Array(this.buffer, this.offset);
      e3 = `[${t2[0]}, ${t2[1]}, ${t2[2]}, ${t2[3]}]`;
      for (let n2 = 4; n2 < t2.length; n2 += 4) e3 += `, [${t2[n2]}, ${t2[n2 + 1]}, ${t2[n2 + 2]}, ${t2[n2 + 3]}]`;
    } else e3 = "[...]";
    else this.typeInfo instanceof n ? e3 += "{...}" : e3 = "[...]";
    return e3;
  }
};
var We = class _We extends Ne {
  constructor(e3, t2, n2, s2) {
    super(t2, null), this.data = e3, this.descriptor = n2, this.view = s2;
  }
  clone() {
    return new _We(this.data, this.typeInfo, this.descriptor, this.view);
  }
  get width() {
    var e3, t2;
    const n2 = this.descriptor.size;
    return n2 instanceof Array && n2.length > 0 ? null !== (e3 = n2[0]) && void 0 !== e3 ? e3 : 0 : n2 instanceof Object && null !== (t2 = n2.width) && void 0 !== t2 ? t2 : 0;
  }
  get height() {
    var e3, t2;
    const n2 = this.descriptor.size;
    return n2 instanceof Array && n2.length > 1 ? null !== (e3 = n2[1]) && void 0 !== e3 ? e3 : 0 : n2 instanceof Object && null !== (t2 = n2.height) && void 0 !== t2 ? t2 : 0;
  }
  get depthOrArrayLayers() {
    var e3, t2;
    const n2 = this.descriptor.size;
    return n2 instanceof Array && n2.length > 2 ? null !== (e3 = n2[2]) && void 0 !== e3 ? e3 : 0 : n2 instanceof Object && null !== (t2 = n2.depthOrArrayLayers) && void 0 !== t2 ? t2 : 0;
  }
  get format() {
    var e3;
    return this.descriptor && null !== (e3 = this.descriptor.format) && void 0 !== e3 ? e3 : "rgba8unorm";
  }
  get sampleCount() {
    var e3;
    return this.descriptor && null !== (e3 = this.descriptor.sampleCount) && void 0 !== e3 ? e3 : 1;
  }
  get mipLevelCount() {
    var e3;
    return this.descriptor && null !== (e3 = this.descriptor.mipLevelCount) && void 0 !== e3 ? e3 : 1;
  }
  get dimension() {
    var e3;
    return this.descriptor && null !== (e3 = this.descriptor.dimension) && void 0 !== e3 ? e3 : "2d";
  }
  getMipLevelSize(e3) {
    if (e3 >= this.mipLevelCount) return [0, 0, 0];
    const t2 = [this.width, this.height, this.depthOrArrayLayers];
    for (let n2 = 0; n2 < t2.length; ++n2) t2[n2] = Math.max(1, t2[n2] >> e3);
    return t2;
  }
  get texelByteSize() {
    const e3 = this.format, t2 = S[e3];
    return t2 ? t2.isDepthStencil ? 4 : t2.bytesPerBlock : 0;
  }
  get bytesPerRow() {
    return this.width * this.texelByteSize;
  }
  get isDepthStencil() {
    const e3 = this.format, t2 = S[e3];
    return !!t2 && t2.isDepthStencil;
  }
  getGpuSize() {
    const e3 = this.format, t2 = S[e3], n2 = this.width;
    if (!e3 || n2 <= 0 || !t2) return -1;
    const s2 = this.height, r2 = this.depthOrArrayLayers, a2 = this.dimension;
    return n2 / t2.blockWidth * ("1d" === a2 ? 1 : s2 / t2.blockHeight) * t2.bytesPerBlock * r2;
  }
  getPixel(e3, t2, n2 = 0, s2 = 0) {
    const r2 = this.texelByteSize, a2 = this.bytesPerRow, i2 = this.height, o2 = this.data[s2];
    return k(new Uint8Array(o2), e3, t2, n2, s2, i2, a2, r2, this.format);
  }
  setPixel(e3, t2, n2, s2, r2) {
    const a2 = this.texelByteSize, i2 = this.bytesPerRow, o2 = this.height, c2 = this.data[s2];
    !function(e4, t3, n3, s3, r3, a3, i3, o3, c3, l2) {
      const u2 = s3 * (i3 >>= r3) * (a3 >>= r3) + n3 * i3 + t3 * o3;
      switch (c3) {
        case "r8unorm":
          return void T(e4, u2, "8unorm", 1, l2);
        case "r8snorm":
          return void T(e4, u2, "8snorm", 1, l2);
        case "r8uint":
          return void T(e4, u2, "8uint", 1, l2);
        case "r8sint":
          return void T(e4, u2, "8sint", 1, l2);
        case "rg8unorm":
          return void T(e4, u2, "8unorm", 2, l2);
        case "rg8snorm":
          return void T(e4, u2, "8snorm", 2, l2);
        case "rg8uint":
          return void T(e4, u2, "8uint", 2, l2);
        case "rg8sint":
          return void T(e4, u2, "8sint", 2, l2);
        case "rgba8unorm-srgb":
        case "rgba8unorm":
        case "bgra8unorm-srgb":
        case "bgra8unorm":
          return void T(e4, u2, "8unorm", 4, l2);
        case "rgba8snorm":
          return void T(e4, u2, "8snorm", 4, l2);
        case "rgba8uint":
          return void T(e4, u2, "8uint", 4, l2);
        case "rgba8sint":
          return void T(e4, u2, "8sint", 4, l2);
        case "r16uint":
          return void T(e4, u2, "16uint", 1, l2);
        case "r16sint":
          return void T(e4, u2, "16sint", 1, l2);
        case "r16float":
          return void T(e4, u2, "16float", 1, l2);
        case "rg16uint":
          return void T(e4, u2, "16uint", 2, l2);
        case "rg16sint":
          return void T(e4, u2, "16sint", 2, l2);
        case "rg16float":
          return void T(e4, u2, "16float", 2, l2);
        case "rgba16uint":
          return void T(e4, u2, "16uint", 4, l2);
        case "rgba16sint":
          return void T(e4, u2, "16sint", 4, l2);
        case "rgba16float":
          return void T(e4, u2, "16float", 4, l2);
        case "r32uint":
          return void T(e4, u2, "32uint", 1, l2);
        case "r32sint":
          return void T(e4, u2, "32sint", 1, l2);
        case "depth16unorm":
        case "depth24plus":
        case "depth24plus-stencil8":
        case "depth32float":
        case "depth32float-stencil8":
        case "r32float":
          return void T(e4, u2, "32float", 1, l2);
        case "rg32uint":
          return void T(e4, u2, "32uint", 2, l2);
        case "rg32sint":
          return void T(e4, u2, "32sint", 2, l2);
        case "rg32float":
          return void T(e4, u2, "32float", 2, l2);
        case "rgba32uint":
          return void T(e4, u2, "32uint", 4, l2);
        case "rgba32sint":
          return void T(e4, u2, "32sint", 4, l2);
        case "rgba32float":
          return void T(e4, u2, "32float", 4, l2);
        case "rg11b10ufloat":
          console.error("TODO: rg11b10ufloat not supported for writing");
      }
    }(new Uint8Array(c2), e3, t2, n2, s2, o2, i2, a2, this.format, r2);
  }
};
((e3) => {
  e3[e3.token = 0] = "token", e3[e3.keyword = 1] = "keyword", e3[e3.reserved = 2] = "reserved";
})(z || (z = {}));
var qe = class {
  constructor(e3, t2, n2) {
    this.name = e3, this.type = t2, this.rule = n2;
  }
  toString() {
    return this.name;
  }
};
var He = class {
};
H = He, He.none = new qe("", z.reserved, ""), He.eof = new qe("EOF", z.token, ""), He.reserved = { asm: new qe("asm", z.reserved, "asm"), bf16: new qe("bf16", z.reserved, "bf16"), do: new qe("do", z.reserved, "do"), enum: new qe("enum", z.reserved, "enum"), f16: new qe("f16", z.reserved, "f16"), f64: new qe("f64", z.reserved, "f64"), handle: new qe("handle", z.reserved, "handle"), i8: new qe("i8", z.reserved, "i8"), i16: new qe("i16", z.reserved, "i16"), i64: new qe("i64", z.reserved, "i64"), mat: new qe("mat", z.reserved, "mat"), premerge: new qe("premerge", z.reserved, "premerge"), regardless: new qe("regardless", z.reserved, "regardless"), typedef: new qe("typedef", z.reserved, "typedef"), u8: new qe("u8", z.reserved, "u8"), u16: new qe("u16", z.reserved, "u16"), u64: new qe("u64", z.reserved, "u64"), unless: new qe("unless", z.reserved, "unless"), using: new qe("using", z.reserved, "using"), vec: new qe("vec", z.reserved, "vec"), void: new qe("void", z.reserved, "void") }, He.keywords = { array: new qe("array", z.keyword, "array"), atomic: new qe("atomic", z.keyword, "atomic"), bool: new qe("bool", z.keyword, "bool"), f32: new qe("f32", z.keyword, "f32"), i32: new qe("i32", z.keyword, "i32"), mat2x2: new qe("mat2x2", z.keyword, "mat2x2"), mat2x3: new qe("mat2x3", z.keyword, "mat2x3"), mat2x4: new qe("mat2x4", z.keyword, "mat2x4"), mat3x2: new qe("mat3x2", z.keyword, "mat3x2"), mat3x3: new qe("mat3x3", z.keyword, "mat3x3"), mat3x4: new qe("mat3x4", z.keyword, "mat3x4"), mat4x2: new qe("mat4x2", z.keyword, "mat4x2"), mat4x3: new qe("mat4x3", z.keyword, "mat4x3"), mat4x4: new qe("mat4x4", z.keyword, "mat4x4"), ptr: new qe("ptr", z.keyword, "ptr"), sampler: new qe("sampler", z.keyword, "sampler"), sampler_comparison: new qe("sampler_comparison", z.keyword, "sampler_comparison"), struct: new qe("struct", z.keyword, "struct"), texture_1d: new qe("texture_1d", z.keyword, "texture_1d"), texture_2d: new qe("texture_2d", z.keyword, "texture_2d"), texture_2d_array: new qe("texture_2d_array", z.keyword, "texture_2d_array"), texture_3d: new qe("texture_3d", z.keyword, "texture_3d"), texture_cube: new qe("texture_cube", z.keyword, "texture_cube"), texture_cube_array: new qe("texture_cube_array", z.keyword, "texture_cube_array"), texture_multisampled_2d: new qe("texture_multisampled_2d", z.keyword, "texture_multisampled_2d"), texture_storage_1d: new qe("texture_storage_1d", z.keyword, "texture_storage_1d"), texture_storage_2d: new qe("texture_storage_2d", z.keyword, "texture_storage_2d"), texture_storage_2d_array: new qe("texture_storage_2d_array", z.keyword, "texture_storage_2d_array"), texture_storage_3d: new qe("texture_storage_3d", z.keyword, "texture_storage_3d"), texture_depth_2d: new qe("texture_depth_2d", z.keyword, "texture_depth_2d"), texture_depth_2d_array: new qe("texture_depth_2d_array", z.keyword, "texture_depth_2d_array"), texture_depth_cube: new qe("texture_depth_cube", z.keyword, "texture_depth_cube"), texture_depth_cube_array: new qe("texture_depth_cube_array", z.keyword, "texture_depth_cube_array"), texture_depth_multisampled_2d: new qe("texture_depth_multisampled_2d", z.keyword, "texture_depth_multisampled_2d"), texture_external: new qe("texture_external", z.keyword, "texture_external"), u32: new qe("u32", z.keyword, "u32"), vec2: new qe("vec2", z.keyword, "vec2"), vec3: new qe("vec3", z.keyword, "vec3"), vec4: new qe("vec4", z.keyword, "vec4"), bitcast: new qe("bitcast", z.keyword, "bitcast"), block: new qe("block", z.keyword, "block"), break: new qe("break", z.keyword, "break"), case: new qe("case", z.keyword, "case"), continue: new qe("continue", z.keyword, "continue"), continuing: new qe("continuing", z.keyword, "continuing"), default: new qe("default", z.keyword, "default"), diagnostic: new qe("diagnostic", z.keyword, "diagnostic"), discard: new qe("discard", z.keyword, "discard"), else: new qe("else", z.keyword, "else"), enable: new qe("enable", z.keyword, "enable"), fallthrough: new qe("fallthrough", z.keyword, "fallthrough"), false: new qe("false", z.keyword, "false"), fn: new qe("fn", z.keyword, "fn"), for: new qe("for", z.keyword, "for"), function: new qe("function", z.keyword, "function"), if: new qe("if", z.keyword, "if"), let: new qe("let", z.keyword, "let"), const: new qe("const", z.keyword, "const"), loop: new qe("loop", z.keyword, "loop"), while: new qe("while", z.keyword, "while"), private: new qe("private", z.keyword, "private"), read: new qe("read", z.keyword, "read"), read_write: new qe("read_write", z.keyword, "read_write"), return: new qe("return", z.keyword, "return"), requires: new qe("requires", z.keyword, "requires"), storage: new qe("storage", z.keyword, "storage"), switch: new qe("switch", z.keyword, "switch"), true: new qe("true", z.keyword, "true"), alias: new qe("alias", z.keyword, "alias"), type: new qe("type", z.keyword, "type"), uniform: new qe("uniform", z.keyword, "uniform"), var: new qe("var", z.keyword, "var"), override: new qe("override", z.keyword, "override"), workgroup: new qe("workgroup", z.keyword, "workgroup"), write: new qe("write", z.keyword, "write"), r8unorm: new qe("r8unorm", z.keyword, "r8unorm"), r8snorm: new qe("r8snorm", z.keyword, "r8snorm"), r8uint: new qe("r8uint", z.keyword, "r8uint"), r8sint: new qe("r8sint", z.keyword, "r8sint"), r16uint: new qe("r16uint", z.keyword, "r16uint"), r16sint: new qe("r16sint", z.keyword, "r16sint"), r16float: new qe("r16float", z.keyword, "r16float"), rg8unorm: new qe("rg8unorm", z.keyword, "rg8unorm"), rg8snorm: new qe("rg8snorm", z.keyword, "rg8snorm"), rg8uint: new qe("rg8uint", z.keyword, "rg8uint"), rg8sint: new qe("rg8sint", z.keyword, "rg8sint"), r32uint: new qe("r32uint", z.keyword, "r32uint"), r32sint: new qe("r32sint", z.keyword, "r32sint"), r32float: new qe("r32float", z.keyword, "r32float"), rg16uint: new qe("rg16uint", z.keyword, "rg16uint"), rg16sint: new qe("rg16sint", z.keyword, "rg16sint"), rg16float: new qe("rg16float", z.keyword, "rg16float"), rgba8unorm: new qe("rgba8unorm", z.keyword, "rgba8unorm"), rgba8unorm_srgb: new qe("rgba8unorm_srgb", z.keyword, "rgba8unorm_srgb"), rgba8snorm: new qe("rgba8snorm", z.keyword, "rgba8snorm"), rgba8uint: new qe("rgba8uint", z.keyword, "rgba8uint"), rgba8sint: new qe("rgba8sint", z.keyword, "rgba8sint"), bgra8unorm: new qe("bgra8unorm", z.keyword, "bgra8unorm"), bgra8unorm_srgb: new qe("bgra8unorm_srgb", z.keyword, "bgra8unorm_srgb"), rgb10a2unorm: new qe("rgb10a2unorm", z.keyword, "rgb10a2unorm"), rg11b10float: new qe("rg11b10float", z.keyword, "rg11b10float"), rg32uint: new qe("rg32uint", z.keyword, "rg32uint"), rg32sint: new qe("rg32sint", z.keyword, "rg32sint"), rg32float: new qe("rg32float", z.keyword, "rg32float"), rgba16uint: new qe("rgba16uint", z.keyword, "rgba16uint"), rgba16sint: new qe("rgba16sint", z.keyword, "rgba16sint"), rgba16float: new qe("rgba16float", z.keyword, "rgba16float"), rgba32uint: new qe("rgba32uint", z.keyword, "rgba32uint"), rgba32sint: new qe("rgba32sint", z.keyword, "rgba32sint"), rgba32float: new qe("rgba32float", z.keyword, "rgba32float"), static_assert: new qe("static_assert", z.keyword, "static_assert") }, He.tokens = { decimal_float_literal: new qe("decimal_float_literal", z.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?[fh]?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+[fh]?)|(-?[0-9]+[fh])/), hex_float_literal: new qe("hex_float_literal", z.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+[fh]?))/), int_literal: new qe("int_literal", z.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/), uint_literal: new qe("uint_literal", z.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/), name: new qe("name", z.token, /([_\p{XID_Start}][\p{XID_Continue}]+)|([\p{XID_Start}])/u), ident: new qe("ident", z.token, /[_a-zA-Z][0-9a-zA-Z_]*/), and: new qe("and", z.token, "&"), and_and: new qe("and_and", z.token, "&&"), arrow: new qe("arrow ", z.token, "->"), attr: new qe("attr", z.token, "@"), forward_slash: new qe("forward_slash", z.token, "/"), bang: new qe("bang", z.token, "!"), bracket_left: new qe("bracket_left", z.token, "["), bracket_right: new qe("bracket_right", z.token, "]"), brace_left: new qe("brace_left", z.token, "{"), brace_right: new qe("brace_right", z.token, "}"), colon: new qe("colon", z.token, ":"), comma: new qe("comma", z.token, ","), equal: new qe("equal", z.token, "="), equal_equal: new qe("equal_equal", z.token, "=="), not_equal: new qe("not_equal", z.token, "!="), greater_than: new qe("greater_than", z.token, ">"), greater_than_equal: new qe("greater_than_equal", z.token, ">="), shift_right: new qe("shift_right", z.token, ">>"), less_than: new qe("less_than", z.token, "<"), less_than_equal: new qe("less_than_equal", z.token, "<="), shift_left: new qe("shift_left", z.token, "<<"), modulo: new qe("modulo", z.token, "%"), minus: new qe("minus", z.token, "-"), minus_minus: new qe("minus_minus", z.token, "--"), period: new qe("period", z.token, "."), plus: new qe("plus", z.token, "+"), plus_plus: new qe("plus_plus", z.token, "++"), or: new qe("or", z.token, "|"), or_or: new qe("or_or", z.token, "||"), paren_left: new qe("paren_left", z.token, "("), paren_right: new qe("paren_right", z.token, ")"), semicolon: new qe("semicolon", z.token, ";"), star: new qe("star", z.token, "*"), tilde: new qe("tilde", z.token, "~"), underscore: new qe("underscore", z.token, "_"), xor: new qe("xor", z.token, "^"), plus_equal: new qe("plus_equal", z.token, "+="), minus_equal: new qe("minus_equal", z.token, "-="), times_equal: new qe("times_equal", z.token, "*="), division_equal: new qe("division_equal", z.token, "/="), modulo_equal: new qe("modulo_equal", z.token, "%="), and_equal: new qe("and_equal", z.token, "&="), or_equal: new qe("or_equal", z.token, "|="), xor_equal: new qe("xor_equal", z.token, "^="), shift_right_equal: new qe("shift_right_equal", z.token, ">>="), shift_left_equal: new qe("shift_left_equal", z.token, "<<=") }, He.simpleTokens = { "@": H.tokens.attr, "{": H.tokens.brace_left, "}": H.tokens.brace_right, ":": H.tokens.colon, ",": H.tokens.comma, "(": H.tokens.paren_left, ")": H.tokens.paren_right, ";": H.tokens.semicolon }, He.literalTokens = { "&": H.tokens.and, "&&": H.tokens.and_and, "->": H.tokens.arrow, "/": H.tokens.forward_slash, "!": H.tokens.bang, "[": H.tokens.bracket_left, "]": H.tokens.bracket_right, "=": H.tokens.equal, "==": H.tokens.equal_equal, "!=": H.tokens.not_equal, ">": H.tokens.greater_than, ">=": H.tokens.greater_than_equal, ">>": H.tokens.shift_right, "<": H.tokens.less_than, "<=": H.tokens.less_than_equal, "<<": H.tokens.shift_left, "%": H.tokens.modulo, "-": H.tokens.minus, "--": H.tokens.minus_minus, ".": H.tokens.period, "+": H.tokens.plus, "++": H.tokens.plus_plus, "|": H.tokens.or, "||": H.tokens.or_or, "*": H.tokens.star, "~": H.tokens.tilde, _: H.tokens.underscore, "^": H.tokens.xor, "+=": H.tokens.plus_equal, "-=": H.tokens.minus_equal, "*=": H.tokens.times_equal, "/=": H.tokens.division_equal, "%=": H.tokens.modulo_equal, "&=": H.tokens.and_equal, "|=": H.tokens.or_equal, "^=": H.tokens.xor_equal, ">>=": H.tokens.shift_right_equal, "<<=": H.tokens.shift_left_equal }, He.regexTokens = { decimal_float_literal: H.tokens.decimal_float_literal, hex_float_literal: H.tokens.hex_float_literal, int_literal: H.tokens.int_literal, uint_literal: H.tokens.uint_literal, ident: H.tokens.ident }, He.storage_class = [H.keywords.function, H.keywords.private, H.keywords.workgroup, H.keywords.uniform, H.keywords.storage], He.access_mode = [H.keywords.read, H.keywords.write, H.keywords.read_write], He.sampler_type = [H.keywords.sampler, H.keywords.sampler_comparison], He.sampled_texture_type = [H.keywords.texture_1d, H.keywords.texture_2d, H.keywords.texture_2d_array, H.keywords.texture_3d, H.keywords.texture_cube, H.keywords.texture_cube_array], He.multisampled_texture_type = [H.keywords.texture_multisampled_2d], He.storage_texture_type = [H.keywords.texture_storage_1d, H.keywords.texture_storage_2d, H.keywords.texture_storage_2d_array, H.keywords.texture_storage_3d], He.depth_texture_type = [H.keywords.texture_depth_2d, H.keywords.texture_depth_2d_array, H.keywords.texture_depth_cube, H.keywords.texture_depth_cube_array, H.keywords.texture_depth_multisampled_2d], He.texture_external_type = [H.keywords.texture_external], He.any_texture_type = [...H.sampled_texture_type, ...H.multisampled_texture_type, ...H.storage_texture_type, ...H.depth_texture_type, ...H.texture_external_type], He.texel_format = [H.keywords.r8unorm, H.keywords.r8snorm, H.keywords.r8uint, H.keywords.r8sint, H.keywords.r16uint, H.keywords.r16sint, H.keywords.r16float, H.keywords.rg8unorm, H.keywords.rg8snorm, H.keywords.rg8uint, H.keywords.rg8sint, H.keywords.r32uint, H.keywords.r32sint, H.keywords.r32float, H.keywords.rg16uint, H.keywords.rg16sint, H.keywords.rg16float, H.keywords.rgba8unorm, H.keywords.rgba8unorm_srgb, H.keywords.rgba8snorm, H.keywords.rgba8uint, H.keywords.rgba8sint, H.keywords.bgra8unorm, H.keywords.bgra8unorm_srgb, H.keywords.rgb10a2unorm, H.keywords.rg11b10float, H.keywords.rg32uint, H.keywords.rg32sint, H.keywords.rg32float, H.keywords.rgba16uint, H.keywords.rgba16sint, H.keywords.rgba16float, H.keywords.rgba32uint, H.keywords.rgba32sint, H.keywords.rgba32float], He.const_literal = [H.tokens.int_literal, H.tokens.uint_literal, H.tokens.decimal_float_literal, H.tokens.hex_float_literal, H.keywords.true, H.keywords.false], He.literal_or_ident = [H.tokens.ident, H.tokens.int_literal, H.tokens.uint_literal, H.tokens.decimal_float_literal, H.tokens.hex_float_literal, H.tokens.name], He.element_count_expression = [H.tokens.int_literal, H.tokens.uint_literal, H.tokens.ident], He.template_types = [H.keywords.vec2, H.keywords.vec3, H.keywords.vec4, H.keywords.mat2x2, H.keywords.mat2x3, H.keywords.mat2x4, H.keywords.mat3x2, H.keywords.mat3x3, H.keywords.mat3x4, H.keywords.mat4x2, H.keywords.mat4x3, H.keywords.mat4x4, H.keywords.atomic, H.keywords.bitcast, ...H.any_texture_type], He.attribute_name = [H.tokens.ident, H.keywords.block, H.keywords.diagnostic], He.assignment_operators = [H.tokens.equal, H.tokens.plus_equal, H.tokens.minus_equal, H.tokens.times_equal, H.tokens.division_equal, H.tokens.modulo_equal, H.tokens.and_equal, H.tokens.or_equal, H.tokens.xor_equal, H.tokens.shift_right_equal, H.tokens.shift_left_equal], He.increment_operators = [H.tokens.plus_plus, H.tokens.minus_minus];
var ze = class {
  constructor(e3, t2, n2, s2, r2) {
    this.type = e3, this.lexeme = t2, this.line = n2, this.start = s2, this.end = r2;
  }
  toString() {
    return this.lexeme;
  }
  isTemplateType() {
    return -1 != He.template_types.indexOf(this.type);
  }
  isArrayType() {
    return this.type == He.keywords.array;
  }
  isArrayOrTemplateType() {
    return this.isArrayType() || this.isTemplateType();
  }
};
var Re = class {
  constructor(e3) {
    this._tokens = [], this._start = 0, this._current = 0, this._line = 1, this._source = null != e3 ? e3 : "";
  }
  scanTokens() {
    for (; !this._isAtEnd(); ) if (this._start = this._current, !this.scanToken()) throw `Invalid syntax at line ${this._line}`;
    return this._tokens.push(new ze(He.eof, "", this._line, this._current, this._current)), this._tokens;
  }
  scanToken() {
    let e3 = this._advance();
    if ("\n" == e3) return this._line++, true;
    if (this._isWhitespace(e3)) return true;
    if ("/" == e3) {
      if ("/" == this._peekAhead()) {
        for (; "\n" != e3; ) {
          if (this._isAtEnd()) return true;
          e3 = this._advance();
        }
        return this._line++, true;
      }
      if ("*" == this._peekAhead()) {
        this._advance();
        let t3 = 1;
        for (; t3 > 0; ) {
          if (this._isAtEnd()) return true;
          if (e3 = this._advance(), "\n" == e3) this._line++;
          else if ("*" == e3) {
            if ("/" == this._peekAhead() && (this._advance(), t3--, 0 == t3)) return true;
          } else "/" == e3 && "*" == this._peekAhead() && (this._advance(), t3++);
        }
        return true;
      }
    }
    const t2 = He.simpleTokens[e3];
    if (t2) return this._addToken(t2), true;
    let n2 = He.none;
    const s2 = this._isAlpha(e3), r2 = "_" === e3;
    if (this._isAlphaNumeric(e3)) {
      let t3 = this._peekAhead();
      for (; this._isAlphaNumeric(t3); ) e3 += this._advance(), t3 = this._peekAhead();
    }
    if (s2) {
      const t3 = He.keywords[e3];
      if (t3) return this._addToken(t3), true;
    }
    if (s2 || r2) return this._addToken(He.tokens.ident), true;
    for (; ; ) {
      let t3 = this._findType(e3);
      const s3 = this._peekAhead();
      if ("-" == e3 && this._tokens.length > 0) {
        if ("=" == s3) return this._current++, e3 += s3, this._addToken(He.tokens.minus_equal), true;
        if ("-" == s3) return this._current++, e3 += s3, this._addToken(He.tokens.minus_minus), true;
        const n3 = this._tokens.length - 1;
        if ((-1 != He.literal_or_ident.indexOf(this._tokens[n3].type) || this._tokens[n3].type == He.tokens.paren_right) && ">" != s3) return this._addToken(t3), true;
      }
      if (">" == e3 && (">" == s3 || "=" == s3)) {
        let e4 = false, n3 = this._tokens.length - 1;
        for (let t4 = 0; t4 < 5 && n3 >= 0 && -1 === He.assignment_operators.indexOf(this._tokens[n3].type); ++t4, --n3) if (this._tokens[n3].type === He.tokens.less_than) {
          n3 > 0 && this._tokens[n3 - 1].isArrayOrTemplateType() && (e4 = true);
          break;
        }
        if (e4) return this._addToken(t3), true;
      }
      if (t3 === He.none) {
        let s4 = e3, r3 = 0;
        const a2 = 2;
        for (let e4 = 0; e4 < a2; ++e4) if (s4 += this._peekAhead(e4), t3 = this._findType(s4), t3 !== He.none) {
          r3 = e4;
          break;
        }
        if (t3 === He.none) return n2 !== He.none && (this._current--, this._addToken(n2), true);
        e3 = s4, this._current += r3 + 1;
      }
      if (n2 = t3, this._isAtEnd()) break;
      e3 += this._advance();
    }
    return n2 !== He.none && (this._addToken(n2), true);
  }
  _findType(e3) {
    for (const t3 in He.regexTokens) {
      const n2 = He.regexTokens[t3];
      if (this._match(e3, n2.rule)) return n2;
    }
    const t2 = He.literalTokens[e3];
    return t2 || He.none;
  }
  _match(e3, t2) {
    const n2 = t2.exec(e3);
    return n2 && 0 == n2.index && n2[0] == e3;
  }
  _isAtEnd() {
    return this._current >= this._source.length;
  }
  _isAlpha(e3) {
    return !this._isNumeric(e3) && !this._isWhitespace(e3) && "_" !== e3 && "." !== e3 && "(" !== e3 && ")" !== e3 && "[" !== e3 && "]" !== e3 && "{" !== e3 && "}" !== e3 && "," !== e3 && ";" !== e3 && ":" !== e3 && "=" !== e3 && "!" !== e3 && "<" !== e3 && ">" !== e3 && "+" !== e3 && "-" !== e3 && "*" !== e3 && "/" !== e3 && "%" !== e3 && "&" !== e3 && "|" !== e3 && "^" !== e3 && "~" !== e3 && "@" !== e3 && "#" !== e3 && "?" !== e3 && "'" !== e3 && "`" !== e3 && '"' !== e3 && "\\" !== e3 && "\n" !== e3 && "\r" !== e3 && "	" !== e3 && "\0" !== e3;
  }
  _isNumeric(e3) {
    return e3 >= "0" && e3 <= "9";
  }
  _isAlphaNumeric(e3) {
    return this._isAlpha(e3) || this._isNumeric(e3) || "_" === e3;
  }
  _isWhitespace(e3) {
    return " " == e3 || "	" == e3 || "\r" == e3;
  }
  _advance(e3 = 0) {
    let t2 = this._source[this._current];
    return e3 = e3 || 0, e3++, this._current += e3, t2;
  }
  _peekAhead(e3 = 0) {
    return e3 = e3 || 0, this._current + e3 >= this._source.length ? "\0" : this._source[this._current + e3];
  }
  _addToken(e3) {
    const t2 = this._source.substring(this._start, this._current);
    this._tokens.push(new ze(e3, t2, this._line, this._start, this._current));
  }
};
function Ge(e3) {
  return Array.isArray(e3) || (null == e3 ? void 0 : e3.buffer) instanceof ArrayBuffer;
}
var Xe = new Float32Array(1);
var je = new Uint32Array(Xe.buffer);
var Ze = new Uint32Array(Xe.buffer);
var Qe = new Int32Array(1);
var Ye = new Float32Array(Qe.buffer);
var Ke = new Uint32Array(Qe.buffer);
var Je = new Uint32Array(1);
var et = new Float32Array(Je.buffer);
var tt = new Int32Array(Je.buffer);
function nt(e3, t2, n2) {
  if (t2 === n2) return e3;
  if ("f32" === t2) {
    if ("i32" === n2 || "x32" === n2) return Xe[0] = e3, je[0];
    if ("u32" === n2) return Xe[0] = e3, Ze[0];
  } else if ("i32" === t2 || "x32" === t2) {
    if ("f32" === n2) return Qe[0] = e3, Ye[0];
    if ("u32" === n2) return Qe[0] = e3, Ke[0];
  } else if ("u32" === t2) {
    if ("f32" === n2) return Je[0] = e3, et[0];
    if ("i32" === n2 || "x32" === n2) return Je[0] = e3, tt[0];
  }
  return console.error(`Unsupported cast from ${t2} to ${n2}`), e3;
}
var st = class {
  constructor(e3) {
    this.resources = null, this.inUse = false, this.info = null, this.node = e3;
  }
};
var rt = class {
  constructor(e3, t2) {
    this.align = e3, this.size = t2;
  }
};
var at = class _at {
  constructor() {
    this.uniforms = [], this.storage = [], this.textures = [], this.samplers = [], this.aliases = [], this.overrides = [], this.structs = [], this.entry = new d(), this.functions = [], this._types = /* @__PURE__ */ new Map(), this._functions = /* @__PURE__ */ new Map();
  }
  _isStorageTexture(e3) {
    return "texture_storage_1d" == e3.name || "texture_storage_2d" == e3.name || "texture_storage_2d_array" == e3.name || "texture_storage_3d" == e3.name;
  }
  updateAST(e3) {
    for (const t2 of e3) t2 instanceof D && this._functions.set(t2.name, new st(t2));
    for (const t2 of e3) if (t2 instanceof oe) {
      const e4 = this.getTypeInfo(t2, null);
      e4 instanceof n && this.structs.push(e4);
    }
    for (const t2 of e3) if (t2 instanceof te) this.aliases.push(this._getAliasInfo(t2));
    else {
      if (t2 instanceof M) {
        const e4 = t2, n2 = this._getAttributeNum(e4.attributes, "id", 0), s2 = null != e4.type ? this.getTypeInfo(e4.type, e4.attributes) : null;
        this.overrides.push(new h(e4.name, s2, e4.attributes, n2));
        continue;
      }
      if (this._isUniformVar(t2)) {
        const e4 = t2, n2 = this._getAttributeNum(e4.attributes, "group", 0), s2 = this._getAttributeNum(e4.attributes, "binding", 0), r2 = this.getTypeInfo(e4.type, e4.attributes), a2 = new o(e4.name, r2, n2, s2, e4.attributes, i.Uniform, e4.access);
        a2.access || (a2.access = "read"), this.uniforms.push(a2);
        continue;
      }
      if (this._isStorageVar(t2)) {
        const e4 = t2, n2 = this._getAttributeNum(e4.attributes, "group", 0), s2 = this._getAttributeNum(e4.attributes, "binding", 0), r2 = this.getTypeInfo(e4.type, e4.attributes), a2 = this._isStorageTexture(r2), c2 = new o(e4.name, r2, n2, s2, e4.attributes, a2 ? i.StorageTexture : i.Storage, e4.access);
        c2.access || (c2.access = "read"), this.storage.push(c2);
        continue;
      }
      if (this._isTextureVar(t2)) {
        const e4 = t2, n2 = this._getAttributeNum(e4.attributes, "group", 0), s2 = this._getAttributeNum(e4.attributes, "binding", 0), r2 = this.getTypeInfo(e4.type, e4.attributes), a2 = this._isStorageTexture(r2), c2 = new o(e4.name, r2, n2, s2, e4.attributes, a2 ? i.StorageTexture : i.Texture, e4.access);
        c2.access || (c2.access = "read"), a2 ? this.storage.push(c2) : this.textures.push(c2);
        continue;
      }
      if (this._isSamplerVar(t2)) {
        const e4 = t2, n2 = this._getAttributeNum(e4.attributes, "group", 0), s2 = this._getAttributeNum(e4.attributes, "binding", 0), r2 = this.getTypeInfo(e4.type, e4.attributes), a2 = new o(e4.name, r2, n2, s2, e4.attributes, i.Sampler, e4.access);
        this.samplers.push(a2);
        continue;
      }
    }
    for (const t2 of e3) if (t2 instanceof D) {
      const e4 = this._getAttribute(t2, "vertex"), n2 = this._getAttribute(t2, "fragment"), s2 = this._getAttribute(t2, "compute"), r2 = e4 || n2 || s2, a2 = new p(t2.name, null == r2 ? void 0 : r2.name, t2.attributes);
      a2.attributes = t2.attributes, a2.startLine = t2.startLine, a2.endLine = t2.endLine, this.functions.push(a2), this._functions.get(t2.name).info = a2, r2 && (this._functions.get(t2.name).inUse = true, a2.inUse = true, a2.resources = this._findResources(t2, !!r2), a2.inputs = this._getInputs(t2.args), a2.outputs = this._getOutputs(t2.returnType), this.entry[r2.name].push(a2)), a2.arguments = t2.args.map((e5) => new f(e5.name, this.getTypeInfo(e5.type, e5.attributes), e5.attributes)), a2.returnType = t2.returnType ? this.getTypeInfo(t2.returnType, t2.attributes) : null;
      continue;
    }
    for (const e4 of this._functions.values()) e4.info && (e4.info.inUse = e4.inUse, this._addCalls(e4.node, e4.info.calls));
    for (const e4 of this._functions.values()) e4.node.search((t2) => {
      var n2, s2, r2;
      if (t2 instanceof De) {
        if (t2.value) if (Ge(t2.value)) for (const s3 of t2.value) for (const t3 of this.overrides) s3 === t3.name && (null === (n2 = e4.info) || void 0 === n2 || n2.overrides.push(t3));
        else for (const n3 of this.overrides) t2.value === n3.name && (null === (s2 = e4.info) || void 0 === s2 || s2.overrides.push(n3));
      } else if (t2 instanceof ge) for (const n3 of this.overrides) t2.name === n3.name && (null === (r2 = e4.info) || void 0 === r2 || r2.overrides.push(n3));
    });
    for (const e4 of this.uniforms) this._markStructsInUse(e4.type);
    for (const e4 of this.storage) this._markStructsInUse(e4.type);
  }
  getFunctionInfo(e3) {
    for (const t2 of this.functions) if (t2.name == e3) return t2;
    return null;
  }
  getStructInfo(e3) {
    for (const t2 of this.structs) if (t2.name == e3) return t2;
    return null;
  }
  getOverrideInfo(e3) {
    for (const t2 of this.overrides) if (t2.name == e3) return t2;
    return null;
  }
  _markStructsInUse(e3) {
    if (e3) if (e3.isStruct) {
      if (e3.inUse = true, e3.members) for (const t2 of e3.members) this._markStructsInUse(t2.type);
    } else if (e3.isArray) this._markStructsInUse(e3.format);
    else if (e3.isTemplate) e3.format && this._markStructsInUse(e3.format);
    else {
      const t2 = this._getAlias(e3.name);
      t2 && this._markStructsInUse(t2);
    }
  }
  _addCalls(e3, t2) {
    var n2;
    for (const s2 of e3.calls) {
      const e4 = null === (n2 = this._functions.get(s2.name)) || void 0 === n2 ? void 0 : n2.info;
      e4 && t2.add(e4);
    }
  }
  findResource(e3, t2, n2) {
    if (n2) {
      for (const s2 of this.entry.compute) if (s2.name === n2) {
        for (const n3 of s2.resources) if (n3.group == e3 && n3.binding == t2) return n3;
      }
      for (const s2 of this.entry.vertex) if (s2.name === n2) {
        for (const n3 of s2.resources) if (n3.group == e3 && n3.binding == t2) return n3;
      }
      for (const s2 of this.entry.fragment) if (s2.name === n2) {
        for (const n3 of s2.resources) if (n3.group == e3 && n3.binding == t2) return n3;
      }
    }
    for (const n3 of this.uniforms) if (n3.group == e3 && n3.binding == t2) return n3;
    for (const n3 of this.storage) if (n3.group == e3 && n3.binding == t2) return n3;
    for (const n3 of this.textures) if (n3.group == e3 && n3.binding == t2) return n3;
    for (const n3 of this.samplers) if (n3.group == e3 && n3.binding == t2) return n3;
    return null;
  }
  _findResource(e3) {
    for (const t2 of this.uniforms) if (t2.name == e3) return t2;
    for (const t2 of this.storage) if (t2.name == e3) return t2;
    for (const t2 of this.textures) if (t2.name == e3) return t2;
    for (const t2 of this.samplers) if (t2.name == e3) return t2;
    return null;
  }
  _markStructsFromAST(e3) {
    const t2 = this.getTypeInfo(e3, null);
    this._markStructsInUse(t2);
  }
  _findResources(e3, t2) {
    const n2 = [], s2 = this, r2 = [];
    return e3.search((a2) => {
      if (a2 instanceof E) r2.push({});
      else if (a2 instanceof $) r2.pop();
      else if (a2 instanceof F) {
        const e4 = a2;
        t2 && null !== e4.type && this._markStructsFromAST(e4.type), r2.length > 0 && (r2[r2.length - 1][e4.name] = e4);
      } else if (a2 instanceof de) {
        const e4 = a2;
        t2 && null !== e4.type && this._markStructsFromAST(e4.type);
      } else if (a2 instanceof U) {
        const e4 = a2;
        t2 && null !== e4.type && this._markStructsFromAST(e4.type), r2.length > 0 && (r2[r2.length - 1][e4.name] = e4);
      } else if (a2 instanceof ge) {
        const e4 = a2;
        if (r2.length > 0) {
          if (r2[r2.length - 1][e4.name]) return;
        }
        const t3 = s2._findResource(e4.name);
        t3 && n2.push(t3);
      } else if (a2 instanceof me) {
        const r3 = a2, i2 = s2._functions.get(r3.name);
        i2 && (t2 && (i2.inUse = true), e3.calls.add(i2.node), null === i2.resources && (i2.resources = s2._findResources(i2.node, t2)), n2.push(...i2.resources));
      } else if (a2 instanceof X) {
        const r3 = a2, i2 = s2._functions.get(r3.name);
        i2 && (t2 && (i2.inUse = true), e3.calls.add(i2.node), null === i2.resources && (i2.resources = s2._findResources(i2.node, t2)), n2.push(...i2.resources));
      }
    }), [...new Map(n2.map((e4) => [e4.name, e4])).values()];
  }
  getBindGroups() {
    const e3 = [];
    function t2(t3, n2) {
      t3 >= e3.length && (e3.length = t3 + 1), void 0 === e3[t3] && (e3[t3] = []), n2 >= e3[t3].length && (e3[t3].length = n2 + 1);
    }
    for (const n2 of this.uniforms) {
      t2(n2.group, n2.binding);
      e3[n2.group][n2.binding] = n2;
    }
    for (const n2 of this.storage) {
      t2(n2.group, n2.binding);
      e3[n2.group][n2.binding] = n2;
    }
    for (const n2 of this.textures) {
      t2(n2.group, n2.binding);
      e3[n2.group][n2.binding] = n2;
    }
    for (const n2 of this.samplers) {
      t2(n2.group, n2.binding);
      e3[n2.group][n2.binding] = n2;
    }
    return e3;
  }
  _getOutputs(e3, t2 = void 0) {
    if (void 0 === t2 && (t2 = []), e3 instanceof oe) this._getStructOutputs(e3, t2);
    else {
      const n2 = this._getOutputInfo(e3);
      null !== n2 && t2.push(n2);
    }
    return t2;
  }
  _getStructOutputs(e3, t2) {
    for (const n2 of e3.members) if (n2.type instanceof oe) this._getStructOutputs(n2.type, t2);
    else {
      const e4 = this._getAttribute(n2, "location") || this._getAttribute(n2, "builtin");
      if (null !== e4) {
        const s2 = this.getTypeInfo(n2.type, n2.type.attributes), r2 = this._parseInt(e4.value), a2 = new u(n2.name, s2, e4.name, r2);
        t2.push(a2);
      }
    }
  }
  _getOutputInfo(e3) {
    const t2 = this._getAttribute(e3, "location") || this._getAttribute(e3, "builtin");
    if (null !== t2) {
      const n2 = this.getTypeInfo(e3, e3.attributes), s2 = this._parseInt(t2.value);
      return new u("", n2, t2.name, s2);
    }
    return null;
  }
  _getInputs(e3, t2 = void 0) {
    void 0 === t2 && (t2 = []);
    for (const n2 of e3) if (n2.type instanceof oe) this._getStructInputs(n2.type, t2);
    else {
      const e4 = this._getInputInfo(n2);
      null !== e4 && t2.push(e4);
    }
    return t2;
  }
  _getStructInputs(e3, t2) {
    for (const n2 of e3.members) if (n2.type instanceof oe) this._getStructInputs(n2.type, t2);
    else {
      const e4 = this._getInputInfo(n2);
      null !== e4 && t2.push(e4);
    }
  }
  _getInputInfo(e3) {
    const t2 = this._getAttribute(e3, "location") || this._getAttribute(e3, "builtin");
    if (null !== t2) {
      const n2 = this._getAttribute(e3, "interpolation"), s2 = this.getTypeInfo(e3.type, e3.attributes), r2 = this._parseInt(t2.value), a2 = new l(e3.name, s2, t2.name, r2);
      return null !== n2 && (a2.interpolation = this._parseString(n2.value)), a2;
    }
    return null;
  }
  _parseString(e3) {
    return e3 instanceof Array && (e3 = e3[0]), e3;
  }
  _parseInt(e3) {
    e3 instanceof Array && (e3 = e3[0]);
    const t2 = parseInt(e3);
    return isNaN(t2) ? e3 : t2;
  }
  _getAlias(e3) {
    for (const t2 of this.aliases) if (t2.name == e3) return t2.type;
    return null;
  }
  _getAliasInfo(e3) {
    return new c(e3.name, this.getTypeInfo(e3.type, null));
  }
  getTypeInfoByName(e3) {
    for (const t2 of this.structs) if (t2.name == e3) return t2;
    for (const t2 of this.aliases) if (t2.name == e3) return t2.type;
    return null;
  }
  getTypeInfo(i2, o2 = null) {
    if (this._types.has(i2)) return this._types.get(i2);
    if (i2 instanceof le) {
      const e3 = i2.type ? this.getTypeInfo(i2.type, i2.attributes) : null, t2 = new r(i2.name, e3, o2);
      return this._types.set(i2, t2), this._updateTypeInfo(t2), t2;
    }
    if (i2 instanceof ue) {
      const e3 = i2, t2 = e3.format ? this.getTypeInfo(e3.format, e3.attributes) : null, n2 = new s(e3.name, o2);
      return n2.format = t2, n2.count = e3.count, this._types.set(i2, n2), this._updateTypeInfo(n2), n2;
    }
    if (i2 instanceof oe) {
      const e3 = i2, s2 = new n(e3.name, o2);
      s2.startLine = e3.startLine, s2.endLine = e3.endLine;
      for (const n2 of e3.members) {
        const e4 = this.getTypeInfo(n2.type, n2.attributes);
        s2.members.push(new t(n2.name, e4, n2.attributes));
      }
      return this._types.set(i2, s2), this._updateTypeInfo(s2), s2;
    }
    if (i2 instanceof he) {
      const t2 = i2, n2 = t2.format instanceof ae, s2 = t2.format ? n2 ? this.getTypeInfo(t2.format, null) : new e(t2.format, null) : null, r2 = new a(t2.name, s2, o2, t2.access);
      return this._types.set(i2, r2), this._updateTypeInfo(r2), r2;
    }
    if (i2 instanceof ce) {
      const e3 = i2, t2 = e3.format ? this.getTypeInfo(e3.format, null) : null, n2 = new a(e3.name, t2, o2, e3.access);
      return this._types.set(i2, n2), this._updateTypeInfo(n2), n2;
    }
    const c2 = new e(i2.name, o2);
    return this._types.set(i2, c2), this._updateTypeInfo(c2), c2;
  }
  _updateTypeInfo(e3) {
    var t2, a2, i2;
    const o2 = this._getTypeSize(e3);
    if (e3.size = null !== (t2 = null == o2 ? void 0 : o2.size) && void 0 !== t2 ? t2 : 0, e3 instanceof s && e3.format) {
      const t3 = this._getTypeSize(e3.format);
      e3.stride = Math.max(null !== (a2 = null == t3 ? void 0 : t3.size) && void 0 !== a2 ? a2 : 0, null !== (i2 = null == t3 ? void 0 : t3.align) && void 0 !== i2 ? i2 : 0), this._updateTypeInfo(e3.format);
    }
    e3 instanceof r && this._updateTypeInfo(e3.format), e3 instanceof n && this._updateStructInfo(e3);
  }
  _updateStructInfo(e3) {
    var t2;
    let n2 = 0, s2 = 0, r2 = 0, a2 = 0;
    for (let i2 = 0, o2 = e3.members.length; i2 < o2; ++i2) {
      const o3 = e3.members[i2], c2 = this._getTypeSize(o3);
      if (!c2) continue;
      null !== (t2 = this._getAlias(o3.type.name)) && void 0 !== t2 || o3.type;
      const l2 = c2.align, u2 = c2.size;
      n2 = this._roundUp(l2, n2 + s2), s2 = u2, r2 = n2, a2 = Math.max(a2, l2), o3.offset = n2, o3.size = u2, this._updateTypeInfo(o3.type);
    }
    e3.size = this._roundUp(a2, r2 + s2), e3.align = a2;
  }
  _getTypeSize(r2) {
    var a2, i2;
    if (null == r2) return null;
    const o2 = this._getAttributeNum(r2.attributes, "size", 0), c2 = this._getAttributeNum(r2.attributes, "align", 0);
    if (r2 instanceof t && (r2 = r2.type), r2 instanceof e) {
      const e3 = this._getAlias(r2.name);
      null !== e3 && (r2 = e3);
    }
    {
      const e3 = _at._typeInfo[r2.name];
      if (void 0 !== e3) {
        const t2 = "f16" === (null === (a2 = r2.format) || void 0 === a2 ? void 0 : a2.name) ? 2 : 1;
        return new rt(Math.max(c2, e3.align / t2), Math.max(o2, e3.size / t2));
      }
    }
    {
      const e3 = _at._typeInfo[r2.name.substring(0, r2.name.length - 1)];
      if (e3) {
        const t2 = "h" === r2.name[r2.name.length - 1] ? 2 : 1;
        return new rt(Math.max(c2, e3.align / t2), Math.max(o2, e3.size / t2));
      }
    }
    if (r2 instanceof s) {
      let e3 = r2, t2 = 8, n2 = 8;
      const s2 = this._getTypeSize(e3.format);
      null !== s2 && (n2 = s2.size, t2 = s2.align);
      return n2 = e3.count * this._getAttributeNum(null !== (i2 = null == r2 ? void 0 : r2.attributes) && void 0 !== i2 ? i2 : null, "stride", this._roundUp(t2, n2)), o2 && (n2 = o2), new rt(Math.max(c2, t2), Math.max(o2, n2));
    }
    if (r2 instanceof n) {
      let e3 = 0, t2 = 0, n2 = 0, s2 = 0, a3 = 0;
      for (const t3 of r2.members) {
        const r3 = this._getTypeSize(t3.type);
        null !== r3 && (e3 = Math.max(r3.align, e3), n2 = this._roundUp(r3.align, n2 + s2), s2 = r3.size, a3 = n2);
      }
      return t2 = this._roundUp(e3, a3 + s2), new rt(Math.max(c2, e3), Math.max(o2, t2));
    }
    return null;
  }
  _isUniformVar(e3) {
    return e3 instanceof F && "uniform" == e3.storage;
  }
  _isStorageVar(e3) {
    return e3 instanceof F && "storage" == e3.storage;
  }
  _isTextureVar(e3) {
    return e3 instanceof F && null !== e3.type && -1 != _at._textureTypes.indexOf(e3.type.name);
  }
  _isSamplerVar(e3) {
    return e3 instanceof F && null !== e3.type && -1 != _at._samplerTypes.indexOf(e3.type.name);
  }
  _getAttribute(e3, t2) {
    const n2 = e3;
    if (!n2 || !n2.attributes) return null;
    const s2 = n2.attributes;
    for (let e4 of s2) if (e4.name == t2) return e4;
    return null;
  }
  _getAttributeNum(e3, t2, n2) {
    if (null === e3) return n2;
    for (let s2 of e3) if (s2.name == t2) {
      let e4 = null !== s2 && null !== s2.value ? s2.value : n2;
      return e4 instanceof Array && (e4 = e4[0]), "number" == typeof e4 ? e4 : "string" == typeof e4 ? parseInt(e4) : n2;
    }
    return n2;
  }
  _roundUp(e3, t2) {
    return Math.ceil(t2 / e3) * e3;
  }
};
at._typeInfo = { f16: { align: 2, size: 2 }, i32: { align: 4, size: 4 }, u32: { align: 4, size: 4 }, f32: { align: 4, size: 4 }, atomic: { align: 4, size: 4 }, vec2: { align: 8, size: 8 }, vec3: { align: 16, size: 12 }, vec4: { align: 16, size: 16 }, mat2x2: { align: 8, size: 16 }, mat3x2: { align: 8, size: 24 }, mat4x2: { align: 8, size: 32 }, mat2x3: { align: 16, size: 32 }, mat3x3: { align: 16, size: 48 }, mat4x3: { align: 16, size: 64 }, mat2x4: { align: 16, size: 32 }, mat3x4: { align: 16, size: 48 }, mat4x4: { align: 16, size: 64 } }, at._textureTypes = He.any_texture_type.map((e3) => e3.name), at._samplerTypes = He.sampler_type.map((e3) => e3.name);
var it = 0;
var ot = class _ot {
  constructor(e3, t2, n2) {
    this.id = it++, this.name = e3, this.value = t2, this.node = n2;
  }
  clone() {
    return new _ot(this.name, this.value, this.node);
  }
};
var ct = class _ct {
  constructor(e3) {
    this.id = it++, this.name = e3.name, this.node = e3;
  }
  clone() {
    return new _ct(this.node);
  }
};
var lt = class _lt {
  constructor(e3) {
    this.parent = null, this.variables = /* @__PURE__ */ new Map(), this.functions = /* @__PURE__ */ new Map(), this.currentFunctionName = "", this.id = it++, e3 && (this.parent = e3, this.currentFunctionName = e3.currentFunctionName);
  }
  getVariable(e3) {
    var t2;
    return this.variables.has(e3) ? null !== (t2 = this.variables.get(e3)) && void 0 !== t2 ? t2 : null : this.parent ? this.parent.getVariable(e3) : null;
  }
  getFunction(e3) {
    var t2;
    return this.functions.has(e3) ? null !== (t2 = this.functions.get(e3)) && void 0 !== t2 ? t2 : null : this.parent ? this.parent.getFunction(e3) : null;
  }
  createVariable(e3, t2, n2) {
    this.variables.set(e3, new ot(e3, t2, null != n2 ? n2 : null));
  }
  setVariable(e3, t2, n2) {
    const s2 = this.getVariable(e3);
    null !== s2 ? s2.value = t2 : this.createVariable(e3, t2, n2);
  }
  getVariableValue(e3) {
    var t2;
    const n2 = this.getVariable(e3);
    return null !== (t2 = null == n2 ? void 0 : n2.value) && void 0 !== t2 ? t2 : null;
  }
  clone() {
    return new _lt(this);
  }
};
var ut = class {
  evalExpression(e3, t2) {
    return null;
  }
  getTypeInfo(e3) {
    return null;
  }
  getVariableName(e3, t2) {
    return "";
  }
};
var ht = class {
  constructor(e3) {
    this.exec = e3;
  }
  getTypeInfo(e3) {
    return this.exec.getTypeInfo(e3);
  }
  All(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    let s2 = true;
    if (n2 instanceof Me) return n2.data.forEach((e4) => {
      e4 || (s2 = false);
    }), new Be(s2 ? 1 : 0, this.getTypeInfo("bool"));
    throw new Error(`All() expects a vector argument. Line ${e3.line}`);
  }
  Any(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) {
      const e4 = n2.data.some((e5) => e5);
      return new Be(e4 ? 1 : 0, this.getTypeInfo("bool"));
    }
    throw new Error(`Any() expects a vector argument. Line ${e3.line}`);
  }
  Select(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[2], t2);
    if (!(n2 instanceof Be)) throw new Error(`Select() expects a bool condition. Line ${e3.line}`);
    return n2.value ? this.exec.evalExpression(e3.args[1], t2) : this.exec.evalExpression(e3.args[0], t2);
  }
  ArrayLength(e3, t2) {
    let n2 = e3.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.evalExpression(n2, t2);
    if (s2 instanceof Pe && 0 === s2.typeInfo.size) {
      const e4 = s2.typeInfo, t3 = s2.buffer.byteLength / e4.stride;
      return new Be(t3, this.getTypeInfo("u32"));
    }
    return new Be(s2.typeInfo.size, this.getTypeInfo("u32"));
  }
  Abs(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.abs(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.abs(s2.value), s2.typeInfo);
  }
  Acos(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.acos(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.acos(s2.value), n2.typeInfo);
  }
  Acosh(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.acosh(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.acosh(s2.value), n2.typeInfo);
  }
  Asin(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.asin(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.asin(s2.value), n2.typeInfo);
  }
  Asinh(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.asinh(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.asinh(s2.value), n2.typeInfo);
  }
  Atan(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.atan(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.atan(s2.value), n2.typeInfo);
  }
  Atanh(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.atanh(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.atanh(s2.value), n2.typeInfo);
  }
  Atan2(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2), s2 = this.exec.evalExpression(e3.args[1], t2);
    if (n2 instanceof Me && s2 instanceof Me) return new Me(n2.data.map((e4, t3) => Math.atan2(e4, s2.data[t3])), n2.typeInfo);
    const r2 = n2, a2 = s2;
    return new Be(Math.atan2(r2.value, a2.value), n2.typeInfo);
  }
  Ceil(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.ceil(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.ceil(s2.value), n2.typeInfo);
  }
  _clamp(e3, t2, n2) {
    return Math.min(Math.max(e3, t2), n2);
  }
  Clamp(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2), s2 = this.exec.evalExpression(e3.args[1], t2), r2 = this.exec.evalExpression(e3.args[2], t2);
    if (n2 instanceof Me && s2 instanceof Me && r2 instanceof Me) return new Me(n2.data.map((e4, t3) => this._clamp(e4, s2.data[t3], r2.data[t3])), n2.typeInfo);
    const a2 = n2, i2 = s2, o2 = r2;
    return new Be(this._clamp(a2.value, i2.value, o2.value), n2.typeInfo);
  }
  Cos(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.cos(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.cos(s2.value), n2.typeInfo);
  }
  Cosh(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.cosh(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.cos(s2.value), n2.typeInfo);
  }
  CountLeadingZeros(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.clz32(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.clz32(s2.value), n2.typeInfo);
  }
  _countOneBits(e3) {
    let t2 = 0;
    for (; 0 !== e3; ) 1 & e3 && t2++, e3 >>= 1;
    return t2;
  }
  CountOneBits(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => this._countOneBits(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(this._countOneBits(s2.value), n2.typeInfo);
  }
  _countTrailingZeros(e3) {
    if (0 === e3) return 32;
    let t2 = 0;
    for (; !(1 & e3); ) e3 >>= 1, t2++;
    return t2;
  }
  CountTrailingZeros(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => this._countTrailingZeros(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(this._countTrailingZeros(s2.value), n2.typeInfo);
  }
  Cross(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2), s2 = this.exec.evalExpression(e3.args[1], t2);
    if (n2 instanceof Me && s2 instanceof Me) {
      if (3 !== n2.data.length || 3 !== s2.data.length) return console.error(`Cross() expects 3D vectors. Line ${e3.line}`), null;
      const t3 = n2.data, r2 = s2.data;
      return new Me([t3[1] * r2[2] - r2[1] * t3[2], t3[2] * r2[0] - r2[2] * t3[0], t3[0] * r2[1] - r2[0] * t3[1]], n2.typeInfo);
    }
    return console.error(`Cross() expects vector arguments. Line ${e3.line}`), null;
  }
  Degrees(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2), s2 = 180 / Math.PI;
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => e4 * s2), n2.typeInfo);
    return new Be(n2.value * s2, this.getTypeInfo("f32"));
  }
  Determinant(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Ue) {
      const e4 = n2.data, t3 = n2.typeInfo.getTypeName(), s2 = t3.endsWith("h") ? this.getTypeInfo("f16") : this.getTypeInfo("f32");
      if ("mat2x2" === t3 || "mat2x2f" === t3 || "mat2x2h" === t3) return new Be(e4[0] * e4[3] - e4[1] * e4[2], s2);
      if ("mat2x3" === t3 || "mat2x3f" === t3 || "mat2x3h" === t3) return new Be(e4[0] * (e4[4] * e4[8] - e4[5] * e4[7]) - e4[1] * (e4[3] * e4[8] - e4[5] * e4[6]) + e4[2] * (e4[3] * e4[7] - e4[4] * e4[6]), s2);
      if ("mat2x4" === t3 || "mat2x4f" === t3 || "mat2x4h" === t3) console.error(`TODO: Determinant for ${t3}`);
      else if ("mat3x2" === t3 || "mat3x2f" === t3 || "mat3x2h" === t3) console.error(`TODO: Determinant for ${t3}`);
      else {
        if ("mat3x3" === t3 || "mat3x3f" === t3 || "mat3x3h" === t3) return new Be(e4[0] * (e4[4] * e4[8] - e4[5] * e4[7]) - e4[1] * (e4[3] * e4[8] - e4[5] * e4[6]) + e4[2] * (e4[3] * e4[7] - e4[4] * e4[6]), s2);
        "mat3x4" === t3 || "mat3x4f" === t3 || "mat3x4h" === t3 || "mat4x2" === t3 || "mat4x2f" === t3 || "mat4x2h" === t3 || "mat4x3" === t3 || "mat4x3f" === t3 || "mat4x3h" === t3 ? console.error(`TODO: Determinant for ${t3}`) : "mat4x4" !== t3 && "mat4x4f" !== t3 && "mat4x4h" !== t3 || console.error(`TODO: Determinant for ${t3}`);
      }
    }
    return console.error(`Determinant expects a matrix argument. Line ${e3.line}`), null;
  }
  Distance(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2), s2 = this.exec.evalExpression(e3.args[1], t2);
    if (n2 instanceof Me && s2 instanceof Me) {
      let e4 = 0;
      for (let t3 = 0; t3 < n2.data.length; ++t3) e4 += (n2.data[t3] - s2.data[t3]) * (n2.data[t3] - s2.data[t3]);
      return new Be(Math.sqrt(e4), this.getTypeInfo("f32"));
    }
    const r2 = n2, a2 = s2;
    return new Be(Math.abs(r2.value - a2.value), n2.typeInfo);
  }
  _dot(e3, t2) {
    let n2 = 0;
    for (let s2 = 0; s2 < e3.length; ++s2) n2 += t2[s2] * e3[s2];
    return n2;
  }
  Dot(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2), s2 = this.exec.evalExpression(e3.args[1], t2);
    return n2 instanceof Me && s2 instanceof Me ? new Be(this._dot(n2.data, s2.data), this.getTypeInfo("f32")) : (console.error(`Dot() expects vector arguments. Line ${e3.line}`), null);
  }
  Dot4U8Packed(e3, t2) {
    return console.error(`TODO: dot4U8Packed. Line ${e3.line}`), null;
  }
  Dot4I8Packed(e3, t2) {
    return console.error(`TODO: dot4I8Packed. Line ${e3.line}`), null;
  }
  Exp(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.exp(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.exp(s2.value), n2.typeInfo);
  }
  Exp2(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.pow(2, e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.pow(2, s2.value), n2.typeInfo);
  }
  ExtractBits(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2), s2 = this.exec.evalExpression(e3.args[1], t2), r2 = this.exec.evalExpression(e3.args[2], t2);
    if ("u32" !== s2.typeInfo.name && "x32" !== s2.typeInfo.name) return console.error(`ExtractBits() expects an i32 offset argument. Line ${e3.line}`), null;
    if ("u32" !== r2.typeInfo.name && "x32" !== r2.typeInfo.name) return console.error(`ExtractBits() expects an i32 count argument. Line ${e3.line}`), null;
    const a2 = s2.value, i2 = r2.value;
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => e4 >> a2 & (1 << i2) - 1), n2.typeInfo);
    if ("i32" !== n2.typeInfo.name && "x32" !== n2.typeInfo.name) return console.error(`ExtractBits() expects an i32 argument. Line ${e3.line}`), null;
    const o2 = n2.value;
    return new Be(o2 >> a2 & (1 << i2) - 1, this.getTypeInfo("i32"));
  }
  FaceForward(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2), s2 = this.exec.evalExpression(e3.args[1], t2), r2 = this.exec.evalExpression(e3.args[2], t2);
    if (n2 instanceof Me && s2 instanceof Me && r2 instanceof Me) {
      const e4 = this._dot(s2.data, r2.data);
      return new Me(e4 < 0 ? Array.from(n2.data) : n2.data.map((e5) => -e5), n2.typeInfo);
    }
    return console.error(`FaceForward() expects vector arguments. Line ${e3.line}`), null;
  }
  _firstLeadingBit(e3) {
    return 0 === e3 ? -1 : 31 - Math.clz32(e3);
  }
  FirstLeadingBit(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => this._firstLeadingBit(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(this._firstLeadingBit(s2.value), n2.typeInfo);
  }
  _firstTrailingBit(e3) {
    return 0 === e3 ? -1 : Math.log2(e3 & -e3);
  }
  FirstTrailingBit(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => this._firstTrailingBit(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(this._firstTrailingBit(s2.value), n2.typeInfo);
  }
  Floor(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.floor(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.floor(s2.value), n2.typeInfo);
  }
  Fma(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2), s2 = this.exec.evalExpression(e3.args[1], t2), r2 = this.exec.evalExpression(e3.args[2], t2);
    if (n2 instanceof Me && s2 instanceof Me && r2 instanceof Me) return n2.data.length !== s2.data.length || n2.data.length !== r2.data.length ? (console.error(`Fma() expects vectors of the same length. Line ${e3.line}`), null) : new Me(n2.data.map((e4, t3) => e4 * s2.data[t3] + r2.data[t3]), n2.typeInfo);
    const a2 = n2, i2 = s2, o2 = r2;
    return new Be(a2.value * i2.value + o2.value, a2.typeInfo);
  }
  Fract(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => e4 - Math.floor(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(s2.value - Math.floor(s2.value), n2.typeInfo);
  }
  Frexp(e3, t2) {
    return console.error(`TODO: frexp. Line ${e3.line}`), null;
  }
  InsertBits(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2), s2 = this.exec.evalExpression(e3.args[1], t2), r2 = this.exec.evalExpression(e3.args[2], t2), a2 = this.exec.evalExpression(e3.args[3], t2);
    if ("u32" !== r2.typeInfo.name && "x32" !== r2.typeInfo.name) return console.error(`InsertBits() expects an i32 offset argument. Line ${e3.line}`), null;
    const i2 = r2.value, o2 = (1 << a2.value) - 1 << i2, c2 = ~o2;
    if (n2 instanceof Me && s2 instanceof Me) return new Me(n2.data.map((e4, t3) => e4 & c2 | s2.data[t3] << i2 & o2), n2.typeInfo);
    const l2 = n2.value, u2 = s2.value;
    return new Be(l2 & c2 | u2 << i2 & o2, n2.typeInfo);
  }
  InverseSqrt(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => 1 / Math.sqrt(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(1 / Math.sqrt(s2.value), n2.typeInfo);
  }
  Ldexp(e3, t2) {
    return console.error(`TODO: ldexp. Line ${e3.line}`), null;
  }
  Length(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) {
      let e4 = 0;
      return n2.data.forEach((t3) => {
        e4 += t3 * t3;
      }), new Be(Math.sqrt(e4), this.getTypeInfo("f32"));
    }
    const s2 = n2;
    return new Be(Math.abs(s2.value), n2.typeInfo);
  }
  Log(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.log(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.log(s2.value), n2.typeInfo);
  }
  Log2(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.log2(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.log2(s2.value), n2.typeInfo);
  }
  Max(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2), s2 = this.exec.evalExpression(e3.args[1], t2);
    if (n2 instanceof Me && s2 instanceof Me) return new Me(n2.data.map((e4, t3) => Math.max(e4, s2.data[t3])), n2.typeInfo);
    const r2 = n2, a2 = s2;
    return new Be(Math.max(r2.value, a2.value), n2.typeInfo);
  }
  Min(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2), s2 = this.exec.evalExpression(e3.args[1], t2);
    if (n2 instanceof Me && s2 instanceof Me) return new Me(n2.data.map((e4, t3) => Math.min(e4, s2.data[t3])), n2.typeInfo);
    const r2 = n2, a2 = s2;
    return new Be(Math.min(r2.value, a2.value), n2.typeInfo);
  }
  Mix(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2), s2 = this.exec.evalExpression(e3.args[1], t2), r2 = this.exec.evalExpression(e3.args[2], t2);
    if (n2 instanceof Me && s2 instanceof Me && r2 instanceof Me) return new Me(n2.data.map((e4, t3) => n2.data[t3] * (1 - r2.data[t3]) + s2.data[t3] * r2.data[t3]), n2.typeInfo);
    const a2 = s2, i2 = r2;
    return new Be(n2.value * (1 - i2.value) + a2.value * i2.value, n2.typeInfo);
  }
  Modf(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2), s2 = this.exec.evalExpression(e3.args[1], t2);
    if (n2 instanceof Me && s2 instanceof Me) return new Me(n2.data.map((e4, t3) => e4 % s2.data[t3]), n2.typeInfo);
    const r2 = s2;
    return new Be(n2.value % r2.value, n2.typeInfo);
  }
  Normalize(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) {
      const s2 = this.Length(e3, t2).value;
      return new Me(n2.data.map((e4) => e4 / s2), n2.typeInfo);
    }
    return console.error(`Normalize() expects a vector argument. Line ${e3.line}`), null;
  }
  Pow(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2), s2 = this.exec.evalExpression(e3.args[1], t2);
    if (n2 instanceof Me && s2 instanceof Me) return new Me(n2.data.map((e4, t3) => Math.pow(e4, s2.data[t3])), n2.typeInfo);
    const r2 = n2, a2 = s2;
    return new Be(Math.pow(r2.value, a2.value), n2.typeInfo);
  }
  QuantizeToF16(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => e4), n2.typeInfo);
    return new Be(n2.value, n2.typeInfo);
  }
  Radians(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => e4 * Math.PI / 180), n2.typeInfo);
    return new Be(n2.value * Math.PI / 180, this.getTypeInfo("f32"));
  }
  Reflect(e3, t2) {
    let n2 = this.exec.evalExpression(e3.args[0], t2), s2 = this.exec.evalExpression(e3.args[1], t2);
    if (n2 instanceof Me && s2 instanceof Me) {
      const e4 = this._dot(n2.data, s2.data);
      return new Me(n2.data.map((t3, n3) => t3 - 2 * e4 * s2.data[n3]), n2.typeInfo);
    }
    return console.error(`Reflect() expects vector arguments. Line ${e3.line}`), null;
  }
  Refract(e3, t2) {
    let n2 = this.exec.evalExpression(e3.args[0], t2), s2 = this.exec.evalExpression(e3.args[1], t2), r2 = this.exec.evalExpression(e3.args[2], t2);
    if (n2 instanceof Me && s2 instanceof Me && r2 instanceof Be) {
      const e4 = this._dot(s2.data, n2.data);
      return new Me(n2.data.map((t3, n3) => {
        const a2 = 1 - r2.value * r2.value * (1 - e4 * e4);
        if (a2 < 0) return 0;
        const i2 = Math.sqrt(a2);
        return r2.value * t3 - (r2.value * e4 + i2) * s2.data[n3];
      }), n2.typeInfo);
    }
    return console.error(`Refract() expects vector arguments and a scalar argument. Line ${e3.line}`), null;
  }
  ReverseBits(e3, t2) {
    return console.error(`TODO: reverseBits. Line ${e3.line}`), null;
  }
  Round(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.round(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.round(s2.value), n2.typeInfo);
  }
  Saturate(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.min(Math.max(e4, 0), 1)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.min(Math.max(s2.value, 0), 1), n2.typeInfo);
  }
  Sign(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.sign(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.sign(s2.value), n2.typeInfo);
  }
  Sin(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.sin(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.sin(s2.value), n2.typeInfo);
  }
  Sinh(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.sinh(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.sinh(s2.value), n2.typeInfo);
  }
  _smoothstep(e3, t2, n2) {
    const s2 = Math.min(Math.max((n2 - e3) / (t2 - e3), 0), 1);
    return s2 * s2 * (3 - 2 * s2);
  }
  SmoothStep(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2), s2 = this.exec.evalExpression(e3.args[1], t2), r2 = this.exec.evalExpression(e3.args[2], t2);
    if (r2 instanceof Me && n2 instanceof Me && s2 instanceof Me) return new Me(r2.data.map((e4, t3) => this._smoothstep(n2.data[t3], s2.data[t3], e4)), r2.typeInfo);
    const a2 = n2, i2 = s2, o2 = r2;
    return new Be(this._smoothstep(a2.value, i2.value, o2.value), r2.typeInfo);
  }
  Sqrt(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.sqrt(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.sqrt(s2.value), n2.typeInfo);
  }
  Step(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2), s2 = this.exec.evalExpression(e3.args[1], t2);
    if (s2 instanceof Me && n2 instanceof Me) return new Me(s2.data.map((e4, t3) => e4 < n2.data[t3] ? 0 : 1), s2.typeInfo);
    const r2 = n2;
    return new Be(s2.value < r2.value ? 0 : 1, r2.typeInfo);
  }
  Tan(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.tan(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.tan(s2.value), n2.typeInfo);
  }
  Tanh(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.tanh(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.tanh(s2.value), n2.typeInfo);
  }
  _getTransposeType(e3) {
    const t2 = e3.getTypeName();
    return "mat2x2f" === t2 || "mat2x2h" === t2 ? e3 : "mat2x3f" === t2 ? this.getTypeInfo("mat3x2f") : "mat2x3h" === t2 ? this.getTypeInfo("mat3x2h") : "mat2x4f" === t2 ? this.getTypeInfo("mat4x2f") : "mat2x4h" === t2 ? this.getTypeInfo("mat4x2h") : "mat3x2f" === t2 ? this.getTypeInfo("mat2x3f") : "mat3x2h" === t2 ? this.getTypeInfo("mat2x3h") : "mat3x3f" === t2 || "mat3x3h" === t2 ? e3 : "mat3x4f" === t2 ? this.getTypeInfo("mat4x3f") : "mat3x4h" === t2 ? this.getTypeInfo("mat4x3h") : "mat4x2f" === t2 ? this.getTypeInfo("mat2x4f") : "mat4x2h" === t2 ? this.getTypeInfo("mat2x4h") : "mat4x3f" === t2 ? this.getTypeInfo("mat3x4f") : "mat4x3h" === t2 ? this.getTypeInfo("mat3x4h") : ("mat4x4f" === t2 || "mat4x4h" === t2 || console.error(`Invalid matrix type ${t2}`), e3);
  }
  Transpose(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (!(n2 instanceof Ue)) return console.error(`Transpose() expects a matrix argument. Line ${e3.line}`), null;
    const s2 = this._getTransposeType(n2.typeInfo);
    if ("mat2x2" === n2.typeInfo.name || "mat2x2f" === n2.typeInfo.name || "mat2x2h" === n2.typeInfo.name) {
      const e4 = n2.data;
      return new Ue([e4[0], e4[2], e4[1], e4[3]], s2);
    }
    if ("mat2x3" === n2.typeInfo.name || "mat2x3f" === n2.typeInfo.name || "mat2x3h" === n2.typeInfo.name) {
      const e4 = n2.data;
      return new Ue([e4[0], e4[3], e4[6], e4[1], e4[4], e4[7]], s2);
    }
    if ("mat2x4" === n2.typeInfo.name || "mat2x4f" === n2.typeInfo.name || "mat2x4h" === n2.typeInfo.name) {
      const e4 = n2.data;
      return new Ue([e4[0], e4[4], e4[8], e4[12], e4[1], e4[5], e4[9], e4[13]], s2);
    }
    if ("mat3x2" === n2.typeInfo.name || "mat3x2f" === n2.typeInfo.name || "mat3x2h" === n2.typeInfo.name) {
      const e4 = n2.data;
      return new Ue([e4[0], e4[3], e4[1], e4[4], e4[2], e4[5]], s2);
    }
    if ("mat3x3" === n2.typeInfo.name || "mat3x3f" === n2.typeInfo.name || "mat3x3h" === n2.typeInfo.name) {
      const e4 = n2.data;
      return new Ue([e4[0], e4[3], e4[6], e4[1], e4[4], e4[7], e4[2], e4[5], e4[8]], s2);
    }
    if ("mat3x4" === n2.typeInfo.name || "mat3x4f" === n2.typeInfo.name || "mat3x4h" === n2.typeInfo.name) {
      const e4 = n2.data;
      return new Ue([e4[0], e4[4], e4[8], e4[12], e4[1], e4[5], e4[9], e4[13], e4[2], e4[6], e4[10], e4[14]], s2);
    }
    if ("mat4x2" === n2.typeInfo.name || "mat4x2f" === n2.typeInfo.name || "mat4x2h" === n2.typeInfo.name) {
      const e4 = n2.data;
      return new Ue([e4[0], e4[4], e4[1], e4[5], e4[2], e4[6]], s2);
    }
    if ("mat4x3" === n2.typeInfo.name || "mat4x3f" === n2.typeInfo.name || "mat4x3h" === n2.typeInfo.name) {
      const e4 = n2.data;
      return new Ue([e4[0], e4[4], e4[8], e4[1], e4[5], e4[9], e4[2], e4[6], e4[10]], s2);
    }
    if ("mat4x4" === n2.typeInfo.name || "mat4x4f" === n2.typeInfo.name || "mat4x4h" === n2.typeInfo.name) {
      const e4 = n2.data;
      return new Ue([e4[0], e4[4], e4[8], e4[12], e4[1], e4[5], e4[9], e4[13], e4[2], e4[6], e4[10], e4[14], e4[3], e4[7], e4[11], e4[15]], s2);
    }
    return console.error(`Invalid matrix type ${n2.typeInfo.name}`), null;
  }
  Trunc(e3, t2) {
    const n2 = this.exec.evalExpression(e3.args[0], t2);
    if (n2 instanceof Me) return new Me(n2.data.map((e4) => Math.trunc(e4)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.trunc(s2.value), n2.typeInfo);
  }
  Dpdx(e3, t2) {
    return console.error(`TODO: dpdx. Line ${e3.line}`), null;
  }
  DpdxCoarse(e3, t2) {
    return console.error(`TODO: dpdxCoarse. Line ${e3.line}`), null;
  }
  DpdxFine(e3, t2) {
    return console.error("TODO: dpdxFine"), null;
  }
  Dpdy(e3, t2) {
    return console.error("TODO: dpdy"), null;
  }
  DpdyCoarse(e3, t2) {
    return console.error("TODO: dpdyCoarse"), null;
  }
  DpdyFine(e3, t2) {
    return console.error("TODO: dpdyFine"), null;
  }
  Fwidth(e3, t2) {
    return console.error("TODO: fwidth"), null;
  }
  FwidthCoarse(e3, t2) {
    return console.error("TODO: fwidthCoarse"), null;
  }
  FwidthFine(e3, t2) {
    return console.error("TODO: fwidthFine"), null;
  }
  TextureDimensions(e3, t2) {
    const n2 = e3.args[0], s2 = e3.args.length > 1 ? this.exec.evalExpression(e3.args[1], t2).value : 0;
    if (n2 instanceof ge) {
      const r2 = n2.name, a2 = t2.getVariableValue(r2);
      if (a2 instanceof We) {
        if (s2 < 0 || s2 >= a2.mipLevelCount) return console.error(`Invalid mip level for textureDimensions. Line ${e3.line}`), null;
        const t3 = a2.getMipLevelSize(s2), n3 = a2.dimension;
        return "1d" === n3 ? new Be(t3[0], this.getTypeInfo("u32")) : "3d" === n3 ? new Me(t3, this.getTypeInfo("vec3u")) : "2d" === n3 ? new Me(t3.slice(0, 2), this.getTypeInfo("vec2u")) : (console.error(`Invalid texture dimension ${n3} not found. Line ${e3.line}`), null);
      }
      return console.error(`Texture ${r2} not found. Line ${e3.line}`), null;
    }
    return console.error(`Invalid texture argument for textureDimensions. Line ${e3.line}`), null;
  }
  TextureGather(e3, t2) {
    return console.error("TODO: textureGather"), null;
  }
  TextureGatherCompare(e3, t2) {
    return console.error("TODO: textureGatherCompare"), null;
  }
  TextureLoad(e3, t2) {
    const n2 = e3.args[0], s2 = this.exec.evalExpression(e3.args[1], t2), r2 = e3.args.length > 2 ? this.exec.evalExpression(e3.args[2], t2).value : 0;
    if (!(s2 instanceof Me) || 2 !== s2.data.length) return console.error(`Invalid UV argument for textureLoad. Line ${e3.line}`), null;
    if (n2 instanceof ge) {
      const a2 = n2.name, i2 = t2.getVariableValue(a2);
      if (i2 instanceof We) {
        const t3 = Math.floor(s2.data[0]), n3 = Math.floor(s2.data[1]);
        if (t3 < 0 || t3 >= i2.width || n3 < 0 || n3 >= i2.height) return console.error(`Texture ${a2} out of bounds. Line ${e3.line}`), null;
        const o2 = i2.getPixel(t3, n3, 0, r2);
        return null === o2 ? (console.error(`Invalid texture format for textureLoad. Line ${e3.line}`), null) : new Me(o2, this.getTypeInfo("vec4f"));
      }
      return console.error(`Texture ${a2} not found. Line ${e3.line}`), null;
    }
    return console.error(`Invalid texture argument for textureLoad. Line ${e3.line}`), null;
  }
  TextureNumLayers(e3, t2) {
    const n2 = e3.args[0];
    if (n2 instanceof ge) {
      const s2 = n2.name, r2 = t2.getVariableValue(s2);
      return r2 instanceof We ? new Be(r2.depthOrArrayLayers, this.getTypeInfo("u32")) : (console.error(`Texture ${s2} not found. Line ${e3.line}`), null);
    }
    return console.error(`Invalid texture argument for textureNumLayers. Line ${e3.line}`), null;
  }
  TextureNumLevels(e3, t2) {
    const n2 = e3.args[0];
    if (n2 instanceof ge) {
      const s2 = n2.name, r2 = t2.getVariableValue(s2);
      return r2 instanceof We ? new Be(r2.mipLevelCount, this.getTypeInfo("u32")) : (console.error(`Texture ${s2} not found. Line ${e3.line}`), null);
    }
    return console.error(`Invalid texture argument for textureNumLevels. Line ${e3.line}`), null;
  }
  TextureNumSamples(e3, t2) {
    const n2 = e3.args[0];
    if (n2 instanceof ge) {
      const s2 = n2.name, r2 = t2.getVariableValue(s2);
      return r2 instanceof We ? new Be(r2.sampleCount, this.getTypeInfo("u32")) : (console.error(`Texture ${s2} not found. Line ${e3.line}`), null);
    }
    return console.error(`Invalid texture argument for textureNumSamples. Line ${e3.line}`), null;
  }
  TextureSample(e3, t2) {
    return console.error("TODO: textureSample"), null;
  }
  TextureSampleBias(e3, t2) {
    return console.error("TODO: textureSampleBias"), null;
  }
  TextureSampleCompare(e3, t2) {
    return console.error("TODO: textureSampleCompare"), null;
  }
  TextureSampleCompareLevel(e3, t2) {
    return console.error("TODO: textureSampleCompareLevel"), null;
  }
  TextureSampleGrad(e3, t2) {
    return console.error("TODO: textureSampleGrad"), null;
  }
  TextureSampleLevel(e3, t2) {
    return console.error("TODO: textureSampleLevel"), null;
  }
  TextureSampleBaseClampToEdge(e3, t2) {
    return console.error("TODO: textureSampleBaseClampToEdge"), null;
  }
  TextureStore(e3, t2) {
    const n2 = e3.args[0], s2 = this.exec.evalExpression(e3.args[1], t2), r2 = 4 === e3.args.length ? this.exec.evalExpression(e3.args[2], t2).value : 0, a2 = 4 === e3.args.length ? this.exec.evalExpression(e3.args[3], t2).data : this.exec.evalExpression(e3.args[2], t2).data;
    if (4 !== a2.length) return console.error(`Invalid value argument for textureStore. Line ${e3.line}`), null;
    if (!(s2 instanceof Me) || 2 !== s2.data.length) return console.error(`Invalid UV argument for textureStore. Line ${e3.line}`), null;
    if (n2 instanceof ge) {
      const i2 = n2.name, o2 = t2.getVariableValue(i2);
      if (o2 instanceof We) {
        const t3 = o2.getMipLevelSize(0), n3 = Math.floor(s2.data[0]), c2 = Math.floor(s2.data[1]);
        return n3 < 0 || n3 >= t3[0] || c2 < 0 || c2 >= t3[1] ? (console.error(`Texture ${i2} out of bounds. Line ${e3.line}`), null) : (o2.setPixel(n3, c2, 0, r2, Array.from(a2)), null);
      }
      return console.error(`Texture ${i2} not found. Line ${e3.line}`), null;
    }
    return console.error(`Invalid texture argument for textureStore. Line ${e3.line}`), null;
  }
  AtomicLoad(e3, t2) {
    let n2 = e3.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2);
    return t2.getVariable(s2).value.getSubData(this.exec, n2.postfix, t2);
  }
  AtomicStore(e3, t2) {
    let n2 = e3.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e3.args[1];
    const i2 = this.exec.evalExpression(a2, t2), o2 = r2.value.getSubData(this.exec, n2.postfix, t2);
    return o2 instanceof Be && i2 instanceof Be && (o2.value = i2.value), r2.value instanceof Pe && r2.value.setDataValue(this.exec, o2, n2.postfix, t2), null;
  }
  AtomicAdd(e3, t2) {
    let n2 = e3.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e3.args[1];
    const i2 = this.exec.evalExpression(a2, t2), o2 = r2.value.getSubData(this.exec, n2.postfix, t2), c2 = new Be(o2.value, o2.typeInfo);
    return o2 instanceof Be && i2 instanceof Be && (o2.value += i2.value), r2.value instanceof Pe && r2.value.setDataValue(this.exec, o2, n2.postfix, t2), c2;
  }
  AtomicSub(e3, t2) {
    let n2 = e3.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e3.args[1];
    const i2 = this.exec.evalExpression(a2, t2), o2 = r2.value.getSubData(this.exec, n2.postfix, t2), c2 = new Be(o2.value, o2.typeInfo);
    return o2 instanceof Be && i2 instanceof Be && (o2.value -= i2.value), r2.value instanceof Pe && r2.value.setDataValue(this.exec, o2, n2.postfix, t2), c2;
  }
  AtomicMax(e3, t2) {
    let n2 = e3.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e3.args[1];
    const i2 = this.exec.evalExpression(a2, t2), o2 = r2.value.getSubData(this.exec, n2.postfix, t2), c2 = new Be(o2.value, o2.typeInfo);
    return o2 instanceof Be && i2 instanceof Be && (o2.value = Math.max(o2.value, i2.value)), r2.value instanceof Pe && r2.value.setDataValue(this.exec, o2, n2.postfix, t2), c2;
  }
  AtomicMin(e3, t2) {
    let n2 = e3.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e3.args[1];
    const i2 = this.exec.evalExpression(a2, t2), o2 = r2.value.getSubData(this.exec, n2.postfix, t2), c2 = new Be(o2.value, o2.typeInfo);
    return o2 instanceof Be && i2 instanceof Be && (o2.value = Math.min(o2.value, i2.value)), r2.value instanceof Pe && r2.value.setDataValue(this.exec, o2, n2.postfix, t2), c2;
  }
  AtomicAnd(e3, t2) {
    let n2 = e3.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e3.args[1];
    const i2 = this.exec.evalExpression(a2, t2), o2 = r2.value.getSubData(this.exec, n2.postfix, t2), c2 = new Be(o2.value, o2.typeInfo);
    return o2 instanceof Be && i2 instanceof Be && (o2.value = o2.value & i2.value), r2.value instanceof Pe && r2.value.setDataValue(this.exec, o2, n2.postfix, t2), c2;
  }
  AtomicOr(e3, t2) {
    let n2 = e3.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e3.args[1];
    const i2 = this.exec.evalExpression(a2, t2), o2 = r2.value.getSubData(this.exec, n2.postfix, t2), c2 = new Be(o2.value, o2.typeInfo);
    return o2 instanceof Be && i2 instanceof Be && (o2.value = o2.value | i2.value), r2.value instanceof Pe && r2.value.setDataValue(this.exec, o2, n2.postfix, t2), c2;
  }
  AtomicXor(e3, t2) {
    let n2 = e3.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e3.args[1];
    const i2 = this.exec.evalExpression(a2, t2), o2 = r2.value.getSubData(this.exec, n2.postfix, t2), c2 = new Be(o2.value, o2.typeInfo);
    return o2 instanceof Be && i2 instanceof Be && (o2.value = o2.value ^ i2.value), r2.value instanceof Pe && r2.value.setDataValue(this.exec, o2, n2.postfix, t2), c2;
  }
  AtomicExchange(e3, t2) {
    let n2 = e3.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e3.args[1];
    const i2 = this.exec.evalExpression(a2, t2), o2 = r2.value.getSubData(this.exec, n2.postfix, t2), c2 = new Be(o2.value, o2.typeInfo);
    return o2 instanceof Be && i2 instanceof Be && (o2.value = i2.value), r2.value instanceof Pe && r2.value.setDataValue(this.exec, o2, n2.postfix, t2), c2;
  }
  AtomicCompareExchangeWeak(e3, t2) {
    return console.error("TODO: atomicCompareExchangeWeak"), null;
  }
  Pack4x8snorm(e3, t2) {
    return console.error("TODO: pack4x8snorm"), null;
  }
  Pack4x8unorm(e3, t2) {
    return console.error("TODO: pack4x8unorm"), null;
  }
  Pack4xI8(e3, t2) {
    return console.error("TODO: pack4xI8"), null;
  }
  Pack4xU8(e3, t2) {
    return console.error("TODO: pack4xU8"), null;
  }
  Pack4x8Clamp(e3, t2) {
    return console.error("TODO: pack4x8Clamp"), null;
  }
  Pack4xU8Clamp(e3, t2) {
    return console.error("TODO: pack4xU8Clamp"), null;
  }
  Pack2x16snorm(e3, t2) {
    return console.error("TODO: pack2x16snorm"), null;
  }
  Pack2x16unorm(e3, t2) {
    return console.error("TODO: pack2x16unorm"), null;
  }
  Pack2x16float(e3, t2) {
    return console.error("TODO: pack2x16float"), null;
  }
  Unpack4x8snorm(e3, t2) {
    return console.error("TODO: unpack4x8snorm"), null;
  }
  Unpack4x8unorm(e3, t2) {
    return console.error("TODO: unpack4x8unorm"), null;
  }
  Unpack4xI8(e3, t2) {
    return console.error("TODO: unpack4xI8"), null;
  }
  Unpack4xU8(e3, t2) {
    return console.error("TODO: unpack4xU8"), null;
  }
  Unpack2x16snorm(e3, t2) {
    return console.error("TODO: unpack2x16snorm"), null;
  }
  Unpack2x16unorm(e3, t2) {
    return console.error("TODO: unpack2x16unorm"), null;
  }
  Unpack2x16float(e3, t2) {
    return console.error("TODO: unpack2x16float"), null;
  }
  StorageBarrier(e3, t2) {
    return null;
  }
  TextureBarrier(e3, t2) {
    return null;
  }
  WorkgroupBarrier(e3, t2) {
    return null;
  }
  WorkgroupUniformLoad(e3, t2) {
    return null;
  }
  SubgroupAdd(e3, t2) {
    return console.error("TODO: subgroupAdd"), null;
  }
  SubgroupExclusiveAdd(e3, t2) {
    return console.error("TODO: subgroupExclusiveAdd"), null;
  }
  SubgroupInclusiveAdd(e3, t2) {
    return console.error("TODO: subgroupInclusiveAdd"), null;
  }
  SubgroupAll(e3, t2) {
    return console.error("TODO: subgroupAll"), null;
  }
  SubgroupAnd(e3, t2) {
    return console.error("TODO: subgroupAnd"), null;
  }
  SubgroupAny(e3, t2) {
    return console.error("TODO: subgroupAny"), null;
  }
  SubgroupBallot(e3, t2) {
    return console.error("TODO: subgroupBallot"), null;
  }
  SubgroupBroadcast(e3, t2) {
    return console.error("TODO: subgroupBroadcast"), null;
  }
  SubgroupBroadcastFirst(e3, t2) {
    return console.error("TODO: subgroupBroadcastFirst"), null;
  }
  SubgroupElect(e3, t2) {
    return console.error("TODO: subgroupElect"), null;
  }
  SubgroupMax(e3, t2) {
    return console.error("TODO: subgroupMax"), null;
  }
  SubgroupMin(e3, t2) {
    return console.error("TODO: subgroupMin"), null;
  }
  SubgroupMul(e3, t2) {
    return console.error("TODO: subgroupMul"), null;
  }
  SubgroupExclusiveMul(e3, t2) {
    return console.error("TODO: subgroupExclusiveMul"), null;
  }
  SubgroupInclusiveMul(e3, t2) {
    return console.error("TODO: subgroupInclusiveMul"), null;
  }
  SubgroupOr(e3, t2) {
    return console.error("TODO: subgroupOr"), null;
  }
  SubgroupShuffle(e3, t2) {
    return console.error("TODO: subgroupShuffle"), null;
  }
  SubgroupShuffleDown(e3, t2) {
    return console.error("TODO: subgroupShuffleDown"), null;
  }
  SubgroupShuffleUp(e3, t2) {
    return console.error("TODO: subgroupShuffleUp"), null;
  }
  SubgroupShuffleXor(e3, t2) {
    return console.error("TODO: subgroupShuffleXor"), null;
  }
  SubgroupXor(e3, t2) {
    return console.error("TODO: subgroupXor"), null;
  }
  QuadBroadcast(e3, t2) {
    return console.error("TODO: quadBroadcast"), null;
  }
  QuadSwapDiagonal(e3, t2) {
    return console.error("TODO: quadSwapDiagonal"), null;
  }
  QuadSwapX(e3, t2) {
    return console.error("TODO: quadSwapX"), null;
  }
  QuadSwapY(e3, t2) {
    return console.error("TODO: quadSwapY"), null;
  }
};
var ft = { vec2: 2, vec2f: 2, vec2i: 2, vec2u: 2, vec2b: 2, vec2h: 2, vec3: 3, vec3f: 3, vec3i: 3, vec3u: 3, vec3b: 3, vec3h: 3, vec4: 4, vec4f: 4, vec4i: 4, vec4u: 4, vec4b: 4, vec4h: 4 };
var pt = { mat2x2: [2, 2, 4], mat2x2f: [2, 2, 4], mat2x2h: [2, 2, 4], mat2x3: [2, 3, 6], mat2x3f: [2, 3, 6], mat2x3h: [2, 3, 6], mat2x4: [2, 4, 8], mat2x4f: [2, 4, 8], mat2x4h: [2, 4, 8], mat3x2: [3, 2, 6], mat3x2f: [3, 2, 6], mat3x2h: [3, 2, 6], mat3x3: [3, 3, 9], mat3x3f: [3, 3, 9], mat3x3h: [3, 3, 9], mat3x4: [3, 4, 12], mat3x4f: [3, 4, 12], mat3x4h: [3, 4, 12], mat4x2: [4, 2, 8], mat4x2f: [4, 2, 8], mat4x2h: [4, 2, 8], mat4x3: [4, 3, 12], mat4x3f: [4, 3, 12], mat4x3h: [4, 3, 12], mat4x4: [4, 4, 16], mat4x4f: [4, 4, 16], mat4x4h: [4, 4, 16] };
var dt = class _dt extends ut {
  constructor(e3, t2) {
    var n2;
    super(), this.ast = null != e3 ? e3 : [], this.reflection = new at(), this.reflection.updateAST(this.ast), this.context = null !== (n2 = null == t2 ? void 0 : t2.clone()) && void 0 !== n2 ? n2 : new lt(), this.builtins = new ht(this), this.typeInfo = { bool: this.getTypeInfo(ae.bool), i32: this.getTypeInfo(ae.i32), u32: this.getTypeInfo(ae.u32), f32: this.getTypeInfo(ae.f32), f16: this.getTypeInfo(ae.f16), vec2f: this.getTypeInfo(ce.vec2f), vec2u: this.getTypeInfo(ce.vec2u), vec2i: this.getTypeInfo(ce.vec2i), vec2h: this.getTypeInfo(ce.vec2h), vec3f: this.getTypeInfo(ce.vec3f), vec3u: this.getTypeInfo(ce.vec3u), vec3i: this.getTypeInfo(ce.vec3i), vec3h: this.getTypeInfo(ce.vec3h), vec4f: this.getTypeInfo(ce.vec4f), vec4u: this.getTypeInfo(ce.vec4u), vec4i: this.getTypeInfo(ce.vec4i), vec4h: this.getTypeInfo(ce.vec4h), mat2x2f: this.getTypeInfo(ce.mat2x2f), mat2x3f: this.getTypeInfo(ce.mat2x3f), mat2x4f: this.getTypeInfo(ce.mat2x4f), mat3x2f: this.getTypeInfo(ce.mat3x2f), mat3x3f: this.getTypeInfo(ce.mat3x3f), mat3x4f: this.getTypeInfo(ce.mat3x4f), mat4x2f: this.getTypeInfo(ce.mat4x2f), mat4x3f: this.getTypeInfo(ce.mat4x3f), mat4x4f: this.getTypeInfo(ce.mat4x4f) };
  }
  getVariableValue(e3) {
    var t2, n2;
    const r2 = null !== (n2 = null === (t2 = this.context.getVariable(e3)) || void 0 === t2 ? void 0 : t2.value) && void 0 !== n2 ? n2 : null;
    if (null === r2) return null;
    if (r2 instanceof Be) return r2.value;
    if (r2 instanceof Me) return Array.from(r2.data);
    if (r2 instanceof Ue) return Array.from(r2.data);
    if (r2 instanceof Pe && r2.typeInfo instanceof s) {
      if ("u32" === r2.typeInfo.format.name) return Array.from(new Uint32Array(r2.buffer, r2.offset, r2.typeInfo.count));
      if ("i32" === r2.typeInfo.format.name) return Array.from(new Int32Array(r2.buffer, r2.offset, r2.typeInfo.count));
      if ("f32" === r2.typeInfo.format.name) return Array.from(new Float32Array(r2.buffer, r2.offset, r2.typeInfo.count));
    }
    return console.error(`Unsupported return variable type ${r2.typeInfo.name}`), null;
  }
  execute(e3) {
    (e3 = null != e3 ? e3 : {}).constants && this._setOverrides(e3.constants, this.context), this._execStatements(this.ast, this.context);
  }
  dispatchWorkgroups(e3, t2, n2, s2) {
    const r2 = this.context.clone();
    (s2 = null != s2 ? s2 : {}).constants && this._setOverrides(s2.constants, r2), this._execStatements(this.ast, r2);
    const a2 = r2.getFunction(e3);
    if (!a2) return void console.error(`Function ${e3} not found`);
    if ("number" == typeof t2) t2 = [t2, 1, 1];
    else {
      if (0 === t2.length) return void console.error("Invalid dispatch count");
      1 === t2.length ? t2 = [t2[0], 1, 1] : 2 === t2.length ? t2 = [t2[0], t2[1], 1] : t2.length > 3 && (t2 = [t2[0], t2[1], t2[2]]);
    }
    const i2 = t2[0], o2 = t2[1], c2 = t2[2], l2 = this.getTypeInfo("vec3u");
    r2.setVariable("@num_workgroups", new Me(t2, l2));
    const u2 = this.reflection.getFunctionInfo(e3);
    null === u2 && console.error(`Function ${e3} not found in reflection data`);
    for (const e4 in n2) for (const t3 in n2[e4]) {
      const s3 = n2[e4][t3];
      r2.variables.forEach((n3) => {
        var r3;
        const a3 = n3.node;
        if (null == a3 ? void 0 : a3.attributes) {
          let i3 = null, o3 = null;
          for (const e5 of a3.attributes) "binding" === e5.name ? i3 = e5.value : "group" === e5.name && (o3 = e5.value);
          if (t3 == i3 && e4 == o3) {
            let i4 = false;
            for (const s4 of u2.resources) if (s4.name === n3.name && s4.group === parseInt(e4) && s4.binding === parseInt(t3)) {
              i4 = true;
              break;
            }
            if (i4) if (void 0 !== s3.texture && void 0 !== s3.descriptor) {
              const e5 = new We(s3.texture, this.getTypeInfo(a3.type), s3.descriptor, null !== (r3 = s3.texture.view) && void 0 !== r3 ? r3 : null);
              n3.value = e5;
            } else void 0 !== s3.uniform ? n3.value = new Pe(s3.uniform, this.getTypeInfo(a3.type)) : n3.value = new Pe(s3, this.getTypeInfo(a3.type));
          }
        }
      });
    }
    for (let e4 = 0; e4 < c2; ++e4) for (let t3 = 0; t3 < o2; ++t3) for (let n3 = 0; n3 < i2; ++n3) r2.setVariable("@workgroup_id", new Me([n3, t3, e4], this.getTypeInfo("vec3u"))), this._dispatchWorkgroup(a2, [n3, t3, e4], r2);
  }
  execStatement(e3, t2) {
    if (e3 instanceof Y) return this.evalExpression(e3.value, t2);
    if (e3 instanceof se) {
      if (e3.condition) {
        const n2 = this.evalExpression(e3.condition, t2);
        if (!(n2 instanceof Be)) throw new Error("Invalid break-if condition");
        if (!n2.value) return null;
      }
      return _dt._breakObj;
    }
    if (e3 instanceof re) return _dt._continueObj;
    if (e3 instanceof U) this._let(e3, t2);
    else if (e3 instanceof F) this._var(e3, t2);
    else if (e3 instanceof P) this._const(e3, t2);
    else if (e3 instanceof D) this._function(e3, t2);
    else {
      if (e3 instanceof Q) return this._if(e3, t2);
      if (e3 instanceof Z) return this._switch(e3, t2);
      if (e3 instanceof B) return this._for(e3, t2);
      if (e3 instanceof V) return this._while(e3, t2);
      if (e3 instanceof j) return this._loop(e3, t2);
      if (e3 instanceof O) {
        const n2 = t2.clone();
        return n2.currentFunctionName = t2.currentFunctionName, this._execStatements(e3.body, n2);
      }
      if (e3 instanceof G) this._assign(e3, t2);
      else if (e3 instanceof R) this._increment(e3, t2);
      else {
        if (e3 instanceof oe) return null;
        if (e3 instanceof M) {
          const n2 = e3.name;
          null === t2.getVariable(n2) && t2.setVariable(n2, new Be(0, this.getTypeInfo("u32")));
        } else if (e3 instanceof X) this._call(e3, t2);
        else {
          if (e3 instanceof ee) return null;
          if (e3 instanceof te) return null;
          console.error("Invalid statement type.", e3, `Line ${e3.line}`);
        }
      }
    }
    return null;
  }
  evalExpression(e3, t2) {
    return e3 instanceof Ie ? this._evalBinaryOp(e3, t2) : e3 instanceof xe ? this._evalLiteral(e3, t2) : e3 instanceof ge ? this._evalVariable(e3, t2) : e3 instanceof me ? this._evalCall(e3, t2) : e3 instanceof de ? this._evalCreate(e3, t2) : e3 instanceof _e ? this._evalConst(e3, t2) : e3 instanceof ye ? this._evalBitcast(e3, t2) : e3 instanceof ke ? this._evalUnaryOp(e3, t2) : (console.error("Invalid expression type", e3, `Line ${e3.line}`), null);
  }
  getTypeInfo(e3) {
    var t2;
    if (e3 instanceof ae) {
      const t3 = this.reflection.getTypeInfo(e3);
      if (null !== t3) return t3;
    }
    let n2 = null !== (t2 = this.typeInfo[e3]) && void 0 !== t2 ? t2 : null;
    return null !== n2 || (n2 = this.reflection.getTypeInfoByName(e3)), n2;
  }
  _setOverrides(e3, t2) {
    for (const n2 in e3) {
      const s2 = e3[n2], r2 = this.reflection.getOverrideInfo(n2);
      null !== r2 ? (null === r2.type && (r2.type = this.getTypeInfo("u32")), "u32" === r2.type.name || "i32" === r2.type.name || "f32" === r2.type.name || "f16" === r2.type.name ? t2.setVariable(n2, new Be(s2, r2.type)) : "bool" === r2.type.name ? t2.setVariable(n2, new Be(s2 ? 1 : 0, r2.type)) : "vec2" === r2.type.name || "vec3" === r2.type.name || "vec4" === r2.type.name || "vec2f" === r2.type.name || "vec3f" === r2.type.name || "vec4f" === r2.type.name || "vec2i" === r2.type.name || "vec3i" === r2.type.name || "vec4i" === r2.type.name || "vec2u" === r2.type.name || "vec3u" === r2.type.name || "vec4u" === r2.type.name || "vec2h" === r2.type.name || "vec3h" === r2.type.name || "vec4h" === r2.type.name ? t2.setVariable(n2, new Me(s2, r2.type)) : console.error(`Invalid constant type for ${n2}`)) : console.error(`Override ${n2} does not exist in the shader.`);
    }
  }
  _dispatchWorkgroup(e3, t2, n2) {
    const s2 = [1, 1, 1];
    for (const t3 of e3.node.attributes) if ("workgroup_size" === t3.name) {
      if (t3.value.length > 0) {
        const e4 = n2.getVariableValue(t3.value[0]);
        s2[0] = e4 instanceof Be ? e4.value : parseInt(t3.value[0]);
      }
      if (t3.value.length > 1) {
        const e4 = n2.getVariableValue(t3.value[1]);
        s2[1] = e4 instanceof Be ? e4.value : parseInt(t3.value[1]);
      }
      if (t3.value.length > 2) {
        const e4 = n2.getVariableValue(t3.value[2]);
        s2[2] = e4 instanceof Be ? e4.value : parseInt(t3.value[2]);
      }
    }
    const r2 = this.getTypeInfo("vec3u"), a2 = this.getTypeInfo("u32");
    n2.setVariable("@workgroup_size", new Me(s2, r2));
    const i2 = s2[0], o2 = s2[1], c2 = s2[2];
    for (let l2 = 0, u2 = 0; l2 < c2; ++l2) for (let c3 = 0; c3 < o2; ++c3) for (let o3 = 0; o3 < i2; ++o3, ++u2) {
      const i3 = [o3, c3, l2], h2 = [o3 + t2[0] * s2[0], c3 + t2[1] * s2[1], l2 + t2[2] * s2[2]];
      n2.setVariable("@local_invocation_id", new Me(i3, r2)), n2.setVariable("@global_invocation_id", new Me(h2, r2)), n2.setVariable("@local_invocation_index", new Be(u2, a2)), this._dispatchExec(e3, n2);
    }
  }
  _dispatchExec(e3, t2) {
    for (const n2 of e3.node.args) for (const e4 of n2.attributes) if ("builtin" === e4.name) {
      const s2 = `@${e4.value}`, r2 = t2.getVariable(s2);
      void 0 !== r2 && t2.variables.set(n2.name, r2);
    }
    this._execStatements(e3.node.body, t2);
  }
  getVariableName(e3, t2) {
    for (; e3 instanceof ke; ) e3 = e3.right;
    return e3 instanceof ge ? e3.name : (console.error("Unknown variable type", e3, "Line", e3.line), null);
  }
  _execStatements(e3, t2) {
    for (const n2 of e3) {
      if (n2 instanceof Array) {
        const e5 = t2.clone(), s2 = this._execStatements(n2, e5);
        if (s2) return s2;
        continue;
      }
      const e4 = this.execStatement(n2, t2);
      if (e4) return e4;
    }
    return null;
  }
  _call(e3, t2) {
    const n2 = t2.clone();
    n2.currentFunctionName = e3.name;
    const s2 = t2.getFunction(e3.name);
    if (s2) {
      for (let t3 = 0; t3 < s2.node.args.length; ++t3) {
        const r2 = s2.node.args[t3], a2 = this.evalExpression(e3.args[t3], n2);
        n2.setVariable(r2.name, a2, r2);
      }
      this._execStatements(s2.node.body, n2);
    } else if (e3.isBuiltin) this._callBuiltinFunction(e3, n2);
    else {
      this.getTypeInfo(e3.name) && this._evalCreate(e3, t2);
    }
  }
  _increment(e3, t2) {
    const n2 = this.getVariableName(e3.variable, t2), s2 = t2.getVariable(n2);
    s2 ? "++" === e3.operator ? s2.value instanceof Be ? s2.value.value++ : console.error(`Variable ${n2} is not a scalar. Line ${e3.line}`) : "--" === e3.operator ? s2.value instanceof Be ? s2.value.value-- : console.error(`Variable ${n2} is not a scalar. Line ${e3.line}`) : console.error(`Unknown increment operator ${e3.operator}. Line ${e3.line}`) : console.error(`Variable ${n2} not found. Line ${e3.line}`);
  }
  _getVariableData(e3, t2) {
    if (e3 instanceof ge) {
      const n2 = this.getVariableName(e3, t2), s2 = t2.getVariable(n2);
      return null === s2 ? (console.error(`Variable ${n2} not found. Line ${e3.line}`), null) : s2.value.getSubData(this, e3.postfix, t2);
    }
    if (e3 instanceof ke) {
      if ("*" === e3.operator) {
        const n2 = this._getVariableData(e3.right, t2);
        return n2 instanceof Oe ? n2.reference.getSubData(this, e3.postfix, t2) : (console.error(`Variable ${e3.right} is not a pointer. Line ${e3.line}`), null);
      }
      if ("&" === e3.operator) {
        const n2 = this._getVariableData(e3.right, t2);
        return new Oe(n2);
      }
    }
    return null;
  }
  _assign(e3, t2) {
    let n2 = null, s2 = "<var>", r2 = null;
    if (e3.variable instanceof ke) {
      const n3 = this._getVariableData(e3.variable, t2), s3 = this.evalExpression(e3.value, t2), r3 = e3.operator;
      if ("=" === r3) {
        if (n3 instanceof Be || n3 instanceof Me || n3 instanceof Ue) {
          if (s3 instanceof Be || s3 instanceof Me || s3 instanceof Ue && n3.data.length === s3.data.length) return void n3.data.set(s3.data);
          console.error(`Invalid assignment. Line ${e3.line}`);
        } else if (n3 instanceof Pe && s3 instanceof Pe && n3.buffer.byteLength - n3.offset >= s3.buffer.byteLength - s3.offset) return void (n3.buffer.byteLength % 4 == 0 ? new Uint32Array(n3.buffer, n3.offset, n3.typeInfo.size / 4).set(new Uint32Array(s3.buffer, s3.offset, s3.typeInfo.size / 4)) : new Uint8Array(n3.buffer, n3.offset, n3.typeInfo.size).set(new Uint8Array(s3.buffer, s3.offset, s3.typeInfo.size)));
        return console.error(`Invalid assignment. Line ${e3.line}`), null;
      }
      if ("+=" === r3) return n3 instanceof Be || n3 instanceof Me || n3 instanceof Ue ? s3 instanceof Be || s3 instanceof Me || s3 instanceof Ue ? void n3.data.set(s3.data.map((e4, t3) => n3.data[t3] + e4)) : void console.error(`Invalid assignment . Line ${e3.line}`) : void console.error(`Invalid assignment. Line ${e3.line}`);
      if ("-=" === r3) return (n3 instanceof Be || n3 instanceof Me || n3 instanceof Ue) && (s3 instanceof Be || s3 instanceof Me || s3 instanceof Ue) ? void n3.data.set(s3.data.map((e4, t3) => n3.data[t3] - e4)) : void console.error(`Invalid assignment. Line ${e3.line}`);
    }
    if (e3.variable instanceof ke) {
      if ("*" === e3.variable.operator) {
        s2 = this.getVariableName(e3.variable.right, t2);
        const r3 = t2.getVariable(s2);
        if (!(r3 && r3.value instanceof Oe)) return void console.error(`Variable ${s2} is not a pointer. Line ${e3.line}`);
        n2 = r3.value.reference;
        let a3 = e3.variable.postfix;
        if (!a3) {
          let t3 = e3.variable.right;
          for (; t3 instanceof ke; ) {
            if (t3.postfix) {
              a3 = t3.postfix;
              break;
            }
            t3 = t3.right;
          }
        }
        a3 && (n2 = n2.getSubData(this, a3, t2));
      }
    } else {
      r2 = e3.variable.postfix, s2 = this.getVariableName(e3.variable, t2);
      const a3 = t2.getVariable(s2);
      if (null === a3) return void console.error(`Variable ${s2} not found. Line ${e3.line}`);
      n2 = a3.value;
    }
    if (n2 instanceof Oe && (n2 = n2.reference), null === n2) return void console.error(`Variable ${s2} not found. Line ${e3.line}`);
    const a2 = this.evalExpression(e3.value, t2), i2 = e3.operator;
    if ("=" !== i2) {
      const s3 = n2.getSubData(this, r2, t2);
      if (s3 instanceof Me && a2 instanceof Be) {
        const t3 = s3.data, n3 = a2.value;
        if ("+=" === i2) for (let e4 = 0; e4 < t3.length; ++e4) t3[e4] += n3;
        else if ("-=" === i2) for (let e4 = 0; e4 < t3.length; ++e4) t3[e4] -= n3;
        else if ("*=" === i2) for (let e4 = 0; e4 < t3.length; ++e4) t3[e4] *= n3;
        else if ("/=" === i2) for (let e4 = 0; e4 < t3.length; ++e4) t3[e4] /= n3;
        else if ("%=" === i2) for (let e4 = 0; e4 < t3.length; ++e4) t3[e4] %= n3;
        else if ("&=" === i2) for (let e4 = 0; e4 < t3.length; ++e4) t3[e4] &= n3;
        else if ("|=" === i2) for (let e4 = 0; e4 < t3.length; ++e4) t3[e4] |= n3;
        else if ("^=" === i2) for (let e4 = 0; e4 < t3.length; ++e4) t3[e4] ^= n3;
        else if ("<<=" === i2) for (let e4 = 0; e4 < t3.length; ++e4) t3[e4] <<= n3;
        else if (">>=" === i2) for (let e4 = 0; e4 < t3.length; ++e4) t3[e4] >>= n3;
        else console.error(`Invalid operator ${i2}. Line ${e3.line}`);
      } else if (s3 instanceof Me && a2 instanceof Me) {
        const t3 = s3.data, n3 = a2.data;
        if (t3.length !== n3.length) return void console.error(`Vector length mismatch. Line ${e3.line}`);
        if ("+=" === i2) for (let e4 = 0; e4 < t3.length; ++e4) t3[e4] += n3[e4];
        else if ("-=" === i2) for (let e4 = 0; e4 < t3.length; ++e4) t3[e4] -= n3[e4];
        else if ("*=" === i2) for (let e4 = 0; e4 < t3.length; ++e4) t3[e4] *= n3[e4];
        else if ("/=" === i2) for (let e4 = 0; e4 < t3.length; ++e4) t3[e4] /= n3[e4];
        else if ("%=" === i2) for (let e4 = 0; e4 < t3.length; ++e4) t3[e4] %= n3[e4];
        else if ("&=" === i2) for (let e4 = 0; e4 < t3.length; ++e4) t3[e4] &= n3[e4];
        else if ("|=" === i2) for (let e4 = 0; e4 < t3.length; ++e4) t3[e4] |= n3[e4];
        else if ("^=" === i2) for (let e4 = 0; e4 < t3.length; ++e4) t3[e4] ^= n3[e4];
        else if ("<<=" === i2) for (let e4 = 0; e4 < t3.length; ++e4) t3[e4] <<= n3[e4];
        else if (">>=" === i2) for (let e4 = 0; e4 < t3.length; ++e4) t3[e4] >>= n3[e4];
        else console.error(`Invalid operator ${i2}. Line ${e3.line}`);
      } else {
        if (!(s3 instanceof Be && a2 instanceof Be)) return void console.error(`Invalid type for ${e3.operator} operator. Line ${e3.line}`);
        "+=" === i2 ? s3.value += a2.value : "-=" === i2 ? s3.value -= a2.value : "*=" === i2 ? s3.value *= a2.value : "/=" === i2 ? s3.value /= a2.value : "%=" === i2 ? s3.value %= a2.value : "&=" === i2 ? s3.value &= a2.value : "|=" === i2 ? s3.value |= a2.value : "^=" === i2 ? s3.value ^= a2.value : "<<=" === i2 ? s3.value <<= a2.value : ">>=" === i2 ? s3.value >>= a2.value : console.error(`Invalid operator ${i2}. Line ${e3.line}`);
      }
      return void (n2 instanceof Pe && n2.setDataValue(this, s3, r2, t2));
    }
    if (n2 instanceof Pe) n2.setDataValue(this, a2, r2, t2);
    else if (r2) {
      if (!(n2 instanceof Me || n2 instanceof Ue)) return void console.error(`Variable ${s2} is not a vector or matrix. Line ${e3.line}`);
      if (r2 instanceof ve) {
        const i3 = this.evalExpression(r2.index, t2).value;
        if (n2 instanceof Me) {
          if (!(a2 instanceof Be)) return void console.error(`Invalid assignment to ${s2}. Line ${e3.line}`);
          n2.data[i3] = a2.value;
        } else {
          if (!(n2 instanceof Ue)) return void console.error(`Invalid assignment to ${s2}. Line ${e3.line}`);
          {
            const i4 = this.evalExpression(r2.index, t2).value;
            if (i4 < 0) return void console.error(`Invalid assignment to ${s2}. Line ${e3.line}`);
            if (!(a2 instanceof Me)) return void console.error(`Invalid assignment to ${s2}. Line ${e3.line}`);
            {
              const t3 = n2.typeInfo.getTypeName();
              if ("mat2x2" === t3 || "mat2x2f" === t3 || "mat2x2h" === t3) {
                if (!(i4 < 2 && 2 === a2.data.length)) return void console.error(`Invalid assignment to ${s2}. Line ${e3.line}`);
                n2.data[2 * i4] = a2.data[0], n2.data[2 * i4 + 1] = a2.data[1];
              } else if ("mat2x3" === t3 || "mat2x3f" === t3 || "mat2x3h" === t3) {
                if (!(i4 < 2 && 3 === a2.data.length)) return void console.error(`Invalid assignment to ${s2}. Line ${e3.line}`);
                n2.data[3 * i4] = a2.data[0], n2.data[3 * i4 + 1] = a2.data[1], n2.data[3 * i4 + 2] = a2.data[2];
              } else if ("mat2x4" === t3 || "mat2x4f" === t3 || "mat2x4h" === t3) {
                if (!(i4 < 2 && 4 === a2.data.length)) return void console.error(`Invalid assignment to ${s2}. Line ${e3.line}`);
                n2.data[4 * i4] = a2.data[0], n2.data[4 * i4 + 1] = a2.data[1], n2.data[4 * i4 + 2] = a2.data[2], n2.data[4 * i4 + 3] = a2.data[3];
              } else if ("mat3x2" === t3 || "mat3x2f" === t3 || "mat3x2h" === t3) {
                if (!(i4 < 3 && 2 === a2.data.length)) return void console.error(`Invalid assignment to ${s2}. Line ${e3.line}`);
                n2.data[2 * i4] = a2.data[0], n2.data[2 * i4 + 1] = a2.data[1];
              } else if ("mat3x3" === t3 || "mat3x3f" === t3 || "mat3x3h" === t3) {
                if (!(i4 < 3 && 3 === a2.data.length)) return void console.error(`Invalid assignment to ${s2}. Line ${e3.line}`);
                n2.data[3 * i4] = a2.data[0], n2.data[3 * i4 + 1] = a2.data[1], n2.data[3 * i4 + 2] = a2.data[2];
              } else if ("mat3x4" === t3 || "mat3x4f" === t3 || "mat3x4h" === t3) {
                if (!(i4 < 3 && 4 === a2.data.length)) return void console.error(`Invalid assignment to ${s2}. Line ${e3.line}`);
                n2.data[4 * i4] = a2.data[0], n2.data[4 * i4 + 1] = a2.data[1], n2.data[4 * i4 + 2] = a2.data[2], n2.data[4 * i4 + 3] = a2.data[3];
              } else if ("mat4x2" === t3 || "mat4x2f" === t3 || "mat4x2h" === t3) {
                if (!(i4 < 4 && 2 === a2.data.length)) return void console.error(`Invalid assignment to ${s2}. Line ${e3.line}`);
                n2.data[2 * i4] = a2.data[0], n2.data[2 * i4 + 1] = a2.data[1];
              } else if ("mat4x3" === t3 || "mat4x3f" === t3 || "mat4x3h" === t3) {
                if (!(i4 < 4 && 3 === a2.data.length)) return void console.error(`Invalid assignment to ${s2}. Line ${e3.line}`);
                n2.data[3 * i4] = a2.data[0], n2.data[3 * i4 + 1] = a2.data[1], n2.data[3 * i4 + 2] = a2.data[2];
              } else {
                if ("mat4x4" !== t3 && "mat4x4f" !== t3 && "mat4x4h" !== t3) return void console.error(`Invalid assignment to ${s2}. Line ${e3.line}`);
                if (!(i4 < 4 && 4 === a2.data.length)) return void console.error(`Invalid assignment to ${s2}. Line ${e3.line}`);
                n2.data[4 * i4] = a2.data[0], n2.data[4 * i4 + 1] = a2.data[1], n2.data[4 * i4 + 2] = a2.data[2], n2.data[4 * i4 + 3] = a2.data[3];
              }
            }
          }
        }
      } else if (r2 instanceof pe) {
        const t3 = r2.value;
        if (!(n2 instanceof Me)) return void console.error(`Invalid assignment to ${t3}. Variable ${s2} is not a vector. Line ${e3.line}`);
        if (a2 instanceof Be) {
          if (t3.length > 1) return void console.error(`Invalid assignment to ${t3} for variable ${s2}. Line ${e3.line}`);
          if ("x" === t3) n2.data[0] = a2.value;
          else if ("y" === t3) {
            if (n2.data.length < 2) return void console.error(`Invalid assignment to ${t3} for variable ${s2}. Line ${e3.line}`);
            n2.data[1] = a2.value;
          } else if ("z" === t3) {
            if (n2.data.length < 3) return void console.error(`Invalid assignment to ${t3} for variable ${s2}. Line ${e3.line}`);
            n2.data[2] = a2.value;
          } else if ("w" === t3) {
            if (n2.data.length < 4) return void console.error(`Invalid assignment to ${t3} for variable ${s2}. Line ${e3.line}`);
            n2.data[3] = a2.value;
          }
        } else {
          if (!(a2 instanceof Me)) return void console.error(`Invalid assignment to ${s2}. Line ${e3.line}`);
          if (t3.length !== a2.data.length) return void console.error(`Invalid assignment to ${t3} for variable ${s2}. Line ${e3.line}`);
          for (let r3 = 0; r3 < t3.length; ++r3) {
            const i3 = t3[r3];
            if ("x" === i3 || "r" === i3) n2.data[0] = a2.data[r3];
            else if ("y" === i3 || "g" === i3) {
              if (a2.data.length < 2) return void console.error(`Invalid assignment to ${i3} for variable ${s2}. Line ${e3.line}`);
              n2.data[1] = a2.data[r3];
            } else if ("z" === i3 || "b" === i3) {
              if (a2.data.length < 3) return void console.error(`Invalid assignment to ${i3} for variable ${s2}. Line ${e3.line}`);
              n2.data[2] = a2.data[r3];
            } else {
              if ("w" !== i3 && "a" !== i3) return void console.error(`Invalid assignment to ${i3} for variable ${s2}. Line ${e3.line}`);
              if (a2.data.length < 4) return void console.error(`Invalid assignment to ${i3} for variable ${s2}. Line ${e3.line}`);
              n2.data[3] = a2.data[r3];
            }
          }
        }
      }
    } else n2 instanceof Be && a2 instanceof Be ? n2.value = a2.value : n2 instanceof Me && a2 instanceof Me || n2 instanceof Ue && a2 instanceof Ue ? n2.data.set(a2.data) : console.error(`Invalid assignment to ${s2}. Line ${e3.line}`);
  }
  _function(e3, t2) {
    const n2 = new ct(e3);
    t2.functions.set(e3.name, n2);
  }
  _const(e3, t2) {
    let n2 = null;
    null !== e3.value && (n2 = this.evalExpression(e3.value, t2)), t2.createVariable(e3.name, n2, e3);
  }
  _let(e3, t2) {
    let n2 = null;
    if (null !== e3.value) {
      if (n2 = this.evalExpression(e3.value, t2), null === n2) return void console.error(`Invalid value for variable ${e3.name}. Line ${e3.line}`);
      e3.value instanceof ke || (n2 = n2.clone());
    } else {
      const s2 = e3.type.name;
      if ("f32" === s2 || "i32" === s2 || "u32" === s2 || "bool" === s2 || "f16" === s2 || "vec2" === s2 || "vec3" === s2 || "vec4" === s2 || "vec2f" === s2 || "vec3f" === s2 || "vec4f" === s2 || "vec2i" === s2 || "vec3i" === s2 || "vec4i" === s2 || "vec2u" === s2 || "vec3u" === s2 || "vec4u" === s2 || "vec2h" === s2 || "vec3h" === s2 || "vec4h" === s2 || "vec2b" === s2 || "vec3b" === s2 || "vec4b" === s2 || "mat2x2" === s2 || "mat2x3" === s2 || "mat2x4" === s2 || "mat3x2" === s2 || "mat3x3" === s2 || "mat3x4" === s2 || "mat4x2" === s2 || "mat4x3" === s2 || "mat4x4" === s2 || "mat2x2f" === s2 || "mat2x3f" === s2 || "mat2x4f" === s2 || "mat3x2f" === s2 || "mat3x3f" === s2 || "mat3x4f" === s2 || "mat4x2f" === s2 || "mat4x3f" === s2 || "mat4x4f" === s2 || "mat2x2h" === s2 || "mat2x3h" === s2 || "mat2x4h" === s2 || "mat3x2h" === s2 || "mat3x3h" === s2 || "mat3x4h" === s2 || "mat4x2h" === s2 || "mat4x3h" === s2 || "mat4x4h" === s2 || "array" === s2) {
        const s3 = new de(e3.type, []);
        n2 = this._evalCreate(s3, t2);
      }
    }
    t2.createVariable(e3.name, n2, e3);
  }
  _var(e3, t2) {
    let n2 = null;
    if (null !== e3.value) {
      if (n2 = this.evalExpression(e3.value, t2), null === n2) return void console.error(`Invalid value for variable ${e3.name}. Line ${e3.line}`);
      e3.value instanceof ke || (n2 = n2.clone());
    } else {
      if (null === e3.type) return void console.error(`Variable ${e3.name} has no type. Line ${e3.line}`);
      const s2 = e3.type.name;
      if ("f32" === s2 || "i32" === s2 || "u32" === s2 || "bool" === s2 || "f16" === s2 || "vec2" === s2 || "vec3" === s2 || "vec4" === s2 || "vec2f" === s2 || "vec3f" === s2 || "vec4f" === s2 || "vec2i" === s2 || "vec3i" === s2 || "vec4i" === s2 || "vec2u" === s2 || "vec3u" === s2 || "vec4u" === s2 || "vec2h" === s2 || "vec3h" === s2 || "vec4h" === s2 || "vec2b" === s2 || "vec3b" === s2 || "vec4b" === s2 || "mat2x2" === s2 || "mat2x3" === s2 || "mat2x4" === s2 || "mat3x2" === s2 || "mat3x3" === s2 || "mat3x4" === s2 || "mat4x2" === s2 || "mat4x3" === s2 || "mat4x4" === s2 || "mat2x2f" === s2 || "mat2x3f" === s2 || "mat2x4f" === s2 || "mat3x2f" === s2 || "mat3x3f" === s2 || "mat3x4f" === s2 || "mat4x2f" === s2 || "mat4x3f" === s2 || "mat4x4f" === s2 || "mat2x2h" === s2 || "mat2x3h" === s2 || "mat2x4h" === s2 || "mat3x2h" === s2 || "mat3x3h" === s2 || "mat3x4h" === s2 || "mat4x2h" === s2 || "mat4x3h" === s2 || "mat4x4h" === s2 || e3.type instanceof ue || e3.type instanceof oe || e3.type instanceof ce) {
        const s3 = new de(e3.type, []);
        n2 = this._evalCreate(s3, t2);
      }
    }
    t2.createVariable(e3.name, n2, e3);
  }
  _switch(e3, t2) {
    t2 = t2.clone();
    const n2 = this.evalExpression(e3.condition, t2);
    if (!(n2 instanceof Be)) return console.error(`Invalid if condition. Line ${e3.line}`), null;
    let s2 = null;
    for (const r2 of e3.cases) if (r2 instanceof Ae) for (const a2 of r2.selectors) {
      if (a2 instanceof Se) {
        s2 = r2;
        continue;
      }
      const i2 = this.evalExpression(a2, t2);
      if (!(i2 instanceof Be)) return console.error(`Invalid case selector. Line ${e3.line}`), null;
      if (i2.value === n2.value) return this._execStatements(r2.body, t2);
    }
    else r2 instanceof Ee && (s2 = r2);
    return s2 ? this._execStatements(s2.body, t2) : null;
  }
  _if(e3, t2) {
    t2 = t2.clone();
    const n2 = this.evalExpression(e3.condition, t2);
    if (!(n2 instanceof Be)) return console.error(`Invalid if condition. Line ${e3.line}`), null;
    if (n2.value) return this._execStatements(e3.body, t2);
    for (const n3 of e3.elseif) {
      const s2 = this.evalExpression(n3.condition, t2);
      if (!(s2 instanceof Be)) return console.error(`Invalid if condition. Line ${e3.line}`), null;
      if (s2.value) return this._execStatements(n3.body, t2);
    }
    return e3.else ? this._execStatements(e3.else, t2) : null;
  }
  _getScalarValue(e3) {
    return e3 instanceof Be ? e3.value : (console.error("Expected scalar value.", e3), 0);
  }
  _for(e3, t2) {
    for (t2 = t2.clone(), this.execStatement(e3.init, t2); this._getScalarValue(this.evalExpression(e3.condition, t2)); ) {
      const n2 = this._execStatements(e3.body, t2);
      if (n2 === _dt._breakObj) break;
      if (null !== n2 && n2 !== _dt._continueObj) return n2;
      this.execStatement(e3.increment, t2);
    }
    return null;
  }
  _loop(e3, t2) {
    for (t2 = t2.clone(); ; ) {
      const n2 = this._execStatements(e3.body, t2);
      if (n2 === _dt._breakObj) break;
      if (n2 === _dt._continueObj) {
        if (e3.continuing) {
          if (this._execStatements(e3.continuing.body, t2) === _dt._breakObj) break;
        }
      } else if (null !== n2) return n2;
    }
    return null;
  }
  _while(e3, t2) {
    for (t2 = t2.clone(); this._getScalarValue(this.evalExpression(e3.condition, t2)); ) {
      const n2 = this._execStatements(e3.body, t2);
      if (n2 === _dt._breakObj) break;
      if (n2 !== _dt._continueObj && null !== n2) return n2;
    }
    return null;
  }
  _evalBitcast(e3, t2) {
    const n2 = this.evalExpression(e3.value, t2), s2 = e3.type;
    if (n2 instanceof Be) {
      const e4 = nt(n2.value, n2.typeInfo.name, s2.name);
      return new Be(e4, this.getTypeInfo(s2));
    }
    if (n2 instanceof Me) {
      const t3 = n2.typeInfo.getTypeName();
      let r2 = "";
      if (t3.endsWith("f")) r2 = "f32";
      else if (t3.endsWith("i")) r2 = "i32";
      else if (t3.endsWith("u")) r2 = "u32";
      else if (t3.endsWith("b")) r2 = "bool";
      else {
        if (!t3.endsWith("h")) return console.error(`Unknown vector type ${t3}. Line ${e3.line}`), null;
        r2 = "f16";
      }
      const a2 = s2.getTypeName();
      let i2 = "";
      if (a2.endsWith("f")) i2 = "f32";
      else if (a2.endsWith("i")) i2 = "i32";
      else if (a2.endsWith("u")) i2 = "u32";
      else if (a2.endsWith("b")) i2 = "bool";
      else {
        if (!a2.endsWith("h")) return console.error(`Unknown vector type ${i2}. Line ${e3.line}`), null;
        i2 = "f16";
      }
      const o2 = function(e4, t4, n3) {
        if (t4 === n3) return e4;
        const s3 = new Array(e4.length);
        for (let r3 = 0; r3 < e4.length; r3++) s3[r3] = nt(e4[r3], t4, n3);
        return s3;
      }(Array.from(n2.data), r2, i2);
      return new Me(o2, this.getTypeInfo(s2));
    }
    return console.error(`TODO: bitcast for ${n2.typeInfo.name}. Line ${e3.line}`), null;
  }
  _evalConst(e3, t2) {
    return t2.getVariableValue(e3.name).clone().getSubData(this, e3.postfix, t2);
  }
  _evalCreate(e3, t2) {
    var r2;
    if (e3 instanceof de) {
      if (null === e3.type) return Ve.void;
      switch (e3.type.getTypeName()) {
        case "bool":
        case "i32":
        case "u32":
        case "f32":
        case "f16":
          return this._callConstructorValue(e3, t2);
        case "vec2":
        case "vec3":
        case "vec4":
        case "vec2f":
        case "vec3f":
        case "vec4f":
        case "vec2h":
        case "vec3h":
        case "vec4h":
        case "vec2i":
        case "vec3i":
        case "vec4i":
        case "vec2u":
        case "vec3u":
        case "vec4u":
        case "vec2b":
        case "vec3b":
        case "vec4b":
          return this._callConstructorVec(e3, t2);
        case "mat2x2":
        case "mat2x2f":
        case "mat2x2h":
        case "mat2x3":
        case "mat2x3f":
        case "mat2x3h":
        case "mat2x4":
        case "mat2x4f":
        case "mat2x4h":
        case "mat3x2":
        case "mat3x2f":
        case "mat3x2h":
        case "mat3x3":
        case "mat3x3f":
        case "mat3x3h":
        case "mat3x4":
        case "mat3x4f":
        case "mat3x4h":
        case "mat4x2":
        case "mat4x2f":
        case "mat4x2h":
        case "mat4x3":
        case "mat4x3f":
        case "mat4x3h":
        case "mat4x4":
        case "mat4x4f":
        case "mat4x4h":
          return this._callConstructorMatrix(e3, t2);
      }
    }
    const a2 = e3 instanceof de ? e3.type.name : e3.name, i2 = e3 instanceof de ? this.getTypeInfo(e3.type) : this.getTypeInfo(e3.name);
    if (null === i2) return console.error(`Unknown type ${a2}. Line ${e3.line}`), null;
    if (0 === i2.size) return null;
    const o2 = new Pe(new ArrayBuffer(i2.size), i2, 0);
    if (i2 instanceof n) {
      if (e3.args) for (let n2 = 0; n2 < e3.args.length; ++n2) {
        const s2 = i2.members[n2], r3 = e3.args[n2], a3 = this.evalExpression(r3, t2);
        o2.setData(this, a3, s2.type, s2.offset, t2);
      }
    } else if (i2 instanceof s) {
      let n2 = 0;
      if (e3.args) for (let s2 = 0; s2 < e3.args.length; ++s2) {
        const a3 = e3.args[s2], c2 = this.evalExpression(a3, t2);
        null === i2.format && ("x32" === (null === (r2 = c2.typeInfo) || void 0 === r2 ? void 0 : r2.name) ? i2.format = this.getTypeInfo("i32") : i2.format = c2.typeInfo), o2.setData(this, c2, i2.format, n2, t2), n2 += i2.stride;
      }
    } else console.error(`Unknown type "${a2}". Line ${e3.line}`);
    return e3 instanceof de ? o2.getSubData(this, e3.postfix, t2) : o2;
  }
  _evalLiteral(e3, t2) {
    const n2 = this.getTypeInfo(e3.type), s2 = n2.name;
    if ("x32" === s2 || "u32" === s2 || "f32" === s2 || "f16" === s2 || "i32" === s2 || "bool" === s2) {
      return new Be(e3.scalarValue, n2);
    }
    return "vec2" === s2 || "vec3" === s2 || "vec4" === s2 || "vec2f" === s2 || "vec3f" === s2 || "vec4f" === s2 || "vec2h" === s2 || "vec3h" === s2 || "vec4h" === s2 || "vec2i" === s2 || "vec3i" === s2 || "vec4i" === s2 || "vec2u" === s2 || "vec3u" === s2 || "vec4u" === s2 ? this._callConstructorVec(e3, t2) : "mat2x2" === s2 || "mat2x3" === s2 || "mat2x4" === s2 || "mat3x2" === s2 || "mat3x3" === s2 || "mat3x4" === s2 || "mat4x2" === s2 || "mat4x3" === s2 || "mat4x4" === s2 || "mat2x2f" === s2 || "mat2x3f" === s2 || "mat2x4f" === s2 || "mat3x2f" === s2 || "mat3x3f" === s2 || "mat3x4f" === s2 || "mat4x2f" === s2 || "mat4x3f" === s2 || "mat4x4f" === s2 || "mat2x2h" === s2 || "mat2x3h" === s2 || "mat2x4h" === s2 || "mat3x2h" === s2 || "mat3x3h" === s2 || "mat3x4h" === s2 || "mat4x2h" === s2 || "mat4x3h" === s2 || "mat4x4h" === s2 ? this._callConstructorMatrix(e3, t2) : e3.value;
  }
  _evalVariable(e3, t2) {
    const n2 = t2.getVariableValue(e3.name);
    return null === n2 ? n2 : n2.getSubData(this, e3.postfix, t2);
  }
  _maxFormatTypeInfo(e3) {
    let t2 = e3[0];
    if ("f32" === t2.name) return t2;
    for (let n2 = 1; n2 < e3.length; ++n2) {
      const s2 = _dt._priority.get(t2.name);
      _dt._priority.get(e3[n2].name) < s2 && (t2 = e3[n2]);
    }
    return "x32" === t2.name ? this.getTypeInfo("i32") : t2;
  }
  _evalUnaryOp(e3, t2) {
    const n2 = this.evalExpression(e3.right, t2);
    if ("&" === e3.operator) return new Oe(n2);
    if ("*" === e3.operator) return n2 instanceof Oe ? n2.reference.getSubData(this, e3.postfix, t2) : (console.error(`Invalid dereference. Line ${e3.line}`), null);
    const s2 = n2 instanceof Be ? n2.value : n2 instanceof Me ? Array.from(n2.data) : null;
    switch (e3.operator) {
      case "+": {
        if (Ge(s2)) {
          const e5 = s2.map((e6, t4) => +e6);
          return new Me(e5, n2.typeInfo);
        }
        const e4 = s2, t3 = this._maxFormatTypeInfo([n2.typeInfo, n2.typeInfo]);
        return new Be(+e4, t3);
      }
      case "-": {
        if (Ge(s2)) {
          const e5 = s2.map((e6, t4) => -e6);
          return new Me(e5, n2.typeInfo);
        }
        const e4 = s2, t3 = this._maxFormatTypeInfo([n2.typeInfo, n2.typeInfo]);
        return new Be(-e4, t3);
      }
      case "!": {
        if (Ge(s2)) {
          const e5 = s2.map((e6, t4) => e6 ? 0 : 1);
          return new Me(e5, n2.typeInfo);
        }
        const e4 = s2, t3 = this._maxFormatTypeInfo([n2.typeInfo, n2.typeInfo]);
        return new Be(e4 ? 0 : 1, t3);
      }
      case "~": {
        if (Ge(s2)) {
          const e5 = s2.map((e6, t4) => ~e6);
          return new Me(e5, n2.typeInfo);
        }
        const e4 = s2, t3 = this._maxFormatTypeInfo([n2.typeInfo, n2.typeInfo]);
        return new Be(~e4, t3);
      }
    }
    return console.error(`Invalid unary operator ${e3.operator}. Line ${e3.line}`), null;
  }
  _evalBinaryOp(e3, t2) {
    const n2 = this.evalExpression(e3.left, t2), s2 = this.evalExpression(e3.right, t2), r2 = n2 instanceof Be ? n2.value : n2 instanceof Me || n2 instanceof Ue ? Array.from(n2.data) : null, a2 = s2 instanceof Be ? s2.value : s2 instanceof Me || s2 instanceof Ue ? Array.from(s2.data) : null;
    switch (e3.operator) {
      case "+": {
        if (Ge(r2) && Ge(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length) return console.error(`Vector length mismatch. Line ${e3.line}.`), null;
          const i3 = t4.map((e4, t5) => e4 + s3[t5]);
          return new Me(i3, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e4 = a2, t4 = r2.map((t5, n3) => t5 + e4);
          return new Me(t4, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e4 = r2, t4 = a2.map((t5, n3) => e4 + t5);
          return new Me(t4, s2.typeInfo);
        }
        const t3 = r2, i2 = a2, o2 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Be(t3 + i2, o2);
      }
      case "-": {
        if (Ge(r2) && Ge(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length) return console.error(`Vector length mismatch. Line ${e3.line}.`), null;
          const i3 = t4.map((e4, t5) => e4 - s3[t5]);
          return new Me(i3, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e4 = a2, t4 = r2.map((t5, n3) => t5 - e4);
          return new Me(t4, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e4 = r2, t4 = a2.map((t5, n3) => e4 - t5);
          return new Me(t4, s2.typeInfo);
        }
        const t3 = r2, i2 = a2, o2 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Be(t3 - i2, o2);
      }
      case "*": {
        if (Ge(r2) && Ge(a2)) {
          const t4 = r2, i3 = a2;
          if (n2 instanceof Ue && s2 instanceof Ue) {
            const r3 = function(e4, t5, n3, s3) {
              if (void 0 === pt[t5.name] || void 0 === pt[s3.name]) return null;
              const r4 = pt[t5.name][0], a4 = pt[t5.name][1], i4 = pt[s3.name][0];
              if (r4 !== pt[s3.name][1]) return null;
              const o4 = new Array(i4 * a4);
              for (let t6 = 0; t6 < a4; t6++) for (let s4 = 0; s4 < i4; s4++) {
                let c3 = 0;
                for (let i5 = 0; i5 < r4; i5++) c3 += e4[i5 * a4 + t6] * n3[s4 * r4 + i5];
                o4[t6 * i4 + s4] = c3;
              }
              return o4;
            }(t4, n2.typeInfo, i3, s2.typeInfo);
            if (null === r3) return console.error(`Matrix multiplication failed. Line ${e3.line}.`), null;
            const a3 = pt[s2.typeInfo.name][0], o3 = pt[n2.typeInfo.name][1], c2 = this.getTypeInfo(`mat${a3}x${o3}f`);
            return new Ue(r3, c2);
          }
          if (n2 instanceof Ue && s2 instanceof Me) {
            const r3 = function(e4, t5, n3, s3) {
              if (void 0 === pt[t5.name] || void 0 === ft[s3.name]) return null;
              const r4 = pt[t5.name][0], a3 = pt[t5.name][1];
              if (r4 !== n3.length) return null;
              const i4 = new Array(a3);
              for (let t6 = 0; t6 < a3; t6++) {
                let s4 = 0;
                for (let i5 = 0; i5 < r4; i5++) s4 += e4[i5 * a3 + t6] * n3[i5];
                i4[t6] = s4;
              }
              return i4;
            }(t4, n2.typeInfo, i3, s2.typeInfo);
            return null === r3 ? (console.error(`Matrix vector multiplication failed. Line ${e3.line}.`), null) : new Me(r3, s2.typeInfo);
          }
          if (n2 instanceof Me && s2 instanceof Ue) {
            const r3 = function(e4, t5, n3, s3) {
              if (void 0 === ft[t5.name] || void 0 === pt[s3.name]) return null;
              const r4 = pt[s3.name][0], a3 = pt[s3.name][1];
              if (a3 !== e4.length) return null;
              const i4 = [];
              for (let t6 = 0; t6 < r4; t6++) {
                let s4 = 0;
                for (let i5 = 0; i5 < a3; i5++) s4 += e4[i5] * n3[i5 * r4 + t6];
                i4[t6] = s4;
              }
              return i4;
            }(t4, n2.typeInfo, i3, s2.typeInfo);
            return null === r3 ? (console.error(`Matrix vector multiplication failed. Line ${e3.line}.`), null) : new Me(r3, n2.typeInfo);
          }
          {
            if (t4.length !== i3.length) return console.error(`Vector length mismatch. Line ${e3.line}.`), null;
            const s3 = t4.map((e4, t5) => e4 * i3[t5]);
            return new Me(s3, n2.typeInfo);
          }
        }
        if (Ge(r2)) {
          const e4 = a2, t4 = r2.map((t5, n3) => t5 * e4);
          return n2 instanceof Ue ? new Ue(t4, n2.typeInfo) : new Me(t4, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e4 = r2, t4 = a2.map((t5, n3) => e4 * t5);
          return s2 instanceof Ue ? new Ue(t4, s2.typeInfo) : new Me(t4, s2.typeInfo);
        }
        const t3 = r2, i2 = a2, o2 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Be(t3 * i2, o2);
      }
      case "%": {
        if (Ge(r2) && Ge(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length) return console.error(`Vector length mismatch. Line ${e3.line}.`), null;
          const i3 = t4.map((e4, t5) => e4 % s3[t5]);
          return new Me(i3, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e4 = a2, t4 = r2.map((t5, n3) => t5 % e4);
          return new Me(t4, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e4 = r2, t4 = a2.map((t5, n3) => e4 % t5);
          return new Me(t4, s2.typeInfo);
        }
        const t3 = r2, i2 = a2, o2 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Be(t3 % i2, o2);
      }
      case "/": {
        if (Ge(r2) && Ge(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length) return console.error(`Vector length mismatch. Line ${e3.line}.`), null;
          const i3 = t4.map((e4, t5) => e4 / s3[t5]);
          return new Me(i3, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e4 = a2, t4 = r2.map((t5, n3) => t5 / e4);
          return new Me(t4, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e4 = r2, t4 = a2.map((t5, n3) => e4 / t5);
          return new Me(t4, s2.typeInfo);
        }
        const t3 = r2, i2 = a2, o2 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Be(t3 / i2, o2);
      }
      case "&": {
        if (Ge(r2) && Ge(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length) return console.error(`Vector length mismatch. Line ${e3.line}.`), null;
          const i3 = t4.map((e4, t5) => e4 & s3[t5]);
          return new Me(i3, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e4 = a2, t4 = r2.map((t5, n3) => t5 & e4);
          return new Me(t4, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e4 = r2, t4 = a2.map((t5, n3) => e4 & t5);
          return new Me(t4, s2.typeInfo);
        }
        const t3 = r2, i2 = a2, o2 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Be(t3 & i2, o2);
      }
      case "|": {
        if (Ge(r2) && Ge(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length) return console.error(`Vector length mismatch. Line ${e3.line}.`), null;
          const i3 = t4.map((e4, t5) => e4 | s3[t5]);
          return new Me(i3, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e4 = a2, t4 = r2.map((t5, n3) => t5 | e4);
          return new Me(t4, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e4 = r2, t4 = a2.map((t5, n3) => e4 | t5);
          return new Me(t4, s2.typeInfo);
        }
        const t3 = r2, i2 = a2, o2 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Be(t3 | i2, o2);
      }
      case "^": {
        if (Ge(r2) && Ge(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length) return console.error(`Vector length mismatch. Line ${e3.line}.`), null;
          const i3 = t4.map((e4, t5) => e4 ^ s3[t5]);
          return new Me(i3, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e4 = a2, t4 = r2.map((t5, n3) => t5 ^ e4);
          return new Me(t4, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e4 = r2, t4 = a2.map((t5, n3) => e4 ^ t5);
          return new Me(t4, s2.typeInfo);
        }
        const t3 = r2, i2 = a2, o2 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Be(t3 ^ i2, o2);
      }
      case "<<": {
        if (Ge(r2) && Ge(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length) return console.error(`Vector length mismatch. Line ${e3.line}.`), null;
          const i3 = t4.map((e4, t5) => e4 << s3[t5]);
          return new Me(i3, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e4 = a2, t4 = r2.map((t5, n3) => t5 << e4);
          return new Me(t4, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e4 = r2, t4 = a2.map((t5, n3) => e4 << t5);
          return new Me(t4, s2.typeInfo);
        }
        const t3 = r2, i2 = a2, o2 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Be(t3 << i2, o2);
      }
      case ">>": {
        if (Ge(r2) && Ge(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length) return console.error(`Vector length mismatch. Line ${e3.line}.`), null;
          const i3 = t4.map((e4, t5) => e4 >> s3[t5]);
          return new Me(i3, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e4 = a2, t4 = r2.map((t5, n3) => t5 >> e4);
          return new Me(t4, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e4 = r2, t4 = a2.map((t5, n3) => e4 >> t5);
          return new Me(t4, s2.typeInfo);
        }
        const t3 = r2, i2 = a2, o2 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Be(t3 >> i2, o2);
      }
      case ">":
        if (Ge(r2) && Ge(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length) return console.error(`Vector length mismatch. Line ${e3.line}.`), null;
          const i2 = t3.map((e4, t4) => e4 > s3[t4] ? 1 : 0);
          return new Me(i2, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e4 = a2, t3 = r2.map((t4, n3) => t4 > e4 ? 1 : 0);
          return new Me(t3, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e4 = r2, t3 = a2.map((t4, n3) => e4 > t4 ? 1 : 0);
          return new Me(t3, s2.typeInfo);
        }
        return new Be(r2 > a2 ? 1 : 0, this.getTypeInfo("bool"));
      case "<":
        if (Ge(r2) && Ge(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length) return console.error(`Vector length mismatch. Line ${e3.line}.`), null;
          const i2 = t3.map((e4, t4) => e4 < s3[t4] ? 1 : 0);
          return new Me(i2, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e4 = a2, t3 = r2.map((t4, n3) => t4 < e4 ? 1 : 0);
          return new Me(t3, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e4 = r2, t3 = a2.map((t4, n3) => e4 < t4 ? 1 : 0);
          return new Me(t3, s2.typeInfo);
        }
        return new Be(r2 < a2 ? 1 : 0, this.getTypeInfo("bool"));
      case "==":
        if (Ge(r2) && Ge(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length) return console.error(`Vector length mismatch. Line ${e3.line}.`), null;
          const i2 = t3.map((e4, t4) => e4 === s3[t4] ? 1 : 0);
          return new Me(i2, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e4 = a2, t3 = r2.map((t4, n3) => t4 == e4 ? 1 : 0);
          return new Me(t3, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e4 = r2, t3 = a2.map((t4, n3) => e4 == t4 ? 1 : 0);
          return new Me(t3, s2.typeInfo);
        }
        return new Be(r2 === a2 ? 1 : 0, this.getTypeInfo("bool"));
      case "!=":
        if (Ge(r2) && Ge(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length) return console.error(`Vector length mismatch. Line ${e3.line}.`), null;
          const i2 = t3.map((e4, t4) => e4 !== s3[t4] ? 1 : 0);
          return new Me(i2, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e4 = a2, t3 = r2.map((t4, n3) => t4 !== e4 ? 1 : 0);
          return new Me(t3, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e4 = r2, t3 = a2.map((t4, n3) => e4 !== t4 ? 1 : 0);
          return new Me(t3, s2.typeInfo);
        }
        return new Be(r2 !== a2 ? 1 : 0, this.getTypeInfo("bool"));
      case ">=":
        if (Ge(r2) && Ge(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length) return console.error(`Vector length mismatch. Line ${e3.line}.`), null;
          const i2 = t3.map((e4, t4) => e4 >= s3[t4] ? 1 : 0);
          return new Me(i2, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e4 = a2, t3 = r2.map((t4, n3) => t4 >= e4 ? 1 : 0);
          return new Me(t3, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e4 = r2, t3 = a2.map((t4, n3) => e4 >= t4 ? 1 : 0);
          return new Me(t3, s2.typeInfo);
        }
        return new Be(r2 >= a2 ? 1 : 0, this.getTypeInfo("bool"));
      case "<=":
        if (Ge(r2) && Ge(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length) return console.error(`Vector length mismatch. Line ${e3.line}.`), null;
          const i2 = t3.map((e4, t4) => e4 <= s3[t4] ? 1 : 0);
          return new Me(i2, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e4 = a2, t3 = r2.map((t4, n3) => t4 <= e4 ? 1 : 0);
          return new Me(t3, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e4 = r2, t3 = a2.map((t4, n3) => e4 <= t4 ? 1 : 0);
          return new Me(t3, s2.typeInfo);
        }
        return new Be(r2 <= a2 ? 1 : 0, this.getTypeInfo("bool"));
      case "&&":
        if (Ge(r2) && Ge(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length) return console.error(`Vector length mismatch. Line ${e3.line}.`), null;
          const i2 = t3.map((e4, t4) => e4 && s3[t4] ? 1 : 0);
          return new Me(i2, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e4 = a2, t3 = r2.map((t4, n3) => t4 && e4 ? 1 : 0);
          return new Me(t3, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e4 = r2, t3 = a2.map((t4, n3) => e4 && t4 ? 1 : 0);
          return new Me(t3, s2.typeInfo);
        }
        return new Be(r2 && a2 ? 1 : 0, this.getTypeInfo("bool"));
      case "||":
        if (Ge(r2) && Ge(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length) return console.error(`Vector length mismatch. Line ${e3.line}.`), null;
          const i2 = t3.map((e4, t4) => e4 || s3[t4] ? 1 : 0);
          return new Me(i2, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e4 = a2, t3 = r2.map((t4, n3) => t4 || e4 ? 1 : 0);
          return new Me(t3, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e4 = r2, t3 = a2.map((t4, n3) => e4 || t4 ? 1 : 0);
          return new Me(t3, s2.typeInfo);
        }
        return new Be(r2 || a2 ? 1 : 0, this.getTypeInfo("bool"));
    }
    return console.error(`Unknown operator ${e3.operator}. Line ${e3.line}`), null;
  }
  _evalCall(e3, t2) {
    if (null !== e3.cachedReturnValue) return e3.cachedReturnValue;
    const n2 = t2.clone();
    n2.currentFunctionName = e3.name;
    const s2 = t2.getFunction(e3.name);
    if (!s2) {
      if (e3.isBuiltin) return this._callBuiltinFunction(e3, n2);
      return this.getTypeInfo(e3.name) ? this._evalCreate(e3, t2) : (console.error(`Unknown function "${e3.name}". Line ${e3.line}`), null);
    }
    for (let t3 = 0; t3 < s2.node.args.length; ++t3) {
      const r2 = s2.node.args[t3], a2 = this.evalExpression(e3.args[t3], n2);
      n2.createVariable(r2.name, a2, r2);
    }
    return this._execStatements(s2.node.body, n2);
  }
  _callBuiltinFunction(e3, t2) {
    switch (e3.name) {
      case "all":
        return this.builtins.All(e3, t2);
      case "any":
        return this.builtins.Any(e3, t2);
      case "select":
        return this.builtins.Select(e3, t2);
      case "arrayLength":
        return this.builtins.ArrayLength(e3, t2);
      case "abs":
        return this.builtins.Abs(e3, t2);
      case "acos":
        return this.builtins.Acos(e3, t2);
      case "acosh":
        return this.builtins.Acosh(e3, t2);
      case "asin":
        return this.builtins.Asin(e3, t2);
      case "asinh":
        return this.builtins.Asinh(e3, t2);
      case "atan":
        return this.builtins.Atan(e3, t2);
      case "atanh":
        return this.builtins.Atanh(e3, t2);
      case "atan2":
        return this.builtins.Atan2(e3, t2);
      case "ceil":
        return this.builtins.Ceil(e3, t2);
      case "clamp":
        return this.builtins.Clamp(e3, t2);
      case "cos":
        return this.builtins.Cos(e3, t2);
      case "cosh":
        return this.builtins.Cosh(e3, t2);
      case "countLeadingZeros":
        return this.builtins.CountLeadingZeros(e3, t2);
      case "countOneBits":
        return this.builtins.CountOneBits(e3, t2);
      case "countTrailingZeros":
        return this.builtins.CountTrailingZeros(e3, t2);
      case "cross":
        return this.builtins.Cross(e3, t2);
      case "degrees":
        return this.builtins.Degrees(e3, t2);
      case "determinant":
        return this.builtins.Determinant(e3, t2);
      case "distance":
        return this.builtins.Distance(e3, t2);
      case "dot":
        return this.builtins.Dot(e3, t2);
      case "dot4U8Packed":
        return this.builtins.Dot4U8Packed(e3, t2);
      case "dot4I8Packed":
        return this.builtins.Dot4I8Packed(e3, t2);
      case "exp":
        return this.builtins.Exp(e3, t2);
      case "exp2":
        return this.builtins.Exp2(e3, t2);
      case "extractBits":
        return this.builtins.ExtractBits(e3, t2);
      case "faceForward":
        return this.builtins.FaceForward(e3, t2);
      case "firstLeadingBit":
        return this.builtins.FirstLeadingBit(e3, t2);
      case "firstTrailingBit":
        return this.builtins.FirstTrailingBit(e3, t2);
      case "floor":
        return this.builtins.Floor(e3, t2);
      case "fma":
        return this.builtins.Fma(e3, t2);
      case "fract":
        return this.builtins.Fract(e3, t2);
      case "frexp":
        return this.builtins.Frexp(e3, t2);
      case "insertBits":
        return this.builtins.InsertBits(e3, t2);
      case "inverseSqrt":
        return this.builtins.InverseSqrt(e3, t2);
      case "ldexp":
        return this.builtins.Ldexp(e3, t2);
      case "length":
        return this.builtins.Length(e3, t2);
      case "log":
        return this.builtins.Log(e3, t2);
      case "log2":
        return this.builtins.Log2(e3, t2);
      case "max":
        return this.builtins.Max(e3, t2);
      case "min":
        return this.builtins.Min(e3, t2);
      case "mix":
        return this.builtins.Mix(e3, t2);
      case "modf":
        return this.builtins.Modf(e3, t2);
      case "normalize":
        return this.builtins.Normalize(e3, t2);
      case "pow":
        return this.builtins.Pow(e3, t2);
      case "quantizeToF16":
        return this.builtins.QuantizeToF16(e3, t2);
      case "radians":
        return this.builtins.Radians(e3, t2);
      case "reflect":
        return this.builtins.Reflect(e3, t2);
      case "refract":
        return this.builtins.Refract(e3, t2);
      case "reverseBits":
        return this.builtins.ReverseBits(e3, t2);
      case "round":
        return this.builtins.Round(e3, t2);
      case "saturate":
        return this.builtins.Saturate(e3, t2);
      case "sign":
        return this.builtins.Sign(e3, t2);
      case "sin":
        return this.builtins.Sin(e3, t2);
      case "sinh":
        return this.builtins.Sinh(e3, t2);
      case "smoothstep":
        return this.builtins.SmoothStep(e3, t2);
      case "sqrt":
        return this.builtins.Sqrt(e3, t2);
      case "step":
        return this.builtins.Step(e3, t2);
      case "tan":
        return this.builtins.Tan(e3, t2);
      case "tanh":
        return this.builtins.Tanh(e3, t2);
      case "transpose":
        return this.builtins.Transpose(e3, t2);
      case "trunc":
        return this.builtins.Trunc(e3, t2);
      case "dpdx":
        return this.builtins.Dpdx(e3, t2);
      case "dpdxCoarse":
        return this.builtins.DpdxCoarse(e3, t2);
      case "dpdxFine":
        return this.builtins.DpdxFine(e3, t2);
      case "dpdy":
        return this.builtins.Dpdy(e3, t2);
      case "dpdyCoarse":
        return this.builtins.DpdyCoarse(e3, t2);
      case "dpdyFine":
        return this.builtins.DpdyFine(e3, t2);
      case "fwidth":
        return this.builtins.Fwidth(e3, t2);
      case "fwidthCoarse":
        return this.builtins.FwidthCoarse(e3, t2);
      case "fwidthFine":
        return this.builtins.FwidthFine(e3, t2);
      case "textureDimensions":
        return this.builtins.TextureDimensions(e3, t2);
      case "textureGather":
        return this.builtins.TextureGather(e3, t2);
      case "textureGatherCompare":
        return this.builtins.TextureGatherCompare(e3, t2);
      case "textureLoad":
        return this.builtins.TextureLoad(e3, t2);
      case "textureNumLayers":
        return this.builtins.TextureNumLayers(e3, t2);
      case "textureNumLevels":
        return this.builtins.TextureNumLevels(e3, t2);
      case "textureNumSamples":
        return this.builtins.TextureNumSamples(e3, t2);
      case "textureSample":
        return this.builtins.TextureSample(e3, t2);
      case "textureSampleBias":
        return this.builtins.TextureSampleBias(e3, t2);
      case "textureSampleCompare":
        return this.builtins.TextureSampleCompare(e3, t2);
      case "textureSampleCompareLevel":
        return this.builtins.TextureSampleCompareLevel(e3, t2);
      case "textureSampleGrad":
        return this.builtins.TextureSampleGrad(e3, t2);
      case "textureSampleLevel":
        return this.builtins.TextureSampleLevel(e3, t2);
      case "textureSampleBaseClampToEdge":
        return this.builtins.TextureSampleBaseClampToEdge(e3, t2);
      case "textureStore":
        return this.builtins.TextureStore(e3, t2);
      case "atomicLoad":
        return this.builtins.AtomicLoad(e3, t2);
      case "atomicStore":
        return this.builtins.AtomicStore(e3, t2);
      case "atomicAdd":
        return this.builtins.AtomicAdd(e3, t2);
      case "atomicSub":
        return this.builtins.AtomicSub(e3, t2);
      case "atomicMax":
        return this.builtins.AtomicMax(e3, t2);
      case "atomicMin":
        return this.builtins.AtomicMin(e3, t2);
      case "atomicAnd":
        return this.builtins.AtomicAnd(e3, t2);
      case "atomicOr":
        return this.builtins.AtomicOr(e3, t2);
      case "atomicXor":
        return this.builtins.AtomicXor(e3, t2);
      case "atomicExchange":
        return this.builtins.AtomicExchange(e3, t2);
      case "atomicCompareExchangeWeak":
        return this.builtins.AtomicCompareExchangeWeak(e3, t2);
      case "pack4x8snorm":
        return this.builtins.Pack4x8snorm(e3, t2);
      case "pack4x8unorm":
        return this.builtins.Pack4x8unorm(e3, t2);
      case "pack4xI8":
        return this.builtins.Pack4xI8(e3, t2);
      case "pack4xU8":
        return this.builtins.Pack4xU8(e3, t2);
      case "pack4x8Clamp":
        return this.builtins.Pack4x8Clamp(e3, t2);
      case "pack4xU8Clamp":
        return this.builtins.Pack4xU8Clamp(e3, t2);
      case "pack2x16snorm":
        return this.builtins.Pack2x16snorm(e3, t2);
      case "pack2x16unorm":
        return this.builtins.Pack2x16unorm(e3, t2);
      case "pack2x16float":
        return this.builtins.Pack2x16float(e3, t2);
      case "unpack4x8snorm":
        return this.builtins.Unpack4x8snorm(e3, t2);
      case "unpack4x8unorm":
        return this.builtins.Unpack4x8unorm(e3, t2);
      case "unpack4xI8":
        return this.builtins.Unpack4xI8(e3, t2);
      case "unpack4xU8":
        return this.builtins.Unpack4xU8(e3, t2);
      case "unpack2x16snorm":
        return this.builtins.Unpack2x16snorm(e3, t2);
      case "unpack2x16unorm":
        return this.builtins.Unpack2x16unorm(e3, t2);
      case "unpack2x16float":
        return this.builtins.Unpack2x16float(e3, t2);
      case "storageBarrier":
        return this.builtins.StorageBarrier(e3, t2);
      case "textureBarrier":
        return this.builtins.TextureBarrier(e3, t2);
      case "workgroupBarrier":
        return this.builtins.WorkgroupBarrier(e3, t2);
      case "workgroupUniformLoad":
        return this.builtins.WorkgroupUniformLoad(e3, t2);
      case "subgroupAdd":
        return this.builtins.SubgroupAdd(e3, t2);
      case "subgroupExclusiveAdd":
        return this.builtins.SubgroupExclusiveAdd(e3, t2);
      case "subgroupInclusiveAdd":
        return this.builtins.SubgroupInclusiveAdd(e3, t2);
      case "subgroupAll":
        return this.builtins.SubgroupAll(e3, t2);
      case "subgroupAnd":
        return this.builtins.SubgroupAnd(e3, t2);
      case "subgroupAny":
        return this.builtins.SubgroupAny(e3, t2);
      case "subgroupBallot":
        return this.builtins.SubgroupBallot(e3, t2);
      case "subgroupBroadcast":
        return this.builtins.SubgroupBroadcast(e3, t2);
      case "subgroupBroadcastFirst":
        return this.builtins.SubgroupBroadcastFirst(e3, t2);
      case "subgroupElect":
        return this.builtins.SubgroupElect(e3, t2);
      case "subgroupMax":
        return this.builtins.SubgroupMax(e3, t2);
      case "subgroupMin":
        return this.builtins.SubgroupMin(e3, t2);
      case "subgroupMul":
        return this.builtins.SubgroupMul(e3, t2);
      case "subgroupExclusiveMul":
        return this.builtins.SubgroupExclusiveMul(e3, t2);
      case "subgroupInclusiveMul":
        return this.builtins.SubgroupInclusiveMul(e3, t2);
      case "subgroupOr":
        return this.builtins.SubgroupOr(e3, t2);
      case "subgroupShuffle":
        return this.builtins.SubgroupShuffle(e3, t2);
      case "subgroupShuffleDown":
        return this.builtins.SubgroupShuffleDown(e3, t2);
      case "subgroupShuffleUp":
        return this.builtins.SubgroupShuffleUp(e3, t2);
      case "subgroupShuffleXor":
        return this.builtins.SubgroupShuffleXor(e3, t2);
      case "subgroupXor":
        return this.builtins.SubgroupXor(e3, t2);
      case "quadBroadcast":
        return this.builtins.QuadBroadcast(e3, t2);
      case "quadSwapDiagonal":
        return this.builtins.QuadSwapDiagonal(e3, t2);
      case "quadSwapX":
        return this.builtins.QuadSwapX(e3, t2);
      case "quadSwapY":
        return this.builtins.QuadSwapY(e3, t2);
    }
    const n2 = t2.getFunction(e3.name);
    if (n2) {
      const s2 = t2.clone();
      for (let t3 = 0; t3 < n2.node.args.length; ++t3) {
        const r2 = n2.node.args[t3], a2 = this.evalExpression(e3.args[t3], s2);
        s2.setVariable(r2.name, a2, r2);
      }
      return this._execStatements(n2.node.body, s2);
    }
    return null;
  }
  _callConstructorValue(e3, t2) {
    if (!e3.args || 0 === e3.args.length) return new Be(0, this.getTypeInfo(e3.type));
    const n2 = this.evalExpression(e3.args[0], t2);
    return n2.typeInfo = this.getTypeInfo(e3.type), n2.getSubData(this, e3.postfix, t2).clone();
  }
  _callConstructorVec(e3, t2) {
    const n2 = this.getTypeInfo(e3.type), s2 = e3.type.getTypeName(), r2 = ft[s2];
    if (void 0 === r2) return console.error(`Invalid vec constructor ${s2}. Line ${e3.line}`), null;
    const a2 = [];
    if (e3 instanceof xe) if (e3.isVector) {
      const t3 = e3.vectorValue;
      for (const e4 of t3) a2.push(e4);
    } else a2.push(e3.scalarValue);
    else if (e3.args) for (const n3 of e3.args) {
      const e4 = this.evalExpression(n3, t2);
      if (e4 instanceof Me) {
        const t3 = e4.data;
        for (let e5 = 0; e5 < t3.length; ++e5) {
          let n4 = t3[e5];
          a2.push(n4);
        }
      } else if (e4 instanceof Be) {
        let t3 = e4.value;
        a2.push(t3);
      }
    }
    if (e3.type instanceof ce && null === e3.type.format && (e3.type.format = ce.f32), 0 === a2.length) {
      const s3 = new Array(r2).fill(0);
      return new Me(s3, n2).getSubData(this, e3.postfix, t2);
    }
    if (1 === a2.length) for (; a2.length < r2; ) a2.push(a2[0]);
    if (a2.length < r2) return console.error(`Invalid vec constructor. Line ${e3.line}`), null;
    return new Me(a2.length > r2 ? a2.slice(0, r2) : a2, n2).getSubData(this, e3.postfix, t2);
  }
  _callConstructorMatrix(e3, t2) {
    const n2 = this.getTypeInfo(e3.type), s2 = e3.type.getTypeName(), r2 = pt[s2];
    if (void 0 === r2) return console.error(`Invalid matrix constructor ${s2}. Line ${e3.line}`), null;
    const i2 = [];
    if (e3 instanceof xe) if (e3.isVector) {
      const t3 = e3.vectorValue;
      for (const e4 of t3) i2.push(e4);
    } else i2.push(e3.scalarValue);
    else if (e3.args) for (const n3 of e3.args) {
      const e4 = this.evalExpression(n3, t2);
      e4 instanceof Me ? i2.push(...e4.data) : e4 instanceof Be ? i2.push(e4.value) : e4 instanceof Ue && i2.push(...e4.data);
    }
    if (n2 instanceof a && null === n2.format && (n2.format = this.getTypeInfo("f32")), 0 === i2.length) {
      const s3 = new Array(r2[2]).fill(0);
      return new Ue(s3, n2).getSubData(this, e3.postfix, t2);
    }
    return i2.length !== r2[2] ? (console.error(`Invalid matrix constructor. Line ${e3.line}`), null) : new Ue(i2, n2).getSubData(this, e3.postfix, t2);
  }
};
dt._breakObj = new Ne(new e("BREAK", null), null), dt._continueObj = new Ne(new e("CONTINUE", null), null), dt._priority = /* @__PURE__ */ new Map([["f32", 0], ["f16", 1], ["u32", 2], ["i32", 3], ["x32", 3]]);
var mt = class {
  constructor() {
    this.constants = /* @__PURE__ */ new Map(), this.aliases = /* @__PURE__ */ new Map(), this.structs = /* @__PURE__ */ new Map();
  }
};
var gt = class {
  constructor() {
    this._tokens = [], this._current = 0, this._currentLine = 1, this._deferArrayCountEval = [], this._currentLoop = [], this._context = new mt(), this._exec = new dt(), this._forwardTypeCount = 0;
  }
  parse(e3) {
    this._initialize(e3), this._deferArrayCountEval.length = 0;
    const t2 = [];
    for (; !this._isAtEnd(); ) {
      const e4 = this._global_decl_or_directive();
      if (!e4) break;
      t2.push(e4);
    }
    if (this._deferArrayCountEval.length > 0) {
      for (const e4 of this._deferArrayCountEval) {
        const t3 = e4.arrayType, n2 = e4.countNode;
        if (n2 instanceof ge) {
          const e5 = n2.name, s2 = this._context.constants.get(e5);
          if (s2) try {
            const e6 = s2.constEvaluate(this._exec);
            t3.count = e6;
          } catch (e6) {
          }
        }
      }
      this._deferArrayCountEval.length = 0;
    }
    if (this._forwardTypeCount > 0) for (const e4 of t2) e4.search((e5) => {
      e5 instanceof Ce || e5 instanceof le ? e5.type = this._forwardType(e5.type) : e5 instanceof ue ? e5.format = this._forwardType(e5.format) : e5 instanceof F || e5 instanceof U || e5 instanceof P ? e5.type = this._forwardType(e5.type) : e5 instanceof D ? e5.returnType = this._forwardType(e5.returnType) : e5 instanceof $e && (e5.type = this._forwardType(e5.type));
    });
    return t2;
  }
  _forwardType(e3) {
    if (e3 instanceof ie) {
      const t2 = this._getType(e3.name);
      if (t2) return t2;
    } else e3 instanceof le ? e3.type = this._forwardType(e3.type) : e3 instanceof ue && (e3.format = this._forwardType(e3.format));
    return e3;
  }
  _initialize(e3) {
    if (e3) if ("string" == typeof e3) {
      const t2 = new Re(e3);
      this._tokens = t2.scanTokens();
    } else this._tokens = e3;
    else this._tokens = [];
    this._current = 0;
  }
  _updateNode(e3, t2) {
    return e3.line = null != t2 ? t2 : this._currentLine, e3;
  }
  _error(e3, t2) {
    return { token: e3, message: t2, toString: () => `${t2}` };
  }
  _isAtEnd() {
    return this._current >= this._tokens.length || this._peek().type == He.eof;
  }
  _match(e3) {
    if (e3 instanceof qe) return !!this._check(e3) && (this._advance(), true);
    for (let t2 = 0, n2 = e3.length; t2 < n2; ++t2) {
      const n3 = e3[t2];
      if (this._check(n3)) return this._advance(), true;
    }
    return false;
  }
  _consume(e3, t2) {
    if (this._check(e3)) return this._advance();
    throw this._error(this._peek(), `${t2}. Line:${this._currentLine}`);
  }
  _check(e3) {
    if (this._isAtEnd()) return false;
    const t2 = this._peek();
    if (e3 instanceof Array) {
      const n2 = t2.type;
      let s2 = false;
      for (const t3 of e3) {
        if (n2 === t3) return true;
        t3 === He.tokens.name && (s2 = true);
      }
      if (s2) {
        const e4 = He.tokens.name.rule.exec(t2.lexeme);
        if (e4 && 0 == e4.index && e4[0] == t2.lexeme) return true;
      }
      return false;
    }
    if (t2.type === e3) return true;
    if (e3 === He.tokens.name) {
      const e4 = He.tokens.name.rule.exec(t2.lexeme);
      return e4 && 0 == e4.index && e4[0] == t2.lexeme;
    }
    return false;
  }
  _advance() {
    var e3, t2;
    return this._currentLine = null !== (t2 = null === (e3 = this._peek()) || void 0 === e3 ? void 0 : e3.line) && void 0 !== t2 ? t2 : -1, this._isAtEnd() || this._current++, this._previous();
  }
  _peek() {
    return this._tokens[this._current];
  }
  _previous() {
    return this._tokens[this._current - 1];
  }
  _global_decl_or_directive() {
    for (; this._match(He.tokens.semicolon) && !this._isAtEnd(); ) ;
    if (this._match(He.keywords.alias)) {
      const e4 = this._type_alias();
      return this._consume(He.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([e4]), e4;
    }
    if (this._match(He.keywords.diagnostic)) {
      const e4 = this._diagnostic();
      return this._consume(He.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([e4]), e4;
    }
    if (this._match(He.keywords.requires)) {
      const e4 = this._requires_directive();
      return this._consume(He.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([e4]), e4;
    }
    if (this._match(He.keywords.enable)) {
      const e4 = this._enable_directive();
      return this._consume(He.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([e4]), e4;
    }
    const e3 = this._attribute();
    if (this._check(He.keywords.var)) {
      const t2 = this._global_variable_decl();
      return null != t2 && (t2.attributes = e3), this._consume(He.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t2]), t2;
    }
    if (this._check(He.keywords.override)) {
      const t2 = this._override_variable_decl();
      return null != t2 && (t2.attributes = e3), this._consume(He.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t2]), t2;
    }
    if (this._check(He.keywords.let)) {
      const t2 = this._global_let_decl();
      return null != t2 && (t2.attributes = e3), this._consume(He.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t2]), t2;
    }
    if (this._check(He.keywords.const)) {
      const t2 = this._global_const_decl();
      return null != t2 && (t2.attributes = e3), this._consume(He.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t2]), t2;
    }
    if (this._check(He.keywords.struct)) {
      const t2 = this._struct_decl();
      return null != t2 && (t2.attributes = e3), this._exec.reflection.updateAST([t2]), t2;
    }
    if (this._check(He.keywords.fn)) {
      const t2 = this._function_decl();
      return null != t2 && (t2.attributes = e3), this._exec.reflection.updateAST([t2]), t2;
    }
    return null;
  }
  _function_decl() {
    if (!this._match(He.keywords.fn)) return null;
    const e3 = this._currentLine, t2 = this._consume(He.tokens.ident, "Expected function name.").toString();
    this._consume(He.tokens.paren_left, "Expected '(' for function arguments.");
    const n2 = [];
    if (!this._check(He.tokens.paren_right)) do {
      if (this._check(He.tokens.paren_right)) break;
      const e4 = this._attribute(), t3 = this._consume(He.tokens.name, "Expected argument name.").toString();
      this._consume(He.tokens.colon, "Expected ':' for argument type.");
      const s3 = this._attribute(), r3 = this._type_decl();
      null != r3 && (r3.attributes = s3, n2.push(this._updateNode(new $e(t3, r3, e4))));
    } while (this._match(He.tokens.comma));
    this._consume(He.tokens.paren_right, "Expected ')' after function arguments.");
    let s2 = null;
    if (this._match(He.tokens.arrow)) {
      const e4 = this._attribute();
      s2 = this._type_decl(), null != s2 && (s2.attributes = e4);
    }
    const r2 = this._compound_statement(), a2 = this._currentLine;
    return this._updateNode(new D(t2, n2, s2, r2, e3, a2), e3);
  }
  _compound_statement() {
    const e3 = [];
    for (this._consume(He.tokens.brace_left, "Expected '{' for block."); !this._check(He.tokens.brace_right); ) {
      const t2 = this._statement();
      null !== t2 && e3.push(t2);
    }
    return this._consume(He.tokens.brace_right, "Expected '}' for block."), e3;
  }
  _statement() {
    for (; this._match(He.tokens.semicolon) && !this._isAtEnd(); ) ;
    if (this._check(He.tokens.attr) && this._attribute(), this._check(He.keywords.if)) return this._if_statement();
    if (this._check(He.keywords.switch)) return this._switch_statement();
    if (this._check(He.keywords.loop)) return this._loop_statement();
    if (this._check(He.keywords.for)) return this._for_statement();
    if (this._check(He.keywords.while)) return this._while_statement();
    if (this._check(He.keywords.continuing)) return this._continuing_statement();
    if (this._check(He.keywords.static_assert)) return this._static_assert_statement();
    if (this._check(He.tokens.brace_left)) return this._compound_statement();
    let e3 = null;
    if (this._check(He.keywords.return)) e3 = this._return_statement();
    else if (this._check([He.keywords.var, He.keywords.let, He.keywords.const])) e3 = this._variable_statement();
    else if (this._match(He.keywords.discard)) e3 = this._updateNode(new ne());
    else if (this._match(He.keywords.break)) {
      const t2 = this._updateNode(new se());
      if (this._currentLoop.length > 0) {
        const e4 = this._currentLoop[this._currentLoop.length - 1];
        t2.loopId = e4.id;
      }
      e3 = t2, this._check(He.keywords.if) && (this._advance(), t2.condition = this._optional_paren_expression());
    } else if (this._match(He.keywords.continue)) {
      const t2 = this._updateNode(new re());
      if (!(this._currentLoop.length > 0)) throw this._error(this._peek(), `Continue statement must be inside a loop. Line: ${t2.line}`);
      {
        const e4 = this._currentLoop[this._currentLoop.length - 1];
        t2.loopId = e4.id;
      }
      e3 = t2;
    } else e3 = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement();
    return null != e3 && this._consume(He.tokens.semicolon, "Expected ';' after statement."), e3;
  }
  _static_assert_statement() {
    if (!this._match(He.keywords.static_assert)) return null;
    const e3 = this._currentLine, t2 = this._optional_paren_expression();
    return this._updateNode(new N(t2), e3);
  }
  _while_statement() {
    if (!this._match(He.keywords.while)) return null;
    const e3 = this._updateNode(new V(null, null));
    return this._currentLoop.push(e3), e3.condition = this._optional_paren_expression(), this._check(He.tokens.attr) && this._attribute(), e3.body = this._compound_statement(), this._currentLoop.pop(), e3;
  }
  _continuing_statement() {
    const e3 = this._currentLoop.length > 0 ? this._currentLoop[this._currentLoop.length - 1].id : -1;
    if (!this._match(He.keywords.continuing)) return null;
    const t2 = this._currentLine, n2 = this._compound_statement();
    return this._updateNode(new O(n2, e3), t2);
  }
  _for_statement() {
    if (!this._match(He.keywords.for)) return null;
    this._consume(He.tokens.paren_left, "Expected '('.");
    const e3 = this._updateNode(new B(null, null, null, null));
    return this._currentLoop.push(e3), e3.init = this._check(He.tokens.semicolon) ? null : this._for_init(), this._consume(He.tokens.semicolon, "Expected ';'."), e3.condition = this._check(He.tokens.semicolon) ? null : this._short_circuit_or_expression(), this._consume(He.tokens.semicolon, "Expected ';'."), e3.increment = this._check(He.tokens.paren_right) ? null : this._for_increment(), this._consume(He.tokens.paren_right, "Expected ')'."), this._check(He.tokens.attr) && this._attribute(), e3.body = this._compound_statement(), this._currentLoop.pop(), e3;
  }
  _for_init() {
    return this._variable_statement() || this._func_call_statement() || this._assignment_statement();
  }
  _for_increment() {
    return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();
  }
  _variable_statement() {
    if (this._check(He.keywords.var)) {
      const e3 = this._variable_decl();
      if (null === e3) throw this._error(this._peek(), "Variable declaration expected.");
      let t2 = null;
      return this._match(He.tokens.equal) && (t2 = this._short_circuit_or_expression()), this._updateNode(new F(e3.name, e3.type, e3.storage, e3.access, t2), e3.line);
    }
    if (this._match(He.keywords.let)) {
      const e3 = this._currentLine, t2 = this._consume(He.tokens.name, "Expected name for let.").toString();
      let n2 = null;
      if (this._match(He.tokens.colon)) {
        const e4 = this._attribute();
        n2 = this._type_decl(), null != n2 && (n2.attributes = e4);
      }
      this._consume(He.tokens.equal, "Expected '=' for let.");
      const s2 = this._short_circuit_or_expression();
      return this._updateNode(new U(t2, n2, null, null, s2), e3);
    }
    if (this._match(He.keywords.const)) {
      const e3 = this._currentLine, t2 = this._consume(He.tokens.name, "Expected name for const.").toString();
      let n2 = null;
      if (this._match(He.tokens.colon)) {
        const e4 = this._attribute();
        n2 = this._type_decl(), null != n2 && (n2.attributes = e4);
      }
      this._consume(He.tokens.equal, "Expected '=' for const.");
      const s2 = this._short_circuit_or_expression();
      return null === n2 && s2 instanceof xe && (n2 = s2.type), this._updateNode(new P(t2, n2, null, null, s2), e3);
    }
    return null;
  }
  _increment_decrement_statement() {
    const e3 = this._current, t2 = this._unary_expression();
    if (null == t2) return null;
    if (!this._check(He.increment_operators)) return this._current = e3, null;
    const n2 = this._consume(He.increment_operators, "Expected increment operator");
    return this._updateNode(new R(n2.type === He.tokens.plus_plus ? W.increment : W.decrement, t2));
  }
  _assignment_statement() {
    let e3 = null;
    const t2 = this._currentLine;
    if (this._check(He.tokens.brace_right)) return null;
    let n2 = this._match(He.tokens.underscore);
    if (n2 || (e3 = this._unary_expression()), !n2 && null == e3) return null;
    const s2 = this._consume(He.assignment_operators, "Expected assignment operator."), r2 = this._short_circuit_or_expression();
    return this._updateNode(new G(q.parse(s2.lexeme), e3, r2), t2);
  }
  _func_call_statement() {
    if (!this._check(He.tokens.ident)) return null;
    const e3 = this._currentLine, t2 = this._current, n2 = this._consume(He.tokens.ident, "Expected function name."), s2 = this._argument_expression_list();
    return null === s2 ? (this._current = t2, null) : this._updateNode(new X(n2.lexeme, s2), e3);
  }
  _loop_statement() {
    if (!this._match(He.keywords.loop)) return null;
    this._check(He.tokens.attr) && this._attribute(), this._consume(He.tokens.brace_left, "Expected '{' for loop.");
    const e3 = this._updateNode(new j([], null));
    this._currentLoop.push(e3);
    let t2 = this._statement();
    for (; null !== t2; ) {
      if (Array.isArray(t2)) for (let n2 of t2) e3.body.push(n2);
      else e3.body.push(t2);
      if (t2 instanceof O) {
        e3.continuing = t2;
        break;
      }
      t2 = this._statement();
    }
    return this._currentLoop.pop(), this._consume(He.tokens.brace_right, "Expected '}' for loop."), e3;
  }
  _switch_statement() {
    if (!this._match(He.keywords.switch)) return null;
    const e3 = this._updateNode(new Z(null, []));
    if (this._currentLoop.push(e3), e3.condition = this._optional_paren_expression(), this._check(He.tokens.attr) && this._attribute(), this._consume(He.tokens.brace_left, "Expected '{' for switch."), e3.cases = this._switch_body(), null == e3.cases || 0 == e3.cases.length) throw this._error(this._previous(), "Expected 'case' or 'default'.");
    return this._consume(He.tokens.brace_right, "Expected '}' for switch."), this._currentLoop.pop(), e3;
  }
  _switch_body() {
    const e3 = [];
    let t2 = false;
    for (; this._check([He.keywords.default, He.keywords.case]); ) {
      if (this._match(He.keywords.case)) {
        const n2 = this._case_selectors();
        for (const e4 of n2) if (e4 instanceof Se) {
          if (t2) throw this._error(this._previous(), "Multiple default cases in switch statement.");
          t2 = true;
          break;
        }
        this._match(He.tokens.colon), this._check(He.tokens.attr) && this._attribute(), this._consume(He.tokens.brace_left, "Exected '{' for switch case.");
        const s2 = this._case_body();
        this._consume(He.tokens.brace_right, "Exected '}' for switch case."), e3.push(this._updateNode(new Ae(n2, s2)));
      }
      if (this._match(He.keywords.default)) {
        if (t2) throw this._error(this._previous(), "Multiple default cases in switch statement.");
        this._match(He.tokens.colon), this._check(He.tokens.attr) && this._attribute(), this._consume(He.tokens.brace_left, "Exected '{' for switch default.");
        const n2 = this._case_body();
        this._consume(He.tokens.brace_right, "Exected '}' for switch default."), e3.push(this._updateNode(new Ee(n2)));
      }
    }
    return e3;
  }
  _case_selectors() {
    const e3 = [];
    for (this._match(He.keywords.default) ? e3.push(this._updateNode(new Se())) : e3.push(this._shift_expression()); this._match(He.tokens.comma); ) this._match(He.keywords.default) ? e3.push(this._updateNode(new Se())) : e3.push(this._shift_expression());
    return e3;
  }
  _case_body() {
    if (this._match(He.keywords.fallthrough)) return this._consume(He.tokens.semicolon, "Expected ';'"), [];
    let e3 = this._statement();
    if (null == e3) return [];
    e3 instanceof Array || (e3 = [e3]);
    const t2 = this._case_body();
    return 0 == t2.length ? e3 : [...e3, t2[0]];
  }
  _if_statement() {
    if (!this._match(He.keywords.if)) return null;
    const e3 = this._currentLine, t2 = this._optional_paren_expression();
    this._check(He.tokens.attr) && this._attribute();
    const n2 = this._compound_statement();
    let s2 = [];
    this._match_elseif() && (this._check(He.tokens.attr) && this._attribute(), s2 = this._elseif_statement(s2));
    let r2 = null;
    return this._match(He.keywords.else) && (this._check(He.tokens.attr) && this._attribute(), r2 = this._compound_statement()), this._updateNode(new Q(t2, n2, s2, r2), e3);
  }
  _match_elseif() {
    return this._tokens[this._current].type === He.keywords.else && this._tokens[this._current + 1].type === He.keywords.if && (this._advance(), this._advance(), true);
  }
  _elseif_statement(e3 = []) {
    const t2 = this._optional_paren_expression(), n2 = this._compound_statement();
    return e3.push(this._updateNode(new Le(t2, n2))), this._match_elseif() && (this._check(He.tokens.attr) && this._attribute(), this._elseif_statement(e3)), e3;
  }
  _return_statement() {
    if (!this._match(He.keywords.return)) return null;
    const e3 = this._short_circuit_or_expression();
    return this._updateNode(new Y(e3));
  }
  _short_circuit_or_expression() {
    let e3 = this._short_circuit_and_expr();
    for (; this._match(He.tokens.or_or); ) e3 = this._updateNode(new Ie(this._previous().toString(), e3, this._short_circuit_and_expr()));
    return e3;
  }
  _short_circuit_and_expr() {
    let e3 = this._inclusive_or_expression();
    for (; this._match(He.tokens.and_and); ) e3 = this._updateNode(new Ie(this._previous().toString(), e3, this._inclusive_or_expression()));
    return e3;
  }
  _inclusive_or_expression() {
    let e3 = this._exclusive_or_expression();
    for (; this._match(He.tokens.or); ) e3 = this._updateNode(new Ie(this._previous().toString(), e3, this._exclusive_or_expression()));
    return e3;
  }
  _exclusive_or_expression() {
    let e3 = this._and_expression();
    for (; this._match(He.tokens.xor); ) e3 = this._updateNode(new Ie(this._previous().toString(), e3, this._and_expression()));
    return e3;
  }
  _and_expression() {
    let e3 = this._equality_expression();
    for (; this._match(He.tokens.and); ) e3 = this._updateNode(new Ie(this._previous().toString(), e3, this._equality_expression()));
    return e3;
  }
  _equality_expression() {
    const e3 = this._relational_expression();
    return this._match([He.tokens.equal_equal, He.tokens.not_equal]) ? this._updateNode(new Ie(this._previous().toString(), e3, this._relational_expression())) : e3;
  }
  _relational_expression() {
    let e3 = this._shift_expression();
    for (; this._match([He.tokens.less_than, He.tokens.greater_than, He.tokens.less_than_equal, He.tokens.greater_than_equal]); ) e3 = this._updateNode(new Ie(this._previous().toString(), e3, this._shift_expression()));
    return e3;
  }
  _shift_expression() {
    let e3 = this._additive_expression();
    for (; this._match([He.tokens.shift_left, He.tokens.shift_right]); ) e3 = this._updateNode(new Ie(this._previous().toString(), e3, this._additive_expression()));
    return e3;
  }
  _additive_expression() {
    let e3 = this._multiplicative_expression();
    for (; this._match([He.tokens.plus, He.tokens.minus]); ) e3 = this._updateNode(new Ie(this._previous().toString(), e3, this._multiplicative_expression()));
    return e3;
  }
  _multiplicative_expression() {
    let e3 = this._unary_expression();
    for (; this._match([He.tokens.star, He.tokens.forward_slash, He.tokens.modulo]); ) e3 = this._updateNode(new Ie(this._previous().toString(), e3, this._unary_expression()));
    return e3;
  }
  _unary_expression() {
    return this._match([He.tokens.minus, He.tokens.bang, He.tokens.tilde, He.tokens.star, He.tokens.and]) ? this._updateNode(new ke(this._previous().toString(), this._unary_expression())) : this._singular_expression();
  }
  _singular_expression() {
    const e3 = this._primary_expression(), t2 = this._postfix_expression();
    return t2 && (e3.postfix = t2), e3;
  }
  _postfix_expression() {
    if (this._match(He.tokens.bracket_left)) {
      const e3 = this._short_circuit_or_expression();
      this._consume(He.tokens.bracket_right, "Expected ']'.");
      const t2 = this._updateNode(new ve(e3)), n2 = this._postfix_expression();
      return n2 && (t2.postfix = n2), t2;
    }
    if (this._match(He.tokens.period)) {
      const e3 = this._consume(He.tokens.name, "Expected member name."), t2 = this._postfix_expression(), n2 = this._updateNode(new pe(e3.lexeme));
      return t2 && (n2.postfix = t2), n2;
    }
    return null;
  }
  _getStruct(e3) {
    if (this._context.aliases.has(e3)) {
      return this._context.aliases.get(e3).type;
    }
    if (this._context.structs.has(e3)) {
      return this._context.structs.get(e3);
    }
    return null;
  }
  _getType(e3) {
    const t2 = this._getStruct(e3);
    if (null !== t2) return t2;
    switch (e3) {
      case "void":
        return ae.void;
      case "bool":
        return ae.bool;
      case "i32":
        return ae.i32;
      case "u32":
        return ae.u32;
      case "f32":
        return ae.f32;
      case "f16":
        return ae.f16;
      case "vec2f":
        return ce.vec2f;
      case "vec3f":
        return ce.vec3f;
      case "vec4f":
        return ce.vec4f;
      case "vec2i":
        return ce.vec2i;
      case "vec3i":
        return ce.vec3i;
      case "vec4i":
        return ce.vec4i;
      case "vec2u":
        return ce.vec2u;
      case "vec3u":
        return ce.vec3u;
      case "vec4u":
        return ce.vec4u;
      case "vec2h":
        return ce.vec2h;
      case "vec3h":
        return ce.vec3h;
      case "vec4h":
        return ce.vec4h;
      case "mat2x2f":
        return ce.mat2x2f;
      case "mat2x3f":
        return ce.mat2x3f;
      case "mat2x4f":
        return ce.mat2x4f;
      case "mat3x2f":
        return ce.mat3x2f;
      case "mat3x3f":
        return ce.mat3x3f;
      case "mat3x4f":
        return ce.mat3x4f;
      case "mat4x2f":
        return ce.mat4x2f;
      case "mat4x3f":
        return ce.mat4x3f;
      case "mat4x4f":
        return ce.mat4x4f;
      case "mat2x2h":
        return ce.mat2x2h;
      case "mat2x3h":
        return ce.mat2x3h;
      case "mat2x4h":
        return ce.mat2x4h;
      case "mat3x2h":
        return ce.mat3x2h;
      case "mat3x3h":
        return ce.mat3x3h;
      case "mat3x4h":
        return ce.mat3x4h;
      case "mat4x2h":
        return ce.mat4x2h;
      case "mat4x3h":
        return ce.mat4x3h;
      case "mat4x4h":
        return ce.mat4x4h;
      case "mat2x2i":
        return ce.mat2x2i;
      case "mat2x3i":
        return ce.mat2x3i;
      case "mat2x4i":
        return ce.mat2x4i;
      case "mat3x2i":
        return ce.mat3x2i;
      case "mat3x3i":
        return ce.mat3x3i;
      case "mat3x4i":
        return ce.mat3x4i;
      case "mat4x2i":
        return ce.mat4x2i;
      case "mat4x3i":
        return ce.mat4x3i;
      case "mat4x4i":
        return ce.mat4x4i;
      case "mat2x2u":
        return ce.mat2x2u;
      case "mat2x3u":
        return ce.mat2x3u;
      case "mat2x4u":
        return ce.mat2x4u;
      case "mat3x2u":
        return ce.mat3x2u;
      case "mat3x3u":
        return ce.mat3x3u;
      case "mat3x4u":
        return ce.mat3x4u;
      case "mat4x2u":
        return ce.mat4x2u;
      case "mat4x3u":
        return ce.mat4x3u;
      case "mat4x4u":
        return ce.mat4x4u;
    }
    return null;
  }
  _validateTypeRange(e3, t2) {
    if ("i32" === t2.name) {
      if (e3 < -2147483648 || e3 > 2147483647) throw this._error(this._previous(), `Value out of range for i32: ${e3}. Line: ${this._currentLine}.`);
    } else if ("u32" === t2.name && (e3 < 0 || e3 > 4294967295)) throw this._error(this._previous(), `Value out of range for u32: ${e3}. Line: ${this._currentLine}.`);
  }
  _primary_expression() {
    if (this._match(He.tokens.ident)) {
      const e4 = this._previous().toString();
      if (this._check(He.tokens.paren_left)) {
        const t3 = this._argument_expression_list(), n2 = this._getType(e4);
        return null !== n2 ? this._updateNode(new de(n2, t3)) : this._updateNode(new me(e4, t3));
      }
      if (this._context.constants.has(e4)) {
        const t3 = this._context.constants.get(e4);
        return this._updateNode(new _e(e4, t3.value));
      }
      return this._updateNode(new ge(e4));
    }
    if (this._match(He.tokens.int_literal)) {
      const e4 = this._previous().toString();
      let t3 = e4.endsWith("i") || e4.endsWith("i") ? ae.i32 : e4.endsWith("u") || e4.endsWith("U") ? ae.u32 : ae.x32;
      const n2 = parseInt(e4);
      return this._validateTypeRange(n2, t3), this._updateNode(new xe(new Be(n2, this._exec.getTypeInfo(t3)), t3));
    }
    if (this._match(He.tokens.uint_literal)) {
      const e4 = parseInt(this._previous().toString());
      return this._validateTypeRange(e4, ae.u32), this._updateNode(new xe(new Be(e4, this._exec.getTypeInfo(ae.u32)), ae.u32));
    }
    if (this._match([He.tokens.decimal_float_literal, He.tokens.hex_float_literal])) {
      let e4 = this._previous().toString(), t3 = e4.endsWith("h");
      t3 && (e4 = e4.substring(0, e4.length - 1));
      const n2 = parseFloat(e4);
      this._validateTypeRange(n2, t3 ? ae.f16 : ae.f32);
      const s2 = t3 ? ae.f16 : ae.f32;
      return this._updateNode(new xe(new Be(n2, this._exec.getTypeInfo(s2)), s2));
    }
    if (this._match([He.keywords.true, He.keywords.false])) {
      let e4 = this._previous().toString() === He.keywords.true.rule;
      return this._updateNode(new xe(new Be(e4 ? 1 : 0, this._exec.getTypeInfo(ae.bool)), ae.bool));
    }
    if (this._check(He.tokens.paren_left)) return this._paren_expression();
    if (this._match(He.keywords.bitcast)) {
      this._consume(He.tokens.less_than, "Expected '<'.");
      const e4 = this._type_decl();
      this._consume(He.tokens.greater_than, "Expected '>'.");
      const t3 = this._paren_expression();
      return this._updateNode(new ye(e4, t3));
    }
    const e3 = this._type_decl(), t2 = this._argument_expression_list();
    return this._updateNode(new de(e3, t2));
  }
  _argument_expression_list() {
    if (!this._match(He.tokens.paren_left)) return null;
    const e3 = [];
    do {
      if (this._check(He.tokens.paren_right)) break;
      const t2 = this._short_circuit_or_expression();
      e3.push(t2);
    } while (this._match(He.tokens.comma));
    return this._consume(He.tokens.paren_right, "Expected ')' for agument list"), e3;
  }
  _optional_paren_expression() {
    this._match(He.tokens.paren_left);
    const e3 = this._short_circuit_or_expression();
    return this._match(He.tokens.paren_right), e3;
  }
  _paren_expression() {
    this._consume(He.tokens.paren_left, "Expected '('.");
    const e3 = this._short_circuit_or_expression();
    return this._consume(He.tokens.paren_right, "Expected ')'."), e3;
  }
  _struct_decl() {
    if (!this._match(He.keywords.struct)) return null;
    const e3 = this._currentLine, t2 = this._consume(He.tokens.ident, "Expected name for struct.").toString();
    this._consume(He.tokens.brace_left, "Expected '{' for struct body.");
    const n2 = [];
    for (; !this._check(He.tokens.brace_right); ) {
      const e4 = this._attribute(), t3 = this._consume(He.tokens.name, "Expected variable name.").toString();
      this._consume(He.tokens.colon, "Expected ':' for struct member type.");
      const s3 = this._attribute(), r3 = this._type_decl();
      null != r3 && (r3.attributes = s3), this._check(He.tokens.brace_right) ? this._match(He.tokens.comma) : this._consume(He.tokens.comma, "Expected ',' for struct member."), n2.push(this._updateNode(new Ce(t3, r3, e4)));
    }
    this._consume(He.tokens.brace_right, "Expected '}' after struct body.");
    const s2 = this._currentLine, r2 = this._updateNode(new oe(t2, n2, e3, s2), e3);
    return this._context.structs.set(t2, r2), r2;
  }
  _global_variable_decl() {
    const e3 = this._variable_decl();
    if (!e3) return null;
    if (this._match(He.tokens.equal)) {
      const t2 = this._const_expression();
      e3.value = t2;
    }
    if (null !== e3.type && e3.value instanceof xe) {
      if ("x32" !== e3.value.type.name) {
        if (e3.type.getTypeName() !== e3.value.type.getTypeName()) throw this._error(this._peek(), `Invalid cast from ${e3.value.type.name} to ${e3.type.name}. Line:${this._currentLine}`);
      }
      e3.value.isScalar && this._validateTypeRange(e3.value.scalarValue, e3.type), e3.value.type = e3.type;
    } else null === e3.type && e3.value instanceof xe && (e3.type = "x32" === e3.value.type.name ? ae.i32 : e3.value.type, e3.value.isScalar && this._validateTypeRange(e3.value.scalarValue, e3.type));
    return e3;
  }
  _override_variable_decl() {
    const e3 = this._override_decl();
    return e3 && this._match(He.tokens.equal) && (e3.value = this._const_expression()), e3;
  }
  _global_const_decl() {
    var e3;
    if (!this._match(He.keywords.const)) return null;
    const t2 = this._consume(He.tokens.name, "Expected variable name"), n2 = this._currentLine;
    let s2 = null;
    if (this._match(He.tokens.colon)) {
      const e4 = this._attribute();
      s2 = this._type_decl(), null != s2 && (s2.attributes = e4);
    }
    let r2 = null;
    this._consume(He.tokens.equal, "const declarations require an assignment");
    const i2 = this._short_circuit_or_expression();
    try {
      let e4 = [ae.f32], n3 = i2.constEvaluate(this._exec, e4);
      n3 instanceof Be && this._validateTypeRange(n3.value, e4[0]), e4[0] instanceof ce && null === e4[0].format && n3.typeInfo instanceof a && null !== n3.typeInfo.format && ("f16" === n3.typeInfo.format.name ? e4[0].format = ae.f16 : "f32" === n3.typeInfo.format.name ? e4[0].format = ae.f32 : "i32" === n3.typeInfo.format.name ? e4[0].format = ae.i32 : "u32" === n3.typeInfo.format.name ? e4[0].format = ae.u32 : "bool" === n3.typeInfo.format.name ? e4[0].format = ae.bool : console.error(`TODO: impelement template format type ${n3.typeInfo.format.name}`)), r2 = this._updateNode(new xe(n3, e4[0])), this._exec.context.setVariable(t2.toString(), n3);
    } catch (e4) {
      r2 = i2;
    }
    if (null !== s2 && r2 instanceof xe) {
      if ("x32" !== r2.type.name) {
        if (s2.getTypeName() !== r2.type.getTypeName()) throw this._error(this._peek(), `Invalid cast from ${r2.type.name} to ${s2.name}. Line:${this._currentLine}`);
      }
      r2.type = s2, r2.isScalar && this._validateTypeRange(r2.scalarValue, r2.type);
    } else null === s2 && r2 instanceof xe && (s2 = null !== (e3 = null == r2 ? void 0 : r2.type) && void 0 !== e3 ? e3 : ae.f32, s2 === ae.x32 && (s2 = ae.i32));
    const o2 = this._updateNode(new P(t2.toString(), s2, "", "", r2), n2);
    return this._context.constants.set(o2.name, o2), o2;
  }
  _global_let_decl() {
    if (!this._match(He.keywords.let)) return null;
    const e3 = this._currentLine, t2 = this._consume(He.tokens.name, "Expected variable name");
    let n2 = null;
    if (this._match(He.tokens.colon)) {
      const e4 = this._attribute();
      n2 = this._type_decl(), null != n2 && (n2.attributes = e4);
    }
    let s2 = null;
    if (this._match(He.tokens.equal) && (s2 = this._const_expression()), null !== n2 && s2 instanceof xe) {
      if ("x32" !== s2.type.name) {
        if (n2.getTypeName() !== s2.type.getTypeName()) throw this._error(this._peek(), `Invalid cast from ${s2.type.name} to ${n2.name}. Line:${this._currentLine}`);
      }
      s2.type = n2;
    } else null === n2 && s2 instanceof xe && (n2 = "x32" === s2.type.name ? ae.i32 : s2.type);
    return s2 instanceof xe && s2.isScalar && this._validateTypeRange(s2.scalarValue, n2), this._updateNode(new U(t2.toString(), n2, "", "", s2), e3);
  }
  _const_expression() {
    return this._short_circuit_or_expression();
  }
  _variable_decl() {
    if (!this._match(He.keywords.var)) return null;
    const e3 = this._currentLine;
    let t2 = "", n2 = "";
    this._match(He.tokens.less_than) && (t2 = this._consume(He.storage_class, "Expected storage_class.").toString(), this._match(He.tokens.comma) && (n2 = this._consume(He.access_mode, "Expected access_mode.").toString()), this._consume(He.tokens.greater_than, "Expected '>'."));
    const s2 = this._consume(He.tokens.name, "Expected variable name");
    let r2 = null;
    if (this._match(He.tokens.colon)) {
      const e4 = this._attribute();
      r2 = this._type_decl(), null != r2 && (r2.attributes = e4);
    }
    return this._updateNode(new F(s2.toString(), r2, t2, n2, null), e3);
  }
  _override_decl() {
    if (!this._match(He.keywords.override)) return null;
    const e3 = this._consume(He.tokens.name, "Expected variable name");
    let t2 = null;
    if (this._match(He.tokens.colon)) {
      const e4 = this._attribute();
      t2 = this._type_decl(), null != t2 && (t2.attributes = e4);
    }
    return this._updateNode(new M(e3.toString(), t2, null));
  }
  _diagnostic() {
    this._consume(He.tokens.paren_left, "Expected '('");
    const e3 = this._consume(He.tokens.ident, "Expected severity control name.");
    this._consume(He.tokens.comma, "Expected ','");
    let t2 = this._consume(He.tokens.ident, "Expected diagnostic rule name.").toString();
    if (this._match(He.tokens.period)) {
      t2 += `.${this._consume(He.tokens.ident, "Expected diagnostic message.").toString()}`;
    }
    return this._consume(He.tokens.paren_right, "Expected ')'"), this._updateNode(new ee(e3.toString(), t2));
  }
  _enable_directive() {
    const e3 = this._consume(He.tokens.ident, "identity expected.");
    return this._updateNode(new K(e3.toString()));
  }
  _requires_directive() {
    const e3 = [this._consume(He.tokens.ident, "identity expected.").toString()];
    for (; this._match(He.tokens.comma); ) {
      const t2 = this._consume(He.tokens.ident, "identity expected.");
      e3.push(t2.toString());
    }
    return this._updateNode(new J(e3));
  }
  _type_alias() {
    const e3 = this._consume(He.tokens.ident, "identity expected.");
    this._consume(He.tokens.equal, "Expected '=' for type alias.");
    let t2 = this._type_decl();
    if (null === t2) throw this._error(this._peek(), "Expected Type for Alias.");
    this._context.aliases.has(t2.name) && (t2 = this._context.aliases.get(t2.name).type);
    const n2 = this._updateNode(new te(e3.toString(), t2));
    return this._context.aliases.set(n2.name, n2), n2;
  }
  _type_decl() {
    if (this._check([He.tokens.ident, ...He.texel_format, He.keywords.bool, He.keywords.f32, He.keywords.i32, He.keywords.u32])) {
      const e4 = this._advance().toString();
      if (this._context.structs.has(e4)) return this._context.structs.get(e4);
      if (this._context.aliases.has(e4)) return this._context.aliases.get(e4).type;
      if (!this._getType(e4)) {
        const t3 = this._updateNode(new ie(e4));
        return this._forwardTypeCount++, t3;
      }
      return this._updateNode(new ae(e4));
    }
    let e3 = this._texture_sampler_types();
    if (e3) return e3;
    if (this._check(He.template_types)) {
      let e4 = this._advance().toString(), t3 = null, n2 = null;
      this._match(He.tokens.less_than) && (t3 = this._type_decl(), n2 = null, this._match(He.tokens.comma) && (n2 = this._consume(He.access_mode, "Expected access_mode for pointer").toString()), this._consume(He.tokens.greater_than, "Expected '>' for type."));
      return this._updateNode(new ce(e4, t3, n2));
    }
    if (this._match(He.keywords.ptr)) {
      let e4 = this._previous().toString();
      this._consume(He.tokens.less_than, "Expected '<' for pointer.");
      const t3 = this._consume(He.storage_class, "Expected storage_class for pointer");
      this._consume(He.tokens.comma, "Expected ',' for pointer.");
      const n2 = this._type_decl();
      let s2 = null;
      this._match(He.tokens.comma) && (s2 = this._consume(He.access_mode, "Expected access_mode for pointer").toString()), this._consume(He.tokens.greater_than, "Expected '>' for pointer.");
      return this._updateNode(new le(e4, t3.toString(), n2, s2));
    }
    const t2 = this._attribute();
    if (this._match(He.keywords.array)) {
      let e4 = null, n2 = -1;
      const s2 = this._previous();
      let r2 = null;
      if (this._match(He.tokens.less_than)) {
        e4 = this._type_decl(), this._context.aliases.has(e4.name) && (e4 = this._context.aliases.get(e4.name).type);
        let t3 = "";
        if (this._match(He.tokens.comma)) {
          r2 = this._shift_expression();
          try {
            t3 = r2.constEvaluate(this._exec).toString(), r2 = null;
          } catch (e5) {
            t3 = "1";
          }
        }
        this._consume(He.tokens.greater_than, "Expected '>' for array."), n2 = t3 ? parseInt(t3) : 0;
      }
      const a2 = this._updateNode(new ue(s2.toString(), t2, e4, n2));
      return r2 && this._deferArrayCountEval.push({ arrayType: a2, countNode: r2 }), a2;
    }
    return null;
  }
  _texture_sampler_types() {
    if (this._match(He.sampler_type)) return this._updateNode(new he(this._previous().toString(), null, null));
    if (this._match(He.depth_texture_type)) return this._updateNode(new he(this._previous().toString(), null, null));
    if (this._match(He.sampled_texture_type) || this._match(He.multisampled_texture_type)) {
      const e3 = this._previous();
      this._consume(He.tokens.less_than, "Expected '<' for sampler type.");
      const t2 = this._type_decl();
      return this._consume(He.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new he(e3.toString(), t2, null));
    }
    if (this._match(He.storage_texture_type)) {
      const e3 = this._previous();
      this._consume(He.tokens.less_than, "Expected '<' for sampler type.");
      const t2 = this._consume(He.texel_format, "Invalid texel format.").toString();
      this._consume(He.tokens.comma, "Expected ',' after texel format.");
      const n2 = this._consume(He.access_mode, "Expected access mode for storage texture type.").toString();
      return this._consume(He.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new he(e3.toString(), t2, n2));
    }
    return null;
  }
  _attribute() {
    let e3 = [];
    for (; this._match(He.tokens.attr); ) {
      const t2 = this._consume(He.attribute_name, "Expected attribute name"), n2 = this._updateNode(new De(t2.toString(), null));
      if (this._match(He.tokens.paren_left)) {
        if (n2.value = this._consume(He.literal_or_ident, "Expected attribute value").toString(), this._check(He.tokens.comma)) {
          this._advance();
          do {
            const e4 = this._consume(He.literal_or_ident, "Expected attribute value").toString();
            n2.value instanceof Array || (n2.value = [n2.value]), n2.value.push(e4);
          } while (this._match(He.tokens.comma));
        }
        this._consume(He.tokens.paren_right, "Expected ')'");
      }
      e3.push(n2);
    }
    return 0 == e3.length ? null : e3;
  }
};
var _t = class extends at {
  constructor(e3) {
    super(), e3 && this.update(e3);
  }
  update(e3) {
    const t2 = new gt().parse(e3);
    this.updateAST(t2);
  }
};

// node_modules/@luma.gl/shadertools/dist/lib/wgsl/get-shader-layout-wgsl.js
function getShaderLayoutFromWGSL(source6) {
  var _a3;
  const shaderLayout = { attributes: [], bindings: [] };
  let parsedWGSL;
  try {
    parsedWGSL = parseWGSL(source6);
  } catch (error) {
    log.error(error.message)();
    return shaderLayout;
  }
  for (const uniform of parsedWGSL.uniforms) {
    const members = [];
    for (const attribute of ((_a3 = uniform.type) == null ? void 0 : _a3.members) || []) {
      members.push({
        name: attribute.name,
        type: getType(attribute.type)
      });
    }
    shaderLayout.bindings.push({
      type: "uniform",
      name: uniform.name,
      group: uniform.group,
      location: uniform.binding,
      // @ts-expect-error TODO - unused for now but needs fixing
      members
    });
  }
  for (const texture of parsedWGSL.textures) {
    shaderLayout.bindings.push({
      type: "texture",
      name: texture.name,
      group: texture.group,
      location: texture.binding
    });
  }
  for (const sampler of parsedWGSL.samplers) {
    shaderLayout.bindings.push({
      type: "sampler",
      name: sampler.name,
      group: sampler.group,
      location: sampler.binding
    });
  }
  const vertex2 = parsedWGSL.entry.vertex[0];
  const attributeCount = (vertex2 == null ? void 0 : vertex2.inputs.length) || 0;
  for (let i2 = 0; i2 < attributeCount; i2++) {
    const wgslAttribute = vertex2.inputs[i2];
    if (wgslAttribute.locationType === "location") {
      const type = getType(wgslAttribute.type);
      shaderLayout.attributes.push({
        name: wgslAttribute.name,
        location: Number(wgslAttribute.location),
        type
      });
    }
  }
  return shaderLayout;
}
function getType(type) {
  return (type == null ? void 0 : type.format) ? `${type.name}<${type.format.name}>` : type.name;
}
function parseWGSL(source6) {
  try {
    return new _t(source6);
  } catch (error) {
    if (error instanceof Error) {
      throw error;
    }
    let message = "WGSL parse error";
    if (typeof error === "object" && (error == null ? void 0 : error.message)) {
      message += `: ${error.message} `;
    }
    if (typeof error === "object" && (error == null ? void 0 : error.token)) {
      message += error.token.line || "";
    }
    throw new Error(message, { cause: error });
  }
}

// node_modules/@math.gl/core/dist/lib/common.js
var RADIANS_TO_DEGREES = 1 / Math.PI * 180;
var DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
var DEFAULT_CONFIG = {
  EPSILON: 1e-12,
  debug: false,
  precision: 4,
  printTypes: false,
  printDegrees: false,
  printRowMajor: true,
  _cartographicRadians: false
};
globalThis.mathgl = globalThis.mathgl || { config: { ...DEFAULT_CONFIG } };
var config = globalThis.mathgl.config;
function formatValue(value, { precision = config.precision } = {}) {
  value = round(value);
  return `${parseFloat(value.toPrecision(precision))}`;
}
function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function radians(degrees2, result) {
  return map(degrees2, (degrees3) => degrees3 * DEGREES_TO_RADIANS, result);
}
function degrees(radians2, result) {
  return map(radians2, (radians3) => radians3 * RADIANS_TO_DEGREES, result);
}
function clamp(value, min4, max4) {
  return map(value, (value2) => Math.max(min4, Math.min(max4, value2)));
}
function lerp(a2, b2, t2) {
  if (isArray(a2)) {
    return a2.map((ai, i2) => lerp(ai, b2[i2], t2));
  }
  return t2 * b2 + (1 - t2) * a2;
}
function equals(a2, b2, epsilon) {
  const oldEpsilon = config.EPSILON;
  if (epsilon) {
    config.EPSILON = epsilon;
  }
  try {
    if (a2 === b2) {
      return true;
    }
    if (isArray(a2) && isArray(b2)) {
      if (a2.length !== b2.length) {
        return false;
      }
      for (let i2 = 0; i2 < a2.length; ++i2) {
        if (!equals(a2[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    if (a2 && a2.equals) {
      return a2.equals(b2);
    }
    if (b2 && b2.equals) {
      return b2.equals(a2);
    }
    if (typeof a2 === "number" && typeof b2 === "number") {
      return Math.abs(a2 - b2) <= config.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
    }
    return false;
  } finally {
    config.EPSILON = oldEpsilon;
  }
}
function round(value) {
  return Math.round(value / config.EPSILON) * config.EPSILON;
}
function duplicateArray(array) {
  return array.clone ? array.clone() : new Array(array.length);
}
function map(value, func, result) {
  if (isArray(value)) {
    const array = value;
    result = result || duplicateArray(array);
    for (let i2 = 0; i2 < result.length && i2 < array.length; ++i2) {
      const val = typeof value === "number" ? value : value[i2];
      result[i2] = func(val, i2, result);
    }
    return result;
  }
  return func(value);
}

// node_modules/@math.gl/core/dist/classes/base/math-array.js
var MathArray = class extends Array {
  // Common methods
  /**
   * Clone the current object
   * @returns a new copy of this object
   */
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array, offset = 0) {
    for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
      this[i2] = array[i2 + offset];
    }
    return this.check();
  }
  toArray(targetArray = [], offset = 0) {
    for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
      targetArray[offset + i2] = this[i2];
    }
    return targetArray;
  }
  toObject(targetObject) {
    return targetObject;
  }
  from(arrayOrObject) {
    return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : (
      // @ts-ignore
      this.fromObject(arrayOrObject)
    );
  }
  to(arrayOrObject) {
    if (arrayOrObject === this) {
      return this;
    }
    return isArray(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
  }
  toTarget(target) {
    return target ? this.to(target) : this;
  }
  /** @deprecated */
  toFloat32Array() {
    return new Float32Array(this);
  }
  toString() {
    return this.formatString(config);
  }
  /** Formats string according to options */
  formatString(opts) {
    let string = "";
    for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
      string += (i2 > 0 ? ", " : "") + formatValue(this[i2], opts);
    }
    return `${opts.printTypes ? this.constructor.name : ""}[${string}]`;
  }
  equals(array) {
    if (!array || this.length !== array.length) {
      return false;
    }
    for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
      if (!equals(this[i2], array[i2])) {
        return false;
      }
    }
    return true;
  }
  exactEquals(array) {
    if (!array || this.length !== array.length) {
      return false;
    }
    for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
      if (this[i2] !== array[i2]) {
        return false;
      }
    }
    return true;
  }
  // Modifiers
  /** Negates all values in this object */
  negate() {
    for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
      this[i2] = -this[i2];
    }
    return this.check();
  }
  lerp(a2, b2, t2) {
    if (t2 === void 0) {
      return this.lerp(this, a2, b2);
    }
    for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
      const ai = a2[i2];
      const endValue = typeof b2 === "number" ? b2 : b2[i2];
      this[i2] = ai + t2 * (endValue - ai);
    }
    return this.check();
  }
  /** Minimal */
  min(vector) {
    for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
      this[i2] = Math.min(vector[i2], this[i2]);
    }
    return this.check();
  }
  /** Maximal */
  max(vector) {
    for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
      this[i2] = Math.max(vector[i2], this[i2]);
    }
    return this.check();
  }
  clamp(minVector, maxVector) {
    for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
      this[i2] = Math.min(Math.max(this[i2], minVector[i2]), maxVector[i2]);
    }
    return this.check();
  }
  add(...vectors) {
    for (const vector of vectors) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] += vector[i2];
      }
    }
    return this.check();
  }
  subtract(...vectors) {
    for (const vector of vectors) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] -= vector[i2];
      }
    }
    return this.check();
  }
  scale(scale7) {
    if (typeof scale7 === "number") {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] *= scale7;
      }
    } else {
      for (let i2 = 0; i2 < this.ELEMENTS && i2 < scale7.length; ++i2) {
        this[i2] *= scale7[i2];
      }
    }
    return this.check();
  }
  /**
   * Multiplies all elements by `scale`
   * Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
   */
  multiplyByScalar(scalar) {
    for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
      this[i2] *= scalar;
    }
    return this.check();
  }
  // Debug checks
  /** Throws an error if array length is incorrect or contains illegal values */
  check() {
    if (config.debug && !this.validate()) {
      throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
    }
    return this;
  }
  /** Returns false if the array length is incorrect or contains illegal values */
  validate() {
    let valid = this.length === this.ELEMENTS;
    for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
      valid = valid && Number.isFinite(this[i2]);
    }
    return valid;
  }
  // three.js compatibility
  /** @deprecated */
  sub(a2) {
    return this.subtract(a2);
  }
  /** @deprecated */
  setScalar(a2) {
    for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
      this[i2] = a2;
    }
    return this.check();
  }
  /** @deprecated */
  addScalar(a2) {
    for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
      this[i2] += a2;
    }
    return this.check();
  }
  /** @deprecated */
  subScalar(a2) {
    return this.addScalar(-a2);
  }
  /** @deprecated */
  multiplyScalar(scalar) {
    for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
      this[i2] *= scalar;
    }
    return this.check();
  }
  /** @deprecated */
  divideScalar(a2) {
    return this.multiplyByScalar(1 / a2);
  }
  /** @deprecated */
  clampScalar(min4, max4) {
    for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
      this[i2] = Math.min(Math.max(this[i2], min4), max4);
    }
    return this.check();
  }
  /** @deprecated */
  get elements() {
    return this;
  }
};

// node_modules/@math.gl/core/dist/lib/validators.js
function validateVector(v2, length5) {
  if (v2.length !== length5) {
    return false;
  }
  for (let i2 = 0; i2 < v2.length; ++i2) {
    if (!Number.isFinite(v2[i2])) {
      return false;
    }
  }
  return true;
}
function checkNumber(value) {
  if (!Number.isFinite(value)) {
    throw new Error(`Invalid number ${JSON.stringify(value)}`);
  }
  return value;
}
function checkVector(v2, length5, callerName = "") {
  if (config.debug && !validateVector(v2, length5)) {
    throw new Error(`math.gl: ${callerName} some fields set to invalid numbers'`);
  }
  return v2;
}

// node_modules/@math.gl/core/dist/lib/assert.js
function assert2(condition, message) {
  if (!condition) {
    throw new Error(`math.gl assertion ${message}`);
  }
}

// node_modules/@math.gl/core/dist/classes/base/vector.js
var Vector = class extends MathArray {
  // ACCESSORS
  get x() {
    return this[0];
  }
  set x(value) {
    this[0] = checkNumber(value);
  }
  get y() {
    return this[1];
  }
  set y(value) {
    this[1] = checkNumber(value);
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   *
   * @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
   * Instead we provide `len` and `magnitude`
   */
  len() {
    return Math.sqrt(this.lengthSquared());
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   */
  magnitude() {
    return this.len();
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  lengthSquared() {
    let length5 = 0;
    for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
      length5 += this[i2] * this[i2];
    }
    return length5;
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  magnitudeSquared() {
    return this.lengthSquared();
  }
  distance(mathArray) {
    return Math.sqrt(this.distanceSquared(mathArray));
  }
  distanceSquared(mathArray) {
    let length5 = 0;
    for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
      const dist4 = this[i2] - mathArray[i2];
      length5 += dist4 * dist4;
    }
    return checkNumber(length5);
  }
  dot(mathArray) {
    let product = 0;
    for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
      product += this[i2] * mathArray[i2];
    }
    return checkNumber(product);
  }
  // MODIFIERS
  normalize() {
    const length5 = this.magnitude();
    if (length5 !== 0) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] /= length5;
      }
    }
    return this.check();
  }
  multiply(...vectors) {
    for (const vector of vectors) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] *= vector[i2];
      }
    }
    return this.check();
  }
  divide(...vectors) {
    for (const vector of vectors) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] /= vector[i2];
      }
    }
    return this.check();
  }
  // THREE.js compatibility
  lengthSq() {
    return this.lengthSquared();
  }
  distanceTo(vector) {
    return this.distance(vector);
  }
  distanceToSquared(vector) {
    return this.distanceSquared(vector);
  }
  getComponent(i2) {
    assert2(i2 >= 0 && i2 < this.ELEMENTS, "index is out of range");
    return checkNumber(this[i2]);
  }
  setComponent(i2, value) {
    assert2(i2 >= 0 && i2 < this.ELEMENTS, "index is out of range");
    this[i2] = value;
    return this.check();
  }
  addVectors(a2, b2) {
    return this.copy(a2).add(b2);
  }
  subVectors(a2, b2) {
    return this.copy(a2).subtract(b2);
  }
  multiplyVectors(a2, b2) {
    return this.copy(a2).multiply(b2);
  }
  addScaledVector(a2, b2) {
    return this.add(new this.constructor(a2).multiplyScalar(b2));
  }
};

// node_modules/@math.gl/core/dist/gl-matrix/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add,
  angle: () => angle,
  ceil: () => ceil,
  clone: () => clone,
  copy: () => copy,
  create: () => create,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals2,
  exactEquals: () => exactEquals,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp2,
  max: () => max,
  min: () => min,
  mul: () => mul,
  multiply: () => multiply,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotate: () => rotate,
  round: () => round3,
  scale: () => scale,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  zero: () => zero
});

// node_modules/@math.gl/core/dist/gl-matrix/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
function round2(a2) {
  if (a2 >= 0)
    return Math.round(a2);
  return a2 % 0.5 === 0 ? Math.floor(a2) : Math.round(a2);
}
var degree = Math.PI / 180;

// node_modules/@math.gl/core/dist/gl-matrix/vec2.js
function create() {
  const out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone(a2) {
  const out = new ARRAY_TYPE(2);
  out[0] = a2[0];
  out[1] = a2[1];
  return out;
}
function fromValues(x2, y2) {
  const out = new ARRAY_TYPE(2);
  out[0] = x2;
  out[1] = y2;
  return out;
}
function copy(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  return out;
}
function set(out, x2, y2) {
  out[0] = x2;
  out[1] = y2;
  return out;
}
function add(out, a2, b2) {
  out[0] = a2[0] + b2[0];
  out[1] = a2[1] + b2[1];
  return out;
}
function subtract(out, a2, b2) {
  out[0] = a2[0] - b2[0];
  out[1] = a2[1] - b2[1];
  return out;
}
function multiply(out, a2, b2) {
  out[0] = a2[0] * b2[0];
  out[1] = a2[1] * b2[1];
  return out;
}
function divide(out, a2, b2) {
  out[0] = a2[0] / b2[0];
  out[1] = a2[1] / b2[1];
  return out;
}
function ceil(out, a2) {
  out[0] = Math.ceil(a2[0]);
  out[1] = Math.ceil(a2[1]);
  return out;
}
function floor(out, a2) {
  out[0] = Math.floor(a2[0]);
  out[1] = Math.floor(a2[1]);
  return out;
}
function min(out, a2, b2) {
  out[0] = Math.min(a2[0], b2[0]);
  out[1] = Math.min(a2[1], b2[1]);
  return out;
}
function max(out, a2, b2) {
  out[0] = Math.max(a2[0], b2[0]);
  out[1] = Math.max(a2[1], b2[1]);
  return out;
}
function round3(out, a2) {
  out[0] = round2(a2[0]);
  out[1] = round2(a2[1]);
  return out;
}
function scale(out, a2, b2) {
  out[0] = a2[0] * b2;
  out[1] = a2[1] * b2;
  return out;
}
function scaleAndAdd(out, a2, b2, scale7) {
  out[0] = a2[0] + b2[0] * scale7;
  out[1] = a2[1] + b2[1] * scale7;
  return out;
}
function distance(a2, b2) {
  const x2 = b2[0] - a2[0];
  const y2 = b2[1] - a2[1];
  return Math.sqrt(x2 * x2 + y2 * y2);
}
function squaredDistance(a2, b2) {
  const x2 = b2[0] - a2[0];
  const y2 = b2[1] - a2[1];
  return x2 * x2 + y2 * y2;
}
function length(a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  return Math.sqrt(x2 * x2 + y2 * y2);
}
function squaredLength(a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  return x2 * x2 + y2 * y2;
}
function negate(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  return out;
}
function inverse(out, a2) {
  out[0] = 1 / a2[0];
  out[1] = 1 / a2[1];
  return out;
}
function normalize(out, a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  let len5 = x2 * x2 + y2 * y2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = a2[0] * len5;
  out[1] = a2[1] * len5;
  return out;
}
function dot(a2, b2) {
  return a2[0] * b2[0] + a2[1] * b2[1];
}
function cross(out, a2, b2) {
  const z2 = a2[0] * b2[1] - a2[1] * b2[0];
  out[0] = out[1] = 0;
  out[2] = z2;
  return out;
}
function lerp2(out, a2, b2, t2) {
  const ax = a2[0];
  const ay = a2[1];
  out[0] = ax + t2 * (b2[0] - ax);
  out[1] = ay + t2 * (b2[1] - ay);
  return out;
}
function random(out, scale7) {
  scale7 = scale7 === void 0 ? 1 : scale7;
  const r2 = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r2) * scale7;
  out[1] = Math.sin(r2) * scale7;
  return out;
}
function transformMat2(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  out[0] = m2[0] * x2 + m2[2] * y2;
  out[1] = m2[1] * x2 + m2[3] * y2;
  return out;
}
function transformMat2d(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  out[0] = m2[0] * x2 + m2[2] * y2 + m2[4];
  out[1] = m2[1] * x2 + m2[3] * y2 + m2[5];
  return out;
}
function transformMat3(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  out[0] = m2[0] * x2 + m2[3] * y2 + m2[6];
  out[1] = m2[1] * x2 + m2[4] * y2 + m2[7];
  return out;
}
function transformMat4(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  out[0] = m2[0] * x2 + m2[4] * y2 + m2[12];
  out[1] = m2[1] * x2 + m2[5] * y2 + m2[13];
  return out;
}
function rotate(out, a2, b2, rad) {
  const p0 = a2[0] - b2[0];
  const p1 = a2[1] - b2[1];
  const sinC = Math.sin(rad);
  const cosC = Math.cos(rad);
  out[0] = p0 * cosC - p1 * sinC + b2[0];
  out[1] = p0 * sinC + p1 * cosC + b2[1];
  return out;
}
function angle(a2, b2) {
  const x1 = a2[0];
  const y1 = a2[1];
  const x2 = b2[0];
  const y2 = b2[1];
  const mag = Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2));
  const cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str(a2) {
  return `vec2(${a2[0]}, ${a2[1]})`;
}
function exactEquals(a2, b2) {
  return a2[0] === b2[0] && a2[1] === b2[1];
}
function equals2(a2, b2) {
  const a0 = a2[0];
  const a1 = a2[1];
  const b0 = b2[0];
  const b1 = b2[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len = length;
var sub = subtract;
var mul = multiply;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var sqrLen = squaredLength;
var forEach = function() {
  const vec = create();
  return function(a2, stride, offset, count2, fn, arg) {
    let i2;
    let l2;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count2) {
      l2 = Math.min(count2 * stride + offset, a2.length);
    } else {
      l2 = a2.length;
    }
    for (i2 = offset; i2 < l2; i2 += stride) {
      vec[0] = a2[i2];
      vec[1] = a2[i2 + 1];
      fn(vec, vec, arg);
      a2[i2] = vec[0];
      a2[i2 + 1] = vec[1];
    }
    return a2;
  };
}();

// node_modules/@math.gl/core/dist/lib/gl-matrix-extras.js
function vec2_transformMat4AsVector(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const w2 = m2[3] * x2 + m2[7] * y2 || 1;
  out[0] = (m2[0] * x2 + m2[4] * y2) / w2;
  out[1] = (m2[1] * x2 + m2[5] * y2) / w2;
  return out;
}
function vec3_transformMat4AsVector(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  const w2 = m2[3] * x2 + m2[7] * y2 + m2[11] * z2 || 1;
  out[0] = (m2[0] * x2 + m2[4] * y2 + m2[8] * z2) / w2;
  out[1] = (m2[1] * x2 + m2[5] * y2 + m2[9] * z2) / w2;
  out[2] = (m2[2] * x2 + m2[6] * y2 + m2[10] * z2) / w2;
  return out;
}
function vec3_transformMat2(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  out[0] = m2[0] * x2 + m2[2] * y2;
  out[1] = m2[1] * x2 + m2[3] * y2;
  out[2] = a2[2];
  return out;
}

// node_modules/@math.gl/core/dist/gl-matrix/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add2,
  angle: () => angle2,
  bezier: () => bezier,
  ceil: () => ceil2,
  clone: () => clone2,
  copy: () => copy2,
  create: () => create2,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot2,
  equals: () => equals3,
  exactEquals: () => exactEquals2,
  floor: () => floor2,
  forEach: () => forEach2,
  fromValues: () => fromValues2,
  hermite: () => hermite,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length2,
  lerp: () => lerp3,
  max: () => max2,
  min: () => min2,
  mul: () => mul2,
  multiply: () => multiply2,
  negate: () => negate2,
  normalize: () => normalize2,
  random: () => random2,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  round: () => round4,
  scale: () => scale2,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set2,
  slerp: () => slerp,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength2,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat42,
  transformQuat: () => transformQuat,
  zero: () => zero2
});
function create2() {
  const out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone2(a2) {
  const out = new ARRAY_TYPE(3);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  return out;
}
function length2(a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  return Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
}
function fromValues2(x2, y2, z2) {
  const out = new ARRAY_TYPE(3);
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  return out;
}
function copy2(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  return out;
}
function set2(out, x2, y2, z2) {
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  return out;
}
function add2(out, a2, b2) {
  out[0] = a2[0] + b2[0];
  out[1] = a2[1] + b2[1];
  out[2] = a2[2] + b2[2];
  return out;
}
function subtract2(out, a2, b2) {
  out[0] = a2[0] - b2[0];
  out[1] = a2[1] - b2[1];
  out[2] = a2[2] - b2[2];
  return out;
}
function multiply2(out, a2, b2) {
  out[0] = a2[0] * b2[0];
  out[1] = a2[1] * b2[1];
  out[2] = a2[2] * b2[2];
  return out;
}
function divide2(out, a2, b2) {
  out[0] = a2[0] / b2[0];
  out[1] = a2[1] / b2[1];
  out[2] = a2[2] / b2[2];
  return out;
}
function ceil2(out, a2) {
  out[0] = Math.ceil(a2[0]);
  out[1] = Math.ceil(a2[1]);
  out[2] = Math.ceil(a2[2]);
  return out;
}
function floor2(out, a2) {
  out[0] = Math.floor(a2[0]);
  out[1] = Math.floor(a2[1]);
  out[2] = Math.floor(a2[2]);
  return out;
}
function min2(out, a2, b2) {
  out[0] = Math.min(a2[0], b2[0]);
  out[1] = Math.min(a2[1], b2[1]);
  out[2] = Math.min(a2[2], b2[2]);
  return out;
}
function max2(out, a2, b2) {
  out[0] = Math.max(a2[0], b2[0]);
  out[1] = Math.max(a2[1], b2[1]);
  out[2] = Math.max(a2[2], b2[2]);
  return out;
}
function round4(out, a2) {
  out[0] = round2(a2[0]);
  out[1] = round2(a2[1]);
  out[2] = round2(a2[2]);
  return out;
}
function scale2(out, a2, b2) {
  out[0] = a2[0] * b2;
  out[1] = a2[1] * b2;
  out[2] = a2[2] * b2;
  return out;
}
function scaleAndAdd2(out, a2, b2, scale7) {
  out[0] = a2[0] + b2[0] * scale7;
  out[1] = a2[1] + b2[1] * scale7;
  out[2] = a2[2] + b2[2] * scale7;
  return out;
}
function distance2(a2, b2) {
  const x2 = b2[0] - a2[0];
  const y2 = b2[1] - a2[1];
  const z2 = b2[2] - a2[2];
  return Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
}
function squaredDistance2(a2, b2) {
  const x2 = b2[0] - a2[0];
  const y2 = b2[1] - a2[1];
  const z2 = b2[2] - a2[2];
  return x2 * x2 + y2 * y2 + z2 * z2;
}
function squaredLength2(a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  return x2 * x2 + y2 * y2 + z2 * z2;
}
function negate2(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  return out;
}
function inverse2(out, a2) {
  out[0] = 1 / a2[0];
  out[1] = 1 / a2[1];
  out[2] = 1 / a2[2];
  return out;
}
function normalize2(out, a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  let len5 = x2 * x2 + y2 * y2 + z2 * z2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = a2[0] * len5;
  out[1] = a2[1] * len5;
  out[2] = a2[2] * len5;
  return out;
}
function dot2(a2, b2) {
  return a2[0] * b2[0] + a2[1] * b2[1] + a2[2] * b2[2];
}
function cross2(out, a2, b2) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const bx = b2[0];
  const by = b2[1];
  const bz = b2[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp3(out, a2, b2, t2) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  out[0] = ax + t2 * (b2[0] - ax);
  out[1] = ay + t2 * (b2[1] - ay);
  out[2] = az + t2 * (b2[2] - az);
  return out;
}
function slerp(out, a2, b2, t2) {
  const angle3 = Math.acos(Math.min(Math.max(dot2(a2, b2), -1), 1));
  const sinTotal = Math.sin(angle3);
  const ratioA = Math.sin((1 - t2) * angle3) / sinTotal;
  const ratioB = Math.sin(t2 * angle3) / sinTotal;
  out[0] = ratioA * a2[0] + ratioB * b2[0];
  out[1] = ratioA * a2[1] + ratioB * b2[1];
  out[2] = ratioA * a2[2] + ratioB * b2[2];
  return out;
}
function hermite(out, a2, b2, c2, d2, t2) {
  const factorTimes2 = t2 * t2;
  const factor1 = factorTimes2 * (2 * t2 - 3) + 1;
  const factor2 = factorTimes2 * (t2 - 2) + t2;
  const factor3 = factorTimes2 * (t2 - 1);
  const factor4 = factorTimes2 * (3 - 2 * t2);
  out[0] = a2[0] * factor1 + b2[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
  out[1] = a2[1] * factor1 + b2[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
  out[2] = a2[2] * factor1 + b2[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
  return out;
}
function bezier(out, a2, b2, c2, d2, t2) {
  const inverseFactor = 1 - t2;
  const inverseFactorTimesTwo = inverseFactor * inverseFactor;
  const factorTimes2 = t2 * t2;
  const factor1 = inverseFactorTimesTwo * inverseFactor;
  const factor2 = 3 * t2 * inverseFactorTimesTwo;
  const factor3 = 3 * factorTimes2 * inverseFactor;
  const factor4 = factorTimes2 * t2;
  out[0] = a2[0] * factor1 + b2[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
  out[1] = a2[1] * factor1 + b2[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
  out[2] = a2[2] * factor1 + b2[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
  return out;
}
function random2(out, scale7) {
  scale7 = scale7 === void 0 ? 1 : scale7;
  const r2 = RANDOM() * 2 * Math.PI;
  const z2 = RANDOM() * 2 - 1;
  const zScale = Math.sqrt(1 - z2 * z2) * scale7;
  out[0] = Math.cos(r2) * zScale;
  out[1] = Math.sin(r2) * zScale;
  out[2] = z2 * scale7;
  return out;
}
function transformMat42(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  let w2 = m2[3] * x2 + m2[7] * y2 + m2[11] * z2 + m2[15];
  w2 = w2 || 1;
  out[0] = (m2[0] * x2 + m2[4] * y2 + m2[8] * z2 + m2[12]) / w2;
  out[1] = (m2[1] * x2 + m2[5] * y2 + m2[9] * z2 + m2[13]) / w2;
  out[2] = (m2[2] * x2 + m2[6] * y2 + m2[10] * z2 + m2[14]) / w2;
  return out;
}
function transformMat32(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  out[0] = x2 * m2[0] + y2 * m2[3] + z2 * m2[6];
  out[1] = x2 * m2[1] + y2 * m2[4] + z2 * m2[7];
  out[2] = x2 * m2[2] + y2 * m2[5] + z2 * m2[8];
  return out;
}
function transformQuat(out, a2, q2) {
  const qx = q2[0];
  const qy = q2[1];
  const qz = q2[2];
  const qw = q2[3];
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  let uvx = qy * z2 - qz * y2;
  let uvy = qz * x2 - qx * z2;
  let uvz = qx * y2 - qy * x2;
  let uuvx = qy * uvz - qz * uvy;
  let uuvy = qz * uvx - qx * uvz;
  let uuvz = qx * uvy - qy * uvx;
  const w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x2 + uvx + uuvx;
  out[1] = y2 + uvy + uuvy;
  out[2] = z2 + uvz + uuvz;
  return out;
}
function rotateX(out, a2, b2, rad) {
  const p2 = [];
  const r2 = [];
  p2[0] = a2[0] - b2[0];
  p2[1] = a2[1] - b2[1];
  p2[2] = a2[2] - b2[2];
  r2[0] = p2[0];
  r2[1] = p2[1] * Math.cos(rad) - p2[2] * Math.sin(rad);
  r2[2] = p2[1] * Math.sin(rad) + p2[2] * Math.cos(rad);
  out[0] = r2[0] + b2[0];
  out[1] = r2[1] + b2[1];
  out[2] = r2[2] + b2[2];
  return out;
}
function rotateY(out, a2, b2, rad) {
  const p2 = [];
  const r2 = [];
  p2[0] = a2[0] - b2[0];
  p2[1] = a2[1] - b2[1];
  p2[2] = a2[2] - b2[2];
  r2[0] = p2[2] * Math.sin(rad) + p2[0] * Math.cos(rad);
  r2[1] = p2[1];
  r2[2] = p2[2] * Math.cos(rad) - p2[0] * Math.sin(rad);
  out[0] = r2[0] + b2[0];
  out[1] = r2[1] + b2[1];
  out[2] = r2[2] + b2[2];
  return out;
}
function rotateZ(out, a2, b2, rad) {
  const p2 = [];
  const r2 = [];
  p2[0] = a2[0] - b2[0];
  p2[1] = a2[1] - b2[1];
  p2[2] = a2[2] - b2[2];
  r2[0] = p2[0] * Math.cos(rad) - p2[1] * Math.sin(rad);
  r2[1] = p2[0] * Math.sin(rad) + p2[1] * Math.cos(rad);
  r2[2] = p2[2];
  out[0] = r2[0] + b2[0];
  out[1] = r2[1] + b2[1];
  out[2] = r2[2] + b2[2];
  return out;
}
function angle2(a2, b2) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const bx = b2[0];
  const by = b2[1];
  const bz = b2[2];
  const mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz));
  const cosine = mag && dot2(a2, b2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str2(a2) {
  return `vec3(${a2[0]}, ${a2[1]}, ${a2[2]})`;
}
function exactEquals2(a2, b2) {
  return a2[0] === b2[0] && a2[1] === b2[1] && a2[2] === b2[2];
}
function equals3(a2, b2) {
  const a0 = a2[0];
  const a1 = a2[1];
  const a22 = a2[2];
  const b0 = b2[0];
  const b1 = b2[1];
  const b22 = b2[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22));
}
var sub2 = subtract2;
var mul2 = multiply2;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var len2 = length2;
var sqrLen2 = squaredLength2;
var forEach2 = function() {
  const vec = create2();
  return function(a2, stride, offset, count2, fn, arg) {
    let i2;
    let l2;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count2) {
      l2 = Math.min(count2 * stride + offset, a2.length);
    } else {
      l2 = a2.length;
    }
    for (i2 = offset; i2 < l2; i2 += stride) {
      vec[0] = a2[i2];
      vec[1] = a2[i2 + 1];
      vec[2] = a2[i2 + 2];
      fn(vec, vec, arg);
      a2[i2] = vec[0];
      a2[i2 + 1] = vec[1];
      a2[i2 + 2] = vec[2];
    }
    return a2;
  };
}();

// node_modules/@math.gl/core/dist/classes/vector3.js
var ORIGIN = [0, 0, 0];
var ZERO;
var Vector3 = class _Vector3 extends Vector {
  static get ZERO() {
    if (!ZERO) {
      ZERO = new _Vector3(0, 0, 0);
      Object.freeze(ZERO);
    }
    return ZERO;
  }
  /**
   * @class
   * @param x
   * @param y
   * @param z
   */
  constructor(x2 = 0, y2 = 0, z2 = 0) {
    super(-0, -0, -0);
    if (arguments.length === 1 && isArray(x2)) {
      this.copy(x2);
    } else {
      if (config.debug) {
        checkNumber(x2);
        checkNumber(y2);
        checkNumber(z2);
      }
      this[0] = x2;
      this[1] = y2;
      this[2] = z2;
    }
  }
  set(x2, y2, z2) {
    this[0] = x2;
    this[1] = y2;
    this[2] = z2;
    return this.check();
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    return this.check();
  }
  fromObject(object) {
    if (config.debug) {
      checkNumber(object.x);
      checkNumber(object.y);
      checkNumber(object.z);
    }
    this[0] = object.x;
    this[1] = object.y;
    this[2] = object.z;
    return this.check();
  }
  toObject(object) {
    object.x = this[0];
    object.y = this[1];
    object.z = this[2];
    return object;
  }
  // Getters/setters
  get ELEMENTS() {
    return 3;
  }
  get z() {
    return this[2];
  }
  set z(value) {
    this[2] = checkNumber(value);
  }
  // ACCESSORS
  angle(vector) {
    return angle2(this, vector);
  }
  // MODIFIERS
  cross(vector) {
    cross2(this, this, vector);
    return this.check();
  }
  rotateX({ radians: radians2, origin = ORIGIN }) {
    rotateX(this, this, origin, radians2);
    return this.check();
  }
  rotateY({ radians: radians2, origin = ORIGIN }) {
    rotateY(this, this, origin, radians2);
    return this.check();
  }
  rotateZ({ radians: radians2, origin = ORIGIN }) {
    rotateZ(this, this, origin, radians2);
    return this.check();
  }
  // Transforms
  // transforms as point (4th component is implicitly 1)
  transform(matrix4) {
    return this.transformAsPoint(matrix4);
  }
  // transforms as point (4th component is implicitly 1)
  transformAsPoint(matrix4) {
    transformMat42(this, this, matrix4);
    return this.check();
  }
  // transforms as vector  (4th component is implicitly 0, ignores translation. slightly faster)
  transformAsVector(matrix4) {
    vec3_transformMat4AsVector(this, this, matrix4);
    return this.check();
  }
  transformByMatrix3(matrix3) {
    transformMat32(this, this, matrix3);
    return this.check();
  }
  transformByMatrix2(matrix2) {
    vec3_transformMat2(this, this, matrix2);
    return this.check();
  }
  transformByQuaternion(quaternion) {
    transformQuat(this, this, quaternion);
    return this.check();
  }
};

// node_modules/@math.gl/core/dist/classes/base/matrix.js
var Matrix = class extends MathArray {
  // fromObject(object) {
  //   const array = object.elements;
  //   return this.fromRowMajor(array);
  // }
  // toObject(object) {
  //   const array = object.elements;
  //   this.toRowMajor(array);
  //   return object;
  // }
  // TODO better override formatString?
  toString() {
    let string = "[";
    if (config.printRowMajor) {
      string += "row-major:";
      for (let row = 0; row < this.RANK; ++row) {
        for (let col = 0; col < this.RANK; ++col) {
          string += ` ${this[col * this.RANK + row]}`;
        }
      }
    } else {
      string += "column-major:";
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        string += ` ${this[i2]}`;
      }
    }
    string += "]";
    return string;
  }
  getElementIndex(row, col) {
    return col * this.RANK + row;
  }
  // By default assumes row major indices
  getElement(row, col) {
    return this[col * this.RANK + row];
  }
  // By default assumes row major indices
  setElement(row, col, value) {
    this[col * this.RANK + row] = checkNumber(value);
    return this;
  }
  getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
    const firstIndex = columnIndex * this.RANK;
    for (let i2 = 0; i2 < this.RANK; ++i2) {
      result[i2] = this[firstIndex + i2];
    }
    return result;
  }
  setColumn(columnIndex, columnVector) {
    const firstIndex = columnIndex * this.RANK;
    for (let i2 = 0; i2 < this.RANK; ++i2) {
      this[firstIndex + i2] = columnVector[i2];
    }
    return this;
  }
};

// node_modules/@math.gl/core/dist/gl-matrix/mat3.js
var mat3_exports = {};
__export(mat3_exports, {
  add: () => add3,
  adjoint: () => adjoint,
  clone: () => clone3,
  copy: () => copy3,
  create: () => create3,
  determinant: () => determinant,
  equals: () => equals4,
  exactEquals: () => exactEquals3,
  frob: () => frob,
  fromMat2d: () => fromMat2d,
  fromMat4: () => fromMat4,
  fromQuat: () => fromQuat,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues3,
  identity: () => identity,
  invert: () => invert,
  mul: () => mul3,
  multiply: () => multiply3,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  normalFromMat4: () => normalFromMat4,
  projection: () => projection,
  rotate: () => rotate2,
  scale: () => scale3,
  set: () => set3,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract3,
  translate: () => translate,
  transpose: () => transpose
});
function create3() {
  const out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[4];
  out[4] = a2[5];
  out[5] = a2[6];
  out[6] = a2[8];
  out[7] = a2[9];
  out[8] = a2[10];
  return out;
}
function clone3(a2) {
  const out = new ARRAY_TYPE(9);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  out[4] = a2[4];
  out[5] = a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  return out;
}
function copy3(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  out[4] = a2[4];
  out[5] = a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  return out;
}
function fromValues3(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  const out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function set3(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function transpose(out, a2) {
  if (out === a2) {
    const a01 = a2[1];
    const a02 = a2[2];
    const a12 = a2[5];
    out[1] = a2[3];
    out[2] = a2[6];
    out[3] = a01;
    out[5] = a2[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a2[0];
    out[1] = a2[3];
    out[2] = a2[6];
    out[3] = a2[1];
    out[4] = a2[4];
    out[5] = a2[7];
    out[6] = a2[2];
    out[7] = a2[5];
    out[8] = a2[8];
  }
  return out;
}
function invert(out, a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  const b01 = a22 * a11 - a12 * a21;
  const b11 = -a22 * a10 + a12 * a20;
  const b21 = a21 * a10 - a11 * a20;
  let det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function adjoint(out, a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
function determinant(a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply3(out, a2, b2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  const b00 = b2[0];
  const b01 = b2[1];
  const b02 = b2[2];
  const b10 = b2[3];
  const b11 = b2[4];
  const b12 = b2[5];
  const b20 = b2[6];
  const b21 = b2[7];
  const b22 = b2[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate(out, a2, v2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  const x2 = v2[0];
  const y2 = v2[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x2 * a00 + y2 * a10 + a20;
  out[7] = x2 * a01 + y2 * a11 + a21;
  out[8] = x2 * a02 + y2 * a12 + a22;
  return out;
}
function rotate2(out, a2, rad) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  out[0] = c2 * a00 + s2 * a10;
  out[1] = c2 * a01 + s2 * a11;
  out[2] = c2 * a02 + s2 * a12;
  out[3] = c2 * a10 - s2 * a00;
  out[4] = c2 * a11 - s2 * a01;
  out[5] = c2 * a12 - s2 * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale3(out, a2, v2) {
  const x2 = v2[0];
  const y2 = v2[1];
  out[0] = x2 * a2[0];
  out[1] = x2 * a2[1];
  out[2] = x2 * a2[2];
  out[3] = y2 * a2[3];
  out[4] = y2 * a2[4];
  out[5] = y2 * a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  return out;
}
function fromTranslation(out, v2) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v2[0];
  out[7] = v2[1];
  out[8] = 1;
  return out;
}
function fromRotation(out, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  out[0] = c2;
  out[1] = s2;
  out[2] = 0;
  out[3] = -s2;
  out[4] = c2;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling(out, v2) {
  out[0] = v2[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v2[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromMat2d(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = 0;
  out[3] = a2[2];
  out[4] = a2[3];
  out[5] = 0;
  out[6] = a2[4];
  out[7] = a2[5];
  out[8] = 1;
  return out;
}
function fromQuat(out, q2) {
  const x2 = q2[0];
  const y2 = q2[1];
  const z2 = q2[2];
  const w2 = q2[3];
  const x22 = x2 + x2;
  const y22 = y2 + y2;
  const z22 = z2 + z2;
  const xx = x2 * x22;
  const yx = y2 * x22;
  const yy = y2 * y22;
  const zx = z2 * x22;
  const zy = z2 * y22;
  const zz = z2 * z22;
  const wx = w2 * x22;
  const wy = w2 * y22;
  const wz = w2 * z22;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
function normalFromMat4(out, a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  const a30 = a2[12];
  const a31 = a2[13];
  const a32 = a2[14];
  const a33 = a2[15];
  const b00 = a00 * a11 - a01 * a10;
  const b01 = a00 * a12 - a02 * a10;
  const b02 = a00 * a13 - a03 * a10;
  const b03 = a01 * a12 - a02 * a11;
  const b04 = a01 * a13 - a03 * a11;
  const b05 = a02 * a13 - a03 * a12;
  const b06 = a20 * a31 - a21 * a30;
  const b07 = a20 * a32 - a22 * a30;
  const b08 = a20 * a33 - a23 * a30;
  const b09 = a21 * a32 - a22 * a31;
  const b10 = a21 * a33 - a23 * a31;
  const b11 = a22 * a33 - a23 * a32;
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
function str3(a2) {
  return `mat3(${a2[0]}, ${a2[1]}, ${a2[2]}, ${a2[3]}, ${a2[4]}, ${a2[5]}, ${a2[6]}, ${a2[7]}, ${a2[8]})`;
}
function frob(a2) {
  return Math.sqrt(a2[0] * a2[0] + a2[1] * a2[1] + a2[2] * a2[2] + a2[3] * a2[3] + a2[4] * a2[4] + a2[5] * a2[5] + a2[6] * a2[6] + a2[7] * a2[7] + a2[8] * a2[8]);
}
function add3(out, a2, b2) {
  out[0] = a2[0] + b2[0];
  out[1] = a2[1] + b2[1];
  out[2] = a2[2] + b2[2];
  out[3] = a2[3] + b2[3];
  out[4] = a2[4] + b2[4];
  out[5] = a2[5] + b2[5];
  out[6] = a2[6] + b2[6];
  out[7] = a2[7] + b2[7];
  out[8] = a2[8] + b2[8];
  return out;
}
function subtract3(out, a2, b2) {
  out[0] = a2[0] - b2[0];
  out[1] = a2[1] - b2[1];
  out[2] = a2[2] - b2[2];
  out[3] = a2[3] - b2[3];
  out[4] = a2[4] - b2[4];
  out[5] = a2[5] - b2[5];
  out[6] = a2[6] - b2[6];
  out[7] = a2[7] - b2[7];
  out[8] = a2[8] - b2[8];
  return out;
}
function multiplyScalar(out, a2, b2) {
  out[0] = a2[0] * b2;
  out[1] = a2[1] * b2;
  out[2] = a2[2] * b2;
  out[3] = a2[3] * b2;
  out[4] = a2[4] * b2;
  out[5] = a2[5] * b2;
  out[6] = a2[6] * b2;
  out[7] = a2[7] * b2;
  out[8] = a2[8] * b2;
  return out;
}
function multiplyScalarAndAdd(out, a2, b2, scale7) {
  out[0] = a2[0] + b2[0] * scale7;
  out[1] = a2[1] + b2[1] * scale7;
  out[2] = a2[2] + b2[2] * scale7;
  out[3] = a2[3] + b2[3] * scale7;
  out[4] = a2[4] + b2[4] * scale7;
  out[5] = a2[5] + b2[5] * scale7;
  out[6] = a2[6] + b2[6] * scale7;
  out[7] = a2[7] + b2[7] * scale7;
  out[8] = a2[8] + b2[8] * scale7;
  return out;
}
function exactEquals3(a2, b2) {
  return a2[0] === b2[0] && a2[1] === b2[1] && a2[2] === b2[2] && a2[3] === b2[3] && a2[4] === b2[4] && a2[5] === b2[5] && a2[6] === b2[6] && a2[7] === b2[7] && a2[8] === b2[8];
}
function equals4(a2, b2) {
  const a0 = a2[0];
  const a1 = a2[1];
  const a22 = a2[2];
  const a3 = a2[3];
  const a4 = a2[4];
  const a5 = a2[5];
  const a6 = a2[6];
  const a7 = a2[7];
  const a8 = a2[8];
  const b0 = b2[0];
  const b1 = b2[1];
  const b22 = b2[2];
  const b3 = b2[3];
  const b4 = b2[4];
  const b5 = b2[5];
  const b6 = b2[6];
  const b7 = b2[7];
  const b8 = b2[8];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
}
var mul3 = multiply3;
var sub3 = subtract3;

// node_modules/@math.gl/core/dist/classes/matrix3.js
var INDICES;
(function(INDICES3) {
  INDICES3[INDICES3["COL0ROW0"] = 0] = "COL0ROW0";
  INDICES3[INDICES3["COL0ROW1"] = 1] = "COL0ROW1";
  INDICES3[INDICES3["COL0ROW2"] = 2] = "COL0ROW2";
  INDICES3[INDICES3["COL1ROW0"] = 3] = "COL1ROW0";
  INDICES3[INDICES3["COL1ROW1"] = 4] = "COL1ROW1";
  INDICES3[INDICES3["COL1ROW2"] = 5] = "COL1ROW2";
  INDICES3[INDICES3["COL2ROW0"] = 6] = "COL2ROW0";
  INDICES3[INDICES3["COL2ROW1"] = 7] = "COL2ROW1";
  INDICES3[INDICES3["COL2ROW2"] = 8] = "COL2ROW2";
})(INDICES || (INDICES = {}));
var IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);

// node_modules/@math.gl/core/dist/gl-matrix/mat4.js
var mat4_exports = {};
__export(mat4_exports, {
  add: () => add4,
  adjoint: () => adjoint2,
  clone: () => clone4,
  copy: () => copy4,
  create: () => create4,
  decompose: () => decompose,
  determinant: () => determinant2,
  equals: () => equals5,
  exactEquals: () => exactEquals4,
  frob: () => frob2,
  fromQuat: () => fromQuat3,
  fromQuat2: () => fromQuat2,
  fromRotation: () => fromRotation2,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromScaling: () => fromScaling2,
  fromTranslation: () => fromTranslation2,
  fromValues: () => fromValues4,
  fromXRotation: () => fromXRotation,
  fromYRotation: () => fromYRotation,
  fromZRotation: () => fromZRotation,
  frustum: () => frustum,
  getRotation: () => getRotation,
  getScaling: () => getScaling,
  getTranslation: () => getTranslation,
  identity: () => identity2,
  invert: () => invert2,
  lookAt: () => lookAt,
  mul: () => mul4,
  multiply: () => multiply4,
  multiplyScalar: () => multiplyScalar2,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
  ortho: () => ortho,
  orthoNO: () => orthoNO,
  orthoZO: () => orthoZO,
  perspective: () => perspective,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  perspectiveNO: () => perspectiveNO,
  perspectiveZO: () => perspectiveZO,
  rotate: () => rotate3,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  scale: () => scale4,
  set: () => set4,
  str: () => str4,
  sub: () => sub4,
  subtract: () => subtract4,
  targetTo: () => targetTo,
  translate: () => translate2,
  transpose: () => transpose2
});
function create4() {
  const out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone4(a2) {
  const out = new ARRAY_TYPE(16);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  out[4] = a2[4];
  out[5] = a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  out[9] = a2[9];
  out[10] = a2[10];
  out[11] = a2[11];
  out[12] = a2[12];
  out[13] = a2[13];
  out[14] = a2[14];
  out[15] = a2[15];
  return out;
}
function copy4(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  out[4] = a2[4];
  out[5] = a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  out[9] = a2[9];
  out[10] = a2[10];
  out[11] = a2[11];
  out[12] = a2[12];
  out[13] = a2[13];
  out[14] = a2[14];
  out[15] = a2[15];
  return out;
}
function fromValues4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  const out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set4(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose2(out, a2) {
  if (out === a2) {
    const a01 = a2[1];
    const a02 = a2[2];
    const a03 = a2[3];
    const a12 = a2[6];
    const a13 = a2[7];
    const a23 = a2[11];
    out[1] = a2[4];
    out[2] = a2[8];
    out[3] = a2[12];
    out[4] = a01;
    out[6] = a2[9];
    out[7] = a2[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a2[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a2[0];
    out[1] = a2[4];
    out[2] = a2[8];
    out[3] = a2[12];
    out[4] = a2[1];
    out[5] = a2[5];
    out[6] = a2[9];
    out[7] = a2[13];
    out[8] = a2[2];
    out[9] = a2[6];
    out[10] = a2[10];
    out[11] = a2[14];
    out[12] = a2[3];
    out[13] = a2[7];
    out[14] = a2[11];
    out[15] = a2[15];
  }
  return out;
}
function invert2(out, a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  const a30 = a2[12];
  const a31 = a2[13];
  const a32 = a2[14];
  const a33 = a2[15];
  const b00 = a00 * a11 - a01 * a10;
  const b01 = a00 * a12 - a02 * a10;
  const b02 = a00 * a13 - a03 * a10;
  const b03 = a01 * a12 - a02 * a11;
  const b04 = a01 * a13 - a03 * a11;
  const b05 = a02 * a13 - a03 * a12;
  const b06 = a20 * a31 - a21 * a30;
  const b07 = a20 * a32 - a22 * a30;
  const b08 = a20 * a33 - a23 * a30;
  const b09 = a21 * a32 - a22 * a31;
  const b10 = a21 * a33 - a23 * a31;
  const b11 = a22 * a33 - a23 * a32;
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint2(out, a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  const a30 = a2[12];
  const a31 = a2[13];
  const a32 = a2[14];
  const a33 = a2[15];
  const b00 = a00 * a11 - a01 * a10;
  const b01 = a00 * a12 - a02 * a10;
  const b02 = a00 * a13 - a03 * a10;
  const b03 = a01 * a12 - a02 * a11;
  const b04 = a01 * a13 - a03 * a11;
  const b05 = a02 * a13 - a03 * a12;
  const b06 = a20 * a31 - a21 * a30;
  const b07 = a20 * a32 - a22 * a30;
  const b08 = a20 * a33 - a23 * a30;
  const b09 = a21 * a32 - a22 * a31;
  const b10 = a21 * a33 - a23 * a31;
  const b11 = a22 * a33 - a23 * a32;
  out[0] = a11 * b11 - a12 * b10 + a13 * b09;
  out[1] = a02 * b10 - a01 * b11 - a03 * b09;
  out[2] = a31 * b05 - a32 * b04 + a33 * b03;
  out[3] = a22 * b04 - a21 * b05 - a23 * b03;
  out[4] = a12 * b08 - a10 * b11 - a13 * b07;
  out[5] = a00 * b11 - a02 * b08 + a03 * b07;
  out[6] = a32 * b02 - a30 * b05 - a33 * b01;
  out[7] = a20 * b05 - a22 * b02 + a23 * b01;
  out[8] = a10 * b10 - a11 * b08 + a13 * b06;
  out[9] = a01 * b08 - a00 * b10 - a03 * b06;
  out[10] = a30 * b04 - a31 * b02 + a33 * b00;
  out[11] = a21 * b02 - a20 * b04 - a23 * b00;
  out[12] = a11 * b07 - a10 * b09 - a12 * b06;
  out[13] = a00 * b09 - a01 * b07 + a02 * b06;
  out[14] = a31 * b01 - a30 * b03 - a32 * b00;
  out[15] = a20 * b03 - a21 * b01 + a22 * b00;
  return out;
}
function determinant2(a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  const a30 = a2[12];
  const a31 = a2[13];
  const a32 = a2[14];
  const a33 = a2[15];
  const b0 = a00 * a11 - a01 * a10;
  const b1 = a00 * a12 - a02 * a10;
  const b2 = a01 * a12 - a02 * a11;
  const b3 = a20 * a31 - a21 * a30;
  const b4 = a20 * a32 - a22 * a30;
  const b5 = a21 * a32 - a22 * a31;
  const b6 = a00 * b5 - a01 * b4 + a02 * b3;
  const b7 = a10 * b5 - a11 * b4 + a12 * b3;
  const b8 = a20 * b2 - a21 * b1 + a22 * b0;
  const b9 = a30 * b2 - a31 * b1 + a32 * b0;
  return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
}
function multiply4(out, a2, b2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  const a30 = a2[12];
  const a31 = a2[13];
  const a32 = a2[14];
  const a33 = a2[15];
  let b0 = b2[0];
  let b1 = b2[1];
  let b22 = b2[2];
  let b3 = b2[3];
  out[0] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  b0 = b2[4];
  b1 = b2[5];
  b22 = b2[6];
  b3 = b2[7];
  out[4] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  b0 = b2[8];
  b1 = b2[9];
  b22 = b2[10];
  b3 = b2[11];
  out[8] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  b0 = b2[12];
  b1 = b2[13];
  b22 = b2[14];
  b3 = b2[15];
  out[12] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  return out;
}
function translate2(out, a2, v2) {
  const x2 = v2[0];
  const y2 = v2[1];
  const z2 = v2[2];
  let a00;
  let a01;
  let a02;
  let a03;
  let a10;
  let a11;
  let a12;
  let a13;
  let a20;
  let a21;
  let a22;
  let a23;
  if (a2 === out) {
    out[12] = a2[0] * x2 + a2[4] * y2 + a2[8] * z2 + a2[12];
    out[13] = a2[1] * x2 + a2[5] * y2 + a2[9] * z2 + a2[13];
    out[14] = a2[2] * x2 + a2[6] * y2 + a2[10] * z2 + a2[14];
    out[15] = a2[3] * x2 + a2[7] * y2 + a2[11] * z2 + a2[15];
  } else {
    a00 = a2[0];
    a01 = a2[1];
    a02 = a2[2];
    a03 = a2[3];
    a10 = a2[4];
    a11 = a2[5];
    a12 = a2[6];
    a13 = a2[7];
    a20 = a2[8];
    a21 = a2[9];
    a22 = a2[10];
    a23 = a2[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x2 + a10 * y2 + a20 * z2 + a2[12];
    out[13] = a01 * x2 + a11 * y2 + a21 * z2 + a2[13];
    out[14] = a02 * x2 + a12 * y2 + a22 * z2 + a2[14];
    out[15] = a03 * x2 + a13 * y2 + a23 * z2 + a2[15];
  }
  return out;
}
function scale4(out, a2, v2) {
  const x2 = v2[0];
  const y2 = v2[1];
  const z2 = v2[2];
  out[0] = a2[0] * x2;
  out[1] = a2[1] * x2;
  out[2] = a2[2] * x2;
  out[3] = a2[3] * x2;
  out[4] = a2[4] * y2;
  out[5] = a2[5] * y2;
  out[6] = a2[6] * y2;
  out[7] = a2[7] * y2;
  out[8] = a2[8] * z2;
  out[9] = a2[9] * z2;
  out[10] = a2[10] * z2;
  out[11] = a2[11] * z2;
  out[12] = a2[12];
  out[13] = a2[13];
  out[14] = a2[14];
  out[15] = a2[15];
  return out;
}
function rotate3(out, a2, rad, axis) {
  let x2 = axis[0];
  let y2 = axis[1];
  let z2 = axis[2];
  let len5 = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
  let c2;
  let s2;
  let t2;
  let a00;
  let a01;
  let a02;
  let a03;
  let a10;
  let a11;
  let a12;
  let a13;
  let a20;
  let a21;
  let a22;
  let a23;
  let b00;
  let b01;
  let b02;
  let b10;
  let b11;
  let b12;
  let b20;
  let b21;
  let b22;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x2 *= len5;
  y2 *= len5;
  z2 *= len5;
  s2 = Math.sin(rad);
  c2 = Math.cos(rad);
  t2 = 1 - c2;
  a00 = a2[0];
  a01 = a2[1];
  a02 = a2[2];
  a03 = a2[3];
  a10 = a2[4];
  a11 = a2[5];
  a12 = a2[6];
  a13 = a2[7];
  a20 = a2[8];
  a21 = a2[9];
  a22 = a2[10];
  a23 = a2[11];
  b00 = x2 * x2 * t2 + c2;
  b01 = y2 * x2 * t2 + z2 * s2;
  b02 = z2 * x2 * t2 - y2 * s2;
  b10 = x2 * y2 * t2 - z2 * s2;
  b11 = y2 * y2 * t2 + c2;
  b12 = z2 * y2 * t2 + x2 * s2;
  b20 = x2 * z2 * t2 + y2 * s2;
  b21 = y2 * z2 * t2 - x2 * s2;
  b22 = z2 * z2 * t2 + c2;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a2 !== out) {
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  return out;
}
function rotateX2(out, a2, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  if (a2 !== out) {
    out[0] = a2[0];
    out[1] = a2[1];
    out[2] = a2[2];
    out[3] = a2[3];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[4] = a10 * c2 + a20 * s2;
  out[5] = a11 * c2 + a21 * s2;
  out[6] = a12 * c2 + a22 * s2;
  out[7] = a13 * c2 + a23 * s2;
  out[8] = a20 * c2 - a10 * s2;
  out[9] = a21 * c2 - a11 * s2;
  out[10] = a22 * c2 - a12 * s2;
  out[11] = a23 * c2 - a13 * s2;
  return out;
}
function rotateY2(out, a2, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  if (a2 !== out) {
    out[4] = a2[4];
    out[5] = a2[5];
    out[6] = a2[6];
    out[7] = a2[7];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[0] = a00 * c2 - a20 * s2;
  out[1] = a01 * c2 - a21 * s2;
  out[2] = a02 * c2 - a22 * s2;
  out[3] = a03 * c2 - a23 * s2;
  out[8] = a00 * s2 + a20 * c2;
  out[9] = a01 * s2 + a21 * c2;
  out[10] = a02 * s2 + a22 * c2;
  out[11] = a03 * s2 + a23 * c2;
  return out;
}
function rotateZ2(out, a2, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  if (a2 !== out) {
    out[8] = a2[8];
    out[9] = a2[9];
    out[10] = a2[10];
    out[11] = a2[11];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[0] = a00 * c2 + a10 * s2;
  out[1] = a01 * c2 + a11 * s2;
  out[2] = a02 * c2 + a12 * s2;
  out[3] = a03 * c2 + a13 * s2;
  out[4] = a10 * c2 - a00 * s2;
  out[5] = a11 * c2 - a01 * s2;
  out[6] = a12 * c2 - a02 * s2;
  out[7] = a13 * c2 - a03 * s2;
  return out;
}
function fromTranslation2(out, v2) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromScaling2(out, v2) {
  out[0] = v2[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v2[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v2[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation2(out, rad, axis) {
  let x2 = axis[0];
  let y2 = axis[1];
  let z2 = axis[2];
  let len5 = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
  let c2;
  let s2;
  let t2;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x2 *= len5;
  y2 *= len5;
  z2 *= len5;
  s2 = Math.sin(rad);
  c2 = Math.cos(rad);
  t2 = 1 - c2;
  out[0] = x2 * x2 * t2 + c2;
  out[1] = y2 * x2 * t2 + z2 * s2;
  out[2] = z2 * x2 * t2 - y2 * s2;
  out[3] = 0;
  out[4] = x2 * y2 * t2 - z2 * s2;
  out[5] = y2 * y2 * t2 + c2;
  out[6] = z2 * y2 * t2 + x2 * s2;
  out[7] = 0;
  out[8] = x2 * z2 * t2 + y2 * s2;
  out[9] = y2 * z2 * t2 - x2 * s2;
  out[10] = z2 * z2 * t2 + c2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c2;
  out[6] = s2;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s2;
  out[10] = c2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  out[0] = c2;
  out[1] = 0;
  out[2] = -s2;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s2;
  out[9] = 0;
  out[10] = c2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  out[0] = c2;
  out[1] = s2;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s2;
  out[5] = c2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q2, v2) {
  const x2 = q2[0];
  const y2 = q2[1];
  const z2 = q2[2];
  const w2 = q2[3];
  const x22 = x2 + x2;
  const y22 = y2 + y2;
  const z22 = z2 + z2;
  const xx = x2 * x22;
  const xy = x2 * y22;
  const xz = x2 * z22;
  const yy = y2 * y22;
  const yz = y2 * z22;
  const zz = z2 * z22;
  const wx = w2 * x22;
  const wy = w2 * y22;
  const wz = w2 * z22;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a2) {
  const translation = new ARRAY_TYPE(3);
  const bx = -a2[0];
  const by = -a2[1];
  const bz = -a2[2];
  const bw = a2[3];
  const ax = a2[4];
  const ay = a2[5];
  const az = a2[6];
  const aw = a2[7];
  const magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a2, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  const m11 = mat[0];
  const m12 = mat[1];
  const m13 = mat[2];
  const m21 = mat[4];
  const m22 = mat[5];
  const m23 = mat[6];
  const m31 = mat[8];
  const m32 = mat[9];
  const m33 = mat[10];
  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  return out;
}
function getRotation(out, mat) {
  const scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  const is1 = 1 / scaling[0];
  const is2 = 1 / scaling[1];
  const is3 = 1 / scaling[2];
  const sm11 = mat[0] * is1;
  const sm12 = mat[1] * is2;
  const sm13 = mat[2] * is3;
  const sm21 = mat[4] * is1;
  const sm22 = mat[5] * is2;
  const sm23 = mat[6] * is3;
  const sm31 = mat[8] * is1;
  const sm32 = mat[9] * is2;
  const sm33 = mat[10] * is3;
  const trace = sm11 + sm22 + sm33;
  let S2 = 0;
  if (trace > 0) {
    S2 = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S2;
    out[0] = (sm23 - sm32) / S2;
    out[1] = (sm31 - sm13) / S2;
    out[2] = (sm12 - sm21) / S2;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S2;
    out[0] = 0.25 * S2;
    out[1] = (sm12 + sm21) / S2;
    out[2] = (sm31 + sm13) / S2;
  } else if (sm22 > sm33) {
    S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S2;
    out[0] = (sm12 + sm21) / S2;
    out[1] = 0.25 * S2;
    out[2] = (sm23 + sm32) / S2;
  } else {
    S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S2;
    out[0] = (sm31 + sm13) / S2;
    out[1] = (sm23 + sm32) / S2;
    out[2] = 0.25 * S2;
  }
  return out;
}
function decompose(out_r, out_t, out_s, mat) {
  out_t[0] = mat[12];
  out_t[1] = mat[13];
  out_t[2] = mat[14];
  const m11 = mat[0];
  const m12 = mat[1];
  const m13 = mat[2];
  const m21 = mat[4];
  const m22 = mat[5];
  const m23 = mat[6];
  const m31 = mat[8];
  const m32 = mat[9];
  const m33 = mat[10];
  out_s[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out_s[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out_s[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  const is1 = 1 / out_s[0];
  const is2 = 1 / out_s[1];
  const is3 = 1 / out_s[2];
  const sm11 = m11 * is1;
  const sm12 = m12 * is2;
  const sm13 = m13 * is3;
  const sm21 = m21 * is1;
  const sm22 = m22 * is2;
  const sm23 = m23 * is3;
  const sm31 = m31 * is1;
  const sm32 = m32 * is2;
  const sm33 = m33 * is3;
  const trace = sm11 + sm22 + sm33;
  let S2 = 0;
  if (trace > 0) {
    S2 = Math.sqrt(trace + 1) * 2;
    out_r[3] = 0.25 * S2;
    out_r[0] = (sm23 - sm32) / S2;
    out_r[1] = (sm31 - sm13) / S2;
    out_r[2] = (sm12 - sm21) / S2;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out_r[3] = (sm23 - sm32) / S2;
    out_r[0] = 0.25 * S2;
    out_r[1] = (sm12 + sm21) / S2;
    out_r[2] = (sm31 + sm13) / S2;
  } else if (sm22 > sm33) {
    S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out_r[3] = (sm31 - sm13) / S2;
    out_r[0] = (sm12 + sm21) / S2;
    out_r[1] = 0.25 * S2;
    out_r[2] = (sm23 + sm32) / S2;
  } else {
    S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out_r[3] = (sm12 - sm21) / S2;
    out_r[0] = (sm31 + sm13) / S2;
    out_r[1] = (sm23 + sm32) / S2;
    out_r[2] = 0.25 * S2;
  }
  return out_r;
}
function fromRotationTranslationScale(out, q2, v2, s2) {
  const x2 = q2[0];
  const y2 = q2[1];
  const z2 = q2[2];
  const w2 = q2[3];
  const x22 = x2 + x2;
  const y22 = y2 + y2;
  const z22 = z2 + z2;
  const xx = x2 * x22;
  const xy = x2 * y22;
  const xz = x2 * z22;
  const yy = y2 * y22;
  const yz = y2 * z22;
  const zz = z2 * z22;
  const wx = w2 * x22;
  const wy = w2 * y22;
  const wz = w2 * z22;
  const sx = s2[0];
  const sy = s2[1];
  const sz = s2[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q2, v2, s2, o2) {
  const x2 = q2[0];
  const y2 = q2[1];
  const z2 = q2[2];
  const w2 = q2[3];
  const x22 = x2 + x2;
  const y22 = y2 + y2;
  const z22 = z2 + z2;
  const xx = x2 * x22;
  const xy = x2 * y22;
  const xz = x2 * z22;
  const yy = y2 * y22;
  const yz = y2 * z22;
  const zz = z2 * z22;
  const wx = w2 * x22;
  const wy = w2 * y22;
  const wz = w2 * z22;
  const sx = s2[0];
  const sy = s2[1];
  const sz = s2[2];
  const ox = o2[0];
  const oy = o2[1];
  const oz = o2[2];
  const out0 = (1 - (yy + zz)) * sx;
  const out1 = (xy + wz) * sx;
  const out2 = (xz - wy) * sx;
  const out4 = (xy - wz) * sy;
  const out5 = (1 - (xx + zz)) * sy;
  const out6 = (yz + wx) * sy;
  const out8 = (xz + wy) * sz;
  const out9 = (yz - wx) * sz;
  const out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v2[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v2[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v2[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat3(out, q2) {
  const x2 = q2[0];
  const y2 = q2[1];
  const z2 = q2[2];
  const w2 = q2[3];
  const x22 = x2 + x2;
  const y22 = y2 + y2;
  const z22 = z2 + z2;
  const xx = x2 * x22;
  const yx = y2 * x22;
  const yy = y2 * y22;
  const zx = z2 * x22;
  const zy = z2 * y22;
  const zz = z2 * z22;
  const wx = w2 * x22;
  const wy = w2 * y22;
  const wz = w2 * z22;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  const rl = 1 / (right - left);
  const tb = 1 / (top - bottom);
  const nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  const f2 = 1 / Math.tan(fovy / 2);
  out[0] = f2 / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    const nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  const f2 = 1 / Math.tan(fovy / 2);
  out[0] = f2 / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    const nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  const upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  const downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  const leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  const rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  const xScale = 2 / (leftTan + rightTan);
  const yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  const lr = 1 / (left - right);
  const bt = 1 / (bottom - top);
  const nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function orthoZO(out, left, right, bottom, top, near, far) {
  const lr = 1 / (left - right);
  const bt = 1 / (bottom - top);
  const nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  let len5;
  let x0;
  let x1;
  let x2;
  let y0;
  let y1;
  let y2;
  let z0;
  let z1;
  let z2;
  const eyex = eye[0];
  const eyey = eye[1];
  const eyez = eye[2];
  const upx = up[0];
  const upy = up[1];
  const upz = up[2];
  const centerx = center[0];
  const centery = center[1];
  const centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity2(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len5 = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len5;
  z1 *= len5;
  z2 *= len5;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len5 = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len5) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len5 = 1 / len5;
    x0 *= len5;
    x1 *= len5;
    x2 *= len5;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len5 = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len5) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len5 = 1 / len5;
    y0 *= len5;
    y1 *= len5;
    y2 *= len5;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  const eyex = eye[0];
  const eyey = eye[1];
  const eyez = eye[2];
  const upx = up[0];
  const upy = up[1];
  const upz = up[2];
  let z0 = eyex - target[0];
  let z1 = eyey - target[1];
  let z2 = eyez - target[2];
  let len5 = z0 * z0 + z1 * z1 + z2 * z2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    z0 *= len5;
    z1 *= len5;
    z2 *= len5;
  }
  let x0 = upy * z2 - upz * z1;
  let x1 = upz * z0 - upx * z2;
  let x2 = upx * z1 - upy * z0;
  len5 = x0 * x0 + x1 * x1 + x2 * x2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    x0 *= len5;
    x1 *= len5;
    x2 *= len5;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str4(a2) {
  return `mat4(${a2[0]}, ${a2[1]}, ${a2[2]}, ${a2[3]}, ${a2[4]}, ${a2[5]}, ${a2[6]}, ${a2[7]}, ${a2[8]}, ${a2[9]}, ${a2[10]}, ${a2[11]}, ${a2[12]}, ${a2[13]}, ${a2[14]}, ${a2[15]})`;
}
function frob2(a2) {
  return Math.sqrt(a2[0] * a2[0] + a2[1] * a2[1] + a2[2] * a2[2] + a2[3] * a2[3] + a2[4] * a2[4] + a2[5] * a2[5] + a2[6] * a2[6] + a2[7] * a2[7] + a2[8] * a2[8] + a2[9] * a2[9] + a2[10] * a2[10] + a2[11] * a2[11] + a2[12] * a2[12] + a2[13] * a2[13] + a2[14] * a2[14] + a2[15] * a2[15]);
}
function add4(out, a2, b2) {
  out[0] = a2[0] + b2[0];
  out[1] = a2[1] + b2[1];
  out[2] = a2[2] + b2[2];
  out[3] = a2[3] + b2[3];
  out[4] = a2[4] + b2[4];
  out[5] = a2[5] + b2[5];
  out[6] = a2[6] + b2[6];
  out[7] = a2[7] + b2[7];
  out[8] = a2[8] + b2[8];
  out[9] = a2[9] + b2[9];
  out[10] = a2[10] + b2[10];
  out[11] = a2[11] + b2[11];
  out[12] = a2[12] + b2[12];
  out[13] = a2[13] + b2[13];
  out[14] = a2[14] + b2[14];
  out[15] = a2[15] + b2[15];
  return out;
}
function subtract4(out, a2, b2) {
  out[0] = a2[0] - b2[0];
  out[1] = a2[1] - b2[1];
  out[2] = a2[2] - b2[2];
  out[3] = a2[3] - b2[3];
  out[4] = a2[4] - b2[4];
  out[5] = a2[5] - b2[5];
  out[6] = a2[6] - b2[6];
  out[7] = a2[7] - b2[7];
  out[8] = a2[8] - b2[8];
  out[9] = a2[9] - b2[9];
  out[10] = a2[10] - b2[10];
  out[11] = a2[11] - b2[11];
  out[12] = a2[12] - b2[12];
  out[13] = a2[13] - b2[13];
  out[14] = a2[14] - b2[14];
  out[15] = a2[15] - b2[15];
  return out;
}
function multiplyScalar2(out, a2, b2) {
  out[0] = a2[0] * b2;
  out[1] = a2[1] * b2;
  out[2] = a2[2] * b2;
  out[3] = a2[3] * b2;
  out[4] = a2[4] * b2;
  out[5] = a2[5] * b2;
  out[6] = a2[6] * b2;
  out[7] = a2[7] * b2;
  out[8] = a2[8] * b2;
  out[9] = a2[9] * b2;
  out[10] = a2[10] * b2;
  out[11] = a2[11] * b2;
  out[12] = a2[12] * b2;
  out[13] = a2[13] * b2;
  out[14] = a2[14] * b2;
  out[15] = a2[15] * b2;
  return out;
}
function multiplyScalarAndAdd2(out, a2, b2, scale7) {
  out[0] = a2[0] + b2[0] * scale7;
  out[1] = a2[1] + b2[1] * scale7;
  out[2] = a2[2] + b2[2] * scale7;
  out[3] = a2[3] + b2[3] * scale7;
  out[4] = a2[4] + b2[4] * scale7;
  out[5] = a2[5] + b2[5] * scale7;
  out[6] = a2[6] + b2[6] * scale7;
  out[7] = a2[7] + b2[7] * scale7;
  out[8] = a2[8] + b2[8] * scale7;
  out[9] = a2[9] + b2[9] * scale7;
  out[10] = a2[10] + b2[10] * scale7;
  out[11] = a2[11] + b2[11] * scale7;
  out[12] = a2[12] + b2[12] * scale7;
  out[13] = a2[13] + b2[13] * scale7;
  out[14] = a2[14] + b2[14] * scale7;
  out[15] = a2[15] + b2[15] * scale7;
  return out;
}
function exactEquals4(a2, b2) {
  return a2[0] === b2[0] && a2[1] === b2[1] && a2[2] === b2[2] && a2[3] === b2[3] && a2[4] === b2[4] && a2[5] === b2[5] && a2[6] === b2[6] && a2[7] === b2[7] && a2[8] === b2[8] && a2[9] === b2[9] && a2[10] === b2[10] && a2[11] === b2[11] && a2[12] === b2[12] && a2[13] === b2[13] && a2[14] === b2[14] && a2[15] === b2[15];
}
function equals5(a2, b2) {
  const a0 = a2[0];
  const a1 = a2[1];
  const a22 = a2[2];
  const a3 = a2[3];
  const a4 = a2[4];
  const a5 = a2[5];
  const a6 = a2[6];
  const a7 = a2[7];
  const a8 = a2[8];
  const a9 = a2[9];
  const a10 = a2[10];
  const a11 = a2[11];
  const a12 = a2[12];
  const a13 = a2[13];
  const a14 = a2[14];
  const a15 = a2[15];
  const b0 = b2[0];
  const b1 = b2[1];
  const b22 = b2[2];
  const b3 = b2[3];
  const b4 = b2[4];
  const b5 = b2[5];
  const b6 = b2[6];
  const b7 = b2[7];
  const b8 = b2[8];
  const b9 = b2[9];
  const b10 = b2[10];
  const b11 = b2[11];
  const b12 = b2[12];
  const b13 = b2[13];
  const b14 = b2[14];
  const b15 = b2[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul4 = multiply4;
var sub4 = subtract4;

// node_modules/@math.gl/core/dist/gl-matrix/vec4.js
var vec4_exports = {};
__export(vec4_exports, {
  add: () => add5,
  ceil: () => ceil3,
  clone: () => clone5,
  copy: () => copy5,
  create: () => create5,
  cross: () => cross3,
  dist: () => dist3,
  distance: () => distance3,
  div: () => div3,
  divide: () => divide3,
  dot: () => dot3,
  equals: () => equals6,
  exactEquals: () => exactEquals5,
  floor: () => floor3,
  forEach: () => forEach3,
  fromValues: () => fromValues5,
  inverse: () => inverse3,
  len: () => len3,
  length: () => length3,
  lerp: () => lerp4,
  max: () => max3,
  min: () => min3,
  mul: () => mul5,
  multiply: () => multiply5,
  negate: () => negate3,
  normalize: () => normalize3,
  random: () => random3,
  round: () => round5,
  scale: () => scale5,
  scaleAndAdd: () => scaleAndAdd3,
  set: () => set5,
  sqrDist: () => sqrDist3,
  sqrLen: () => sqrLen3,
  squaredDistance: () => squaredDistance3,
  squaredLength: () => squaredLength3,
  str: () => str5,
  sub: () => sub5,
  subtract: () => subtract5,
  transformMat4: () => transformMat43,
  transformQuat: () => transformQuat2,
  zero: () => zero3
});
function create5() {
  const out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone5(a2) {
  const out = new ARRAY_TYPE(4);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  return out;
}
function fromValues5(x2, y2, z2, w2) {
  const out = new ARRAY_TYPE(4);
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  out[3] = w2;
  return out;
}
function copy5(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  return out;
}
function set5(out, x2, y2, z2, w2) {
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  out[3] = w2;
  return out;
}
function add5(out, a2, b2) {
  out[0] = a2[0] + b2[0];
  out[1] = a2[1] + b2[1];
  out[2] = a2[2] + b2[2];
  out[3] = a2[3] + b2[3];
  return out;
}
function subtract5(out, a2, b2) {
  out[0] = a2[0] - b2[0];
  out[1] = a2[1] - b2[1];
  out[2] = a2[2] - b2[2];
  out[3] = a2[3] - b2[3];
  return out;
}
function multiply5(out, a2, b2) {
  out[0] = a2[0] * b2[0];
  out[1] = a2[1] * b2[1];
  out[2] = a2[2] * b2[2];
  out[3] = a2[3] * b2[3];
  return out;
}
function divide3(out, a2, b2) {
  out[0] = a2[0] / b2[0];
  out[1] = a2[1] / b2[1];
  out[2] = a2[2] / b2[2];
  out[3] = a2[3] / b2[3];
  return out;
}
function ceil3(out, a2) {
  out[0] = Math.ceil(a2[0]);
  out[1] = Math.ceil(a2[1]);
  out[2] = Math.ceil(a2[2]);
  out[3] = Math.ceil(a2[3]);
  return out;
}
function floor3(out, a2) {
  out[0] = Math.floor(a2[0]);
  out[1] = Math.floor(a2[1]);
  out[2] = Math.floor(a2[2]);
  out[3] = Math.floor(a2[3]);
  return out;
}
function min3(out, a2, b2) {
  out[0] = Math.min(a2[0], b2[0]);
  out[1] = Math.min(a2[1], b2[1]);
  out[2] = Math.min(a2[2], b2[2]);
  out[3] = Math.min(a2[3], b2[3]);
  return out;
}
function max3(out, a2, b2) {
  out[0] = Math.max(a2[0], b2[0]);
  out[1] = Math.max(a2[1], b2[1]);
  out[2] = Math.max(a2[2], b2[2]);
  out[3] = Math.max(a2[3], b2[3]);
  return out;
}
function round5(out, a2) {
  out[0] = round2(a2[0]);
  out[1] = round2(a2[1]);
  out[2] = round2(a2[2]);
  out[3] = round2(a2[3]);
  return out;
}
function scale5(out, a2, b2) {
  out[0] = a2[0] * b2;
  out[1] = a2[1] * b2;
  out[2] = a2[2] * b2;
  out[3] = a2[3] * b2;
  return out;
}
function scaleAndAdd3(out, a2, b2, scale7) {
  out[0] = a2[0] + b2[0] * scale7;
  out[1] = a2[1] + b2[1] * scale7;
  out[2] = a2[2] + b2[2] * scale7;
  out[3] = a2[3] + b2[3] * scale7;
  return out;
}
function distance3(a2, b2) {
  const x2 = b2[0] - a2[0];
  const y2 = b2[1] - a2[1];
  const z2 = b2[2] - a2[2];
  const w2 = b2[3] - a2[3];
  return Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2);
}
function squaredDistance3(a2, b2) {
  const x2 = b2[0] - a2[0];
  const y2 = b2[1] - a2[1];
  const z2 = b2[2] - a2[2];
  const w2 = b2[3] - a2[3];
  return x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2;
}
function length3(a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  const w2 = a2[3];
  return Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2);
}
function squaredLength3(a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  const w2 = a2[3];
  return x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2;
}
function negate3(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  out[3] = -a2[3];
  return out;
}
function inverse3(out, a2) {
  out[0] = 1 / a2[0];
  out[1] = 1 / a2[1];
  out[2] = 1 / a2[2];
  out[3] = 1 / a2[3];
  return out;
}
function normalize3(out, a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  const w2 = a2[3];
  let len5 = x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = x2 * len5;
  out[1] = y2 * len5;
  out[2] = z2 * len5;
  out[3] = w2 * len5;
  return out;
}
function dot3(a2, b2) {
  return a2[0] * b2[0] + a2[1] * b2[1] + a2[2] * b2[2] + a2[3] * b2[3];
}
function cross3(out, u2, v2, w2) {
  const A2 = v2[0] * w2[1] - v2[1] * w2[0];
  const B2 = v2[0] * w2[2] - v2[2] * w2[0];
  const C2 = v2[0] * w2[3] - v2[3] * w2[0];
  const D2 = v2[1] * w2[2] - v2[2] * w2[1];
  const E2 = v2[1] * w2[3] - v2[3] * w2[1];
  const F2 = v2[2] * w2[3] - v2[3] * w2[2];
  const G2 = u2[0];
  const H2 = u2[1];
  const I2 = u2[2];
  const J2 = u2[3];
  out[0] = H2 * F2 - I2 * E2 + J2 * D2;
  out[1] = -(G2 * F2) + I2 * C2 - J2 * B2;
  out[2] = G2 * E2 - H2 * C2 + J2 * A2;
  out[3] = -(G2 * D2) + H2 * B2 - I2 * A2;
  return out;
}
function lerp4(out, a2, b2, t2) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const aw = a2[3];
  out[0] = ax + t2 * (b2[0] - ax);
  out[1] = ay + t2 * (b2[1] - ay);
  out[2] = az + t2 * (b2[2] - az);
  out[3] = aw + t2 * (b2[3] - aw);
  return out;
}
function random3(out, scale7) {
  scale7 = scale7 === void 0 ? 1 : scale7;
  let v1;
  let v2;
  let v3;
  let v4;
  let s1;
  let s2;
  do {
    v1 = RANDOM() * 2 - 1;
    v2 = RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = RANDOM() * 2 - 1;
    v4 = RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);
  const d2 = Math.sqrt((1 - s1) / s2);
  out[0] = scale7 * v1;
  out[1] = scale7 * v2;
  out[2] = scale7 * v3 * d2;
  out[3] = scale7 * v4 * d2;
  return out;
}
function transformMat43(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  const w2 = a2[3];
  out[0] = m2[0] * x2 + m2[4] * y2 + m2[8] * z2 + m2[12] * w2;
  out[1] = m2[1] * x2 + m2[5] * y2 + m2[9] * z2 + m2[13] * w2;
  out[2] = m2[2] * x2 + m2[6] * y2 + m2[10] * z2 + m2[14] * w2;
  out[3] = m2[3] * x2 + m2[7] * y2 + m2[11] * z2 + m2[15] * w2;
  return out;
}
function transformQuat2(out, a2, q2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  const qx = q2[0];
  const qy = q2[1];
  const qz = q2[2];
  const qw = q2[3];
  const ix = qw * x2 + qy * z2 - qz * y2;
  const iy = qw * y2 + qz * x2 - qx * z2;
  const iz = qw * z2 + qx * y2 - qy * x2;
  const iw = -qx * x2 - qy * y2 - qz * z2;
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a2[3];
  return out;
}
function zero3(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}
function str5(a2) {
  return `vec4(${a2[0]}, ${a2[1]}, ${a2[2]}, ${a2[3]})`;
}
function exactEquals5(a2, b2) {
  return a2[0] === b2[0] && a2[1] === b2[1] && a2[2] === b2[2] && a2[3] === b2[3];
}
function equals6(a2, b2) {
  const a0 = a2[0];
  const a1 = a2[1];
  const a22 = a2[2];
  const a3 = a2[3];
  const b0 = b2[0];
  const b1 = b2[1];
  const b22 = b2[2];
  const b3 = b2[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var sub5 = subtract5;
var mul5 = multiply5;
var div3 = divide3;
var dist3 = distance3;
var sqrDist3 = squaredDistance3;
var len3 = length3;
var sqrLen3 = squaredLength3;
var forEach3 = function() {
  const vec = create5();
  return function(a2, stride, offset, count2, fn, arg) {
    let i2;
    let l2;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count2) {
      l2 = Math.min(count2 * stride + offset, a2.length);
    } else {
      l2 = a2.length;
    }
    for (i2 = offset; i2 < l2; i2 += stride) {
      vec[0] = a2[i2];
      vec[1] = a2[i2 + 1];
      vec[2] = a2[i2 + 2];
      vec[3] = a2[i2 + 3];
      fn(vec, vec, arg);
      a2[i2] = vec[0];
      a2[i2 + 1] = vec[1];
      a2[i2 + 2] = vec[2];
      a2[i2 + 3] = vec[3];
    }
    return a2;
  };
}();

// node_modules/@math.gl/core/dist/classes/matrix4.js
var INDICES2;
(function(INDICES3) {
  INDICES3[INDICES3["COL0ROW0"] = 0] = "COL0ROW0";
  INDICES3[INDICES3["COL0ROW1"] = 1] = "COL0ROW1";
  INDICES3[INDICES3["COL0ROW2"] = 2] = "COL0ROW2";
  INDICES3[INDICES3["COL0ROW3"] = 3] = "COL0ROW3";
  INDICES3[INDICES3["COL1ROW0"] = 4] = "COL1ROW0";
  INDICES3[INDICES3["COL1ROW1"] = 5] = "COL1ROW1";
  INDICES3[INDICES3["COL1ROW2"] = 6] = "COL1ROW2";
  INDICES3[INDICES3["COL1ROW3"] = 7] = "COL1ROW3";
  INDICES3[INDICES3["COL2ROW0"] = 8] = "COL2ROW0";
  INDICES3[INDICES3["COL2ROW1"] = 9] = "COL2ROW1";
  INDICES3[INDICES3["COL2ROW2"] = 10] = "COL2ROW2";
  INDICES3[INDICES3["COL2ROW3"] = 11] = "COL2ROW3";
  INDICES3[INDICES3["COL3ROW0"] = 12] = "COL3ROW0";
  INDICES3[INDICES3["COL3ROW1"] = 13] = "COL3ROW1";
  INDICES3[INDICES3["COL3ROW2"] = 14] = "COL3ROW2";
  INDICES3[INDICES3["COL3ROW3"] = 15] = "COL3ROW3";
})(INDICES2 || (INDICES2 = {}));
var DEFAULT_FOVY = 45 * Math.PI / 180;
var DEFAULT_ASPECT = 1;
var DEFAULT_NEAR = 0.1;
var DEFAULT_FAR = 500;
var IDENTITY_MATRIX2 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
var Matrix4 = class extends Matrix {
  static get IDENTITY() {
    return getIdentityMatrix();
  }
  static get ZERO() {
    return getZeroMatrix();
  }
  get ELEMENTS() {
    return 16;
  }
  get RANK() {
    return 4;
  }
  get INDICES() {
    return INDICES2;
  }
  constructor(array) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
    if (arguments.length === 1 && Array.isArray(array)) {
      this.copy(array);
    } else {
      this.identity();
    }
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    this[4] = array[4];
    this[5] = array[5];
    this[6] = array[6];
    this[7] = array[7];
    this[8] = array[8];
    this[9] = array[9];
    this[10] = array[10];
    this[11] = array[11];
    this[12] = array[12];
    this[13] = array[13];
    this[14] = array[14];
    this[15] = array[15];
    return this.check();
  }
  // eslint-disable-next-line max-params
  set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m30;
    this[4] = m01;
    this[5] = m11;
    this[6] = m21;
    this[7] = m31;
    this[8] = m02;
    this[9] = m12;
    this[10] = m22;
    this[11] = m32;
    this[12] = m03;
    this[13] = m13;
    this[14] = m23;
    this[15] = m33;
    return this.check();
  }
  // accepts row major order, stores as column major
  // eslint-disable-next-line max-params
  setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m30;
    this[4] = m01;
    this[5] = m11;
    this[6] = m21;
    this[7] = m31;
    this[8] = m02;
    this[9] = m12;
    this[10] = m22;
    this[11] = m32;
    this[12] = m03;
    this[13] = m13;
    this[14] = m23;
    this[15] = m33;
    return this.check();
  }
  toRowMajor(result) {
    result[0] = this[0];
    result[1] = this[4];
    result[2] = this[8];
    result[3] = this[12];
    result[4] = this[1];
    result[5] = this[5];
    result[6] = this[9];
    result[7] = this[13];
    result[8] = this[2];
    result[9] = this[6];
    result[10] = this[10];
    result[11] = this[14];
    result[12] = this[3];
    result[13] = this[7];
    result[14] = this[11];
    result[15] = this[15];
    return result;
  }
  // Constructors
  /** Set to identity matrix */
  identity() {
    return this.copy(IDENTITY_MATRIX2);
  }
  /**
   *
   * @param object
   * @returns self
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fromObject(object) {
    return this.check();
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   * @param quaternion Quaternion to create matrix from
   * @returns self
   */
  fromQuaternion(quaternion) {
    fromQuat3(this, quaternion);
    return this.check();
  }
  /**
   * Generates a frustum matrix with the given bounds
   * @param view.left - Left bound of the frustum
   * @param view.right - Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top - Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far - Far bound of the frustum. Can be set to Infinity.
   * @returns self
   */
  frustum(view) {
    const { left, right, bottom, top, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
    if (far === Infinity) {
      computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
    } else {
      frustum(this, left, right, bottom, top, near, far);
    }
    return this.check();
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point,
   * and up axis
   * @param view.eye - (vector) Position of the viewer
   * @param view.center - (vector) Point the viewer is looking at
   * @param view.up - (vector) Up axis
   * @returns self
   */
  lookAt(view) {
    const { eye, center = [0, 0, 0], up = [0, 1, 0] } = view;
    lookAt(this, eye, center, up);
    return this.check();
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds
   * from "traditional" view space parameters
   * @param view.left - Left bound of the frustum
   * @param view.right number  Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top number  Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far number  Far bound of the frustum
   * @returns self
   */
  ortho(view) {
    const { left, right, bottom, top, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
    ortho(this, left, right, bottom, top, near, far);
    return this.check();
  }
  /**
   * Generates an orthogonal projection matrix with the same parameters
   * as a perspective matrix (plus focalDistance)
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. Typically viewport width / viewport height
   * @param view.focalDistance Distance in the view frustum used for extent calculations
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  orthographic(view) {
    const { fovy = DEFAULT_FOVY, aspect = DEFAULT_ASPECT, focalDistance = 1, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
    checkRadians(fovy);
    const halfY = fovy / 2;
    const top = focalDistance * Math.tan(halfY);
    const right = top * aspect;
    return this.ortho({
      left: -right,
      right,
      bottom: -top,
      top,
      near,
      far
    });
  }
  /**
   * Generates a perspective projection matrix with the given bounds
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. typically viewport width/height
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  perspective(view) {
    const { fovy = 45 * Math.PI / 180, aspect = 1, near = 0.1, far = 500 } = view;
    checkRadians(fovy);
    perspective(this, fovy, aspect, near, far);
    return this.check();
  }
  // Accessors
  determinant() {
    return determinant2(this);
  }
  /**
   * Extracts the non-uniform scale assuming the matrix is an affine transformation.
   * The scales are the "lengths" of the column vectors in the upper-left 3x3 matrix.
   * @param result
   * @returns self
   */
  getScale(result = [-0, -0, -0]) {
    result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
    result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
    result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
    return result;
  }
  /**
   * Gets the translation portion, assuming the matrix is a affine transformation matrix.
   * @param result
   * @returns self
   */
  getTranslation(result = [-0, -0, -0]) {
    result[0] = this[12];
    result[1] = this[13];
    result[2] = this[14];
    return result;
  }
  /**
   * Gets upper left 3x3 pure rotation matrix (non-scaling), assume affine transformation matrix
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotation(result, scaleResult) {
    result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
    scaleResult = scaleResult || [-0, -0, -0];
    const scale7 = this.getScale(scaleResult);
    const inverseScale0 = 1 / scale7[0];
    const inverseScale1 = 1 / scale7[1];
    const inverseScale2 = 1 / scale7[2];
    result[0] = this[0] * inverseScale0;
    result[1] = this[1] * inverseScale1;
    result[2] = this[2] * inverseScale2;
    result[3] = 0;
    result[4] = this[4] * inverseScale0;
    result[5] = this[5] * inverseScale1;
    result[6] = this[6] * inverseScale2;
    result[7] = 0;
    result[8] = this[8] * inverseScale0;
    result[9] = this[9] * inverseScale1;
    result[10] = this[10] * inverseScale2;
    result[11] = 0;
    result[12] = 0;
    result[13] = 0;
    result[14] = 0;
    result[15] = 1;
    return result;
  }
  /**
   *
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotationMatrix3(result, scaleResult) {
    result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
    scaleResult = scaleResult || [-0, -0, -0];
    const scale7 = this.getScale(scaleResult);
    const inverseScale0 = 1 / scale7[0];
    const inverseScale1 = 1 / scale7[1];
    const inverseScale2 = 1 / scale7[2];
    result[0] = this[0] * inverseScale0;
    result[1] = this[1] * inverseScale1;
    result[2] = this[2] * inverseScale2;
    result[3] = this[4] * inverseScale0;
    result[4] = this[5] * inverseScale1;
    result[5] = this[6] * inverseScale2;
    result[6] = this[8] * inverseScale0;
    result[7] = this[9] * inverseScale1;
    result[8] = this[10] * inverseScale2;
    return result;
  }
  // Modifiers
  transpose() {
    transpose2(this, this);
    return this.check();
  }
  invert() {
    invert2(this, this);
    return this.check();
  }
  // Operations
  multiplyLeft(a2) {
    multiply4(this, a2, this);
    return this.check();
  }
  multiplyRight(a2) {
    multiply4(this, this, a2);
    return this.check();
  }
  // Rotates a matrix by the given angle around the X axis
  rotateX(radians2) {
    rotateX2(this, this, radians2);
    return this.check();
  }
  // Rotates a matrix by the given angle around the Y axis.
  rotateY(radians2) {
    rotateY2(this, this, radians2);
    return this.check();
  }
  /**
   * Rotates a matrix by the given angle around the Z axis.
   * @param radians
   * @returns self
   */
  rotateZ(radians2) {
    rotateZ2(this, this, radians2);
    return this.check();
  }
  /**
   *
   * @param param0
   * @returns self
   */
  rotateXYZ(angleXYZ) {
    return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
  }
  /**
   *
   * @param radians
   * @param axis
   * @returns self
   */
  rotateAxis(radians2, axis) {
    rotate3(this, this, radians2, axis);
    return this.check();
  }
  /**
   *
   * @param factor
   * @returns self
   */
  scale(factor) {
    scale4(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
    return this.check();
  }
  /**
   *
   * @param vec
   * @returns self
   */
  translate(vector) {
    translate2(this, this, vector);
    return this.check();
  }
  // Transforms
  /**
   * Transforms any 2, 3 or 4 element vector. 2 and 3 elements are treated as points
   * @param vector
   * @param result
   * @returns self
   */
  transform(vector, result) {
    if (vector.length === 4) {
      result = transformMat43(result || [-0, -0, -0, -0], vector, this);
      checkVector(result, 4);
      return result;
    }
    return this.transformAsPoint(vector, result);
  }
  /**
   * Transforms any 2 or 3 element array as point (w implicitly 1)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsPoint(vector, result) {
    const { length: length5 } = vector;
    let out;
    switch (length5) {
      case 2:
        out = transformMat4(result || [-0, -0], vector, this);
        break;
      case 3:
        out = transformMat42(result || [-0, -0, -0], vector, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    checkVector(out, vector.length);
    return out;
  }
  /**
   * Transforms any 2 or 3 element array as vector (w implicitly 0)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsVector(vector, result) {
    let out;
    switch (vector.length) {
      case 2:
        out = vec2_transformMat4AsVector(result || [-0, -0], vector, this);
        break;
      case 3:
        out = vec3_transformMat4AsVector(result || [-0, -0, -0], vector, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    checkVector(out, vector.length);
    return out;
  }
  /** @deprecated */
  transformPoint(vector, result) {
    return this.transformAsPoint(vector, result);
  }
  /** @deprecated */
  transformVector(vector, result) {
    return this.transformAsPoint(vector, result);
  }
  /** @deprecated */
  transformDirection(vector, result) {
    return this.transformAsVector(vector, result);
  }
  // three.js math API compatibility
  makeRotationX(radians2) {
    return this.identity().rotateX(radians2);
  }
  makeTranslation(x2, y2, z2) {
    return this.identity().translate([x2, y2, z2]);
  }
};
var ZERO2;
var IDENTITY;
function getZeroMatrix() {
  if (!ZERO2) {
    ZERO2 = new Matrix4([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    Object.freeze(ZERO2);
  }
  return ZERO2;
}
function getIdentityMatrix() {
  if (!IDENTITY) {
    IDENTITY = new Matrix4();
    Object.freeze(IDENTITY);
  }
  return IDENTITY;
}
function checkRadians(possiblyDegrees) {
  if (possiblyDegrees > Math.PI * 2) {
    throw Error("expected radians");
  }
}
function computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
  const column0Row0 = 2 * near / (right - left);
  const column1Row1 = 2 * near / (top - bottom);
  const column2Row0 = (right + left) / (right - left);
  const column2Row1 = (top + bottom) / (top - bottom);
  const column2Row2 = -1;
  const column2Row3 = -1;
  const column3Row2 = -2 * near;
  result[0] = column0Row0;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = column1Row1;
  result[6] = 0;
  result[7] = 0;
  result[8] = column2Row0;
  result[9] = column2Row1;
  result[10] = column2Row2;
  result[11] = column2Row3;
  result[12] = 0;
  result[13] = 0;
  result[14] = column3Row2;
  result[15] = 0;
  return result;
}

// node_modules/@math.gl/core/dist/gl-matrix/quat.js
var quat_exports = {};
__export(quat_exports, {
  add: () => add6,
  calculateW: () => calculateW,
  clone: () => clone6,
  conjugate: () => conjugate,
  copy: () => copy6,
  create: () => create6,
  dot: () => dot4,
  equals: () => equals7,
  exactEquals: () => exactEquals6,
  exp: () => exp,
  fromMat3: () => fromMat3,
  fromValues: () => fromValues6,
  getAngle: () => getAngle,
  getAxisAngle: () => getAxisAngle,
  identity: () => identity3,
  invert: () => invert3,
  len: () => len4,
  length: () => length4,
  lerp: () => lerp5,
  ln: () => ln,
  mul: () => mul6,
  multiply: () => multiply6,
  normalize: () => normalize4,
  pow: () => pow,
  rotateX: () => rotateX3,
  rotateY: () => rotateY3,
  rotateZ: () => rotateZ3,
  rotationTo: () => rotationTo,
  scale: () => scale6,
  set: () => set6,
  setAxes: () => setAxes,
  setAxisAngle: () => setAxisAngle,
  slerp: () => slerp2,
  sqlerp: () => sqlerp,
  sqrLen: () => sqrLen4,
  squaredLength: () => squaredLength4,
  str: () => str6
});
function create6() {
  const out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity3(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  const s2 = Math.sin(rad);
  out[0] = s2 * axis[0];
  out[1] = s2 * axis[1];
  out[2] = s2 * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function getAxisAngle(out_axis, q2) {
  const rad = Math.acos(q2[3]) * 2;
  const s2 = Math.sin(rad / 2);
  if (s2 > EPSILON) {
    out_axis[0] = q2[0] / s2;
    out_axis[1] = q2[1] / s2;
    out_axis[2] = q2[2] / s2;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
function getAngle(a2, b2) {
  const dotproduct = dot4(a2, b2);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply6(out, a2, b2) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const aw = a2[3];
  const bx = b2[0];
  const by = b2[1];
  const bz = b2[2];
  const bw = b2[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX3(out, a2, rad) {
  rad *= 0.5;
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const aw = a2[3];
  const bx = Math.sin(rad);
  const bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY3(out, a2, rad) {
  rad *= 0.5;
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const aw = a2[3];
  const by = Math.sin(rad);
  const bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ3(out, a2, rad) {
  rad *= 0.5;
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const aw = a2[3];
  const bz = Math.sin(rad);
  const bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  out[3] = Math.sqrt(Math.abs(1 - x2 * x2 - y2 * y2 - z2 * z2));
  return out;
}
function exp(out, a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  const w2 = a2[3];
  const r2 = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
  const et2 = Math.exp(w2);
  const s2 = r2 > 0 ? et2 * Math.sin(r2) / r2 : 0;
  out[0] = x2 * s2;
  out[1] = y2 * s2;
  out[2] = z2 * s2;
  out[3] = et2 * Math.cos(r2);
  return out;
}
function ln(out, a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  const w2 = a2[3];
  const r2 = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
  const t2 = r2 > 0 ? Math.atan2(r2, w2) / r2 : 0;
  out[0] = x2 * t2;
  out[1] = y2 * t2;
  out[2] = z2 * t2;
  out[3] = 0.5 * Math.log(x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2);
  return out;
}
function pow(out, a2, b2) {
  ln(out, a2);
  scale6(out, out, b2);
  exp(out, out);
  return out;
}
function slerp2(out, a2, b2, t2) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const aw = a2[3];
  let bx = b2[0];
  let by = b2[1];
  let bz = b2[2];
  let bw = b2[3];
  let cosom;
  let omega;
  let scale0;
  let scale1;
  let sinom;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t2) * omega) / sinom;
    scale1 = Math.sin(t2 * omega) / sinom;
  } else {
    scale0 = 1 - t2;
    scale1 = t2;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function invert3(out, a2) {
  const a0 = a2[0];
  const a1 = a2[1];
  const a22 = a2[2];
  const a3 = a2[3];
  const dot5 = a0 * a0 + a1 * a1 + a22 * a22 + a3 * a3;
  const invDot = dot5 ? 1 / dot5 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a22 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function conjugate(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  out[3] = a2[3];
  return out;
}
function fromMat3(out, m2) {
  const fTrace = m2[0] + m2[4] + m2[8];
  let fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m2[5] - m2[7]) * fRoot;
    out[1] = (m2[6] - m2[2]) * fRoot;
    out[2] = (m2[1] - m2[3]) * fRoot;
  } else {
    let i2 = 0;
    if (m2[4] > m2[0])
      i2 = 1;
    if (m2[8] > m2[i2 * 3 + i2])
      i2 = 2;
    const j2 = (i2 + 1) % 3;
    const k2 = (i2 + 2) % 3;
    fRoot = Math.sqrt(m2[i2 * 3 + i2] - m2[j2 * 3 + j2] - m2[k2 * 3 + k2] + 1);
    out[i2] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m2[j2 * 3 + k2] - m2[k2 * 3 + j2]) * fRoot;
    out[j2] = (m2[j2 * 3 + i2] + m2[i2 * 3 + j2]) * fRoot;
    out[k2] = (m2[k2 * 3 + i2] + m2[i2 * 3 + k2]) * fRoot;
  }
  return out;
}
function str6(a2) {
  return `quat(${a2[0]}, ${a2[1]}, ${a2[2]}, ${a2[3]})`;
}
var clone6 = clone5;
var fromValues6 = fromValues5;
var copy6 = copy5;
var set6 = set5;
var add6 = add5;
var mul6 = multiply6;
var scale6 = scale5;
var dot4 = dot3;
var lerp5 = lerp4;
var length4 = length3;
var len4 = length4;
var squaredLength4 = squaredLength3;
var sqrLen4 = squaredLength4;
var normalize4 = normalize3;
var exactEquals6 = exactEquals5;
function equals7(a2, b2) {
  return Math.abs(dot3(a2, b2)) >= 1 - EPSILON;
}
var rotationTo = function() {
  const tmpvec3 = create2();
  const xUnitVec3 = fromValues2(1, 0, 0);
  const yUnitVec3 = fromValues2(0, 1, 0);
  return function(out, a2, b2) {
    const dot5 = dot2(a2, b2);
    if (dot5 < -0.999999) {
      cross2(tmpvec3, xUnitVec3, a2);
      if (len2(tmpvec3) < 1e-6)
        cross2(tmpvec3, yUnitVec3, a2);
      normalize2(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot5 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    }
    cross2(tmpvec3, a2, b2);
    out[0] = tmpvec3[0];
    out[1] = tmpvec3[1];
    out[2] = tmpvec3[2];
    out[3] = 1 + dot5;
    return normalize4(out, out);
  };
}();
var sqlerp = function() {
  const temp1 = create6();
  const temp2 = create6();
  return function(out, a2, b2, c2, d2, t2) {
    slerp2(temp1, a2, d2, t2);
    slerp2(temp2, b2, c2, t2);
    slerp2(out, temp1, temp2, 2 * t2 * (1 - t2));
    return out;
  };
}();
var setAxes = function() {
  const matr = create3();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize4(out, fromMat3(out, matr));
  };
}();

// node_modules/@math.gl/core/dist/classes/spherical-coordinates.js
var EPSILON2 = 1e-6;
var EARTH_RADIUS_METERS = 6371e3;
var SphericalCoordinates = class _SphericalCoordinates {
  // bearing: number;
  // pitch: number;
  // altitude: number;
  // lnglatZ coordinates
  // longitude: number;
  // latitude: number;
  // lng: number;
  // lat: number;
  // z: number;
  /**
   * Creates a new SphericalCoordinates object
   * @param options
   * @param [options.phi] =0 - rotation around X (latitude)
   * @param [options.theta] =0 - rotation around Y (longitude)
   * @param [options.radius] =1 - Distance from center
   * @param [options.bearing]
   * @param [options.pitch]
   * @param [options.altitude]
   * @param [options.radiusScale] =1
   */
  // eslint-disable-next-line complexity
  constructor({ phi = 0, theta = 0, radius = 1, bearing, pitch, altitude, radiusScale = EARTH_RADIUS_METERS } = {}) {
    this.phi = phi;
    this.theta = theta;
    this.radius = radius || altitude || 1;
    this.radiusScale = radiusScale || 1;
    if (bearing !== void 0) {
      this.bearing = bearing;
    }
    if (pitch !== void 0) {
      this.pitch = pitch;
    }
    this.check();
  }
  toString() {
    return this.formatString(config);
  }
  formatString({ printTypes = false }) {
    const f2 = formatValue;
    return `${printTypes ? "Spherical" : ""}[rho:${f2(this.radius)},theta:${f2(this.theta)},phi:${f2(this.phi)}]`;
  }
  equals(other) {
    return equals(this.radius, other.radius) && equals(this.theta, other.theta) && equals(this.phi, other.phi);
  }
  exactEquals(other) {
    return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;
  }
  /* eslint-disable brace-style */
  // Cartographic (bearing 0 north, pitch 0 look from above)
  get bearing() {
    return 180 - degrees(this.phi);
  }
  set bearing(v2) {
    this.phi = Math.PI - radians(v2);
  }
  get pitch() {
    return degrees(this.theta);
  }
  set pitch(v2) {
    this.theta = radians(v2);
  }
  // get pitch() { return 90 - degrees(this.phi); }
  // set pitch(v) { this.phi = radians(v) + Math.PI / 2; }
  // get altitude() { return this.radius - 1; } // relative altitude
  // lnglatZ coordinates
  get longitude() {
    return degrees(this.phi);
  }
  get latitude() {
    return degrees(this.theta);
  }
  get lng() {
    return degrees(this.phi);
  }
  get lat() {
    return degrees(this.theta);
  }
  get z() {
    return (this.radius - 1) * this.radiusScale;
  }
  /* eslint-enable brace-style */
  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this.check();
  }
  clone() {
    return new _SphericalCoordinates().copy(this);
  }
  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this.check();
  }
  fromLngLatZ([lng, lat, z2]) {
    this.radius = 1 + z2 / this.radiusScale;
    this.phi = radians(lat);
    this.theta = radians(lng);
    return this.check();
  }
  fromVector3(v2) {
    this.radius = length2(v2);
    if (this.radius > 0) {
      this.theta = Math.atan2(v2[0], v2[1]);
      this.phi = Math.acos(clamp(v2[2] / this.radius, -1, 1));
    }
    return this.check();
  }
  toVector3() {
    return new Vector3(0, 0, this.radius).rotateX({ radians: this.theta }).rotateZ({ radians: this.phi });
  }
  // restrict phi to be betwee EPS and PI-EPS
  makeSafe() {
    this.phi = Math.max(EPSILON2, Math.min(Math.PI - EPSILON2, this.phi));
    return this;
  }
  check() {
    if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {
      throw new Error("SphericalCoordinates: some fields set to invalid numbers");
    }
    return this;
  }
};

// node_modules/@math.gl/core/dist/classes/euler.js
var RotationOrder;
(function(RotationOrder2) {
  RotationOrder2[RotationOrder2["ZYX"] = 0] = "ZYX";
  RotationOrder2[RotationOrder2["YXZ"] = 1] = "YXZ";
  RotationOrder2[RotationOrder2["XZY"] = 2] = "XZY";
  RotationOrder2[RotationOrder2["ZXY"] = 3] = "ZXY";
  RotationOrder2[RotationOrder2["YZX"] = 4] = "YZX";
  RotationOrder2[RotationOrder2["XYZ"] = 5] = "XYZ";
})(RotationOrder || (RotationOrder = {}));

// node_modules/@math.gl/core/dist/lib/math-utils.js
var math_utils_exports = {};
__export(math_utils_exports, {
  EPSILON1: () => EPSILON1,
  EPSILON10: () => EPSILON10,
  EPSILON11: () => EPSILON11,
  EPSILON12: () => EPSILON12,
  EPSILON13: () => EPSILON13,
  EPSILON14: () => EPSILON14,
  EPSILON15: () => EPSILON15,
  EPSILON16: () => EPSILON16,
  EPSILON17: () => EPSILON17,
  EPSILON18: () => EPSILON18,
  EPSILON19: () => EPSILON19,
  EPSILON2: () => EPSILON22,
  EPSILON20: () => EPSILON20,
  EPSILON3: () => EPSILON3,
  EPSILON4: () => EPSILON4,
  EPSILON5: () => EPSILON5,
  EPSILON6: () => EPSILON6,
  EPSILON7: () => EPSILON7,
  EPSILON8: () => EPSILON8,
  EPSILON9: () => EPSILON9,
  PI_OVER_FOUR: () => PI_OVER_FOUR,
  PI_OVER_SIX: () => PI_OVER_SIX,
  PI_OVER_TWO: () => PI_OVER_TWO,
  TWO_PI: () => TWO_PI
});
var EPSILON1 = 0.1;
var EPSILON22 = 0.01;
var EPSILON3 = 1e-3;
var EPSILON4 = 1e-4;
var EPSILON5 = 1e-5;
var EPSILON6 = 1e-6;
var EPSILON7 = 1e-7;
var EPSILON8 = 1e-8;
var EPSILON9 = 1e-9;
var EPSILON10 = 1e-10;
var EPSILON11 = 1e-11;
var EPSILON12 = 1e-12;
var EPSILON13 = 1e-13;
var EPSILON14 = 1e-14;
var EPSILON15 = 1e-15;
var EPSILON16 = 1e-16;
var EPSILON17 = 1e-17;
var EPSILON18 = 1e-18;
var EPSILON19 = 1e-19;
var EPSILON20 = 1e-20;
var PI_OVER_TWO = Math.PI / 2;
var PI_OVER_FOUR = Math.PI / 4;
var PI_OVER_SIX = Math.PI / 6;
var TWO_PI = Math.PI * 2;

// node_modules/@luma.gl/shadertools/dist/modules/math/fp16/fp16-utils.js
var buffer = new ArrayBuffer(4);
var floatView = new Float32Array(buffer);
var uint32View = new Uint32Array(buffer);

// node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-utils.js
function fp64ify(a2, out = [], startIndex = 0) {
  const hiPart = Math.fround(a2);
  const loPart = a2 - hiPart;
  out[startIndex] = hiPart;
  out[startIndex + 1] = loPart;
  return out;
}
function fp64LowPart(a2) {
  return a2 - Math.fround(a2);
}
function fp64ifyMatrix4(matrix) {
  const matrixFP64 = new Float32Array(32);
  for (let i2 = 0; i2 < 4; ++i2) {
    for (let j2 = 0; j2 < 4; ++j2) {
      const index = i2 * 4 + j2;
      fp64ify(matrix[j2 * 4 + i2], matrixFP64, index * 2);
    }
  }
  return matrixFP64;
}

// node_modules/@luma.gl/shadertools/dist/modules/math/fp32/fp32.js
var fp32shader = (
  /* glsl */
  `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND

// All these functions are for substituting tan() function from Intel GPU only
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;

const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;

const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;

const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!

float sin_taylor_fp32(float a) {
  float r, s, t, x;

  if (a == 0.0) {
    return 0.0;
  }

  x = -a * a;
  s = a;
  r = a;

  r = r * x;
  t = r * INVERSE_FACTORIAL_3;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_5;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_7;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_9;
  s = s + t;

  return s;
}

void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
  if (a == 0.0) {
    sin_t = 0.0;
    cos_t = 1.0;
  }
  sin_t = sin_taylor_fp32(a);
  cos_t = sqrt(1.0 - sin_t * sin_t);
}

float tan_taylor_fp32(float a) {
    float sin_a;
    float cos_a;

    if (a == 0.0) {
        return 0.0;
    }

    // 2pi range reduction
    float z = floor(a / TWO_PI);
    float r = a - TWO_PI * z;

    float t;
    float q = floor(r / PI_2 + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return 1.0 / 0.0;
    }

    t = r - PI_2 * q;

    q = floor(t / PI_16 + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return 1.0 / 0.0;
    } else {
        t = t - PI_16 * q;
    }

    float u = 0.0;
    float v = 0.0;

    float sin_t, cos_t;
    float s, c;
    sincos_taylor_fp32(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0;
            v = SIN_TABLE_0;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1;
            v = SIN_TABLE_1;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2;
            v = SIN_TABLE_2;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3;
            v = SIN_TABLE_3;
        }
        if (k > 0) {
            s = u * sin_t + v * cos_t;
            c = u * cos_t - v * sin_t;
        } else {
            s = u * sin_t - v * cos_t;
            c = u * cos_t + v * sin_t;
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return sin_a / cos_a;
}
#endif

float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
  return tan_taylor_fp32(a);
#else
  return tan(a);
#endif
}
`
);
var fp32 = {
  name: "fp32",
  vs: fp32shader
};

// node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-arithmetic-glsl.js
var fp64arithmeticShader = (
  /* glsl */
  `
uniform fp64arithmeticUniforms {
  uniform float ONE;
} fp64;

/*
About LUMA_FP64_CODE_ELIMINATION_WORKAROUND

The purpose of this workaround is to prevent shader compilers from
optimizing away necessary arithmetic operations by swapping their sequences
or transform the equation to some 'equivalent' form.

The method is to multiply an artifical variable, ONE, which will be known to
the compiler to be 1 only at runtime. The whole expression is then represented
as a polynomial with respective to ONE. In the coefficients of all terms, only one a
and one b should appear

err = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE
*/

// Divide float number to high and low floats to extend fraction bits
vec2 split(float a) {
  const float SPLIT = 4097.0;
  float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float a_hi = t * fp64.ONE - (t - a);
  float a_lo = a * fp64.ONE - a_hi;
#else
  float a_hi = t - (t - a);
  float a_lo = a - a_hi;
#endif
  return vec2(a_hi, a_lo);
}

// Divide float number again when high float uses too many fraction bits
vec2 split2(vec2 a) {
  vec2 b = split(a.x);
  b.y += a.y;
  return b;
}

// Special sum operation when a > b
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float sum = (a + b) * fp64.ONE;
  float err = b - (sum - a) * fp64.ONE;
#else
  float sum = a + b;
  float err = b - (sum - a);
#endif
  return vec2(sum, err);
}

// General sum operation
vec2 twoSum(float a, float b) {
  float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE + (b - v);
#else
  float v = s - a;
  float err = (a - (s - v)) + (b - v);
#endif
  return vec2(s, err);
}

vec2 twoSub(float a, float b) {
  float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE - (b + v);
#else
  float v = s - a;
  float err = (a - (s - v)) - (b + v);
#endif
  return vec2(s, err);
}

vec2 twoSqr(float a) {
  float prod = a * a;
  vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float err = ((a_fp64.x * a_fp64.x - prod) * fp64.ONE + 2.0 * a_fp64.x *
    a_fp64.y * fp64.ONE * fp64.ONE) + a_fp64.y * a_fp64.y * fp64.ONE * fp64.ONE * fp64.ONE;
#else
  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
  return vec2(prod, err);
}

vec2 twoProd(float a, float b) {
  float prod = a * b;
  vec2 a_fp64 = split(a);
  vec2 b_fp64 = split(b);
  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
  return vec2(prod, err);
}

vec2 sum_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSum(a.x, b.x);
  t = twoSum(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 sub_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSub(a.x, b.x);
  t = twoSub(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 mul_fp64(vec2 a, vec2 b) {
  vec2 prod = twoProd(a.x, b.x);
  // y component is for the error
  prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  return prod;
}

vec2 div_fp64(vec2 a, vec2 b) {
  float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
  vec2 yn = a * xn;
#endif
  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
  vec2 prod = twoProd(xn, diff);
  return sum_fp64(yn, prod);
}

vec2 sqrt_fp64(vec2 a) {
  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);

  float x = 1.0 / sqrt(a.x);
  float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  vec2 yn_sqr = twoSqr(yn) * fp64.ONE;
#else
  vec2 yn_sqr = twoSqr(yn);
#endif
  float diff = sub_fp64(a, yn_sqr).x;
  vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  return sum_fp64(split(yn), prod);
#else
  return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`
);

// node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64.js
var defaultUniforms = {
  // Used in LUMA_FP64_CODE_ELIMINATION_WORKAROUND
  ONE: 1
};
var fp64arithmetic = {
  name: "fp64arithmetic",
  vs: fp64arithmeticShader,
  defaultUniforms,
  uniformTypes: { ONE: "f32" },
  // Additional Functions
  fp64ify,
  fp64LowPart,
  fp64ifyMatrix4
};

// node_modules/@luma.gl/shadertools/dist/modules/engine/picking/picking.js
var DEFAULT_HIGHLIGHT_COLOR = [0, 1, 1, 1];
var vs = (
  /* glsl */
  `uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

out vec4 picking_vRGBcolor_Avalid;

// Normalize unsigned byte color to 0-1 range
vec3 picking_normalizeColor(vec3 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

// Normalize unsigned byte color to 0-1 range
vec4 picking_normalizeColor(vec4 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

bool picking_isColorZero(vec3 color) {
  return dot(color, vec3(1.0)) < 0.00001;
}

bool picking_isColorValid(vec3 color) {
  return dot(color, vec3(1.0)) > 0.00001;
}

// Check if this vertex is highlighted 
bool isVertexHighlighted(vec3 vertexColor) {
  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
  return
    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}

// Set the current picking color
void picking_setPickingColor(vec3 pickingColor) {
  pickingColor = picking_normalizeColor(pickingColor);

  if (bool(picking.isActive)) {
    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable
    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));

    if (!bool(picking.isAttribute)) {
      // Stores the picking color so that the fragment shader can render it during picking
      picking_vRGBcolor_Avalid.rgb = pickingColor;
    }
  } else {
    // Do the comparison with selected item color in vertex shader as it should mean fewer compares
    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
  }
}

void picking_setPickingAttribute(float value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.r = value;
  }
}

void picking_setPickingAttribute(vec2 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rg = value;
  }
}

void picking_setPickingAttribute(vec3 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rgb = value;
  }
}
`
);
var fs = (
  /* glsl */
  `uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

in vec4 picking_vRGBcolor_Avalid;

/*
 * Returns highlight color if this item is selected.
 */
vec4 picking_filterHighlightColor(vec4 color) {
  // If we are still picking, we don't highlight
  if (picking.isActive > 0.5) {
    return color;
  }

  bool selected = bool(picking_vRGBcolor_Avalid.a);

  if (selected) {
    // Blend in highlight color based on its alpha value
    float highLightAlpha = picking.highlightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}

/*
 * Returns picking color if picking enabled else unmodified argument.
 */
vec4 picking_filterPickingColor(vec4 color) {
  if (bool(picking.isActive)) {
    if (picking_vRGBcolor_Avalid.a == 0.0) {
      discard;
    }
    return picking_vRGBcolor_Avalid;
  }
  return color;
}

/*
 * Returns picking color if picking is enabled if not
 * highlight color if this item is selected, otherwise unmodified argument.
 */
vec4 picking_filterColor(vec4 color) {
  vec4 highlightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highlightColor);
}
`
);
var picking = {
  props: {},
  uniforms: {},
  name: "picking",
  uniformTypes: {
    isActive: "f32",
    isAttribute: "f32",
    isHighlightActive: "f32",
    useFloatColors: "f32",
    highlightedObjectColor: "vec3<f32>",
    highlightColor: "vec4<f32>"
  },
  defaultUniforms: {
    isActive: false,
    isAttribute: false,
    isHighlightActive: false,
    useFloatColors: true,
    highlightedObjectColor: [0, 0, 0],
    highlightColor: DEFAULT_HIGHLIGHT_COLOR
  },
  vs,
  fs,
  getUniforms: getUniforms2
};
function getUniforms2(opts = {}, prevUniforms) {
  const uniforms = {};
  if (opts.highlightedObjectColor === void 0) {
  } else if (opts.highlightedObjectColor === null) {
    uniforms.isHighlightActive = false;
  } else {
    uniforms.isHighlightActive = true;
    const highlightedObjectColor = opts.highlightedObjectColor.slice(0, 3);
    uniforms.highlightedObjectColor = highlightedObjectColor;
  }
  if (opts.highlightColor) {
    const color = Array.from(opts.highlightColor, (x2) => x2 / 255);
    if (!Number.isFinite(color[3])) {
      color[3] = 1;
    }
    uniforms.highlightColor = color;
  }
  if (opts.isActive !== void 0) {
    uniforms.isActive = Boolean(opts.isActive);
    uniforms.isAttribute = Boolean(opts.isAttribute);
  }
  if (opts.useFloatColors !== void 0) {
    uniforms.useFloatColors = Boolean(opts.useFloatColors);
  }
  return uniforms;
}

// node_modules/@deck.gl/core/dist/shaderlib/color/color.js
var colorWGSL = (
  /* WGSL */
  `

struct ColorUniforms {
  opacity: f32,
};

var<private> color: ColorUniforms = ColorUniforms(1.0);
// TODO (kaapp) avoiding binding index collisions to handle layer opacity 
// requires some thought.
// @group(0) @binding(0) var<uniform> color: ColorUniforms;

@must_use
fn deckgl_premultiplied_alpha(fragColor: vec4<f32>) -> vec4<f32> {
    return vec4(fragColor.rgb * fragColor.a, fragColor.a); 
};
`
);
var color_default = {
  name: "color",
  dependencies: [],
  source: colorWGSL,
  getUniforms: (_props) => {
    return {};
  },
  uniformTypes: {
    opacity: "f32"
  }
  // @ts-ignore TODO v9.1
};

// node_modules/mjolnir.js/dist/hammerjs/input/input-consts.js
var COMPUTE_INTERVAL = 25;
var InputEvent;
(function(InputEvent2) {
  InputEvent2[InputEvent2["Start"] = 1] = "Start";
  InputEvent2[InputEvent2["Move"] = 2] = "Move";
  InputEvent2[InputEvent2["End"] = 4] = "End";
  InputEvent2[InputEvent2["Cancel"] = 8] = "Cancel";
})(InputEvent || (InputEvent = {}));
var InputDirection;
(function(InputDirection2) {
  InputDirection2[InputDirection2["None"] = 0] = "None";
  InputDirection2[InputDirection2["Left"] = 1] = "Left";
  InputDirection2[InputDirection2["Right"] = 2] = "Right";
  InputDirection2[InputDirection2["Up"] = 4] = "Up";
  InputDirection2[InputDirection2["Down"] = 8] = "Down";
  InputDirection2[InputDirection2["Horizontal"] = 3] = "Horizontal";
  InputDirection2[InputDirection2["Vertical"] = 12] = "Vertical";
  InputDirection2[InputDirection2["All"] = 15] = "All";
})(InputDirection || (InputDirection = {}));

// node_modules/mjolnir.js/dist/hammerjs/recognizer/recognizer-state.js
var RecognizerState;
(function(RecognizerState2) {
  RecognizerState2[RecognizerState2["Possible"] = 1] = "Possible";
  RecognizerState2[RecognizerState2["Began"] = 2] = "Began";
  RecognizerState2[RecognizerState2["Changed"] = 4] = "Changed";
  RecognizerState2[RecognizerState2["Ended"] = 8] = "Ended";
  RecognizerState2[RecognizerState2["Recognized"] = 8] = "Recognized";
  RecognizerState2[RecognizerState2["Cancelled"] = 16] = "Cancelled";
  RecognizerState2[RecognizerState2["Failed"] = 32] = "Failed";
})(RecognizerState || (RecognizerState = {}));

// node_modules/mjolnir.js/dist/hammerjs/touchaction/touchaction-Consts.js
var TOUCH_ACTION_COMPUTE = "compute";
var TOUCH_ACTION_AUTO = "auto";
var TOUCH_ACTION_MANIPULATION = "manipulation";
var TOUCH_ACTION_NONE = "none";
var TOUCH_ACTION_PAN_X = "pan-x";
var TOUCH_ACTION_PAN_Y = "pan-y";

// node_modules/mjolnir.js/dist/hammerjs/touchaction/clean-touch-actions.js
function cleanTouchActions(actions) {
  if (actions.includes(TOUCH_ACTION_NONE)) {
    return TOUCH_ACTION_NONE;
  }
  const hasPanX = actions.includes(TOUCH_ACTION_PAN_X);
  const hasPanY = actions.includes(TOUCH_ACTION_PAN_Y);
  if (hasPanX && hasPanY) {
    return TOUCH_ACTION_NONE;
  }
  if (hasPanX || hasPanY) {
    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
  }
  if (actions.includes(TOUCH_ACTION_MANIPULATION)) {
    return TOUCH_ACTION_MANIPULATION;
  }
  return TOUCH_ACTION_AUTO;
}

// node_modules/mjolnir.js/dist/hammerjs/touchaction/touchaction.js
var TouchAction = class {
  constructor(manager, value) {
    this.actions = "";
    this.manager = manager;
    this.set(value);
  }
  /**
   * set the touchAction value on the element or enable the polyfill
   */
  set(value) {
    if (value === TOUCH_ACTION_COMPUTE) {
      value = this.compute();
    }
    if (this.manager.element) {
      this.manager.element.style.touchAction = value;
      this.actions = value;
    }
  }
  /**
   * just re-set the touchAction value
   */
  update() {
    this.set(this.manager.options.touchAction);
  }
  /**
   * compute the value for the touchAction property based on the recognizer's settings
   */
  compute() {
    let actions = [];
    for (const recognizer of this.manager.recognizers) {
      if (recognizer.options.enable) {
        actions = actions.concat(recognizer.getTouchAction());
      }
    }
    return cleanTouchActions(actions.join(" "));
  }
};

// node_modules/mjolnir.js/dist/hammerjs/utils/split-str.js
function splitStr(str7) {
  return str7.trim().split(/\s+/g);
}

// node_modules/mjolnir.js/dist/hammerjs/utils/event-listeners.js
function addEventListeners(target, types, handler) {
  if (!target) {
    return;
  }
  for (const type of splitStr(types)) {
    target.addEventListener(type, handler, false);
  }
}
function removeEventListeners(target, types, handler) {
  if (!target) {
    return;
  }
  for (const type of splitStr(types)) {
    target.removeEventListener(type, handler, false);
  }
}

// node_modules/mjolnir.js/dist/hammerjs/utils/get-window-for-element.js
function getWindowForElement(element) {
  const doc = element.ownerDocument || element;
  return doc.defaultView;
}

// node_modules/mjolnir.js/dist/hammerjs/utils/has-parent.js
function hasParent(node, parent) {
  let ancestor = node;
  while (ancestor) {
    if (ancestor === parent) {
      return true;
    }
    ancestor = ancestor.parentNode;
  }
  return false;
}

// node_modules/mjolnir.js/dist/hammerjs/input/get-center.js
function getCenter(pointers) {
  const pointersLength = pointers.length;
  if (pointersLength === 1) {
    return {
      x: Math.round(pointers[0].clientX),
      y: Math.round(pointers[0].clientY)
    };
  }
  let x2 = 0;
  let y2 = 0;
  let i2 = 0;
  while (i2 < pointersLength) {
    x2 += pointers[i2].clientX;
    y2 += pointers[i2].clientY;
    i2++;
  }
  return {
    x: Math.round(x2 / pointersLength),
    y: Math.round(y2 / pointersLength)
  };
}

// node_modules/mjolnir.js/dist/hammerjs/input/simple-clone-input-data.js
function simpleCloneInputData(input) {
  const pointers = [];
  let i2 = 0;
  while (i2 < input.pointers.length) {
    pointers[i2] = {
      clientX: Math.round(input.pointers[i2].clientX),
      clientY: Math.round(input.pointers[i2].clientY)
    };
    i2++;
  }
  return {
    timeStamp: Date.now(),
    pointers,
    center: getCenter(pointers),
    deltaX: input.deltaX,
    deltaY: input.deltaY
  };
}

// node_modules/mjolnir.js/dist/hammerjs/input/get-distance.js
function getPointDistance(p1, p2) {
  const x2 = p2.x - p1.x;
  const y2 = p2.y - p1.y;
  return Math.sqrt(x2 * x2 + y2 * y2);
}
function getEventDistance(p1, p2) {
  const x2 = p2.clientX - p1.clientX;
  const y2 = p2.clientY - p1.clientY;
  return Math.sqrt(x2 * x2 + y2 * y2);
}

// node_modules/mjolnir.js/dist/hammerjs/input/get-angle.js
function getPointAngle(p1, p2) {
  const x2 = p2.x - p1.x;
  const y2 = p2.y - p1.y;
  return Math.atan2(y2, x2) * 180 / Math.PI;
}
function getEventAngle(p1, p2) {
  const x2 = p2.clientX - p1.clientX;
  const y2 = p2.clientY - p1.clientY;
  return Math.atan2(y2, x2) * 180 / Math.PI;
}

// node_modules/mjolnir.js/dist/hammerjs/input/get-direction.js
function getDirection(dx, dy) {
  if (dx === dy) {
    return InputDirection.None;
  }
  if (Math.abs(dx) >= Math.abs(dy)) {
    return dx < 0 ? InputDirection.Left : InputDirection.Right;
  }
  return dy < 0 ? InputDirection.Up : InputDirection.Down;
}

// node_modules/mjolnir.js/dist/hammerjs/input/get-delta-xy.js
function computeDeltaXY(session, input) {
  const center = input.center;
  let offset = session.offsetDelta;
  let prevDelta = session.prevDelta;
  const prevInput = session.prevInput;
  if (input.eventType === InputEvent.Start || (prevInput == null ? void 0 : prevInput.eventType) === InputEvent.End) {
    prevDelta = session.prevDelta = {
      x: (prevInput == null ? void 0 : prevInput.deltaX) || 0,
      y: (prevInput == null ? void 0 : prevInput.deltaY) || 0
    };
    offset = session.offsetDelta = {
      x: center.x,
      y: center.y
    };
  }
  return {
    deltaX: prevDelta.x + (center.x - offset.x),
    deltaY: prevDelta.y + (center.y - offset.y)
  };
}

// node_modules/mjolnir.js/dist/hammerjs/input/get-velocity.js
function getVelocity(deltaTime, x2, y2) {
  return {
    x: x2 / deltaTime || 0,
    y: y2 / deltaTime || 0
  };
}

// node_modules/mjolnir.js/dist/hammerjs/input/get-scale.js
function getScale(start, end) {
  return getEventDistance(end[0], end[1]) / getEventDistance(start[0], start[1]);
}

// node_modules/mjolnir.js/dist/hammerjs/input/get-rotation.js
function getRotation2(start, end) {
  return getEventAngle(end[1], end[0]) - getEventAngle(start[1], start[0]);
}

// node_modules/mjolnir.js/dist/hammerjs/input/compute-interval-input-data.js
function computeIntervalInputData(session, input) {
  const last = session.lastInterval || input;
  const deltaTime = input.timeStamp - last.timeStamp;
  let velocity;
  let velocityX;
  let velocityY;
  let direction;
  if (input.eventType !== InputEvent.Cancel && (deltaTime > COMPUTE_INTERVAL || last.velocity === void 0)) {
    const deltaX = input.deltaX - last.deltaX;
    const deltaY = input.deltaY - last.deltaY;
    const v2 = getVelocity(deltaTime, deltaX, deltaY);
    velocityX = v2.x;
    velocityY = v2.y;
    velocity = Math.abs(v2.x) > Math.abs(v2.y) ? v2.x : v2.y;
    direction = getDirection(deltaX, deltaY);
    session.lastInterval = input;
  } else {
    velocity = last.velocity;
    velocityX = last.velocityX;
    velocityY = last.velocityY;
    direction = last.direction;
  }
  input.velocity = velocity;
  input.velocityX = velocityX;
  input.velocityY = velocityY;
  input.direction = direction;
}

// node_modules/mjolnir.js/dist/hammerjs/input/compute-input-data.js
function computeInputData(manager, input) {
  const { session } = manager;
  const { pointers } = input;
  const { length: pointersLength } = pointers;
  if (!session.firstInput) {
    session.firstInput = simpleCloneInputData(input);
  }
  if (pointersLength > 1 && !session.firstMultiple) {
    session.firstMultiple = simpleCloneInputData(input);
  } else if (pointersLength === 1) {
    session.firstMultiple = false;
  }
  const { firstInput, firstMultiple } = session;
  const offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
  const center = input.center = getCenter(pointers);
  input.timeStamp = Date.now();
  input.deltaTime = input.timeStamp - firstInput.timeStamp;
  input.angle = getPointAngle(offsetCenter, center);
  input.distance = getPointDistance(offsetCenter, center);
  const { deltaX, deltaY } = computeDeltaXY(session, input);
  input.deltaX = deltaX;
  input.deltaY = deltaY;
  input.offsetDirection = getDirection(input.deltaX, input.deltaY);
  const overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
  input.overallVelocityX = overallVelocity.x;
  input.overallVelocityY = overallVelocity.y;
  input.overallVelocity = Math.abs(overallVelocity.x) > Math.abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
  input.rotation = firstMultiple ? getRotation2(firstMultiple.pointers, pointers) : 0;
  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
  let target = manager.element;
  if (hasParent(input.srcEvent.target, target)) {
    target = input.srcEvent.target;
  }
  input.target = target;
  computeIntervalInputData(session, input);
  return input;
}

// node_modules/mjolnir.js/dist/hammerjs/input/input-handler.js
function inputHandler(manager, eventType, input) {
  const pointersLen = input.pointers.length;
  const changedPointersLen = input.changedPointers.length;
  const isFirst = eventType & InputEvent.Start && pointersLen - changedPointersLen === 0;
  const isFinal = eventType & (InputEvent.End | InputEvent.Cancel) && pointersLen - changedPointersLen === 0;
  input.isFirst = Boolean(isFirst);
  input.isFinal = Boolean(isFinal);
  if (isFirst) {
    manager.session = {};
  }
  input.eventType = eventType;
  const processedInput = computeInputData(manager, input);
  manager.emit("hammer.input", processedInput);
  manager.recognize(processedInput);
  manager.session.prevInput = processedInput;
}

// node_modules/mjolnir.js/dist/hammerjs/input/input.js
var Input = class {
  constructor(manager) {
    this.evEl = "";
    this.evWin = "";
    this.evTarget = "";
    this.domHandler = (ev) => {
      if (this.manager.options.enable) {
        this.handler(ev);
      }
    };
    this.manager = manager;
    this.element = manager.element;
    this.target = manager.options.inputTarget || manager.element;
  }
  callback(eventType, input) {
    inputHandler(this.manager, eventType, input);
  }
  // eslint-disable @typescript-eslint/unbound-method
  /**
   * bind the events
   */
  init() {
    addEventListeners(this.element, this.evEl, this.domHandler);
    addEventListeners(this.target, this.evTarget, this.domHandler);
    addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
  }
  /**
   * unbind the events
   */
  destroy() {
    removeEventListeners(this.element, this.evEl, this.domHandler);
    removeEventListeners(this.target, this.evTarget, this.domHandler);
    removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
  }
};

// node_modules/mjolnir.js/dist/hammerjs/inputs/pointerevent.js
var POINTER_INPUT_MAP = {
  pointerdown: InputEvent.Start,
  pointermove: InputEvent.Move,
  pointerup: InputEvent.End,
  pointercancel: InputEvent.Cancel,
  pointerout: InputEvent.Cancel
};
var POINTER_ELEMENT_EVENTS = "pointerdown";
var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
var PointerEventInput = class extends Input {
  constructor(manager) {
    super(manager);
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;
    this.store = this.manager.session.pointerEvents = [];
    this.init();
  }
  /**
   * handle mouse events
   */
  handler(ev) {
    const { store } = this;
    let removePointer = false;
    const eventType = POINTER_INPUT_MAP[ev.type];
    const pointerType = ev.pointerType;
    const isTouch = pointerType === "touch";
    let storeIndex = store.findIndex((e3) => e3.pointerId === ev.pointerId);
    if (eventType & InputEvent.Start && (ev.buttons || isTouch)) {
      if (storeIndex < 0) {
        store.push(ev);
        storeIndex = store.length - 1;
      }
    } else if (eventType & (InputEvent.End | InputEvent.Cancel)) {
      removePointer = true;
    }
    if (storeIndex < 0) {
      return;
    }
    store[storeIndex] = ev;
    this.callback(eventType, {
      pointers: store,
      changedPointers: [ev],
      eventType,
      pointerType,
      srcEvent: ev
    });
    if (removePointer) {
      store.splice(storeIndex, 1);
    }
  }
};

// node_modules/mjolnir.js/dist/hammerjs/utils/prefixed.js
var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
function prefixed(obj, property) {
  const camelProp = property[0].toUpperCase() + property.slice(1);
  for (const prefix of VENDOR_PREFIXES) {
    const prop = prefix ? prefix + camelProp : property;
    if (prop in obj) {
      return prop;
    }
  }
  return void 0;
}

// node_modules/mjolnir.js/dist/hammerjs/manager.js
var STOP = 1;
var FORCED_STOP = 2;
var defaultOptions = {
  touchAction: "compute",
  enable: true,
  inputTarget: null,
  cssProps: {
    /**
     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
     */
    userSelect: "none",
    /**
     * (Webkit) Disable default dragging behavior
     */
    // @ts-ignore
    userDrag: "none",
    /**
     * (iOS only) Disables the default callout shown when you touch and hold a touch target.
     * When you touch and hold a touch target such as a link, Safari displays
     * a callout containing information about the link. This property allows you to disable that callout.
     */
    // @ts-ignore
    touchCallout: "none",
    /**
     * (iOS only) Sets the color of the highlight that appears over a link while it's being tapped.
     */
    // @ts-ignore
    tapHighlightColor: "rgba(0,0,0,0)"
  }
};
var Manager = class {
  constructor(element, options) {
    this.options = {
      ...defaultOptions,
      ...options,
      cssProps: { ...defaultOptions.cssProps, ...options.cssProps },
      inputTarget: options.inputTarget || element
    };
    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};
    this.element = element;
    this.input = new PointerEventInput(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);
    this.toggleCssProps(true);
  }
  /**
   * set options
   */
  set(options) {
    Object.assign(this.options, options);
    if (options.touchAction) {
      this.touchAction.update();
    }
    if (options.inputTarget) {
      this.input.destroy();
      this.input.target = options.inputTarget;
      this.input.init();
    }
    return this;
  }
  /**
   * stop recognizing for this session.
   * This session will be discarded, when a new [input]start event is fired.
   * When forced, the recognizer cycle is stopped immediately.
   */
  stop(force) {
    this.session.stopped = force ? FORCED_STOP : STOP;
  }
  /**
   * run the recognizers!
   * called by the inputHandler function on every movement of the pointers (touches)
   * it walks through all the recognizers and tries to detect the gesture that is being made
   */
  recognize(inputData) {
    const { session } = this;
    if (session.stopped) {
      return;
    }
    if (this.session.prevented) {
      inputData.srcEvent.preventDefault();
    }
    let recognizer;
    const { recognizers } = this;
    let { curRecognizer } = session;
    if (!curRecognizer || curRecognizer && curRecognizer.state & RecognizerState.Recognized) {
      curRecognizer = session.curRecognizer = null;
    }
    let i2 = 0;
    while (i2 < recognizers.length) {
      recognizer = recognizers[i2];
      if (session.stopped !== FORCED_STOP && // 1
      (!curRecognizer || recognizer === curRecognizer || // 2
      recognizer.canRecognizeWith(curRecognizer))) {
        recognizer.recognize(inputData);
      } else {
        recognizer.reset();
      }
      if (!curRecognizer && recognizer.state & (RecognizerState.Began | RecognizerState.Changed | RecognizerState.Ended)) {
        curRecognizer = session.curRecognizer = recognizer;
      }
      i2++;
    }
  }
  /**
   * get a recognizer by its event name.
   */
  get(recognizerName) {
    const { recognizers } = this;
    for (let i2 = 0; i2 < recognizers.length; i2++) {
      if (recognizers[i2].options.event === recognizerName) {
        return recognizers[i2];
      }
    }
    return null;
  }
  /**
   * add a recognizer to the manager
   * existing recognizers with the same event name will be removed
   */
  add(recognizer) {
    if (Array.isArray(recognizer)) {
      for (const item of recognizer) {
        this.add(item);
      }
      return this;
    }
    const existing = this.get(recognizer.options.event);
    if (existing) {
      this.remove(existing);
    }
    this.recognizers.push(recognizer);
    recognizer.manager = this;
    this.touchAction.update();
    return recognizer;
  }
  /**
   * remove a recognizer by name or instance
   */
  remove(recognizerOrName) {
    if (Array.isArray(recognizerOrName)) {
      for (const item of recognizerOrName) {
        this.remove(item);
      }
      return this;
    }
    const recognizer = typeof recognizerOrName === "string" ? this.get(recognizerOrName) : recognizerOrName;
    if (recognizer) {
      const { recognizers } = this;
      const index = recognizers.indexOf(recognizer);
      if (index !== -1) {
        recognizers.splice(index, 1);
        this.touchAction.update();
      }
    }
    return this;
  }
  /**
   * bind event
   */
  on(events, handler) {
    if (!events || !handler) {
      return;
    }
    const { handlers } = this;
    for (const event of splitStr(events)) {
      handlers[event] = handlers[event] || [];
      handlers[event].push(handler);
    }
  }
  /**
   * unbind event, leave hander blank to remove all handlers
   */
  off(events, handler) {
    if (!events) {
      return;
    }
    const { handlers } = this;
    for (const event of splitStr(events)) {
      if (!handler) {
        delete handlers[event];
      } else if (handlers[event]) {
        handlers[event].splice(handlers[event].indexOf(handler), 1);
      }
    }
  }
  /**
   * emit event to the listeners
   */
  emit(event, data) {
    const handlers = this.handlers[event] && this.handlers[event].slice();
    if (!handlers || !handlers.length) {
      return;
    }
    const evt = data;
    evt.type = event;
    evt.preventDefault = function() {
      data.srcEvent.preventDefault();
    };
    let i2 = 0;
    while (i2 < handlers.length) {
      handlers[i2](evt);
      i2++;
    }
  }
  /**
   * destroy the manager and unbinds all events
   * it doesn't unbind dom events, that is the user own responsibility
   */
  destroy() {
    this.toggleCssProps(false);
    this.handlers = {};
    this.session = {};
    this.input.destroy();
    this.element = null;
  }
  /**
   * add/remove the css properties as defined in manager.options.cssProps
   */
  toggleCssProps(add8) {
    const { element } = this;
    if (!element) {
      return;
    }
    for (const [name, value] of Object.entries(this.options.cssProps)) {
      const prop = prefixed(element.style, name);
      if (add8) {
        this.oldCssProps[prop] = element.style[prop];
        element.style[prop] = value;
      } else {
        element.style[prop] = this.oldCssProps[prop] || "";
      }
    }
    if (!add8) {
      this.oldCssProps = {};
    }
  }
};

// node_modules/mjolnir.js/dist/hammerjs/utils/unique-id.js
var _uniqueId = 1;
function uniqueId() {
  return _uniqueId++;
}

// node_modules/mjolnir.js/dist/hammerjs/recognizer/state-str.js
function stateStr(state) {
  if (state & RecognizerState.Cancelled) {
    return "cancel";
  } else if (state & RecognizerState.Ended) {
    return "end";
  } else if (state & RecognizerState.Changed) {
    return "move";
  } else if (state & RecognizerState.Began) {
    return "start";
  }
  return "";
}

// node_modules/mjolnir.js/dist/hammerjs/recognizer/recognizer.js
var Recognizer = class {
  constructor(options) {
    this.options = options;
    this.id = uniqueId();
    this.state = RecognizerState.Possible;
    this.simultaneous = {};
    this.requireFail = [];
  }
  /**
   * set options
   */
  set(options) {
    Object.assign(this.options, options);
    this.manager.touchAction.update();
    return this;
  }
  /**
   * recognize simultaneous with an other recognizer.
   */
  recognizeWith(recognizerOrName) {
    if (Array.isArray(recognizerOrName)) {
      for (const item of recognizerOrName) {
        this.recognizeWith(item);
      }
      return this;
    }
    let otherRecognizer;
    if (typeof recognizerOrName === "string") {
      otherRecognizer = this.manager.get(recognizerOrName);
      if (!otherRecognizer) {
        throw new Error(`Cannot find recognizer ${recognizerOrName}`);
      }
    } else {
      otherRecognizer = recognizerOrName;
    }
    const { simultaneous } = this;
    if (!simultaneous[otherRecognizer.id]) {
      simultaneous[otherRecognizer.id] = otherRecognizer;
      otherRecognizer.recognizeWith(this);
    }
    return this;
  }
  /**
   * drop the simultaneous link. it doesnt remove the link on the other recognizer.
   */
  dropRecognizeWith(recognizerOrName) {
    if (Array.isArray(recognizerOrName)) {
      for (const item of recognizerOrName) {
        this.dropRecognizeWith(item);
      }
      return this;
    }
    let otherRecognizer;
    if (typeof recognizerOrName === "string") {
      otherRecognizer = this.manager.get(recognizerOrName);
    } else {
      otherRecognizer = recognizerOrName;
    }
    if (otherRecognizer) {
      delete this.simultaneous[otherRecognizer.id];
    }
    return this;
  }
  /**
   * recognizer can only run when an other is failing
   */
  requireFailure(recognizerOrName) {
    if (Array.isArray(recognizerOrName)) {
      for (const item of recognizerOrName) {
        this.requireFailure(item);
      }
      return this;
    }
    let otherRecognizer;
    if (typeof recognizerOrName === "string") {
      otherRecognizer = this.manager.get(recognizerOrName);
      if (!otherRecognizer) {
        throw new Error(`Cannot find recognizer ${recognizerOrName}`);
      }
    } else {
      otherRecognizer = recognizerOrName;
    }
    const { requireFail } = this;
    if (requireFail.indexOf(otherRecognizer) === -1) {
      requireFail.push(otherRecognizer);
      otherRecognizer.requireFailure(this);
    }
    return this;
  }
  /**
   * drop the requireFailure link. it does not remove the link on the other recognizer.
   */
  dropRequireFailure(recognizerOrName) {
    if (Array.isArray(recognizerOrName)) {
      for (const item of recognizerOrName) {
        this.dropRequireFailure(item);
      }
      return this;
    }
    let otherRecognizer;
    if (typeof recognizerOrName === "string") {
      otherRecognizer = this.manager.get(recognizerOrName);
    } else {
      otherRecognizer = recognizerOrName;
    }
    if (otherRecognizer) {
      const index = this.requireFail.indexOf(otherRecognizer);
      if (index > -1) {
        this.requireFail.splice(index, 1);
      }
    }
    return this;
  }
  /**
   * has require failures boolean
   */
  hasRequireFailures() {
    return Boolean(this.requireFail.find((recognier) => recognier.options.enable));
  }
  /**
   * if the recognizer can recognize simultaneous with an other recognizer
   */
  canRecognizeWith(otherRecognizer) {
    return Boolean(this.simultaneous[otherRecognizer.id]);
  }
  /**
   * You should use `tryEmit` instead of `emit` directly to check
   * that all the needed recognizers has failed before emitting.
   */
  emit(input) {
    if (!input)
      return;
    const { state } = this;
    if (state < RecognizerState.Ended) {
      this.manager.emit(this.options.event + stateStr(state), input);
    }
    this.manager.emit(this.options.event, input);
    if (input.additionalEvent) {
      this.manager.emit(input.additionalEvent, input);
    }
    if (state >= RecognizerState.Ended) {
      this.manager.emit(this.options.event + stateStr(state), input);
    }
  }
  /**
   * Check that all the require failure recognizers has failed,
   * if true, it emits a gesture event,
   * otherwise, setup the state to FAILED.
   */
  tryEmit(input) {
    if (this.canEmit()) {
      this.emit(input);
    } else {
      this.state = RecognizerState.Failed;
    }
  }
  /**
   * can we emit?
   */
  canEmit() {
    let i2 = 0;
    while (i2 < this.requireFail.length) {
      if (!(this.requireFail[i2].state & (RecognizerState.Failed | RecognizerState.Possible))) {
        return false;
      }
      i2++;
    }
    return true;
  }
  /**
   * update the recognizer
   */
  recognize(inputData) {
    const inputDataClone = { ...inputData };
    if (!this.options.enable) {
      this.reset();
      this.state = RecognizerState.Failed;
      return;
    }
    if (this.state & (RecognizerState.Recognized | RecognizerState.Cancelled | RecognizerState.Failed)) {
      this.state = RecognizerState.Possible;
    }
    this.state = this.process(inputDataClone);
    if (this.state & (RecognizerState.Began | RecognizerState.Changed | RecognizerState.Ended | RecognizerState.Cancelled)) {
      this.tryEmit(inputDataClone);
    }
  }
  /**
   * return the event names that are emitted by this recognizer
   */
  getEventNames() {
    return [this.options.event];
  }
  /**
   * called when the gesture isn't allowed to recognize
   * like when another is being recognized or it is disabled
   */
  reset() {
  }
};

// node_modules/mjolnir.js/dist/hammerjs/recognizers/attribute.js
var AttrRecognizer = class extends Recognizer {
  /**
   * Used to check if it the recognizer receives valid input, like input.distance > 10.
   */
  attrTest(input) {
    const optionPointers = this.options.pointers;
    return optionPointers === 0 || input.pointers.length === optionPointers;
  }
  /**
   * Process the input and return the state for the recognizer
   */
  process(input) {
    const { state } = this;
    const { eventType } = input;
    const isRecognized = state & (RecognizerState.Began | RecognizerState.Changed);
    const isValid = this.attrTest(input);
    if (isRecognized && (eventType & InputEvent.Cancel || !isValid)) {
      return state | RecognizerState.Cancelled;
    } else if (isRecognized || isValid) {
      if (eventType & InputEvent.End) {
        return state | RecognizerState.Ended;
      } else if (!(state & RecognizerState.Began)) {
        return RecognizerState.Began;
      }
      return state | RecognizerState.Changed;
    }
    return RecognizerState.Failed;
  }
};

// node_modules/mjolnir.js/dist/hammerjs/recognizers/tap.js
var TapRecognizer = class extends Recognizer {
  constructor(options = {}) {
    super({
      enable: true,
      event: "tap",
      pointers: 1,
      taps: 1,
      interval: 300,
      time: 250,
      threshold: 9,
      posThreshold: 10,
      ...options
    });
    this.pTime = null;
    this.pCenter = null;
    this._timer = null;
    this._input = null;
    this.count = 0;
  }
  getTouchAction() {
    return [TOUCH_ACTION_MANIPULATION];
  }
  process(input) {
    const { options } = this;
    const validPointers = input.pointers.length === options.pointers;
    const validMovement = input.distance < options.threshold;
    const validTouchTime = input.deltaTime < options.time;
    this.reset();
    if (input.eventType & InputEvent.Start && this.count === 0) {
      return this.failTimeout();
    }
    if (validMovement && validTouchTime && validPointers) {
      if (input.eventType !== InputEvent.End) {
        return this.failTimeout();
      }
      const validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
      const validMultiTap = !this.pCenter || getPointDistance(this.pCenter, input.center) < options.posThreshold;
      this.pTime = input.timeStamp;
      this.pCenter = input.center;
      if (!validMultiTap || !validInterval) {
        this.count = 1;
      } else {
        this.count += 1;
      }
      this._input = input;
      const tapCount = this.count % options.taps;
      if (tapCount === 0) {
        if (!this.hasRequireFailures()) {
          return RecognizerState.Recognized;
        }
        this._timer = setTimeout(() => {
          this.state = RecognizerState.Recognized;
          this.tryEmit(this._input);
        }, options.interval);
        return RecognizerState.Began;
      }
    }
    return RecognizerState.Failed;
  }
  failTimeout() {
    this._timer = setTimeout(() => {
      this.state = RecognizerState.Failed;
    }, this.options.interval);
    return RecognizerState.Failed;
  }
  reset() {
    clearTimeout(this._timer);
  }
  emit(input) {
    if (this.state === RecognizerState.Recognized) {
      input.tapCount = this.count;
      this.manager.emit(this.options.event, input);
    }
  }
};

// node_modules/mjolnir.js/dist/hammerjs/recognizers/pan.js
var EVENT_NAMES = ["", "start", "move", "end", "cancel", "up", "down", "left", "right"];
var PanRecognizer = class extends AttrRecognizer {
  constructor(options = {}) {
    super({
      enable: true,
      pointers: 1,
      event: "pan",
      threshold: 10,
      direction: InputDirection.All,
      ...options
    });
    this.pX = null;
    this.pY = null;
  }
  getTouchAction() {
    const { options: { direction } } = this;
    const actions = [];
    if (direction & InputDirection.Horizontal) {
      actions.push(TOUCH_ACTION_PAN_Y);
    }
    if (direction & InputDirection.Vertical) {
      actions.push(TOUCH_ACTION_PAN_X);
    }
    return actions;
  }
  getEventNames() {
    return EVENT_NAMES.map((suffix) => this.options.event + suffix);
  }
  directionTest(input) {
    const { options } = this;
    let hasMoved = true;
    let { distance: distance5 } = input;
    let { direction } = input;
    const x2 = input.deltaX;
    const y2 = input.deltaY;
    if (!(direction & options.direction)) {
      if (options.direction & InputDirection.Horizontal) {
        direction = x2 === 0 ? InputDirection.None : x2 < 0 ? InputDirection.Left : InputDirection.Right;
        hasMoved = x2 !== this.pX;
        distance5 = Math.abs(input.deltaX);
      } else {
        direction = y2 === 0 ? InputDirection.None : y2 < 0 ? InputDirection.Up : InputDirection.Down;
        hasMoved = y2 !== this.pY;
        distance5 = Math.abs(input.deltaY);
      }
    }
    input.direction = direction;
    return hasMoved && distance5 > options.threshold && Boolean(direction & options.direction);
  }
  attrTest(input) {
    return super.attrTest(input) && (Boolean(this.state & RecognizerState.Began) || !(this.state & RecognizerState.Began) && this.directionTest(input));
  }
  emit(input) {
    this.pX = input.deltaX;
    this.pY = input.deltaY;
    const direction = InputDirection[input.direction].toLowerCase();
    if (direction) {
      input.additionalEvent = this.options.event + direction;
    }
    super.emit(input);
  }
};

// node_modules/mjolnir.js/dist/hammerjs/recognizers/pinch.js
var EVENT_NAMES2 = ["", "start", "move", "end", "cancel", "in", "out"];
var PinchRecognizer = class extends AttrRecognizer {
  constructor(options = {}) {
    super({
      enable: true,
      event: "pinch",
      threshold: 0,
      pointers: 2,
      ...options
    });
  }
  getTouchAction() {
    return [TOUCH_ACTION_NONE];
  }
  getEventNames() {
    return EVENT_NAMES2.map((suffix) => this.options.event + suffix);
  }
  attrTest(input) {
    return super.attrTest(input) && (Math.abs(input.scale - 1) > this.options.threshold || Boolean(this.state & RecognizerState.Began));
  }
  emit(input) {
    if (input.scale !== 1) {
      const inOut = input.scale < 1 ? "in" : "out";
      input.additionalEvent = this.options.event + inOut;
    }
    super.emit(input);
  }
};

// node_modules/mjolnir.js/dist/inputs/input.js
var Input2 = class {
  constructor(element, callback, options) {
    this.element = element;
    this.callback = callback;
    this.options = options;
  }
};

// node_modules/mjolnir.js/dist/utils/globals.js
var userAgent = typeof navigator !== "undefined" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "";
var window_ = typeof window !== "undefined" ? window : global;

// node_modules/mjolnir.js/dist/inputs/wheel-input.js
var firefox = userAgent.indexOf("firefox") !== -1;
var WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
var WHEEL_DELTA_PER_LINE = 40;
var SHIFT_MULTIPLIER = 0.25;
var WheelInput = class extends Input2 {
  constructor(element, callback, options) {
    super(element, callback, { enable: true, ...options });
    this.handleEvent = (event) => {
      if (!this.options.enable) {
        return;
      }
      let value = event.deltaY;
      if (globalThis.WheelEvent) {
        if (firefox && event.deltaMode === globalThis.WheelEvent.DOM_DELTA_PIXEL) {
          value /= globalThis.devicePixelRatio;
        }
        if (event.deltaMode === globalThis.WheelEvent.DOM_DELTA_LINE) {
          value *= WHEEL_DELTA_PER_LINE;
        }
      }
      if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
        value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
      }
      if (event.shiftKey && value) {
        value = value * SHIFT_MULTIPLIER;
      }
      this.callback({
        type: "wheel",
        center: {
          x: event.clientX,
          y: event.clientY
        },
        delta: -value,
        srcEvent: event,
        pointerType: "mouse",
        target: event.target
      });
    };
    element.addEventListener("wheel", this.handleEvent, { passive: false });
  }
  destroy() {
    this.element.removeEventListener("wheel", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === "wheel") {
      this.options.enable = enabled;
    }
  }
};

// node_modules/mjolnir.js/dist/inputs/move-input.js
var MOUSE_EVENTS = [
  "mousedown",
  "mousemove",
  "mouseup",
  "mouseover",
  "mouseout",
  "mouseleave"
];
var MoveInput = class extends Input2 {
  constructor(element, callback, options) {
    super(element, callback, { enable: true, ...options });
    this.handleEvent = (event) => {
      this.handleOverEvent(event);
      this.handleOutEvent(event);
      this.handleEnterEvent(event);
      this.handleLeaveEvent(event);
      this.handleMoveEvent(event);
    };
    this.pressed = false;
    const { enable } = this.options;
    this.enableMoveEvent = enable;
    this.enableLeaveEvent = enable;
    this.enableEnterEvent = enable;
    this.enableOutEvent = enable;
    this.enableOverEvent = enable;
    MOUSE_EVENTS.forEach((event) => element.addEventListener(event, this.handleEvent));
  }
  destroy() {
    MOUSE_EVENTS.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    switch (eventType) {
      case "pointermove":
        this.enableMoveEvent = enabled;
        break;
      case "pointerover":
        this.enableOverEvent = enabled;
        break;
      case "pointerout":
        this.enableOutEvent = enabled;
        break;
      case "pointerenter":
        this.enableEnterEvent = enabled;
        break;
      case "pointerleave":
        this.enableLeaveEvent = enabled;
        break;
      default:
    }
  }
  handleOverEvent(event) {
    if (this.enableOverEvent && event.type === "mouseover") {
      this._emit("pointerover", event);
    }
  }
  handleOutEvent(event) {
    if (this.enableOutEvent && event.type === "mouseout") {
      this._emit("pointerout", event);
    }
  }
  handleEnterEvent(event) {
    if (this.enableEnterEvent && event.type === "mouseenter") {
      this._emit("pointerenter", event);
    }
  }
  handleLeaveEvent(event) {
    if (this.enableLeaveEvent && event.type === "mouseleave") {
      this._emit("pointerleave", event);
    }
  }
  handleMoveEvent(event) {
    if (this.enableMoveEvent) {
      switch (event.type) {
        case "mousedown":
          if (event.button >= 0) {
            this.pressed = true;
          }
          break;
        case "mousemove":
          if (event.buttons === 0) {
            this.pressed = false;
          }
          if (!this.pressed) {
            this._emit("pointermove", event);
          }
          break;
        case "mouseup":
          this.pressed = false;
          break;
        default:
      }
    }
  }
  _emit(type, event) {
    this.callback({
      type,
      center: {
        x: event.clientX,
        y: event.clientY
      },
      srcEvent: event,
      pointerType: "mouse",
      target: event.target
    });
  }
};

// node_modules/mjolnir.js/dist/inputs/key-input.js
var KEY_EVENTS = ["keydown", "keyup"];
var KeyInput = class extends Input2 {
  constructor(element, callback, options) {
    super(element, callback, { enable: true, tabIndex: 0, ...options });
    this.handleEvent = (event) => {
      const targetElement = event.target || event.srcElement;
      if (targetElement.tagName === "INPUT" && targetElement.type === "text" || targetElement.tagName === "TEXTAREA") {
        return;
      }
      if (this.enableDownEvent && event.type === "keydown") {
        this.callback({
          type: "keydown",
          srcEvent: event,
          key: event.key,
          target: event.target
        });
      }
      if (this.enableUpEvent && event.type === "keyup") {
        this.callback({
          type: "keyup",
          srcEvent: event,
          key: event.key,
          target: event.target
        });
      }
    };
    this.enableDownEvent = this.options.enable;
    this.enableUpEvent = this.options.enable;
    element.tabIndex = this.options.tabIndex;
    element.style.outline = "none";
    KEY_EVENTS.forEach((event) => element.addEventListener(event, this.handleEvent));
  }
  destroy() {
    KEY_EVENTS.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === "keydown") {
      this.enableDownEvent = enabled;
    }
    if (eventType === "keyup") {
      this.enableUpEvent = enabled;
    }
  }
};

// node_modules/mjolnir.js/dist/inputs/contextmenu-input.js
var ContextmenuInput = class extends Input2 {
  constructor(element, callback, options) {
    super(element, callback, options);
    this.handleEvent = (event) => {
      if (!this.options.enable) {
        return;
      }
      this.callback({
        type: "contextmenu",
        center: {
          x: event.clientX,
          y: event.clientY
        },
        srcEvent: event,
        pointerType: "mouse",
        target: event.target
      });
    };
    element.addEventListener("contextmenu", this.handleEvent);
  }
  destroy() {
    this.element.removeEventListener("contextmenu", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === "contextmenu") {
      this.options.enable = enabled;
    }
  }
};

// node_modules/mjolnir.js/dist/utils/event-utils.js
var DOWN_EVENT = 1;
var MOVE_EVENT = 2;
var UP_EVENT = 4;
var MOUSE_EVENTS2 = {
  pointerdown: DOWN_EVENT,
  pointermove: MOVE_EVENT,
  pointerup: UP_EVENT,
  mousedown: DOWN_EVENT,
  mousemove: MOVE_EVENT,
  mouseup: UP_EVENT
};
var MOUSE_EVENT_BUTTON_LEFT = 0;
var MOUSE_EVENT_BUTTON_MIDDLE = 1;
var MOUSE_EVENT_BUTTON_RIGHT = 2;
var MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
var MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
var MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
function whichButtons(event) {
  const eventType = MOUSE_EVENTS2[event.srcEvent.type];
  if (!eventType) {
    return null;
  }
  const { buttons, button } = event.srcEvent;
  let leftButton = false;
  let middleButton = false;
  let rightButton = false;
  if (eventType === MOVE_EVENT) {
    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
  } else {
    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
  }
  return { leftButton, middleButton, rightButton };
}
function getOffsetPosition(event, rootElement) {
  const center = event.center;
  if (!center) {
    return null;
  }
  const rect = rootElement.getBoundingClientRect();
  const scaleX = rect.width / rootElement.offsetWidth || 1;
  const scaleY = rect.height / rootElement.offsetHeight || 1;
  const offsetCenter = {
    x: (center.x - rect.left - rootElement.clientLeft) / scaleX,
    y: (center.y - rect.top - rootElement.clientTop) / scaleY
  };
  return { center, offsetCenter };
}

// node_modules/mjolnir.js/dist/utils/event-registrar.js
var DEFAULT_OPTIONS = {
  srcElement: "root",
  priority: 0
};
var EventRegistrar = class {
  constructor(eventManager, recognizerName) {
    this.handleEvent = (event) => {
      if (this.isEmpty()) {
        return;
      }
      const mjolnirEvent = this._normalizeEvent(event);
      let target = event.srcEvent.target;
      while (target && target !== mjolnirEvent.rootElement) {
        this._emit(mjolnirEvent, target);
        if (mjolnirEvent.handled) {
          return;
        }
        target = target.parentNode;
      }
      this._emit(mjolnirEvent, "root");
    };
    this.eventManager = eventManager;
    this.recognizerName = recognizerName;
    this.handlers = [];
    this.handlersByElement = /* @__PURE__ */ new Map();
    this._active = false;
  }
  // Returns true if there are no non-passive handlers
  isEmpty() {
    return !this._active;
  }
  add(type, handler, options, once = false, passive = false) {
    const { handlers, handlersByElement } = this;
    const opts = { ...DEFAULT_OPTIONS, ...options };
    let entries = handlersByElement.get(opts.srcElement);
    if (!entries) {
      entries = [];
      handlersByElement.set(opts.srcElement, entries);
    }
    const entry = {
      type,
      handler,
      srcElement: opts.srcElement,
      priority: opts.priority
    };
    if (once) {
      entry.once = true;
    }
    if (passive) {
      entry.passive = true;
    }
    handlers.push(entry);
    this._active = this._active || !entry.passive;
    let insertPosition = entries.length - 1;
    while (insertPosition >= 0) {
      if (entries[insertPosition].priority >= entry.priority) {
        break;
      }
      insertPosition--;
    }
    entries.splice(insertPosition + 1, 0, entry);
  }
  remove(type, handler) {
    const { handlers, handlersByElement } = this;
    for (let i2 = handlers.length - 1; i2 >= 0; i2--) {
      const entry = handlers[i2];
      if (entry.type === type && entry.handler === handler) {
        handlers.splice(i2, 1);
        const entries = handlersByElement.get(entry.srcElement);
        entries.splice(entries.indexOf(entry), 1);
        if (entries.length === 0) {
          handlersByElement.delete(entry.srcElement);
        }
      }
    }
    this._active = handlers.some((entry) => !entry.passive);
  }
  /**
   * Invoke handlers on a particular element
   */
  _emit(event, srcElement) {
    const entries = this.handlersByElement.get(srcElement);
    if (entries) {
      let immediatePropagationStopped = false;
      const stopPropagation = () => {
        event.handled = true;
      };
      const stopImmediatePropagation = () => {
        event.handled = true;
        immediatePropagationStopped = true;
      };
      const entriesToRemove = [];
      for (let i2 = 0; i2 < entries.length; i2++) {
        const { type, handler, once } = entries[i2];
        handler({
          ...event,
          type,
          stopPropagation,
          stopImmediatePropagation
        });
        if (once) {
          entriesToRemove.push(entries[i2]);
        }
        if (immediatePropagationStopped) {
          break;
        }
      }
      for (let i2 = 0; i2 < entriesToRemove.length; i2++) {
        const { type, handler } = entriesToRemove[i2];
        this.remove(type, handler);
      }
    }
  }
  /**
   * Normalizes hammerjs and custom events to have predictable fields.
   */
  _normalizeEvent(event) {
    const rootElement = this.eventManager.getElement();
    return {
      ...event,
      ...whichButtons(event),
      ...getOffsetPosition(event, rootElement),
      preventDefault: () => {
        event.srcEvent.preventDefault();
      },
      stopImmediatePropagation: null,
      stopPropagation: null,
      handled: false,
      rootElement
    };
  }
};

// node_modules/mjolnir.js/dist/event-manager.js
function normalizeRecognizer(item) {
  if ("recognizer" in item) {
    return item;
  }
  let recognizer;
  const itemArray = Array.isArray(item) ? [...item] : [item];
  if (typeof itemArray[0] === "function") {
    const RecognizerType = itemArray.shift();
    const options = itemArray.shift() || {};
    recognizer = new RecognizerType(options);
  } else {
    recognizer = itemArray.shift();
  }
  return {
    recognizer,
    recognizeWith: typeof itemArray[0] === "string" ? [itemArray[0]] : itemArray[0],
    requireFailure: typeof itemArray[1] === "string" ? [itemArray[1]] : itemArray[1]
  };
}
var EventManager = class {
  constructor(element = null, options = {}) {
    this._onBasicInput = (event) => {
      this.manager.emit(event.srcEvent.type, event);
    };
    this._onOtherEvent = (event) => {
      this.manager.emit(event.type, event);
    };
    this.options = {
      recognizers: [],
      events: {},
      touchAction: "compute",
      tabIndex: 0,
      cssProps: {},
      ...options
    };
    this.events = /* @__PURE__ */ new Map();
    this.element = element;
    if (!element)
      return;
    this.manager = new Manager(element, this.options);
    for (const item of this.options.recognizers) {
      const { recognizer, recognizeWith, requireFailure } = normalizeRecognizer(item);
      this.manager.add(recognizer);
      if (recognizeWith) {
        recognizer.recognizeWith(recognizeWith);
      }
      if (requireFailure) {
        recognizer.requireFailure(requireFailure);
      }
    }
    this.manager.on("hammer.input", this._onBasicInput);
    this.wheelInput = new WheelInput(element, this._onOtherEvent, {
      enable: false
    });
    this.moveInput = new MoveInput(element, this._onOtherEvent, {
      enable: false
    });
    this.keyInput = new KeyInput(element, this._onOtherEvent, {
      enable: false,
      tabIndex: options.tabIndex
    });
    this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {
      enable: false
    });
    this.on(this.options.events);
  }
  getElement() {
    return this.element;
  }
  // Tear down internal event management implementations.
  destroy() {
    if (!this.element)
      return;
    this.wheelInput.destroy();
    this.moveInput.destroy();
    this.keyInput.destroy();
    this.contextmenuInput.destroy();
    this.manager.destroy();
  }
  /** Register an event handler function to be called on `event` */
  on(event, handler, opts) {
    this._addEventHandler(event, handler, opts, false);
  }
  once(event, handler, opts) {
    this._addEventHandler(event, handler, opts, true);
  }
  watch(event, handler, opts) {
    this._addEventHandler(event, handler, opts, false, true);
  }
  off(event, handler) {
    this._removeEventHandler(event, handler);
  }
  /*
   * Enable/disable recognizer for the given event
   */
  _toggleRecognizer(name, enabled) {
    var _a3, _b, _c, _d;
    const { manager } = this;
    if (!manager) {
      return;
    }
    const recognizer = manager.get(name);
    if (recognizer) {
      recognizer.set({ enable: enabled });
      manager.touchAction.update();
    }
    (_a3 = this.wheelInput) == null ? void 0 : _a3.enableEventType(name, enabled);
    (_b = this.moveInput) == null ? void 0 : _b.enableEventType(name, enabled);
    (_c = this.keyInput) == null ? void 0 : _c.enableEventType(name, enabled);
    (_d = this.contextmenuInput) == null ? void 0 : _d.enableEventType(name, enabled);
  }
  /**
   * Process the event registration for a single event + handler.
   */
  _addEventHandler(event, handler, opts, once, passive) {
    if (typeof event !== "string") {
      opts = handler;
      for (const [eventName, eventHandler] of Object.entries(event)) {
        this._addEventHandler(eventName, eventHandler, opts, once, passive);
      }
      return;
    }
    const { manager, events } = this;
    if (!manager)
      return;
    let eventRegistrar = events.get(event);
    if (!eventRegistrar) {
      const recognizerName = this._getRecognizerName(event) || event;
      eventRegistrar = new EventRegistrar(this, recognizerName);
      events.set(event, eventRegistrar);
      if (manager) {
        manager.on(event, eventRegistrar.handleEvent);
      }
    }
    eventRegistrar.add(event, handler, opts, once, passive);
    if (!eventRegistrar.isEmpty()) {
      this._toggleRecognizer(eventRegistrar.recognizerName, true);
    }
  }
  /**
   * Process the event deregistration for a single event + handler.
   */
  _removeEventHandler(event, handler) {
    if (typeof event !== "string") {
      for (const [eventName, eventHandler] of Object.entries(event)) {
        this._removeEventHandler(eventName, eventHandler);
      }
      return;
    }
    const { events } = this;
    const eventRegistrar = events.get(event);
    if (!eventRegistrar) {
      return;
    }
    eventRegistrar.remove(event, handler);
    if (eventRegistrar.isEmpty()) {
      const { recognizerName } = eventRegistrar;
      let isRecognizerUsed = false;
      for (const eh of events.values()) {
        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
          isRecognizerUsed = true;
          break;
        }
      }
      if (!isRecognizerUsed) {
        this._toggleRecognizer(recognizerName, false);
      }
    }
  }
  _getRecognizerName(event) {
    var _a3;
    return (_a3 = this.manager.recognizers.find((recognizer) => {
      return recognizer.getEventNames().includes(event);
    })) == null ? void 0 : _a3.options.event;
  }
};

// node_modules/@deck.gl/core/dist/lib/constants.js
var COORDINATE_SYSTEM = {
  /**
   * `LNGLAT` if rendering into a geospatial viewport, `CARTESIAN` otherwise
   */
  DEFAULT: -1,
  /**
   * Positions are interpreted as [longitude, latitude, elevation]
   * longitude/latitude are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT: 1,
  /**
   * Positions are interpreted as [x, y, z] in meter offsets from the coordinate origin.
   * Dimensions are in meters.
   */
  METER_OFFSETS: 2,
  /**
   * Positions are interpreted as [deltaLng, deltaLat, elevation] from the coordinate origin.
   * deltaLng/deltaLat are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT_OFFSETS: 3,
  /**
   * Positions and dimensions are in the common units of the viewport.
   */
  CARTESIAN: 0
};
Object.defineProperty(COORDINATE_SYSTEM, "IDENTITY", {
  get: () => {
    log_default.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")();
    return 0;
  }
});
var PROJECTION_MODE = {
  /**
   * Render geospatial data in Web Mercator projection
   */
  WEB_MERCATOR: 1,
  /**
   * Render geospatial data as a 3D globe
   */
  GLOBE: 2,
  /**
   * (Internal use only) Web Mercator projection at high zoom
   */
  WEB_MERCATOR_AUTO_OFFSET: 4,
  /**
   * No transformation
   */
  IDENTITY: 0
};
var UNIT = {
  common: 0,
  meters: 1,
  pixels: 2
};
var EVENT_HANDLERS = {
  click: "onClick",
  dblclick: "onClick",
  panstart: "onDragStart",
  panmove: "onDrag",
  panend: "onDragEnd"
};
var RECOGNIZERS = {
  multipan: [PanRecognizer, { threshold: 10, direction: InputDirection.Vertical, pointers: 2 }],
  pinch: [PinchRecognizer, {}, null, ["multipan"]],
  pan: [PanRecognizer, { threshold: 1 }, ["pinch"], ["multipan"]],
  dblclick: [TapRecognizer, { event: "dblclick", taps: 2 }],
  click: [TapRecognizer, { event: "click" }, null, ["dblclick"]]
};

// node_modules/@deck.gl/core/dist/shaderlib/misc/geometry.js
var source2 = (
  /* wgsl */
  `const SMOOTH_EDGE_RADIUS: f32 = 0.5;

struct VertexGeometry {
  position: vec4<f32>,
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  normal: vec3<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

var<private> geometry_: VertexGeometry = VertexGeometry(
  vec4<f32>(0.0, 0.0, 1.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec2<f32>(0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0)
);

struct FragmentGeometry {
  uv: vec2<f32>,
};

var<private> fragmentGeometry: FragmentGeometry;

fn smoothedge(edge: f32, x: f32) -> f32 {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`
);
var defines = "#define SMOOTH_EDGE_RADIUS 0.5";
var vs3 = (
  /* glsl */
  `${defines}

struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry = VertexGeometry(
  vec4(0.0, 0.0, 1.0, 0.0),
  vec3(0.0),
  vec3(0.0),
  vec3(0.0),
  vec2(0.0),
  vec3(0.0)
);
`
);
var fs3 = (
  /* glsl */
  `${defines}

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`
);
var geometry_default = {
  name: "geometry",
  source: source2,
  vs: vs3,
  fs: fs3
};

// node_modules/@deck.gl/core/dist/utils/memoize.js
function isEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (Array.isArray(a2)) {
    const len5 = a2.length;
    if (!b2 || b2.length !== len5) {
      return false;
    }
    for (let i2 = 0; i2 < len5; i2++) {
      if (a2[i2] !== b2[i2]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function memoize(compute) {
  let cachedArgs = {};
  let cachedResult;
  return (args) => {
    for (const key in args) {
      if (!isEqual(args[key], cachedArgs[key])) {
        cachedResult = compute(args);
        cachedArgs = args;
        break;
      }
    }
    return cachedResult;
  };
}

// node_modules/@deck.gl/core/dist/shaderlib/project/viewport-uniforms.js
var ZERO_VECTOR = [0, 0, 0, 0];
var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
var IDENTITY_MATRIX3 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
var DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];
var DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
var getMemoizedViewportUniforms = memoize(calculateViewportUniforms);
function getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin = DEFAULT_COORDINATE_ORIGIN) {
  if (coordinateOrigin.length < 3) {
    coordinateOrigin = [coordinateOrigin[0], coordinateOrigin[1], 0];
  }
  let shaderCoordinateOrigin = coordinateOrigin;
  let geospatialOrigin;
  let offsetMode = true;
  if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {
    geospatialOrigin = coordinateOrigin;
  } else {
    geospatialOrigin = viewport.isGeospatial ? (
      // @ts-expect-error longitude and latitude are not defined on the base Viewport, but is expected on geospatial viewports
      [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0]
    ) : null;
  }
  switch (viewport.projectionMode) {
    case PROJECTION_MODE.WEB_MERCATOR:
      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
        geospatialOrigin = [0, 0, 0];
        offsetMode = false;
      }
      break;
    case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:
      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
        shaderCoordinateOrigin = geospatialOrigin;
      } else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
        shaderCoordinateOrigin = [
          Math.fround(viewport.center[0]),
          Math.fround(viewport.center[1]),
          0
        ];
        geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);
        shaderCoordinateOrigin[0] -= coordinateOrigin[0];
        shaderCoordinateOrigin[1] -= coordinateOrigin[1];
        shaderCoordinateOrigin[2] -= coordinateOrigin[2];
      }
      break;
    case PROJECTION_MODE.IDENTITY:
      shaderCoordinateOrigin = viewport.position.map(Math.fround);
      shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;
      break;
    case PROJECTION_MODE.GLOBE:
      offsetMode = false;
      geospatialOrigin = null;
      break;
    default:
      offsetMode = false;
  }
  return { geospatialOrigin, shaderCoordinateOrigin, offsetMode };
}
function calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {
  const { viewMatrixUncentered, projectionMatrix } = viewport;
  let { viewMatrix: viewMatrix2, viewProjectionMatrix } = viewport;
  let projectionCenter = ZERO_VECTOR;
  let originCommon = ZERO_VECTOR;
  let cameraPosCommon = viewport.cameraPosition;
  const { geospatialOrigin, shaderCoordinateOrigin, offsetMode } = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin);
  if (offsetMode) {
    originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
    cameraPosCommon = [
      cameraPosCommon[0] - originCommon[0],
      cameraPosCommon[1] - originCommon[1],
      cameraPosCommon[2] - originCommon[2]
    ];
    originCommon[3] = 1;
    projectionCenter = vec4_exports.transformMat4([], originCommon, viewProjectionMatrix);
    viewMatrix2 = viewMatrixUncentered || viewMatrix2;
    viewProjectionMatrix = mat4_exports.multiply([], projectionMatrix, viewMatrix2);
    viewProjectionMatrix = mat4_exports.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
  }
  return {
    viewMatrix: viewMatrix2,
    viewProjectionMatrix,
    projectionCenter,
    originCommon,
    cameraPosCommon,
    shaderCoordinateOrigin,
    geospatialOrigin
  };
}
function getUniformsFromViewport({
  viewport,
  devicePixelRatio = 1,
  modelMatrix = null,
  // Match Layer.defaultProps
  coordinateSystem = COORDINATE_SYSTEM.DEFAULT,
  coordinateOrigin = DEFAULT_COORDINATE_ORIGIN,
  autoWrapLongitude = false
}) {
  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
  }
  const uniforms = getMemoizedViewportUniforms({
    viewport,
    devicePixelRatio,
    coordinateSystem,
    coordinateOrigin
  });
  uniforms.wrapLongitude = autoWrapLongitude;
  uniforms.modelMatrix = modelMatrix || IDENTITY_MATRIX3;
  return uniforms;
}
function calculateViewportUniforms({ viewport, devicePixelRatio, coordinateSystem, coordinateOrigin }) {
  const { projectionCenter, viewProjectionMatrix, originCommon, cameraPosCommon, shaderCoordinateOrigin, geospatialOrigin } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);
  const distanceScales = viewport.getDistanceScales();
  const viewportSize = [
    viewport.width * devicePixelRatio,
    viewport.height * devicePixelRatio
  ];
  const focalDistance = vec4_exports.transformMat4([], [0, 0, -viewport.focalDistance, 1], viewport.projectionMatrix)[3] || 1;
  const uniforms = {
    // Projection mode values
    coordinateSystem,
    projectionMode: viewport.projectionMode,
    coordinateOrigin: shaderCoordinateOrigin,
    commonOrigin: originCommon.slice(0, 3),
    center: projectionCenter,
    // Backward compatibility
    // TODO: remove in v9
    // @ts-expect-error _pseudoMeters is only defined on WebMercator viewport
    pseudoMeters: Boolean(viewport._pseudoMeters),
    // Screen size
    viewportSize,
    devicePixelRatio,
    focalDistance,
    commonUnitsPerMeter: distanceScales.unitsPerMeter,
    commonUnitsPerWorldUnit: distanceScales.unitsPerMeter,
    commonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,
    scale: viewport.scale,
    // This is the mercator scale (2 ** zoom)
    wrapLongitude: false,
    viewProjectionMatrix,
    modelMatrix: IDENTITY_MATRIX3,
    // This is for lighting calculations
    cameraPosition: cameraPosCommon
  };
  if (geospatialOrigin) {
    const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);
    switch (coordinateSystem) {
      case COORDINATE_SYSTEM.METER_OFFSETS:
        uniforms.commonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;
        uniforms.commonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;
        break;
      case COORDINATE_SYSTEM.LNGLAT:
      case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
        if (!viewport._pseudoMeters) {
          uniforms.commonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;
        }
        uniforms.commonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;
        uniforms.commonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;
        break;
      case COORDINATE_SYSTEM.CARTESIAN:
        uniforms.commonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];
        uniforms.commonUnitsPerWorldUnit2 = [0, 0, distanceScalesAtOrigin.unitsPerMeter2[2]];
        break;
      default:
        break;
    }
  }
  return uniforms;
}

// node_modules/@deck.gl/core/dist/shaderlib/project/project.wgsl.js
var COORDINATE_SYSTEM_WGSL_CONSTANTS = Object.keys(COORDINATE_SYSTEM).map((key) => `const COORDINATE_SYSTEM_${key}: i32 = ${COORDINATE_SYSTEM[key]};`).join("");
var PROJECTION_MODE_WGSL_CONSTANTS = Object.keys(PROJECTION_MODE).map((key) => `const PROJECTION_MODE_${key}: i32 = ${PROJECTION_MODE[key]};`).join("");
var UNIT_WGSL_CONSTANTS = Object.keys(UNIT).map((key) => `const UNIT_${key.toUpperCase()}: i32 = ${UNIT[key]};`).join("");
var projectWGSLHeader = (
  /* wgsl */
  `${COORDINATE_SYSTEM_WGSL_CONSTANTS}
${PROJECTION_MODE_WGSL_CONSTANTS}
${UNIT_WGSL_CONSTANTS}

const TILE_SIZE: f32 = 512.0;
const PI: f32 = 3.1415926536;
const WORLD_SCALE: f32 = TILE_SIZE / (PI * 2.0);
const ZERO_64_LOW: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
const EARTH_RADIUS: f32 = 6370972.0; // meters
const GLOBE_RADIUS: f32 = 256.0;

// -----------------------------------------------------------------------------
// Uniform block (converted from GLSL uniform block)
// -----------------------------------------------------------------------------
struct ProjectUniforms {
  wrapLongitude: i32,
  coordinateSystem: i32,
  commonUnitsPerMeter: vec3<f32>,
  projectionMode: i32,
  scale: f32,
  commonUnitsPerWorldUnit: vec3<f32>,
  commonUnitsPerWorldUnit2: vec3<f32>,
  center: vec4<f32>,
  modelMatrix: mat4x4<f32>,
  viewProjectionMatrix: mat4x4<f32>,
  viewportSize: vec2<f32>,
  devicePixelRatio: f32,
  focalDistance: f32,
  cameraPosition: vec3<f32>,
  coordinateOrigin: vec3<f32>,
  commonOrigin: vec3<f32>,
  pseudoMeters: i32,
};

@group(0) @binding(0)
var<uniform> project: ProjectUniforms;

// -----------------------------------------------------------------------------
// Geometry data
// (In your GLSL code, "geometry" was assumed to be available globally. In WGSL,
// you might supply this via vertex attributes or a uniform. Here we define a
// uniform struct for demonstration.)
// -----------------------------------------------------------------------------

// Structure to carry additional geometry data used by deck.gl filters.
struct Geometry {
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  position: vec4<f32>,
  normal: vec3<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

// @group(0) @binding(1)
var<private> geometry: Geometry;
`
);
var projectWGSL = (
  /* wgsl */
  `${projectWGSLHeader}

// -----------------------------------------------------------------------------
// Functions
// -----------------------------------------------------------------------------

// Returns an adjustment factor for commonUnitsPerMeter
fn _project_size_at_latitude(lat: f32) -> f32 {
  let y = clamp(lat, -89.9, 89.9);
  return 1.0 / cos(radians(y));
}

// Overloaded version: scales a value in meters at a given latitude.
fn _project_size_at_latitude_m(meters: f32, lat: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * _project_size_at_latitude(lat);
}

// Computes a non-linear scale factor based on geometry.
// (Note: This function relies on "geometry" being provided.)
fn project_size() -> f32 {
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
      project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
      project.pseudoMeters == 0) {
    if (geometry.position.w == 0.0) {
      return _project_size_at_latitude(geometry.worldPosition.y);
    }
    let y: f32 = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
    let y2 = y * y;
    let y4 = y2 * y2;
    let y6 = y4 * y2;
    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
  }
  return 1.0;
}

// Overloads to scale offsets (meters to world units)
fn project_size_float(meters: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * project_size();
}

fn project_size_vec2(meters: vec2<f32>) -> vec2<f32> {
  return meters * project.commonUnitsPerMeter.xy * project_size();
}

fn project_size_vec3(meters: vec3<f32>) -> vec3<f32> {
  return meters * project.commonUnitsPerMeter * project_size();
}

fn project_size_vec4(meters: vec4<f32>) -> vec4<f32> {
  return vec4<f32>(meters.xyz * project.commonUnitsPerMeter, meters.w);
}

// Returns a rotation matrix aligning the zaxis with the given up vector.
fn project_get_orientation_matrix(up: vec3<f32>) -> mat3x3<f32> {
  let uz = normalize(up);
  let ux = select(
    vec3<f32>(1.0, 0.0, 0.0),
    normalize(vec3<f32>(uz.y, -uz.x, 0.0)),
    abs(uz.z) == 1.0
  );
  let uy = cross(uz, ux);
  return mat3x3<f32>(ux, uy, uz);
}

// Since WGSL does not support "out" parameters, we return a struct.
struct RotationResult {
  needsRotation: bool,
  transform: mat3x3<f32>,
};

fn project_needs_rotation(commonPosition: vec3<f32>) -> RotationResult {
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    return RotationResult(true, project_get_orientation_matrix(commonPosition));
  } else {
    return RotationResult(false, mat3x3<f32>());  // identity alternative if needed
  };
}

// Projects a normal vector from the current coordinate system to world space.
fn project_normal(vector: vec3<f32>) -> vec3<f32> {
  let normal_modelspace = project.modelMatrix * vec4<f32>(vector, 0.0);
  var n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
  let rotResult = project_needs_rotation(geometry.position.xyz);
  if (rotResult.needsRotation) {
    n = rotResult.transform * n;
  }
  return n;
}

// Applies a scale offset based on y-offset (dy)
fn project_offset_(offset: vec4<f32>) -> vec4<f32> {
  let dy: f32 = offset.y;
  let commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
  return vec4<f32>(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}

// Projects lng/lat coordinates to a unit tile [0,1]
fn project_mercator_(lnglat: vec2<f32>) -> vec2<f32> {
  var x = lnglat.x;
  if (project.wrapLongitude != 0) {
    x = ((x + 180.0) % 360.0) - 180.0;
  }
  let y = clamp(lnglat.y, -89.9, 89.9);
  return vec2<f32>(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// Projects lng/lat/z coordinates for a globe projection.
fn project_globe_(lnglatz: vec3<f32>) -> vec3<f32> {
  let lambda = radians(lnglatz.x);
  let phi = radians(lnglatz.y);
  let cosPhi = cos(phi);
  let D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
  return vec3<f32>(
    sin(lambda) * cosPhi,
    -cos(lambda) * cosPhi,
    sin(phi)
  ) * D;
}

// Projects positions (with an optional 64-bit low part) from the input
// coordinate system to the common space.
fn project_position_vec4_f64(position: vec4<f32>, position64Low: vec3<f32>) -> vec4<f32> {
  var position_world = project.modelMatrix * position;

  // Work around for a Mac+NVIDIA bug:
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_mercator_(position_world.xy),
        _project_size_at_latitude_m(position_world.z, position_world.y),
        position_world.w
      );
    }
    if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
      position_world = vec4f(position_world.xyz + project.coordinateOrigin, position_world.w);
    }
  }
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_globe_(position_world.xyz),
        position_world.w
      );
    }
  }
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
        return vec4<f32>(
          project_mercator_(position_world.xy) - project.commonOrigin.xy,
          project_size_float(position_world.z),
          position_world.w
        );
      }
    }
  }
  if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
      (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
       (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
        project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
    position_world = vec4f(position_world.xyz - project.coordinateOrigin, position_world.w);
  }

  return project_offset_(position_world) +
         project_offset_(project.modelMatrix * vec4<f32>(position64Low, 0.0));
}

// Overloaded versions for different input types.
fn project_position_vec4_f32(position: vec4<f32>) -> vec4<f32> {
  return project_position_vec4_f64(position, ZERO_64_LOW);
}

fn project_position_vec3_f64(position: vec3<f32>, position64Low: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), position64Low);
  return projected_position.xyz;
}

fn project_position_vec3_f32(position: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), ZERO_64_LOW);
  return projected_position.xyz;
}

fn project_position_vec2_f32(position: vec2<f32>) -> vec2<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 0.0, 1.0), ZERO_64_LOW);
  return projected_position.xy;
}

// Transforms a common space position to clip space.
fn project_common_position_to_clipspace_with_projection(position: vec4<f32>, viewProjectionMatrix: mat4x4<f32>, center: vec4<f32>) -> vec4<f32> {
  return viewProjectionMatrix * position + center;
}

// Uses the project viewProjectionMatrix and center.
fn project_common_position_to_clipspace(position: vec4<f32>) -> vec4<f32> {
  return project_common_position_to_clipspace_with_projection(position, project.viewProjectionMatrix, project.center);
}

// Returns a clip space offset corresponding to a given number of screen pixels.
fn project_pixel_size_to_clipspace(pixels: vec2<f32>) -> vec2<f32> {
  let offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
  return offset * project.focalDistance;
}

fn project_meter_size_to_pixel(meters: f32) -> f32 {
  return project_size_float(meters) * project.scale;
}

fn project_unit_size_to_pixel(size: f32, unit: i32) -> f32 {
  if (unit == UNIT_METERS) {
    return project_meter_size_to_pixel(size);
  } else if (unit == UNIT_COMMON) {
    return size * project.scale;
  }
  // UNIT_PIXELS: no scaling applied.
  return size;
}

fn project_pixel_size_float(pixels: f32) -> f32 {
  return pixels / project.scale;
}

fn project_pixel_size_vec2(pixels: vec2<f32>) -> vec2<f32> {
  return pixels / project.scale;
}
`
);

// node_modules/@deck.gl/core/dist/shaderlib/project/project.glsl.js
var COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys(COORDINATE_SYSTEM).map((key) => `const int COORDINATE_SYSTEM_${key} = ${COORDINATE_SYSTEM[key]};`).join("");
var PROJECTION_MODE_GLSL_CONSTANTS = Object.keys(PROJECTION_MODE).map((key) => `const int PROJECTION_MODE_${key} = ${PROJECTION_MODE[key]};`).join("");
var UNIT_GLSL_CONSTANTS = Object.keys(UNIT).map((key) => `const int UNIT_${key.toUpperCase()} = ${UNIT[key]};`).join("");
var projectGLSL = (
  /* glsl */
  `${COORDINATE_SYSTEM_GLSL_CONSTANTS}
${PROJECTION_MODE_GLSL_CONSTANTS}
${UNIT_GLSL_CONSTANTS}
uniform projectUniforms {
bool wrapLongitude;
int coordinateSystem;
vec3 commonUnitsPerMeter;
int projectionMode;
float scale;
vec3 commonUnitsPerWorldUnit;
vec3 commonUnitsPerWorldUnit2;
vec4 center;
mat4 modelMatrix;
mat4 viewProjectionMatrix;
vec2 viewportSize;
float devicePixelRatio;
float focalDistance;
vec3 cameraPosition;
vec3 coordinateOrigin;
vec3 commonOrigin;
bool pseudoMeters;
} project;
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0;
const float GLOBE_RADIUS = 256.0;
float project_size_at_latitude(float lat) {
float y = clamp(lat, -89.9, 89.9);
return 1.0 / cos(radians(y));
}
float project_size() {
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
project.pseudoMeters == false) {
if (geometry.position.w == 0.0) {
return project_size_at_latitude(geometry.worldPosition.y);
}
float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
float y2 = y * y;
float y4 = y2 * y2;
float y6 = y4 * y2;
return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
}
return 1.0;
}
float project_size_at_latitude(float meters, float lat) {
return meters * project.commonUnitsPerMeter.z * project_size_at_latitude(lat);
}
float project_size(float meters) {
return meters * project.commonUnitsPerMeter.z * project_size();
}
vec2 project_size(vec2 meters) {
return meters * project.commonUnitsPerMeter.xy * project_size();
}
vec3 project_size(vec3 meters) {
return meters * project.commonUnitsPerMeter * project_size();
}
vec4 project_size(vec4 meters) {
return vec4(meters.xyz * project.commonUnitsPerMeter, meters.w);
}
mat3 project_get_orientation_matrix(vec3 up) {
vec3 uz = normalize(up);
vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
vec3 uy = cross(uz, ux);
return mat3(ux, uy, uz);
}
bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
transform = project_get_orientation_matrix(commonPosition);
return true;
}
return false;
}
vec3 project_normal(vec3 vector) {
vec4 normal_modelspace = project.modelMatrix * vec4(vector, 0.0);
vec3 n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
mat3 rotation;
if (project_needs_rotation(geometry.position.xyz, rotation)) {
n = rotation * n;
}
return n;
}
vec4 project_offset_(vec4 offset) {
float dy = offset.y;
vec3 commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}
vec2 project_mercator_(vec2 lnglat) {
float x = lnglat.x;
if (project.wrapLongitude) {
x = mod(x + 180., 360.0) - 180.;
}
float y = clamp(lnglat.y, -89.9, 89.9);
return vec2(
radians(x) + PI,
PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
) * WORLD_SCALE;
}
vec3 project_globe_(vec3 lnglatz) {
float lambda = radians(lnglatz.x);
float phi = radians(lnglatz.y);
float cosPhi = cos(phi);
float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
return vec3(
sin(lambda) * cosPhi,
-cos(lambda) * cosPhi,
sin(phi)
) * D;
}
vec4 project_position(vec4 position, vec3 position64Low) {
vec4 position_world = project.modelMatrix * position;
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_mercator_(position_world.xy),
project_size_at_latitude(position_world.z, position_world.y),
position_world.w
);
}
if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
position_world.xyz += project.coordinateOrigin;
}
}
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_globe_(position_world.xyz),
position_world.w
);
}
}
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
return vec4(
project_mercator_(position_world.xy) - project.commonOrigin.xy,
project_size(position_world.z),
position_world.w
);
}
}
}
if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
(project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
(project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
position_world.xyz -= project.coordinateOrigin;
}
return project_offset_(position_world) + project_offset_(project.modelMatrix * vec4(position64Low, 0.0));
}
vec4 project_position(vec4 position) {
return project_position(position, ZERO_64_LOW);
}
vec3 project_position(vec3 position, vec3 position64Low) {
vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
return projected_position.xyz;
}
vec3 project_position(vec3 position) {
vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
return projected_position.xyz;
}
vec2 project_position(vec2 position) {
vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
return projected_position.xy;
}
vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
return viewProjectionMatrix * position + center;
}
vec4 project_common_position_to_clipspace(vec4 position) {
return project_common_position_to_clipspace(position, project.viewProjectionMatrix, project.center);
}
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
vec2 offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
return offset * project.focalDistance;
}
float project_size_to_pixel(float meters) {
return project_size(meters) * project.scale;
}
float project_size_to_pixel(float size, int unit) {
if (unit == UNIT_METERS) return project_size_to_pixel(size);
if (unit == UNIT_COMMON) return size * project.scale;
return size;
}
float project_pixel_size(float pixels) {
return pixels / project.scale;
}
vec2 project_pixel_size(vec2 pixels) {
return pixels / project.scale;
}
`
);

// node_modules/@deck.gl/core/dist/shaderlib/project/project.js
var INITIAL_MODULE_OPTIONS = {};
function getUniforms3(opts = INITIAL_MODULE_OPTIONS) {
  if ("viewport" in opts) {
    return getUniformsFromViewport(opts);
  }
  return {};
}
var project_default = {
  name: "project",
  dependencies: [fp32, geometry_default],
  source: projectWGSL,
  vs: projectGLSL,
  getUniforms: getUniforms3,
  uniformTypes: {
    wrapLongitude: "f32",
    coordinateSystem: "i32",
    commonUnitsPerMeter: "vec3<f32>",
    projectionMode: "i32",
    scale: "f32",
    commonUnitsPerWorldUnit: "vec3<f32>",
    commonUnitsPerWorldUnit2: "vec3<f32>",
    center: "vec4<f32>",
    modelMatrix: "mat4x4<f32>",
    viewProjectionMatrix: "mat4x4<f32>",
    viewportSize: "vec2<f32>",
    devicePixelRatio: "f32",
    focalDistance: "f32",
    cameraPosition: "vec3<f32>",
    coordinateOrigin: "vec3<f32>",
    commonOrigin: "vec3<f32>",
    pseudoMeters: "f32"
  }
  // @ts-ignore TODO v9.1
};

// node_modules/@deck.gl/core/dist/shaderlib/project32/project32.js
var source3 = (
  /* wgsl */
  `// Define a structure to hold both the clip-space position and the common position.
struct ProjectResult {
  clipPosition: vec4<f32>,
  commonPosition: vec4<f32>,
};

// This function mimics the GLSL version with the 'out' parameter by returning both values.
fn project_position_to_clipspace_and_commonspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> ProjectResult {
  // Compute the projected position.
  let projectedPosition: vec3<f32> = project_position_vec3_f64(position, position64Low);

  // Start with the provided offset.
  var finalOffset: vec3<f32> = offset;

  // Get whether a rotation is needed and the rotation matrix.
  let rotationResult = project_needs_rotation(projectedPosition);

  // If rotation is needed, update the offset.
  if (rotationResult.needsRotation) {
    finalOffset = rotationResult.transform * offset;
  }

  // Compute the common position.
  let commonPosition: vec4<f32> = vec4<f32>(projectedPosition + finalOffset, 1.0);

  // Convert to clip-space.
  let clipPosition: vec4<f32> = project_common_position_to_clipspace(commonPosition);

  return ProjectResult(clipPosition, commonPosition);
}

// A convenience overload that returns only the clip-space position.
fn project_position_to_clipspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> vec4<f32> {
  return project_position_to_clipspace_and_commonspace(position, position64Low, offset).clipPosition;
}
`
);
var vs4 = (
  /* glsl */
  `vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  mat3 rotation;
  if (project_needs_rotation(projectedPosition, rotation)) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`
);
var project32_default = {
  name: "project32",
  dependencies: [project_default],
  source: source3,
  vs: vs4
};

// node_modules/@math.gl/web-mercator/dist/math-utils.js
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function transformVector(matrix, vector) {
  const result = vec4_exports.transformMat4([], vector, matrix);
  vec4_exports.scale(result, result, 1 / result[3]);
  return result;
}
function mod(value, divisor) {
  const modulus = value % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}
function lerp6(start, end, step) {
  return step * end + (1 - step) * start;
}
function clamp2(x2, min4, max4) {
  return x2 < min4 ? min4 : x2 > max4 ? max4 : x2;
}
function ieLog2(x2) {
  return Math.log(x2) * Math.LOG2E;
}
var log2 = Math.log2 || ieLog2;

// node_modules/@math.gl/web-mercator/dist/assert.js
function assert3(condition, message) {
  if (!condition) {
    throw new Error(message || "@math.gl/web-mercator: assertion failed.");
  }
}

// node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js
var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS2 = PI / 180;
var RADIANS_TO_DEGREES2 = 180 / PI;
var TILE_SIZE = 512;
var EARTH_CIRCUMFERENCE = 4003e4;
var MAX_LATITUDE = 85.051129;
var DEFAULT_ALTITUDE = 1.5;
function zoomToScale(zoom) {
  return Math.pow(2, zoom);
}
function scaleToZoom(scale7) {
  return log2(scale7);
}
function lngLatToWorld(lngLat) {
  const [lng, lat] = lngLat;
  assert3(Number.isFinite(lng));
  assert3(Number.isFinite(lat) && lat >= -90 && lat <= 90, "invalid latitude");
  const lambda2 = lng * DEGREES_TO_RADIANS2;
  const phi2 = lat * DEGREES_TO_RADIANS2;
  const x2 = TILE_SIZE * (lambda2 + PI) / (2 * PI);
  const y2 = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x2, y2];
}
function worldToLngLat(xy) {
  const [x2, y2] = xy;
  const lambda2 = x2 / TILE_SIZE * (2 * PI) - PI;
  const phi2 = 2 * (Math.atan(Math.exp(y2 / TILE_SIZE * (2 * PI) - PI)) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES2, phi2 * RADIANS_TO_DEGREES2];
}
function getMeterZoom(options) {
  const { latitude } = options;
  assert3(Number.isFinite(latitude));
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;
}
function unitsPerMeter(latitude) {
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
  return TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;
}
function getDistanceScales(options) {
  const { latitude, longitude, highPrecision = false } = options;
  assert3(Number.isFinite(latitude) && Number.isFinite(longitude));
  const worldSize = TILE_SIZE;
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
  const unitsPerDegreeX = worldSize / 360;
  const unitsPerDegreeY = unitsPerDegreeX / latCosine;
  const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
  const result = {
    unitsPerMeter: [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter],
    metersPerUnit: [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter],
    unitsPerDegree: [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter],
    degreesPerUnit: [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter]
  };
  if (highPrecision) {
    const latCosine2 = DEGREES_TO_RADIANS2 * Math.tan(latitude * DEGREES_TO_RADIANS2) / latCosine;
    const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;
    const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
    const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;
    result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];
    result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];
  }
  return result;
}
function addMetersToLngLat(lngLatZ, xyz) {
  const [longitude, latitude, z0] = lngLatZ;
  const [x2, y2, z2] = xyz;
  const { unitsPerMeter: unitsPerMeter2, unitsPerMeter2: unitsPerMeter22 } = getDistanceScales({
    longitude,
    latitude,
    highPrecision: true
  });
  const worldspace = lngLatToWorld(lngLatZ);
  worldspace[0] += x2 * (unitsPerMeter2[0] + unitsPerMeter22[0] * y2);
  worldspace[1] += y2 * (unitsPerMeter2[1] + unitsPerMeter22[1] * y2);
  const newLngLat = worldToLngLat(worldspace);
  const newZ = (z0 || 0) + (z2 || 0);
  return Number.isFinite(z0) || Number.isFinite(z2) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;
}
function getViewMatrix(options) {
  const {
    // Viewport props
    height,
    pitch,
    bearing,
    altitude,
    // Pre-calculated parameters
    scale: scale7,
    center
  } = options;
  const vm = createMat4();
  mat4_exports.translate(vm, vm, [0, 0, -altitude]);
  mat4_exports.rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS2);
  mat4_exports.rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS2);
  const relativeScale = scale7 / height;
  mat4_exports.scale(vm, vm, [relativeScale, relativeScale, relativeScale]);
  if (center) {
    mat4_exports.translate(vm, vm, vec3_exports.negate([], center));
  }
  return vm;
}
function getProjectionParameters(options) {
  const { width, height, altitude, pitch = 0, offset, center, scale: scale7, nearZMultiplier = 1, farZMultiplier = 1 } = options;
  let { fovy = altitudeToFovy(DEFAULT_ALTITUDE) } = options;
  if (altitude !== void 0) {
    fovy = altitudeToFovy(altitude);
  }
  const fovRadians = fovy * DEGREES_TO_RADIANS2;
  const pitchRadians = pitch * DEGREES_TO_RADIANS2;
  const focalDistance = fovyToAltitude(fovy);
  let cameraToSeaLevelDistance = focalDistance;
  if (center) {
    cameraToSeaLevelDistance += center[2] * scale7 / Math.cos(pitchRadians) / height;
  }
  const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height);
  const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin(clamp2(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));
  const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;
  const horizonDistance = cameraToSeaLevelDistance * 10;
  const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);
  return {
    fov: fovRadians,
    aspect: width / height,
    focalDistance,
    near: nearZMultiplier,
    far: farZ
  };
}
function altitudeToFovy(altitude) {
  return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES2;
}
function fovyToAltitude(fovy) {
  return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS2);
}
function worldToPixels(xyz, pixelProjectionMatrix) {
  const [x2, y2, z2 = 0] = xyz;
  assert3(Number.isFinite(x2) && Number.isFinite(y2) && Number.isFinite(z2));
  return transformVector(pixelProjectionMatrix, [x2, y2, z2, 1]);
}
function pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {
  const [x2, y2, z2] = xyz;
  assert3(Number.isFinite(x2) && Number.isFinite(y2), "invalid pixel coordinate");
  if (Number.isFinite(z2)) {
    const coord = transformVector(pixelUnprojectionMatrix, [x2, y2, z2, 1]);
    return coord;
  }
  const coord0 = transformVector(pixelUnprojectionMatrix, [x2, y2, 0, 1]);
  const coord1 = transformVector(pixelUnprojectionMatrix, [x2, y2, 1, 1]);
  const z0 = coord0[2];
  const z1 = coord1[2];
  const t2 = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
  return vec2_exports.lerp([], coord0, coord1, t2);
}

// node_modules/@math.gl/web-mercator/dist/fit-bounds.js
function fitBounds(options) {
  const {
    width,
    height,
    bounds,
    minExtent = 0,
    // 0.01 would be about 1000 meters (degree is ~110KM)
    maxZoom = 24,
    // ~x4,000,000 => About 10 meter extents
    offset = [0, 0]
  } = options;
  const [[west, south], [east, north]] = bounds;
  const padding = getPaddingObject(options.padding);
  const nw = lngLatToWorld([west, clamp2(north, -MAX_LATITUDE, MAX_LATITUDE)]);
  const se2 = lngLatToWorld([east, clamp2(south, -MAX_LATITUDE, MAX_LATITUDE)]);
  const size = [
    Math.max(Math.abs(se2[0] - nw[0]), minExtent),
    Math.max(Math.abs(se2[1] - nw[1]), minExtent)
  ];
  const targetSize = [
    width - padding.left - padding.right - Math.abs(offset[0]) * 2,
    height - padding.top - padding.bottom - Math.abs(offset[1]) * 2
  ];
  assert3(targetSize[0] > 0 && targetSize[1] > 0);
  const scaleX = targetSize[0] / size[0];
  const scaleY = targetSize[1] / size[1];
  const offsetX = (padding.right - padding.left) / 2 / scaleX;
  const offsetY = (padding.top - padding.bottom) / 2 / scaleY;
  const center = [(se2[0] + nw[0]) / 2 + offsetX, (se2[1] + nw[1]) / 2 + offsetY];
  const centerLngLat = worldToLngLat(center);
  const zoom = Math.min(maxZoom, log2(Math.abs(Math.min(scaleX, scaleY))));
  assert3(Number.isFinite(zoom));
  return {
    longitude: centerLngLat[0],
    latitude: centerLngLat[1],
    zoom
  };
}
function getPaddingObject(padding = 0) {
  if (typeof padding === "number") {
    return {
      top: padding,
      bottom: padding,
      left: padding,
      right: padding
    };
  }
  assert3(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
  return padding;
}

// node_modules/@math.gl/web-mercator/dist/get-bounds.js
var DEGREES_TO_RADIANS3 = Math.PI / 180;
function getBounds(viewport, z2 = 0) {
  const { width, height, unproject } = viewport;
  const unprojectOps = { targetZ: z2 };
  const bottomLeft = unproject([0, height], unprojectOps);
  const bottomRight = unproject([width, height], unprojectOps);
  let topLeft;
  let topRight;
  const halfFov = viewport.fovy ? 0.5 * viewport.fovy * DEGREES_TO_RADIANS3 : Math.atan(0.5 / viewport.altitude);
  const angleToGround = (90 - viewport.pitch) * DEGREES_TO_RADIANS3;
  if (halfFov > angleToGround - 0.01) {
    topLeft = unprojectOnFarPlane(viewport, 0, z2);
    topRight = unprojectOnFarPlane(viewport, width, z2);
  } else {
    topLeft = unproject([0, 0], unprojectOps);
    topRight = unproject([width, 0], unprojectOps);
  }
  return [bottomLeft, bottomRight, topRight, topLeft];
}
function unprojectOnFarPlane(viewport, x2, targetZ) {
  const { pixelUnprojectionMatrix } = viewport;
  const coord0 = transformVector(pixelUnprojectionMatrix, [x2, 0, 1, 1]);
  const coord1 = transformVector(pixelUnprojectionMatrix, [x2, viewport.height, 1, 1]);
  const z2 = targetZ * viewport.distanceScales.unitsPerMeter[2];
  const t2 = (z2 - coord0[2]) / (coord1[2] - coord0[2]);
  const coord = vec2_exports.lerp([], coord0, coord1, t2);
  const result = worldToLngLat(coord);
  result.push(targetZ);
  return result;
}

// node_modules/@math.gl/web-mercator/dist/normalize-viewport-props.js
var TILE_SIZE2 = 512;
function normalizeViewportProps(props) {
  const { width, height, pitch = 0 } = props;
  let { longitude, latitude, zoom, bearing = 0 } = props;
  if (longitude < -180 || longitude > 180) {
    longitude = mod(longitude + 180, 360) - 180;
  }
  if (bearing < -180 || bearing > 180) {
    bearing = mod(bearing + 180, 360) - 180;
  }
  const minZoom = log2(height / TILE_SIZE2);
  if (zoom <= minZoom) {
    zoom = minZoom;
    latitude = 0;
  } else {
    const halfHeightPixels = height / 2 / Math.pow(2, zoom);
    const minLatitude = worldToLngLat([0, halfHeightPixels])[1];
    if (latitude < minLatitude) {
      latitude = minLatitude;
    } else {
      const maxLatitude = worldToLngLat([0, TILE_SIZE2 - halfHeightPixels])[1];
      if (latitude > maxLatitude) {
        latitude = maxLatitude;
      }
    }
  }
  return { width, height, longitude, latitude, zoom, pitch, bearing };
}

// node_modules/@math.gl/web-mercator/dist/fly-to-viewport.js
var EPSILON21 = 0.01;
var VIEWPORT_TRANSITION_PROPS = ["longitude", "latitude", "zoom"];
var DEFAULT_OPTS = {
  curve: 1.414,
  speed: 1.2
  // screenSpeed and maxDuration are used only if specified
};
function flyToViewport(startProps, endProps, t2, options) {
  const { startZoom, startCenterXY, uDelta, w0, u1, S: S2, rho, rho2, r0 } = getFlyToTransitionParams(startProps, endProps, options);
  if (u1 < EPSILON21) {
    const viewport = {};
    for (const key of VIEWPORT_TRANSITION_PROPS) {
      const startValue = startProps[key];
      const endValue = endProps[key];
      viewport[key] = lerp6(startValue, endValue, t2);
    }
    return viewport;
  }
  const s2 = t2 * S2;
  const w2 = Math.cosh(r0) / Math.cosh(r0 + rho * s2);
  const u2 = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s2) - Math.sinh(r0)) / rho2) / u1;
  const scaleIncrement = 1 / w2;
  const newZoom = startZoom + scaleToZoom(scaleIncrement);
  const newCenterWorld = vec2_exports.scale([], uDelta, u2);
  vec2_exports.add(newCenterWorld, newCenterWorld, startCenterXY);
  const newCenter = worldToLngLat(newCenterWorld);
  return {
    longitude: newCenter[0],
    latitude: newCenter[1],
    zoom: newZoom
  };
}
function getFlyToDuration(startProps, endProps, options) {
  const opts = { ...DEFAULT_OPTS, ...options };
  const { screenSpeed, speed, maxDuration } = opts;
  const { S: S2, rho } = getFlyToTransitionParams(startProps, endProps, opts);
  const length5 = 1e3 * S2;
  let duration;
  if (Number.isFinite(screenSpeed)) {
    duration = length5 / (screenSpeed / rho);
  } else {
    duration = length5 / speed;
  }
  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;
}
function getFlyToTransitionParams(startProps, endProps, opts) {
  opts = Object.assign({}, DEFAULT_OPTS, opts);
  const rho = opts.curve;
  const startZoom = startProps.zoom;
  const startCenter = [startProps.longitude, startProps.latitude];
  const startScale = zoomToScale(startZoom);
  const endZoom = endProps.zoom;
  const endCenter = [endProps.longitude, endProps.latitude];
  const scale7 = zoomToScale(endZoom - startZoom);
  const startCenterXY = lngLatToWorld(startCenter);
  const endCenterXY = lngLatToWorld(endCenter);
  const uDelta = vec2_exports.sub([], endCenterXY, startCenterXY);
  const w0 = Math.max(startProps.width, startProps.height);
  const w1 = w0 / scale7;
  const u1 = vec2_exports.length(uDelta) * startScale;
  const _u1 = Math.max(u1, EPSILON21);
  const rho2 = rho * rho;
  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);
  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);
  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);
  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
  const S2 = (r1 - r0) / rho;
  return { startZoom, startCenterXY, uDelta, w0, u1, S: S2, rho, rho2, r0, r1 };
}

// node_modules/@deck.gl/core/dist/shaderlib/picking/picking.js
var picking_default = {
  ...picking,
  defaultUniforms: { ...picking.defaultUniforms, useFloatColors: false },
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    // for picking depth values
    picking_setPickingAttribute(position.z / position.w);
  `,
    "vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  `,
    "fs:DECKGL_FILTER_COLOR": {
      order: 99,
      injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    `
    }
  }
};

// node_modules/@deck.gl/core/dist/shaderlib/misc/layer-uniforms.js
var uniformBlock = `uniform layerUniforms {
  uniform float opacity;
} layer;
`;
var layerUniforms = {
  name: "layer",
  vs: uniformBlock,
  fs: uniformBlock,
  getUniforms: (props) => {
    return {
      // apply gamma to opacity to make it visually "linear"
      // TODO - v10: use raw opacity?
      opacity: Math.pow(props.opacity, 1 / 2.2)
    };
  },
  uniformTypes: {
    opacity: "f32"
  }
};

// node_modules/@deck.gl/core/dist/shaderlib/shadow/shadow.js
var uniformBlock2 = (
  /* glsl */
  `
uniform shadowUniforms {
  bool drawShadowMap;
  bool useShadowMap;
  vec4 color;
  highp int lightId;
  float lightCount;
  mat4 viewProjectionMatrix0;
  mat4 viewProjectionMatrix1;
  vec4 projectCenter0;
  vec4 projectCenter1;
} shadow;
`
);
var vertex = (
  /* glsl */
  `
const int max_lights = 2;

out vec3 shadow_vPosition[max_lights];

vec4 shadow_setVertexPosition(vec4 position_commonspace) {
  mat4 viewProjectionMatrices[max_lights];
  viewProjectionMatrices[0] = shadow.viewProjectionMatrix0;
  viewProjectionMatrices[1] = shadow.viewProjectionMatrix1;
  vec4 projectCenters[max_lights];
  projectCenters[0] = shadow.projectCenter0;
  projectCenters[1] = shadow.projectCenter1;

  if (shadow.drawShadowMap) {
    return project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[shadow.lightId], projectCenters[shadow.lightId]);
  }
  if (shadow.useShadowMap) {
    for (int i = 0; i < max_lights; i++) {
      if(i < int(shadow.lightCount)) {
        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[i], projectCenters[i]);
        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
      }
    }
  }
  return gl_Position;
}
`
);
var vs5 = `
${uniformBlock2}
${vertex}
`;
var fragment = (
  /* glsl */
  `
const int max_lights = 2;
uniform sampler2D shadow_uShadowMap0;
uniform sampler2D shadow_uShadowMap1;

in vec3 shadow_vPosition[max_lights];

const vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);
const vec4 bitUnpackShift = 1.0 / bitPackShift;
const vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);

float shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {
  vec4 rgbaDepth = texture(shadowMap, position.xy);

  float z = dot(rgbaDepth, bitUnpackShift);
  return smoothstep(0.001, 0.01, position.z - z);
}

vec4 shadow_filterShadowColor(vec4 color) {
  if (shadow.drawShadowMap) {
    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);
    rgbaDepth -= rgbaDepth.gbaa * bitMask;
    return rgbaDepth;
  }
  if (shadow.useShadowMap) {
    float shadowAlpha = 0.0;
    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);
    if(shadow.lightCount > 1.0) {
      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);
    }
    shadowAlpha *= shadow.color.a / shadow.lightCount;
    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);

    return vec4(
      mix(color.rgb, shadow.color.rgb, shadowAlpha / blendedAlpha),
      blendedAlpha
    );
  }
  return color;
}
`
);
var fs4 = `
${uniformBlock2}
${fragment}
`;
var getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);
var getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);
var DEFAULT_SHADOW_COLOR = [0, 0, 0, 1];
var VECTOR_TO_POINT_MATRIX2 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
function screenToCommonSpace(xyz, pixelUnprojectionMatrix) {
  const [x2, y2, z2] = xyz;
  const coord = pixelsToWorld([x2, y2, z2], pixelUnprojectionMatrix);
  if (Number.isFinite(z2)) {
    return coord;
  }
  return [coord[0], coord[1], 0];
}
function getViewportCenterPosition({ viewport, center }) {
  return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);
}
function getViewProjectionMatrices({ viewport, shadowMatrices }) {
  const projectionMatrices = [];
  const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;
  const farZ = viewport.isGeospatial ? void 0 : 1;
  const corners = [
    [0, 0, farZ],
    // top left ground
    [viewport.width, 0, farZ],
    // top right ground
    [0, viewport.height, farZ],
    // bottom left ground
    [viewport.width, viewport.height, farZ],
    // bottom right ground
    [0, 0, -1],
    // top left near
    [viewport.width, 0, -1],
    // top right near
    [0, viewport.height, -1],
    // bottom left near
    [viewport.width, viewport.height, -1]
    // bottom right near
  ].map((pixel) => (
    // @ts-expect-error z may be undefined
    screenToCommonSpace(pixel, pixelUnprojectionMatrix)
  ));
  for (const shadowMatrix of shadowMatrices) {
    const viewMatrix2 = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());
    const positions = corners.map((corner) => viewMatrix2.transform(corner));
    const projectionMatrix = new Matrix4().ortho({
      left: Math.min(...positions.map((position) => position[0])),
      right: Math.max(...positions.map((position) => position[0])),
      bottom: Math.min(...positions.map((position) => position[1])),
      top: Math.max(...positions.map((position) => position[1])),
      near: Math.min(...positions.map((position) => -position[2])),
      far: Math.max(...positions.map((position) => -position[2]))
    });
    projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));
  }
  return projectionMatrices;
}
function createShadowUniforms(opts) {
  const { shadowEnabled = true, project: projectProps } = opts;
  if (!shadowEnabled || !projectProps || !opts.shadowMatrices || !opts.shadowMatrices.length) {
    return {
      drawShadowMap: false,
      useShadowMap: false,
      shadow_uShadowMap0: opts.dummyShadowMap,
      shadow_uShadowMap1: opts.dummyShadowMap
    };
  }
  const projectUniforms = project_default.getUniforms(projectProps);
  const center = getMemoizedViewportCenterPosition({
    viewport: projectProps.viewport,
    center: projectUniforms.center
  });
  const projectCenters = [];
  const viewProjectionMatrices = getMemoizedViewProjectionMatrices({
    shadowMatrices: opts.shadowMatrices,
    viewport: projectProps.viewport
  }).slice();
  for (let i2 = 0; i2 < opts.shadowMatrices.length; i2++) {
    const viewProjectionMatrix = viewProjectionMatrices[i2];
    const viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new Vector3(projectProps.viewport.center).negate());
    if (projectUniforms.coordinateSystem === COORDINATE_SYSTEM.LNGLAT && projectUniforms.projectionMode === PROJECTION_MODE.WEB_MERCATOR) {
      viewProjectionMatrices[i2] = viewProjectionMatrixCentered;
      projectCenters[i2] = center;
    } else {
      viewProjectionMatrices[i2] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX2);
      projectCenters[i2] = viewProjectionMatrixCentered.transform(center);
    }
  }
  const uniforms = {
    drawShadowMap: Boolean(opts.drawToShadowMap),
    useShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,
    color: opts.shadowColor || DEFAULT_SHADOW_COLOR,
    lightId: opts.shadowLightId || 0,
    lightCount: opts.shadowMatrices.length,
    shadow_uShadowMap0: opts.dummyShadowMap,
    shadow_uShadowMap1: opts.dummyShadowMap
  };
  for (let i2 = 0; i2 < viewProjectionMatrices.length; i2++) {
    uniforms[`viewProjectionMatrix${i2}`] = viewProjectionMatrices[i2];
    uniforms[`projectCenter${i2}`] = projectCenters[i2];
  }
  for (let i2 = 0; i2 < 2; i2++) {
    uniforms[`shadow_uShadowMap${i2}`] = opts.shadowMaps && opts.shadowMaps[i2] || opts.dummyShadowMap;
  }
  return uniforms;
}
var shadow_default = {
  name: "shadow",
  dependencies: [project_default],
  vs: vs5,
  fs: fs4,
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    position = shadow_setVertexPosition(geometry.position);
    `,
    "fs:DECKGL_FILTER_COLOR": `
    color = shadow_filterShadowColor(color);
    `
  },
  getUniforms: createShadowUniforms,
  uniformTypes: {
    drawShadowMap: "f32",
    useShadowMap: "f32",
    color: "vec4<f32>",
    lightId: "i32",
    lightCount: "f32",
    viewProjectionMatrix0: "mat4x4<f32>",
    viewProjectionMatrix1: "mat4x4<f32>",
    projectCenter0: "vec4<f32>",
    projectCenter1: "vec4<f32>"
  }
};

// node_modules/@deck.gl/core/dist/shaderlib/index.js
var DEFAULT_MODULES = [geometry_default];
var SHADER_HOOKS_GLSL = [
  "vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)",
  "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)",
  "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)",
  "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"
];
var SHADER_HOOKS_WGSL = [
  // Not yet supported
];
function getShaderAssembler(language) {
  const shaderAssembler = ShaderAssembler.getDefaultShaderAssembler();
  for (const shaderModule of DEFAULT_MODULES) {
    shaderAssembler.addDefaultModule(shaderModule);
  }
  shaderAssembler._hookFunctions.length = 0;
  const shaderHooks = language === "glsl" ? SHADER_HOOKS_GLSL : SHADER_HOOKS_WGSL;
  for (const shaderHook of shaderHooks) {
    shaderAssembler.addShaderHook(shaderHook);
  }
  return shaderAssembler;
}

// node_modules/@luma.gl/engine/dist/utils/uid.js
var uidCounters = {};
function uid(id = "id") {
  uidCounters[id] = uidCounters[id] || 1;
  const count2 = uidCounters[id]++;
  return `${id}-${count2}`;
}

// node_modules/@luma.gl/engine/dist/geometry/gpu-geometry.js
var GPUGeometry = class {
  constructor(props) {
    __publicField(this, "id");
    __publicField(this, "userData", {});
    /** Determines how vertices are read from the 'vertex' attributes */
    __publicField(this, "topology");
    __publicField(this, "bufferLayout", []);
    __publicField(this, "vertexCount");
    __publicField(this, "indices");
    __publicField(this, "attributes");
    this.id = props.id || uid("geometry");
    this.topology = props.topology;
    this.indices = props.indices || null;
    this.attributes = props.attributes;
    this.vertexCount = props.vertexCount;
    this.bufferLayout = props.bufferLayout || [];
    if (this.indices) {
      if (!(this.indices.usage & Buffer.INDEX)) {
        throw new Error("Index buffer must have INDEX usage");
      }
    }
  }
  destroy() {
    var _a3;
    (_a3 = this.indices) == null ? void 0 : _a3.destroy();
    for (const attribute of Object.values(this.attributes)) {
      attribute.destroy();
    }
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getAttributes() {
    return this.attributes;
  }
  getIndexes() {
    return this.indices || null;
  }
  _calculateVertexCount(positions) {
    const vertexCount = positions.byteLength / 12;
    return vertexCount;
  }
};
function makeGPUGeometry(device, geometry) {
  if (geometry instanceof GPUGeometry) {
    return geometry;
  }
  const indices = getIndexBufferFromGeometry(device, geometry);
  const { attributes, bufferLayout } = getAttributeBuffersFromGeometry(device, geometry);
  return new GPUGeometry({
    topology: geometry.topology || "triangle-list",
    bufferLayout,
    vertexCount: geometry.vertexCount,
    indices,
    attributes
  });
}
function getIndexBufferFromGeometry(device, geometry) {
  if (!geometry.indices) {
    return void 0;
  }
  const data = geometry.indices.value;
  return device.createBuffer({ usage: Buffer.INDEX, data });
}
function getAttributeBuffersFromGeometry(device, geometry) {
  const bufferLayout = [];
  const attributes = {};
  for (const [attributeName, attribute] of Object.entries(geometry.attributes)) {
    let name = attributeName;
    switch (attributeName) {
      case "POSITION":
        name = "positions";
        break;
      case "NORMAL":
        name = "normals";
        break;
      case "TEXCOORD_0":
        name = "texCoords";
        break;
      case "COLOR_0":
        name = "colors";
        break;
    }
    if (attribute) {
      attributes[name] = device.createBuffer({
        data: attribute.value,
        id: `${attributeName}-buffer`
      });
      const { value, size, normalized } = attribute;
      bufferLayout.push({ name, format: getVertexFormatFromAttribute(value, size, normalized) });
    }
  }
  const vertexCount = geometry._calculateVertexCount(geometry.attributes, geometry.indices);
  return { attributes, bufferLayout, vertexCount };
}

// node_modules/@luma.gl/engine/dist/factories/pipeline-factory.js
var _PipelineFactory = class _PipelineFactory {
  constructor(device) {
    __publicField(this, "device");
    __publicField(this, "cachingEnabled");
    __publicField(this, "destroyPolicy");
    __publicField(this, "debug");
    __publicField(this, "_hashCounter", 0);
    __publicField(this, "_hashes", {});
    __publicField(this, "_renderPipelineCache", {});
    __publicField(this, "_computePipelineCache", {});
    this.device = device;
    this.cachingEnabled = device.props._cachePipelines;
    this.destroyPolicy = device.props._cacheDestroyPolicy;
    this.debug = device.props.debugFactories;
  }
  /** Get the singleton default pipeline factory for the specified device */
  static getDefaultPipelineFactory(device) {
    device._lumaData["defaultPipelineFactory"] = device._lumaData["defaultPipelineFactory"] || new _PipelineFactory(device);
    return device._lumaData["defaultPipelineFactory"];
  }
  get [Symbol.toStringTag]() {
    return "PipelineFactory";
  }
  toString() {
    return `PipelineFactory(${this.device.id})`;
  }
  /** Return a RenderPipeline matching supplied props. Reuses an equivalent pipeline if already created. */
  createRenderPipeline(props) {
    var _a3;
    if (!this.cachingEnabled) {
      return this.device.createRenderPipeline(props);
    }
    const allProps = { ...RenderPipeline.defaultProps, ...props };
    const cache = this._renderPipelineCache;
    const hash = this._hashRenderPipeline(allProps);
    let pipeline = (_a3 = cache[hash]) == null ? void 0 : _a3.pipeline;
    if (!pipeline) {
      pipeline = this.device.createRenderPipeline({
        ...allProps,
        id: allProps.id ? `${allProps.id}-cached` : uid("unnamed-cached")
      });
      pipeline.hash = hash;
      cache[hash] = { pipeline, useCount: 1 };
      if (this.debug) {
        log.log(3, `${this}: ${pipeline} created, count=${cache[hash].useCount}`)();
      }
    } else {
      cache[hash].useCount++;
      if (this.debug) {
        log.log(3, `${this}: ${cache[hash].pipeline} reused, count=${cache[hash].useCount}, (id=${props.id})`)();
      }
    }
    return pipeline;
  }
  /** Return a ComputePipeline matching supplied props. Reuses an equivalent pipeline if already created. */
  createComputePipeline(props) {
    var _a3;
    if (!this.cachingEnabled) {
      return this.device.createComputePipeline(props);
    }
    const allProps = { ...ComputePipeline.defaultProps, ...props };
    const cache = this._computePipelineCache;
    const hash = this._hashComputePipeline(allProps);
    let pipeline = (_a3 = cache[hash]) == null ? void 0 : _a3.pipeline;
    if (!pipeline) {
      pipeline = this.device.createComputePipeline({
        ...allProps,
        id: allProps.id ? `${allProps.id}-cached` : void 0
      });
      pipeline.hash = hash;
      cache[hash] = { pipeline, useCount: 1 };
      if (this.debug) {
        log.log(3, `${this}: ${pipeline} created, count=${cache[hash].useCount}`)();
      }
    } else {
      cache[hash].useCount++;
      if (this.debug) {
        log.log(3, `${this}: ${cache[hash].pipeline} reused, count=${cache[hash].useCount}, (id=${props.id})`)();
      }
    }
    return pipeline;
  }
  release(pipeline) {
    if (!this.cachingEnabled) {
      pipeline.destroy();
      return;
    }
    const cache = this._getCache(pipeline);
    const hash = pipeline.hash;
    cache[hash].useCount--;
    if (cache[hash].useCount === 0) {
      this._destroyPipeline(pipeline);
      if (this.debug) {
        log.log(3, `${this}: ${pipeline} released and destroyed`)();
      }
    } else if (cache[hash].useCount < 0) {
      log.error(`${this}: ${pipeline} released, useCount < 0, resetting`)();
      cache[hash].useCount = 0;
    } else if (this.debug) {
      log.log(3, `${this}: ${pipeline} released, count=${cache[hash].useCount}`)();
    }
  }
  // PRIVATE
  /** Destroy a cached pipeline, removing it from the cache (depending on destroy policy) */
  _destroyPipeline(pipeline) {
    const cache = this._getCache(pipeline);
    switch (this.destroyPolicy) {
      case "never":
        return false;
      case "unused":
        delete cache[pipeline.hash];
        pipeline.destroy();
        return true;
    }
  }
  /** Get the appropriate cache for the type of pipeline */
  _getCache(pipeline) {
    let cache;
    if (pipeline instanceof ComputePipeline) {
      cache = this._computePipelineCache;
    }
    if (pipeline instanceof RenderPipeline) {
      cache = this._renderPipelineCache;
    }
    if (!cache) {
      throw new Error(`${this}`);
    }
    if (!cache[pipeline.hash]) {
      throw new Error(`${this}: ${pipeline} matched incorrect entry`);
    }
    return cache;
  }
  /** Calculate a hash based on all the inputs for a compute pipeline */
  _hashComputePipeline(props) {
    const { type } = this.device;
    const shaderHash = this._getHash(props.shader.source);
    return `${type}/C/${shaderHash}`;
  }
  /** Calculate a hash based on all the inputs for a render pipeline */
  _hashRenderPipeline(props) {
    const vsHash = props.vs ? this._getHash(props.vs.source) : 0;
    const fsHash = props.fs ? this._getHash(props.fs.source) : 0;
    const varyingHash = "-";
    const bufferLayoutHash = this._getHash(JSON.stringify(props.bufferLayout));
    const { type } = this.device;
    switch (type) {
      case "webgl":
        return `${type}/R/${vsHash}/${fsHash}V${varyingHash}BL${bufferLayoutHash}`;
      case "webgpu":
      default:
        const parameterHash = this._getHash(JSON.stringify(props.parameters));
        return `${type}/R/${vsHash}/${fsHash}V${varyingHash}T${props.topology}P${parameterHash}BL${bufferLayoutHash}`;
    }
  }
  _getHash(key) {
    if (this._hashes[key] === void 0) {
      this._hashes[key] = this._hashCounter++;
    }
    return this._hashes[key];
  }
};
__publicField(_PipelineFactory, "defaultProps", { ...RenderPipeline.defaultProps });
var PipelineFactory = _PipelineFactory;

// node_modules/@luma.gl/engine/dist/factories/shader-factory.js
var _ShaderFactory = class _ShaderFactory {
  /** @internal */
  constructor(device) {
    __publicField(this, "device");
    __publicField(this, "cachingEnabled");
    __publicField(this, "destroyPolicy");
    __publicField(this, "debug");
    __publicField(this, "_cache", {});
    this.device = device;
    this.cachingEnabled = device.props._cacheShaders;
    this.destroyPolicy = device.props._cacheDestroyPolicy;
    this.debug = true;
  }
  /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */
  static getDefaultShaderFactory(device) {
    var _a3;
    (_a3 = device._lumaData)["defaultShaderFactory"] || (_a3["defaultShaderFactory"] = new _ShaderFactory(device));
    return device._lumaData["defaultShaderFactory"];
  }
  get [Symbol.toStringTag]() {
    return "ShaderFactory";
  }
  toString() {
    return `${this[Symbol.toStringTag]}(${this.device.id})`;
  }
  /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */
  createShader(props) {
    if (!this.cachingEnabled) {
      return this.device.createShader(props);
    }
    const key = this._hashShader(props);
    let cacheEntry = this._cache[key];
    if (!cacheEntry) {
      const shader = this.device.createShader({
        ...props,
        id: props.id ? `${props.id}-cached` : void 0
      });
      this._cache[key] = cacheEntry = { shader, useCount: 1 };
      if (this.debug) {
        log.log(3, `${this}: Created new shader ${shader.id}`)();
      }
    } else {
      cacheEntry.useCount++;
      if (this.debug) {
        log.log(3, `${this}: Reusing shader ${cacheEntry.shader.id} count=${cacheEntry.useCount}`)();
      }
    }
    return cacheEntry.shader;
  }
  /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */
  release(shader) {
    if (!this.cachingEnabled) {
      shader.destroy();
      return;
    }
    const key = this._hashShader(shader);
    const cacheEntry = this._cache[key];
    if (cacheEntry) {
      cacheEntry.useCount--;
      if (cacheEntry.useCount === 0) {
        if (this.destroyPolicy === "unused") {
          delete this._cache[key];
          cacheEntry.shader.destroy();
          if (this.debug) {
            log.log(3, `${this}: Releasing shader ${shader.id}, destroyed`)();
          }
        }
      } else if (cacheEntry.useCount < 0) {
        throw new Error(`ShaderFactory: Shader ${shader.id} released too many times`);
      } else if (this.debug) {
        log.log(3, `${this}: Releasing shader ${shader.id} count=${cacheEntry.useCount}`)();
      }
    }
  }
  // PRIVATE
  _hashShader(value) {
    return `${value.stage}:${value.source}`;
  }
};
__publicField(_ShaderFactory, "defaultProps", { ...Shader.defaultProps });
var ShaderFactory = _ShaderFactory;

// node_modules/@luma.gl/engine/dist/debug/debug-shader-layout.js
function getDebugTableForShaderLayout(layout, name) {
  var _a3;
  const table = {};
  const header = "Values";
  if (layout.attributes.length === 0 && !((_a3 = layout.varyings) == null ? void 0 : _a3.length)) {
    return { "No attributes or varyings": { [header]: "N/A" } };
  }
  for (const attributeDeclaration of layout.attributes) {
    if (attributeDeclaration) {
      const glslDeclaration = `${attributeDeclaration.location} ${attributeDeclaration.name}: ${attributeDeclaration.type}`;
      table[`in ${glslDeclaration}`] = { [header]: attributeDeclaration.stepMode || "vertex" };
    }
  }
  for (const varyingDeclaration of layout.varyings || []) {
    const glslDeclaration = `${varyingDeclaration.location} ${varyingDeclaration.name}`;
    table[`out ${glslDeclaration}`] = { [header]: JSON.stringify(varyingDeclaration) };
  }
  return table;
}

// node_modules/@luma.gl/engine/dist/debug/debug-framebuffer.js
var canvas = null;
var ctx = null;
function debugFramebuffer(fbo, { id, minimap, opaque, top = "0", left = "0", rgbaScale = 1 }) {
  if (!canvas) {
    canvas = document.createElement("canvas");
    canvas.id = id;
    canvas.title = id;
    canvas.style.zIndex = "100";
    canvas.style.position = "absolute";
    canvas.style.top = top;
    canvas.style.left = left;
    canvas.style.border = "blue 5px solid";
    canvas.style.transform = "scaleY(-1)";
    document.body.appendChild(canvas);
    ctx = canvas.getContext("2d");
  }
  if (canvas.width !== fbo.width || canvas.height !== fbo.height) {
    canvas.width = fbo.width / 2;
    canvas.height = fbo.height / 2;
    canvas.style.width = "400px";
    canvas.style.height = "400px";
  }
  const color = fbo.device.readPixelsToArrayWebGL(fbo);
  const imageData = ctx == null ? void 0 : ctx.createImageData(fbo.width, fbo.height);
  if (imageData) {
    const offset = 0;
    for (let i2 = 0; i2 < color.length; i2 += 4) {
      imageData.data[offset + i2 + 0] = color[i2 + 0] * rgbaScale;
      imageData.data[offset + i2 + 1] = color[i2 + 1] * rgbaScale;
      imageData.data[offset + i2 + 2] = color[i2 + 2] * rgbaScale;
      imageData.data[offset + i2 + 3] = opaque ? 255 : color[i2 + 3] * rgbaScale;
    }
    ctx == null ? void 0 : ctx.putImageData(imageData, 0, 0);
  }
}

// node_modules/@luma.gl/engine/dist/utils/deep-equal.js
function deepEqual(a2, b2, depth) {
  if (a2 === b2) {
    return true;
  }
  if (!depth || !a2 || !b2) {
    return false;
  }
  if (Array.isArray(a2)) {
    if (!Array.isArray(b2) || a2.length !== b2.length) {
      return false;
    }
    for (let i2 = 0; i2 < a2.length; i2++) {
      if (!deepEqual(a2[i2], b2[i2], depth - 1)) {
        return false;
      }
    }
    return true;
  }
  if (Array.isArray(b2)) {
    return false;
  }
  if (typeof a2 === "object" && typeof b2 === "object") {
    const aKeys = Object.keys(a2);
    const bKeys = Object.keys(b2);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    for (const key of aKeys) {
      if (!b2.hasOwnProperty(key)) {
        return false;
      }
      if (!deepEqual(a2[key], b2[key], depth - 1)) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/@luma.gl/engine/dist/utils/buffer-layout-helper.js
var BufferLayoutHelper = class {
  constructor(bufferLayouts) {
    __publicField(this, "bufferLayouts");
    this.bufferLayouts = bufferLayouts;
  }
  getBufferLayout(name) {
    return this.bufferLayouts.find((layout) => layout.name === name) || null;
  }
  /** Get attribute names from a BufferLayout */
  getAttributeNamesForBuffer(bufferLayout) {
    var _a3;
    return bufferLayout.attributes ? (_a3 = bufferLayout.attributes) == null ? void 0 : _a3.map((layout) => layout.attribute) : [bufferLayout.name];
  }
  mergeBufferLayouts(bufferLayouts1, bufferLayouts2) {
    const mergedLayouts = [...bufferLayouts1];
    for (const attribute of bufferLayouts2) {
      const index = mergedLayouts.findIndex((attribute2) => attribute2.name === attribute.name);
      if (index < 0) {
        mergedLayouts.push(attribute);
      } else {
        mergedLayouts[index] = attribute;
      }
    }
    return mergedLayouts;
  }
  getBufferIndex(bufferName) {
    const bufferIndex = this.bufferLayouts.findIndex((layout) => layout.name === bufferName);
    if (bufferIndex === -1) {
      log.warn(`BufferLayout: Missing buffer for "${bufferName}".`)();
    }
    return bufferIndex;
  }
};

// node_modules/@luma.gl/engine/dist/utils/buffer-layout-order.js
function sortedBufferLayoutByShaderSourceLocations(shaderLayout, bufferLayout) {
  const shaderLayoutMap = Object.fromEntries(shaderLayout.attributes.map((attr) => [attr.name, attr.location]));
  const sortedLayout = bufferLayout.slice();
  sortedLayout.sort((a2, b2) => {
    const attributeNamesA = a2.attributes ? a2.attributes.map((attr) => attr.attribute) : [a2.name];
    const attributeNamesB = b2.attributes ? b2.attributes.map((attr) => attr.attribute) : [b2.name];
    const minLocationA = Math.min(...attributeNamesA.map((name) => shaderLayoutMap[name]));
    const minLocationB = Math.min(...attributeNamesB.map((name) => shaderLayoutMap[name]));
    return minLocationA - minLocationB;
  });
  return sortedLayout;
}

// node_modules/@math.gl/types/dist/is-array.js
function isTypedArray(value) {
  return ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function isNumberArray(value) {
  if (Array.isArray(value)) {
    return value.length === 0 || typeof value[0] === "number";
  }
  return false;
}
function isNumericArray(value) {
  return isTypedArray(value) || isNumberArray(value);
}

// node_modules/@luma.gl/engine/dist/model/split-uniforms-and-bindings.js
function isUniformValue(value) {
  return isNumericArray(value) || typeof value === "number" || typeof value === "boolean";
}
function splitUniformsAndBindings(uniforms) {
  const result = { bindings: {}, uniforms: {} };
  Object.keys(uniforms).forEach((name) => {
    const uniform = uniforms[name];
    if (isUniformValue(uniform)) {
      result.uniforms[name] = uniform;
    } else {
      result.bindings[name] = uniform;
    }
  });
  return result;
}

// node_modules/@luma.gl/engine/dist/shader-inputs.js
var ShaderInputs = class {
  /** Tracks if uniforms have changed */
  // moduleUniformsChanged: Record<keyof ShaderPropsT, false | string>;
  /**
   * Create a new UniformStore instance
   * @param modules
   */
  constructor(modules, options) {
    __publicField(this, "options", {
      disableWarnings: false
    });
    /**
     * The map of modules
     * @todo should should this include the resolved dependencies?
     */
    // @ts-ignore Fix typings
    __publicField(this, "modules");
    /** Stores the uniform values for each module */
    __publicField(this, "moduleUniforms");
    /** Stores the uniform bindings for each module  */
    __publicField(this, "moduleBindings");
    Object.assign(this.options, options);
    const resolvedModules = getShaderModuleDependencies(Object.values(modules).filter((module) => module.dependencies));
    for (const resolvedModule of resolvedModules) {
      modules[resolvedModule.name] = resolvedModule;
    }
    log.log(1, "Creating ShaderInputs with modules", Object.keys(modules))();
    this.modules = modules;
    this.moduleUniforms = {};
    this.moduleBindings = {};
    for (const [name, module] of Object.entries(modules)) {
      this._addModule(module);
      if (module.name && name !== module.name && !this.options.disableWarnings) {
        log.warn(`Module name: ${name} vs ${module.name}`)();
      }
    }
  }
  /** Destroy */
  destroy() {
  }
  /**
   * Set module props
   */
  setProps(props) {
    var _a3;
    for (const name of Object.keys(props)) {
      const moduleName = name;
      const moduleProps = props[moduleName] || {};
      const module = this.modules[moduleName];
      if (!module) {
        if (!this.options.disableWarnings) {
          log.warn(`Module ${name} not found`)();
        }
        continue;
      }
      const oldUniforms = this.moduleUniforms[moduleName];
      const oldBindings = this.moduleBindings[moduleName];
      const uniformsAndBindings = ((_a3 = module.getUniforms) == null ? void 0 : _a3.call(module, moduleProps, oldUniforms)) || moduleProps;
      const { uniforms, bindings } = splitUniformsAndBindings(uniformsAndBindings);
      this.moduleUniforms[moduleName] = { ...oldUniforms, ...uniforms };
      this.moduleBindings[moduleName] = { ...oldBindings, ...bindings };
    }
  }
  /**
   * Return the map of modules
   * @todo should should this include the resolved dependencies?
   */
  getModules() {
    return Object.values(this.modules);
  }
  /** Get all uniform values for all modules */
  getUniformValues() {
    return this.moduleUniforms;
  }
  /** Merges all bindings for the shader (from the various modules) */
  getBindingValues() {
    const bindings = {};
    for (const moduleBindings of Object.values(this.moduleBindings)) {
      Object.assign(bindings, moduleBindings);
    }
    return bindings;
  }
  // INTERNAL
  /** Return a debug table that can be used for console.table() or log.table() */
  getDebugTable() {
    var _a3;
    const table = {};
    for (const [moduleName, module] of Object.entries(this.moduleUniforms)) {
      for (const [key, value] of Object.entries(module)) {
        table[`${moduleName}.${key}`] = {
          type: (_a3 = this.modules[moduleName].uniformTypes) == null ? void 0 : _a3[key],
          value: String(value)
        };
      }
    }
    return table;
  }
  _addModule(module) {
    const moduleName = module.name;
    this.moduleUniforms[moduleName] = module.defaultUniforms || {};
    this.moduleBindings[moduleName] = {};
  }
};

// node_modules/@luma.gl/engine/dist/application-utils/load-file.js
var pathPrefix = "";
async function loadImageBitmap(url, opts) {
  const image = new Image();
  image.crossOrigin = (opts == null ? void 0 : opts.crossOrigin) || "anonymous";
  image.src = url.startsWith("http") ? url : pathPrefix + url;
  await image.decode();
  return opts ? await createImageBitmap(image, opts) : await createImageBitmap(image);
}

// node_modules/@luma.gl/engine/dist/async-texture/async-texture.js
var TextureCubeFaces = ["+X", "-X", "+Y", "-Y", "+Z", "-Z"];
var CubeFaces = ["+X", "-X", "+Y", "-Y", "+Z", "-Z"];
var _AsyncTexture = class _AsyncTexture {
  constructor(device, props) {
    __publicField(this, "device");
    __publicField(this, "id");
    __publicField(this, "props");
    // TODO - should we type these as possibly `null`? It will make usage harder?
    // @ts-expect-error
    __publicField(this, "texture");
    // @ts-expect-error
    __publicField(this, "sampler");
    // @ts-expect-error
    __publicField(this, "view");
    __publicField(this, "ready");
    __publicField(this, "isReady", false);
    __publicField(this, "destroyed", false);
    __publicField(this, "resolveReady", () => {
    });
    __publicField(this, "rejectReady", () => {
    });
    this.device = device;
    const id = uid("async-texture");
    this.props = { ..._AsyncTexture.defaultProps, id, ...props };
    this.id = this.props.id;
    props = { ...props };
    if (typeof (props == null ? void 0 : props.data) === "string" && props.dimension === "2d") {
      props.data = loadImageBitmap(props.data);
    }
    if (props.mipmaps) {
      props.mipLevels = "auto";
    }
    this.ready = new Promise((resolve2, reject) => {
      this.resolveReady = () => {
        this.isReady = true;
        resolve2();
      };
      this.rejectReady = reject;
    });
    this.initAsync(props);
  }
  get [Symbol.toStringTag]() {
    return "AsyncTexture";
  }
  toString() {
    return `AsyncTexture:"${this.id}"(${this.isReady ? "ready" : "loading"})`;
  }
  async initAsync(props) {
    const asyncData = props.data;
    const data = await awaitAllPromises(asyncData).then(void 0, this.rejectReady);
    if (this.destroyed) {
      return;
    }
    const size = this.props.width && this.props.height ? { width: this.props.width, height: this.props.height } : this.getTextureDataSize(data);
    if (!size) {
      throw new Error("Texture size could not be determined");
    }
    const syncProps = { ...size, ...props, data: void 0, mipLevels: 1 };
    const maxMips = this.device.getMipLevelCount(syncProps.width, syncProps.height);
    syncProps.mipLevels = this.props.mipLevels === "auto" ? maxMips : Math.min(maxMips, this.props.mipLevels);
    this.texture = this.device.createTexture(syncProps);
    this.sampler = this.texture.sampler;
    this.view = this.texture.view;
    if (props.data) {
      switch (this.props.dimension) {
        case "1d":
          this._setTexture1DData(this.texture, data);
          break;
        case "2d":
          this._setTexture2DData(data);
          break;
        case "3d":
          this._setTexture3DData(this.texture, data);
          break;
        case "2d-array":
          this._setTextureArrayData(this.texture, data);
          break;
        case "cube":
          this._setTextureCubeData(this.texture, data);
          break;
        case "cube-array":
          this._setTextureCubeArrayData(this.texture, data);
          break;
      }
    }
    if (this.props.mipmaps) {
      this.generateMipmaps();
    }
    log.info(1, `${this} loaded`);
    this.resolveReady();
  }
  destroy() {
    if (this.texture) {
      this.texture.destroy();
      this.texture = null;
    }
    this.destroyed = true;
  }
  generateMipmaps() {
    this.texture.generateMipmapsWebGL();
  }
  /** Set sampler or create and set new Sampler from SamplerProps */
  setSampler(sampler = {}) {
    this.texture.setSampler(sampler instanceof Sampler ? sampler : this.device.createSampler(sampler));
  }
  /**
   * Textures are immutable and cannot be resized after creation,
   * but we can create a similar texture with the same parameters but a new size.
   * @note Does not copy contents of the texture
   * @note Mipmaps may need to be regenerated after resizing / setting new data
   * @todo Abort pending promise and create a texture with the new size?
   */
  resize(size) {
    if (!this.isReady) {
      throw new Error("Cannot resize texture before it is ready");
    }
    if (size.width === this.texture.width && size.height === this.texture.height) {
      return false;
    }
    if (this.texture) {
      const texture = this.texture;
      this.texture = texture.clone(size);
      texture.destroy();
    }
    return true;
  }
  /** Check if texture data is a typed array */
  isTextureLevelData(data) {
    const typedArray = data == null ? void 0 : data.data;
    return ArrayBuffer.isView(typedArray);
  }
  /** Get the size of the texture described by the provided TextureData */
  getTextureDataSize(data) {
    if (!data) {
      return null;
    }
    if (ArrayBuffer.isView(data)) {
      return null;
    }
    if (Array.isArray(data)) {
      return this.getTextureDataSize(data[0]);
    }
    if (this.device.isExternalImage(data)) {
      return this.device.getExternalImageSize(data);
    }
    if (data && typeof data === "object" && data.constructor === Object) {
      const textureDataArray = Object.values(data);
      const untypedData = textureDataArray[0];
      return { width: untypedData.width, height: untypedData.height };
    }
    throw new Error("texture size deduction failed");
  }
  /** Convert luma.gl cubemap face constants to depth index */
  getCubeFaceDepth(face) {
    switch (face) {
      case "+X":
        return 0;
      case "-X":
        return 1;
      case "+Y":
        return 2;
      case "-Y":
        return 3;
      case "+Z":
        return 4;
      case "-Z":
        return 5;
      default:
        throw new Error(face);
    }
  }
  // EXPERIMENTAL
  setTextureData(data) {
  }
  /** Experimental: Set multiple mip levels */
  _setTexture1DData(texture, data) {
    throw new Error("setTexture1DData not supported in WebGL.");
  }
  /** Experimental: Set multiple mip levels */
  _setTexture2DData(lodData, depth = 0) {
    if (!this.texture) {
      throw new Error("Texture not initialized");
    }
    const lodArray = this._normalizeTextureData(lodData);
    if (lodArray.length > 1 && this.props.mipmaps !== false) {
      log.warn(`Texture ${this.id} mipmap and multiple LODs.`)();
    }
    for (let mipLevel = 0; mipLevel < lodArray.length; mipLevel++) {
      const imageData = lodArray[mipLevel];
      if (this.device.isExternalImage(imageData)) {
        this.texture.copyExternalImage({ image: imageData, depth, mipLevel, flipY: true });
      } else {
        this.texture.copyImageData({ data: imageData.data, mipLevel });
      }
    }
  }
  /**
   * Experimental: Sets 3D texture data: multiple depth slices, multiple mip levels
   * @param data
   */
  _setTexture3DData(texture, data) {
    var _a3;
    if (((_a3 = this.texture) == null ? void 0 : _a3.props.dimension) !== "3d") {
      throw new Error(this.id);
    }
    for (let depth = 0; depth < data.length; depth++) {
      this._setTexture2DData(data[depth], depth);
    }
  }
  /**
   * Experimental: Set Cube texture data, multiple faces, multiple mip levels
   * @todo - could support TextureCubeArray with depth
   * @param data
   * @param index
   */
  _setTextureCubeData(texture, data) {
    var _a3;
    if (((_a3 = this.texture) == null ? void 0 : _a3.props.dimension) !== "cube") {
      throw new Error(this.id);
    }
    for (const [face, faceData] of Object.entries(data)) {
      const faceDepth = CubeFaces.indexOf(face);
      this._setTexture2DData(faceData, faceDepth);
    }
  }
  /**
   * Experimental: Sets texture array data, multiple levels, multiple depth slices
   * @param data
   */
  _setTextureArrayData(texture, data) {
    var _a3;
    if (((_a3 = this.texture) == null ? void 0 : _a3.props.dimension) !== "2d-array") {
      throw new Error(this.id);
    }
    for (let depth = 0; depth < data.length; depth++) {
      this._setTexture2DData(data[depth], depth);
    }
  }
  /**
   * Experimental: Sets texture cube array, multiple faces, multiple levels, multiple mip levels
   * @param data
   */
  _setTextureCubeArrayData(texture, data) {
    throw new Error("setTextureCubeArrayData not supported in WebGL2.");
  }
  /** Experimental */
  _setTextureCubeFaceData(texture, lodData, face, depth = 0) {
    if (Array.isArray(lodData) && lodData.length > 1 && this.props.mipmaps !== false) {
      log.warn(`${this.id} has mipmap and multiple LODs.`)();
    }
    const faceDepth = TextureCubeFaces.indexOf(face);
    this._setTexture2DData(lodData, faceDepth);
  }
  /**
   * Normalize TextureData to an array of TextureImageData / ExternalImages
   * @param data
   * @param options
   * @returns array of TextureImageData / ExternalImages
   */
  _normalizeTextureData(data) {
    const options = this.texture;
    let mipLevelArray;
    if (ArrayBuffer.isView(data)) {
      mipLevelArray = [
        {
          // ts-expect-error does data really need to be Uint8ClampedArray?
          data,
          width: options.width,
          height: options.height
          // depth: options.depth
        }
      ];
    } else if (!Array.isArray(data)) {
      mipLevelArray = [data];
    } else {
      mipLevelArray = data;
    }
    return mipLevelArray;
  }
};
__publicField(_AsyncTexture, "defaultProps", {
  ...Texture.defaultProps,
  data: null,
  mipmaps: false
});
var AsyncTexture = _AsyncTexture;
async function awaitAllPromises(x2) {
  x2 = await x2;
  if (Array.isArray(x2)) {
    return await Promise.all(x2.map(awaitAllPromises));
  }
  if (x2 && typeof x2 === "object" && x2.constructor === Object) {
    const object = x2;
    const values = await Promise.all(Object.values(object));
    const keys = Object.keys(object);
    const resolvedObject = {};
    for (let i2 = 0; i2 < keys.length; i2++) {
      resolvedObject[keys[i2]] = values[i2];
    }
    return resolvedObject;
  }
  return x2;
}

// node_modules/@luma.gl/engine/dist/model/model.js
var LOG_DRAW_PRIORITY = 2;
var LOG_DRAW_TIMEOUT = 1e4;
var _Model = class _Model {
  constructor(device, props) {
    __publicField(this, "device");
    __publicField(this, "id");
    // @ts-expect-error assigned in function called from constructor
    __publicField(this, "source");
    // @ts-expect-error assigned in function called from constructor
    __publicField(this, "vs");
    // @ts-expect-error assigned in function called from constructor
    __publicField(this, "fs");
    __publicField(this, "pipelineFactory");
    __publicField(this, "shaderFactory");
    __publicField(this, "userData", {});
    // Fixed properties (change can trigger pipeline rebuild)
    /** The render pipeline GPU parameters, depth testing etc */
    __publicField(this, "parameters");
    /** The primitive topology */
    __publicField(this, "topology");
    /** Buffer layout */
    __publicField(this, "bufferLayout");
    // Dynamic properties
    /** Use instanced rendering */
    __publicField(this, "isInstanced");
    /** instance count. `undefined` means not instanced */
    __publicField(this, "instanceCount", 0);
    /** Vertex count */
    __publicField(this, "vertexCount");
    /** Index buffer */
    __publicField(this, "indexBuffer", null);
    /** Buffer-valued attributes */
    __publicField(this, "bufferAttributes", {});
    /** Constant-valued attributes */
    __publicField(this, "constantAttributes", {});
    /** Bindings (textures, samplers, uniform buffers) */
    __publicField(this, "bindings", {});
    /**
     * VertexArray
     * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!
     * @todo - allow application to define multiple vertex arrays?
     * */
    __publicField(this, "vertexArray");
    /** TransformFeedback, WebGL 2 only. */
    __publicField(this, "transformFeedback", null);
    /** The underlying GPU "program". @note May be recreated if parameters change */
    __publicField(this, "pipeline");
    /** ShaderInputs instance */
    // @ts-expect-error Assigned in function called by constructor
    __publicField(this, "shaderInputs");
    // @ts-expect-error Assigned in function called by constructor
    __publicField(this, "_uniformStore");
    __publicField(this, "_attributeInfos", {});
    __publicField(this, "_gpuGeometry", null);
    __publicField(this, "props");
    __publicField(this, "_pipelineNeedsUpdate", "newly created");
    __publicField(this, "_needsRedraw", "initializing");
    __publicField(this, "_destroyed", false);
    /** "Time" of last draw. Monotonically increasing timestamp */
    __publicField(this, "_lastDrawTimestamp", -1);
    /** Throttle draw call logging */
    __publicField(this, "_lastLogTime", 0);
    __publicField(this, "_logOpen", false);
    __publicField(this, "_drawCount", 0);
    var _a3, _b, _c, _d;
    this.props = { ..._Model.defaultProps, ...props };
    props = this.props;
    this.id = props.id || uid("model");
    this.device = device;
    Object.assign(this.userData, props.userData);
    const moduleMap = Object.fromEntries(((_a3 = this.props.modules) == null ? void 0 : _a3.map((module) => [module.name, module])) || []);
    const shaderInputs = props.shaderInputs || new ShaderInputs(moduleMap, { disableWarnings: this.props.disableWarnings });
    this.setShaderInputs(shaderInputs);
    const platformInfo = getPlatformInfo(device);
    const modules = (
      // @ts-ignore shaderInputs is assigned in setShaderInputs above.
      (((_b = this.props.modules) == null ? void 0 : _b.length) > 0 ? this.props.modules : (_c = this.shaderInputs) == null ? void 0 : _c.getModules()) || []
    );
    const isWebGPU = this.device.type === "webgpu";
    if (isWebGPU && this.props.source) {
      const { source: source6, getUniforms: getUniforms5 } = this.props.shaderAssembler.assembleWGSLShader({
        platformInfo,
        ...this.props,
        modules
      });
      this.source = source6;
      this._getModuleUniforms = getUniforms5;
      (_d = this.props).shaderLayout || (_d.shaderLayout = getShaderLayoutFromWGSL(this.source));
    } else {
      const { vs: vs10, fs: fs8, getUniforms: getUniforms5 } = this.props.shaderAssembler.assembleGLSLShaderPair({
        platformInfo,
        ...this.props,
        modules
      });
      this.vs = vs10;
      this.fs = fs8;
      this._getModuleUniforms = getUniforms5;
    }
    this.vertexCount = this.props.vertexCount;
    this.instanceCount = this.props.instanceCount;
    this.topology = this.props.topology;
    this.bufferLayout = this.props.bufferLayout;
    this.parameters = this.props.parameters;
    if (props.geometry) {
      this.setGeometry(props.geometry);
    }
    this.pipelineFactory = props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);
    this.shaderFactory = props.shaderFactory || ShaderFactory.getDefaultShaderFactory(this.device);
    this.pipeline = this._updatePipeline();
    this.vertexArray = device.createVertexArray({
      shaderLayout: this.pipeline.shaderLayout,
      bufferLayout: this.pipeline.bufferLayout
    });
    if (this._gpuGeometry) {
      this._setGeometryAttributes(this._gpuGeometry);
    }
    if ("isInstanced" in props) {
      this.isInstanced = props.isInstanced;
    }
    if (props.instanceCount) {
      this.setInstanceCount(props.instanceCount);
    }
    if (props.vertexCount) {
      this.setVertexCount(props.vertexCount);
    }
    if (props.indexBuffer) {
      this.setIndexBuffer(props.indexBuffer);
    }
    if (props.attributes) {
      this.setAttributes(props.attributes);
    }
    if (props.constantAttributes) {
      this.setConstantAttributes(props.constantAttributes);
    }
    if (props.bindings) {
      this.setBindings(props.bindings);
    }
    if (props.transformFeedback) {
      this.transformFeedback = props.transformFeedback;
    }
    Object.seal(this);
  }
  get [Symbol.toStringTag]() {
    return "Model";
  }
  toString() {
    return `Model(${this.id})`;
  }
  destroy() {
    var _a3;
    if (!this._destroyed) {
      this.pipelineFactory.release(this.pipeline);
      this.shaderFactory.release(this.pipeline.vs);
      if (this.pipeline.fs) {
        this.shaderFactory.release(this.pipeline.fs);
      }
      this._uniformStore.destroy();
      (_a3 = this._gpuGeometry) == null ? void 0 : _a3.destroy();
      this._destroyed = true;
    }
  }
  // Draw call
  /** Query redraw status. Clears the status. */
  needsRedraw() {
    if (this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp) {
      this.setNeedsRedraw("contents of bound textures or buffers updated");
    }
    const needsRedraw = this._needsRedraw;
    this._needsRedraw = false;
    return needsRedraw;
  }
  /** Mark the model as needing a redraw */
  setNeedsRedraw(reason) {
    this._needsRedraw || (this._needsRedraw = reason);
  }
  predraw() {
    this.updateShaderInputs();
    this.pipeline = this._updatePipeline();
  }
  draw(renderPass) {
    const loadingBinding = this._areBindingsLoading();
    if (loadingBinding) {
      log.info(LOG_DRAW_PRIORITY, `>>> DRAWING ABORTED ${this.id}: ${loadingBinding} not loaded`)();
      return false;
    }
    try {
      renderPass.pushDebugGroup(`${this}.predraw(${renderPass})`);
      this.predraw();
    } finally {
      renderPass.popDebugGroup();
    }
    let drawSuccess;
    try {
      renderPass.pushDebugGroup(`${this}.draw(${renderPass})`);
      this._logDrawCallStart();
      this.pipeline = this._updatePipeline();
      const syncBindings = this._getBindings();
      this.pipeline.setBindings(syncBindings, {
        disableWarnings: this.props.disableWarnings
      });
      const { indexBuffer } = this.vertexArray;
      const indexCount = indexBuffer ? indexBuffer.byteLength / (indexBuffer.indexType === "uint32" ? 4 : 2) : void 0;
      drawSuccess = this.pipeline.draw({
        renderPass,
        vertexArray: this.vertexArray,
        isInstanced: this.isInstanced,
        vertexCount: this.vertexCount,
        instanceCount: this.instanceCount,
        indexCount,
        transformFeedback: this.transformFeedback || void 0,
        // WebGL shares underlying cached pipelines even for models that have different parameters and topology,
        // so we must provide our unique parameters to each draw
        // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)
        parameters: this.parameters,
        topology: this.topology
      });
    } finally {
      renderPass.popDebugGroup();
      this._logDrawCallEnd();
    }
    this._logFramebuffer(renderPass);
    if (drawSuccess) {
      this._lastDrawTimestamp = this.device.timestamp;
      this._needsRedraw = false;
    } else {
      this._needsRedraw = "waiting for resource initialization";
    }
    return drawSuccess;
  }
  // Update fixed fields (can trigger pipeline rebuild)
  /**
   * Updates the optional geometry
   * Geometry, set topology and bufferLayout
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setGeometry(geometry) {
    var _a3;
    (_a3 = this._gpuGeometry) == null ? void 0 : _a3.destroy();
    const gpuGeometry = geometry && makeGPUGeometry(this.device, geometry);
    if (gpuGeometry) {
      this.setTopology(gpuGeometry.topology || "triangle-list");
      const bufferLayoutHelper = new BufferLayoutHelper(this.bufferLayout);
      this.bufferLayout = bufferLayoutHelper.mergeBufferLayouts(gpuGeometry.bufferLayout, this.bufferLayout);
      if (this.vertexArray) {
        this._setGeometryAttributes(gpuGeometry);
      }
    }
    this._gpuGeometry = gpuGeometry;
  }
  /**
   * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).
   * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setTopology(topology) {
    if (topology !== this.topology) {
      this.topology = topology;
      this._setPipelineNeedsUpdate("topology");
    }
  }
  /**
   * Updates the buffer layout.
   * @note Triggers a pipeline rebuild / pipeline cache fetch
   */
  setBufferLayout(bufferLayout) {
    const bufferLayoutHelper = new BufferLayoutHelper(this.bufferLayout);
    this.bufferLayout = this._gpuGeometry ? bufferLayoutHelper.mergeBufferLayouts(bufferLayout, this._gpuGeometry.bufferLayout) : bufferLayout;
    this._setPipelineNeedsUpdate("bufferLayout");
    this.pipeline = this._updatePipeline();
    this.vertexArray = this.device.createVertexArray({
      shaderLayout: this.pipeline.shaderLayout,
      bufferLayout: this.pipeline.bufferLayout
    });
    if (this._gpuGeometry) {
      this._setGeometryAttributes(this._gpuGeometry);
    }
  }
  /**
   * Set GPU parameters.
   * @note Can trigger a pipeline rebuild / pipeline cache fetch.
   * @param parameters
   */
  setParameters(parameters) {
    if (!deepEqual(parameters, this.parameters, 2)) {
      this.parameters = parameters;
      this._setPipelineNeedsUpdate("parameters");
    }
  }
  // Update dynamic fields
  /**
   * Updates the instance count (used in draw calls)
   * @note Any attributes with stepMode=instance need to be at least this big
   */
  setInstanceCount(instanceCount) {
    this.instanceCount = instanceCount;
    if (this.isInstanced === void 0 && instanceCount > 0) {
      this.isInstanced = true;
    }
    this.setNeedsRedraw("instanceCount");
  }
  /**
   * Updates the vertex count (used in draw calls)
   * @note Any attributes with stepMode=vertex need to be at least this big
   */
  setVertexCount(vertexCount) {
    this.vertexCount = vertexCount;
    this.setNeedsRedraw("vertexCount");
  }
  /** Set the shader inputs */
  setShaderInputs(shaderInputs) {
    this.shaderInputs = shaderInputs;
    this._uniformStore = new UniformStore(this.shaderInputs.modules);
    for (const [moduleName, module] of Object.entries(this.shaderInputs.modules)) {
      if (shaderModuleHasUniforms(module)) {
        const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);
        this.bindings[`${moduleName}Uniforms`] = uniformBuffer;
      }
    }
    this.setNeedsRedraw("shaderInputs");
  }
  /** Update uniform buffers from the model's shader inputs */
  updateShaderInputs() {
    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());
    this.setBindings(this.shaderInputs.getBindingValues());
    this.setNeedsRedraw("shaderInputs");
  }
  /**
   * Sets bindings (textures, samplers, uniform buffers)
   */
  setBindings(bindings) {
    Object.assign(this.bindings, bindings);
    this.setNeedsRedraw("bindings");
  }
  /**
   * Updates optional transform feedback. WebGL only.
   */
  setTransformFeedback(transformFeedback) {
    this.transformFeedback = transformFeedback;
    this.setNeedsRedraw("transformFeedback");
  }
  /**
   * Sets the index buffer
   * @todo - how to unset it if we change geometry?
   */
  setIndexBuffer(indexBuffer) {
    this.vertexArray.setIndexBuffer(indexBuffer);
    this.setNeedsRedraw("indexBuffer");
  }
  /**
   * Sets attributes (buffers)
   * @note Overrides any attributes previously set with the same name
   */
  setAttributes(buffers, options) {
    const disableWarnings = (options == null ? void 0 : options.disableWarnings) ?? this.props.disableWarnings;
    if (buffers["indices"]) {
      log.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();
    }
    this.bufferLayout = sortedBufferLayoutByShaderSourceLocations(this.pipeline.shaderLayout, this.bufferLayout);
    const bufferLayoutHelper = new BufferLayoutHelper(this.bufferLayout);
    for (const [bufferName, buffer2] of Object.entries(buffers)) {
      const bufferLayout = bufferLayoutHelper.getBufferLayout(bufferName);
      if (!bufferLayout) {
        if (!disableWarnings) {
          log.warn(`Model(${this.id}): Missing layout for buffer "${bufferName}".`)();
        }
        continue;
      }
      const attributeNames = bufferLayoutHelper.getAttributeNamesForBuffer(bufferLayout);
      let set7 = false;
      for (const attributeName of attributeNames) {
        const attributeInfo = this._attributeInfos[attributeName];
        if (attributeInfo) {
          const location = this.device.type === "webgpu" ? bufferLayoutHelper.getBufferIndex(attributeInfo.bufferName) : attributeInfo.location;
          this.vertexArray.setBuffer(location, buffer2);
          set7 = true;
        }
      }
      if (!set7 && !disableWarnings) {
        log.warn(`Model(${this.id}): Ignoring buffer "${buffer2.id}" for unknown attribute "${bufferName}"`)();
      }
    }
    this.setNeedsRedraw("attributes");
  }
  /**
   * Sets constant attributes
   * @note Overrides any attributes previously set with the same name
   * Constant attributes are only supported in WebGL, not in WebGPU
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @param constantAttributes
   */
  setConstantAttributes(attributes, options) {
    for (const [attributeName, value] of Object.entries(attributes)) {
      const attributeInfo = this._attributeInfos[attributeName];
      if (attributeInfo) {
        this.vertexArray.setConstantWebGL(attributeInfo.location, value);
      } else if (!((options == null ? void 0 : options.disableWarnings) ?? this.props.disableWarnings)) {
        log.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${attributeName}"`)();
      }
    }
    this.setNeedsRedraw("constants");
  }
  // INTERNAL METHODS
  /** Check that bindings are loaded. Returns id of first binding that is still loading. */
  _areBindingsLoading() {
    for (const binding of Object.values(this.bindings)) {
      if (binding instanceof AsyncTexture && !binding.isReady) {
        return binding.id;
      }
    }
    return false;
  }
  /** Extracts texture view from loaded async textures. Returns null if any textures have not yet been loaded. */
  _getBindings() {
    const validBindings = {};
    for (const [name, binding] of Object.entries(this.bindings)) {
      if (binding instanceof AsyncTexture) {
        if (binding.isReady) {
          validBindings[name] = binding.texture;
        }
      } else {
        validBindings[name] = binding;
      }
    }
    return validBindings;
  }
  /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */
  _getBindingsUpdateTimestamp() {
    let timestamp = 0;
    for (const binding of Object.values(this.bindings)) {
      if (binding instanceof TextureView) {
        timestamp = Math.max(timestamp, binding.texture.updateTimestamp);
      } else if (binding instanceof Buffer || binding instanceof Texture) {
        timestamp = Math.max(timestamp, binding.updateTimestamp);
      } else if (binding instanceof AsyncTexture) {
        timestamp = binding.texture ? Math.max(timestamp, binding.texture.updateTimestamp) : (
          // The texture will become available in the future
          Infinity
        );
      } else if (!(binding instanceof Sampler)) {
        timestamp = Math.max(timestamp, binding.buffer.updateTimestamp);
      }
    }
    return timestamp;
  }
  /**
   * Updates the optional geometry attributes
   * Geometry, sets several attributes, indexBuffer, and also vertex count
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  _setGeometryAttributes(gpuGeometry) {
    const attributes = { ...gpuGeometry.attributes };
    for (const [attributeName] of Object.entries(attributes)) {
      if (!this.pipeline.shaderLayout.attributes.find((layout) => layout.name === attributeName) && attributeName !== "positions") {
        delete attributes[attributeName];
      }
    }
    this.vertexCount = gpuGeometry.vertexCount;
    this.setIndexBuffer(gpuGeometry.indices || null);
    this.setAttributes(gpuGeometry.attributes, { disableWarnings: true });
    this.setAttributes(attributes, { disableWarnings: this.props.disableWarnings });
    this.setNeedsRedraw("geometry attributes");
  }
  /** Mark pipeline as needing update */
  _setPipelineNeedsUpdate(reason) {
    this._pipelineNeedsUpdate || (this._pipelineNeedsUpdate = reason);
    this.setNeedsRedraw(reason);
  }
  /** Update pipeline if needed */
  _updatePipeline() {
    if (this._pipelineNeedsUpdate) {
      let prevShaderVs = null;
      let prevShaderFs = null;
      if (this.pipeline) {
        log.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)();
        prevShaderVs = this.pipeline.vs;
        prevShaderFs = this.pipeline.fs;
      }
      this._pipelineNeedsUpdate = false;
      const vs10 = this.shaderFactory.createShader({
        id: `${this.id}-vertex`,
        stage: "vertex",
        source: this.source || this.vs,
        debugShaders: this.props.debugShaders
      });
      let fs8 = null;
      if (this.source) {
        fs8 = vs10;
      } else if (this.fs) {
        fs8 = this.shaderFactory.createShader({
          id: `${this.id}-fragment`,
          stage: "fragment",
          source: this.source || this.fs,
          debugShaders: this.props.debugShaders
        });
      }
      this.pipeline = this.pipelineFactory.createRenderPipeline({
        ...this.props,
        bufferLayout: this.bufferLayout,
        topology: this.topology,
        parameters: this.parameters,
        // TODO - why set bindings here when we reset them every frame?
        // Should we expose a BindGroup abstraction?
        bindings: this._getBindings(),
        vs: vs10,
        fs: fs8
      });
      this._attributeInfos = getAttributeInfosFromLayouts(this.pipeline.shaderLayout, this.bufferLayout);
      if (prevShaderVs)
        this.shaderFactory.release(prevShaderVs);
      if (prevShaderFs)
        this.shaderFactory.release(prevShaderFs);
    }
    return this.pipeline;
  }
  _logDrawCallStart() {
    const logDrawTimeout = log.level > 3 ? 0 : LOG_DRAW_TIMEOUT;
    if (log.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {
      return;
    }
    this._lastLogTime = Date.now();
    this._logOpen = true;
    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, { collapsed: log.level <= 2 })();
  }
  _logDrawCallEnd() {
    if (this._logOpen) {
      const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.shaderLayout, this.id);
      log.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();
      const uniformTable = this.shaderInputs.getDebugTable();
      log.table(LOG_DRAW_PRIORITY, uniformTable)();
      const attributeTable = this._getAttributeDebugTable();
      log.table(LOG_DRAW_PRIORITY, this._attributeInfos)();
      log.table(LOG_DRAW_PRIORITY, attributeTable)();
      log.groupEnd(LOG_DRAW_PRIORITY)();
      this._logOpen = false;
    }
  }
  _logFramebuffer(renderPass) {
    const debugFramebuffers = this.device.props.debugFramebuffers;
    this._drawCount++;
    if (!debugFramebuffers) {
      return;
    }
    const framebuffer = renderPass.props.framebuffer;
    if (framebuffer) {
      debugFramebuffer(framebuffer, { id: framebuffer.id, minimap: true });
    }
  }
  _getAttributeDebugTable() {
    const table = {};
    for (const [name, attributeInfo] of Object.entries(this._attributeInfos)) {
      const values = this.vertexArray.attributes[attributeInfo.location];
      table[attributeInfo.location] = {
        name,
        type: attributeInfo.shaderType,
        values: values ? this._getBufferOrConstantValues(values, attributeInfo.bufferDataType) : "null"
      };
    }
    if (this.vertexArray.indexBuffer) {
      const { indexBuffer } = this.vertexArray;
      const values = indexBuffer.indexType === "uint32" ? new Uint32Array(indexBuffer.debugData) : new Uint16Array(indexBuffer.debugData);
      table["indices"] = {
        name: "indices",
        type: indexBuffer.indexType,
        values: values.toString()
      };
    }
    return table;
  }
  // TODO - fix typing of luma data types
  _getBufferOrConstantValues(attribute, dataType) {
    const TypedArrayConstructor = getTypedArrayConstructor(dataType);
    const typedArray = attribute instanceof Buffer ? new TypedArrayConstructor(attribute.debugData) : attribute;
    return typedArray.toString();
  }
};
__publicField(_Model, "defaultProps", {
  ...RenderPipeline.defaultProps,
  source: void 0,
  vs: null,
  fs: null,
  id: "unnamed",
  handle: void 0,
  userData: {},
  defines: {},
  modules: [],
  geometry: null,
  indexBuffer: null,
  attributes: {},
  constantAttributes: {},
  varyings: [],
  isInstanced: void 0,
  instanceCount: 0,
  vertexCount: 0,
  shaderInputs: void 0,
  pipelineFactory: void 0,
  shaderFactory: void 0,
  transformFeedback: void 0,
  shaderAssembler: ShaderAssembler.getDefaultShaderAssembler(),
  debugShaders: void 0,
  disableWarnings: void 0
});
var Model = _Model;
function shaderModuleHasUniforms(module) {
  return Boolean(module.uniformTypes && !isObjectEmpty(module.uniformTypes));
}
function getPlatformInfo(device) {
  return {
    type: device.type,
    shaderLanguage: device.info.shadingLanguage,
    shaderLanguageVersion: device.info.shadingLanguageVersion,
    gpu: device.info.gpu,
    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API
    features: device.features
  };
}
function isObjectEmpty(obj) {
  for (const key in obj) {
    return false;
  }
  return true;
}

// node_modules/@luma.gl/engine/dist/geometry/geometry.js
var Geometry = class {
  constructor(props) {
    __publicField(this, "id");
    /** Determines how vertices are read from the 'vertex' attributes */
    __publicField(this, "topology");
    __publicField(this, "vertexCount");
    __publicField(this, "indices");
    __publicField(this, "attributes");
    __publicField(this, "userData", {});
    const { attributes = {}, indices = null, vertexCount = null } = props;
    this.id = props.id || uid("geometry");
    this.topology = props.topology;
    if (indices) {
      this.indices = ArrayBuffer.isView(indices) ? { value: indices, size: 1 } : indices;
    }
    this.attributes = {};
    for (const [attributeName, attributeValue] of Object.entries(attributes)) {
      const attribute = ArrayBuffer.isView(attributeValue) ? { value: attributeValue } : attributeValue;
      if (!ArrayBuffer.isView(attribute.value)) {
        throw new Error(`${this._print(attributeName)}: must be typed array or object with value as typed array`);
      }
      if ((attributeName === "POSITION" || attributeName === "positions") && !attribute.size) {
        attribute.size = 3;
      }
      if (attributeName === "indices") {
        if (this.indices) {
          throw new Error("Multiple indices detected");
        }
        this.indices = attribute;
      } else {
        this.attributes[attributeName] = attribute;
      }
    }
    if (this.indices && this.indices["isIndexed"] !== void 0) {
      this.indices = Object.assign({}, this.indices);
      delete this.indices["isIndexed"];
    }
    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
  }
  getVertexCount() {
    return this.vertexCount;
  }
  /**
   * Return an object with all attributes plus indices added as a field.
   * TODO Geometry types are a mess
   */
  getAttributes() {
    return this.indices ? { indices: this.indices, ...this.attributes } : this.attributes;
  }
  // PRIVATE
  _print(attributeName) {
    return `Geometry ${this.id} attribute ${attributeName}`;
  }
  /**
   * GeometryAttribute
   * value: typed array
   * type: indices, vertices, uvs
   * size: elements per vertex
   * target: WebGL buffer type (string or constant)
   *
   * @param attributes
   * @param indices
   * @returns
   */
  _setAttributes(attributes, indices) {
    return this;
  }
  _calculateVertexCount(attributes, indices) {
    if (indices) {
      return indices.value.length;
    }
    let vertexCount = Infinity;
    for (const attribute of Object.values(attributes)) {
      const { value, size, constant } = attribute;
      if (!constant && value && size !== void 0 && size >= 1) {
        vertexCount = Math.min(vertexCount, value.length / size);
      }
    }
    return vertexCount;
  }
};

// node_modules/@luma.gl/engine/dist/geometries/cube-geometry.js
var CubeGeometry = class extends Geometry {
  constructor(props = {}) {
    const { id = uid("cube-geometry"), indices = true } = props;
    super(indices ? {
      ...props,
      id,
      topology: "triangle-list",
      indices: { size: 1, value: CUBE_INDICES },
      attributes: { ...ATTRIBUTES, ...props.attributes }
    } : {
      ...props,
      id,
      topology: "triangle-list",
      indices: void 0,
      attributes: { ...NON_INDEXED_ATTRIBUTES, ...props.attributes }
    });
  }
};
var CUBE_INDICES = new Uint16Array([
  0,
  1,
  2,
  0,
  2,
  3,
  4,
  5,
  6,
  4,
  6,
  7,
  8,
  9,
  10,
  8,
  10,
  11,
  12,
  13,
  14,
  12,
  14,
  15,
  16,
  17,
  18,
  16,
  18,
  19,
  20,
  21,
  22,
  20,
  22,
  23
]);
var CUBE_POSITIONS = new Float32Array([
  -1,
  -1,
  1,
  1,
  -1,
  1,
  1,
  1,
  1,
  -1,
  1,
  1,
  -1,
  -1,
  -1,
  -1,
  1,
  -1,
  1,
  1,
  -1,
  1,
  -1,
  -1,
  -1,
  1,
  -1,
  -1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  -1,
  -1,
  -1,
  -1,
  1,
  -1,
  -1,
  1,
  -1,
  1,
  -1,
  -1,
  1,
  1,
  -1,
  -1,
  1,
  1,
  -1,
  1,
  1,
  1,
  1,
  -1,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  -1,
  1,
  1,
  -1,
  1,
  -1
]);
var CUBE_NORMALS = new Float32Array([
  // Front face
  0,
  0,
  1,
  0,
  0,
  1,
  0,
  0,
  1,
  0,
  0,
  1,
  // Back face
  0,
  0,
  -1,
  0,
  0,
  -1,
  0,
  0,
  -1,
  0,
  0,
  -1,
  // Top face
  0,
  1,
  0,
  0,
  1,
  0,
  0,
  1,
  0,
  0,
  1,
  0,
  // Bottom face
  0,
  -1,
  0,
  0,
  -1,
  0,
  0,
  -1,
  0,
  0,
  -1,
  0,
  // Right face
  1,
  0,
  0,
  1,
  0,
  0,
  1,
  0,
  0,
  1,
  0,
  0,
  // Left face
  -1,
  0,
  0,
  -1,
  0,
  0,
  -1,
  0,
  0,
  -1,
  0,
  0
]);
var CUBE_TEX_COORDS = new Float32Array([
  // Front face
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  1,
  // Back face
  1,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  // Top face
  0,
  1,
  0,
  0,
  1,
  0,
  1,
  1,
  // Bottom face
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  0,
  // Right face
  1,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  // Left face
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  1
]);
var CUBE_NON_INDEXED_POSITIONS = new Float32Array([
  1,
  -1,
  1,
  -1,
  -1,
  1,
  -1,
  -1,
  -1,
  1,
  -1,
  -1,
  1,
  -1,
  1,
  -1,
  -1,
  -1,
  1,
  1,
  1,
  1,
  -1,
  1,
  1,
  -1,
  -1,
  1,
  1,
  -1,
  1,
  1,
  1,
  1,
  -1,
  -1,
  -1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  -1,
  -1,
  1,
  -1,
  -1,
  1,
  1,
  1,
  1,
  -1,
  -1,
  -1,
  1,
  -1,
  1,
  1,
  -1,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  -1,
  1,
  -1,
  1,
  1,
  1,
  -1,
  1,
  1,
  -1,
  -1,
  1,
  -1,
  -1,
  1,
  1,
  -1,
  1,
  1,
  1,
  1,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  -1,
  1,
  1,
  -1,
  1,
  -1,
  -1,
  -1,
  1,
  -1
]);
var CUBE_NON_INDEXED_TEX_COORDS = new Float32Array([
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  0
]);
var CUBE_NON_INDEXED_COLORS = new Float32Array([
  1,
  0,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  1,
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  0,
  1,
  0,
  1,
  0,
  1
]);
var ATTRIBUTES = {
  POSITION: { size: 3, value: CUBE_POSITIONS },
  NORMAL: { size: 3, value: CUBE_NORMALS },
  TEXCOORD_0: { size: 2, value: CUBE_TEX_COORDS }
};
var NON_INDEXED_ATTRIBUTES = {
  POSITION: { size: 3, value: CUBE_NON_INDEXED_POSITIONS },
  // NORMAL: {size: 3, value: CUBE_NON_INDEXED_NORMALS},
  TEXCOORD_0: { size: 2, value: CUBE_NON_INDEXED_TEX_COORDS },
  COLOR_0: { size: 3, value: CUBE_NON_INDEXED_COLORS }
};

// node_modules/@luma.gl/engine/dist/animation/timeline.js
var channelHandles = 1;
var animationHandles = 1;
var Timeline = class {
  constructor() {
    __publicField(this, "time", 0);
    __publicField(this, "channels", /* @__PURE__ */ new Map());
    __publicField(this, "animations", /* @__PURE__ */ new Map());
    __publicField(this, "playing", false);
    __publicField(this, "lastEngineTime", -1);
  }
  addChannel(props) {
    const { delay = 0, duration = Number.POSITIVE_INFINITY, rate = 1, repeat = 1 } = props;
    const channelId = channelHandles++;
    const channel = {
      time: 0,
      delay,
      duration,
      rate,
      repeat
    };
    this._setChannelTime(channel, this.time);
    this.channels.set(channelId, channel);
    return channelId;
  }
  removeChannel(channelId) {
    this.channels.delete(channelId);
    for (const [animationHandle, animation] of this.animations) {
      if (animation.channel === channelId) {
        this.detachAnimation(animationHandle);
      }
    }
  }
  isFinished(channelId) {
    const channel = this.channels.get(channelId);
    if (channel === void 0) {
      return false;
    }
    return this.time >= channel.delay + channel.duration * channel.repeat;
  }
  getTime(channelId) {
    if (channelId === void 0) {
      return this.time;
    }
    const channel = this.channels.get(channelId);
    if (channel === void 0) {
      return -1;
    }
    return channel.time;
  }
  setTime(time) {
    this.time = Math.max(0, time);
    const channels = this.channels.values();
    for (const channel of channels) {
      this._setChannelTime(channel, this.time);
    }
    const animations = this.animations.values();
    for (const animationData of animations) {
      const { animation, channel } = animationData;
      animation.setTime(this.getTime(channel));
    }
  }
  play() {
    this.playing = true;
  }
  pause() {
    this.playing = false;
    this.lastEngineTime = -1;
  }
  reset() {
    this.setTime(0);
  }
  attachAnimation(animation, channelHandle) {
    const animationHandle = animationHandles++;
    this.animations.set(animationHandle, {
      animation,
      channel: channelHandle
    });
    animation.setTime(this.getTime(channelHandle));
    return animationHandle;
  }
  detachAnimation(channelId) {
    this.animations.delete(channelId);
  }
  update(engineTime) {
    if (this.playing) {
      if (this.lastEngineTime === -1) {
        this.lastEngineTime = engineTime;
      }
      this.setTime(this.time + (engineTime - this.lastEngineTime));
      this.lastEngineTime = engineTime;
    }
  }
  _setChannelTime(channel, time) {
    const offsetTime = time - channel.delay;
    const totalDuration = channel.duration * channel.repeat;
    if (offsetTime >= totalDuration) {
      channel.time = channel.duration * channel.rate;
    } else {
      channel.time = Math.max(0, offsetTime) % channel.duration;
      channel.time *= channel.rate;
    }
  }
};

// node_modules/@luma.gl/engine/dist/animation-loop/request-animation-frame.js
function requestAnimationFramePolyfill(callback) {
  return typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1e3 / 60);
}
function cancelAnimationFramePolyfill(timerId) {
  return typeof window !== "undefined" && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
}

// node_modules/@luma.gl/engine/dist/animation-loop/animation-loop.js
var statIdCounter = 0;
var _AnimationLoop = class _AnimationLoop {
  // _gpuTimeQuery: Query | null = null;
  /*
   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context
   */
  constructor(props) {
    __publicField(this, "device", null);
    __publicField(this, "canvas", null);
    __publicField(this, "props");
    __publicField(this, "animationProps", null);
    __publicField(this, "timeline", null);
    __publicField(this, "stats");
    __publicField(this, "cpuTime");
    __publicField(this, "gpuTime");
    __publicField(this, "frameRate");
    __publicField(this, "display");
    __publicField(this, "needsRedraw", "initialized");
    __publicField(this, "_initialized", false);
    __publicField(this, "_running", false);
    __publicField(this, "_animationFrameId", null);
    __publicField(this, "_nextFramePromise", null);
    __publicField(this, "_resolveNextFrame", null);
    __publicField(this, "_cpuStartTime", 0);
    __publicField(this, "_error", null);
    this.props = { ..._AnimationLoop.defaultAnimationLoopProps, ...props };
    props = this.props;
    if (!props.device) {
      throw new Error("No device provided");
    }
    this.stats = props.stats || new Stats({ id: "animation-loop-stats" });
    this.cpuTime = this.stats.get("CPU Time");
    this.gpuTime = this.stats.get("GPU Time");
    this.frameRate = this.stats.get("Frame Rate");
    this.setProps({ autoResizeViewport: props.autoResizeViewport });
    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
    this._onMousemove = this._onMousemove.bind(this);
    this._onMouseleave = this._onMouseleave.bind(this);
  }
  destroy() {
    this.stop();
    this._setDisplay(null);
  }
  /** @deprecated Use .destroy() */
  delete() {
    this.destroy();
  }
  reportError(error) {
    this.props.onError(error);
    this._error = error;
  }
  /** Flags this animation loop as needing redraw */
  setNeedsRedraw(reason) {
    this.needsRedraw = this.needsRedraw || reason;
    return this;
  }
  setProps(props) {
    if ("autoResizeViewport" in props) {
      this.props.autoResizeViewport = props.autoResizeViewport || false;
    }
    return this;
  }
  /** Starts a render loop if not already running */
  async start() {
    if (this._running) {
      return this;
    }
    this._running = true;
    try {
      let appContext;
      if (!this._initialized) {
        this._initialized = true;
        await this._initDevice();
        this._initialize();
        await this.props.onInitialize(this._getAnimationProps());
      }
      if (!this._running) {
        return null;
      }
      if (appContext !== false) {
        this._cancelAnimationFrame();
        this._requestAnimationFrame();
      }
      return this;
    } catch (err) {
      const error = err instanceof Error ? err : new Error("Unknown error");
      this.props.onError(error);
      throw error;
    }
  }
  /** Stops a render loop if already running, finalizing */
  stop() {
    if (this._running) {
      if (this.animationProps && !this._error) {
        this.props.onFinalize(this.animationProps);
      }
      this._cancelAnimationFrame();
      this._nextFramePromise = null;
      this._resolveNextFrame = null;
      this._running = false;
    }
    return this;
  }
  /** Explicitly draw a frame */
  redraw() {
    var _a3;
    if (((_a3 = this.device) == null ? void 0 : _a3.isLost) || this._error) {
      return this;
    }
    this._beginFrameTimers();
    this._setupFrame();
    this._updateAnimationProps();
    this._renderFrame(this._getAnimationProps());
    this._clearNeedsRedraw();
    if (this._resolveNextFrame) {
      this._resolveNextFrame(this);
      this._nextFramePromise = null;
      this._resolveNextFrame = null;
    }
    this._endFrameTimers();
    return this;
  }
  /** Add a timeline, it will be automatically updated by the animation loop. */
  attachTimeline(timeline) {
    this.timeline = timeline;
    return this.timeline;
  }
  /** Remove a timeline */
  detachTimeline() {
    this.timeline = null;
  }
  /** Wait until a render completes */
  waitForRender() {
    this.setNeedsRedraw("waitForRender");
    if (!this._nextFramePromise) {
      this._nextFramePromise = new Promise((resolve2) => {
        this._resolveNextFrame = resolve2;
      });
    }
    return this._nextFramePromise;
  }
  /** TODO - should use device.deviceContext */
  async toDataURL() {
    this.setNeedsRedraw("toDataURL");
    await this.waitForRender();
    if (this.canvas instanceof HTMLCanvasElement) {
      return this.canvas.toDataURL();
    }
    throw new Error("OffscreenCanvas");
  }
  // PRIVATE METHODS
  _initialize() {
    this._startEventHandling();
    this._initializeAnimationProps();
    this._updateAnimationProps();
    this._resizeViewport();
  }
  _setDisplay(display) {
    if (this.display) {
      this.display.destroy();
      this.display.animationLoop = null;
    }
    if (display) {
      display.animationLoop = this;
    }
    this.display = display;
  }
  _requestAnimationFrame() {
    if (!this._running) {
      return;
    }
    this._animationFrameId = requestAnimationFramePolyfill(this._animationFrame.bind(this));
  }
  _cancelAnimationFrame() {
    if (this._animationFrameId === null) {
      return;
    }
    cancelAnimationFramePolyfill(this._animationFrameId);
    this._animationFrameId = null;
  }
  _animationFrame() {
    if (!this._running) {
      return;
    }
    this.redraw();
    this._requestAnimationFrame();
  }
  // Called on each frame, can be overridden to call onRender multiple times
  // to support e.g. stereoscopic rendering
  _renderFrame(animationProps) {
    var _a3;
    if (this.display) {
      this.display._renderFrame(animationProps);
      return;
    }
    this.props.onRender(this._getAnimationProps());
    (_a3 = this.device) == null ? void 0 : _a3.submit();
  }
  _clearNeedsRedraw() {
    this.needsRedraw = false;
  }
  _setupFrame() {
    this._resizeViewport();
  }
  // Initialize the  object that will be passed to app callbacks
  _initializeAnimationProps() {
    var _a3;
    const canvasContext = (_a3 = this.device) == null ? void 0 : _a3.getDefaultCanvasContext();
    if (!this.device || !canvasContext) {
      throw new Error("loop");
    }
    const canvas2 = canvasContext == null ? void 0 : canvasContext.canvas;
    const useDevicePixels = canvasContext.props.useDevicePixels;
    this.animationProps = {
      animationLoop: this,
      device: this.device,
      canvasContext,
      canvas: canvas2,
      // @ts-expect-error Deprecated
      useDevicePixels,
      timeline: this.timeline,
      needsRedraw: false,
      // Placeholders
      width: 1,
      height: 1,
      aspect: 1,
      // Animation props
      time: 0,
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,
      // Experimental
      _mousePosition: null
      // Event props
    };
  }
  _getAnimationProps() {
    if (!this.animationProps) {
      throw new Error("animationProps");
    }
    return this.animationProps;
  }
  // Update the context object that will be passed to app callbacks
  _updateAnimationProps() {
    if (!this.animationProps) {
      return;
    }
    const { width, height, aspect } = this._getSizeAndAspect();
    if (width !== this.animationProps.width || height !== this.animationProps.height) {
      this.setNeedsRedraw("drawing buffer resized");
    }
    if (aspect !== this.animationProps.aspect) {
      this.setNeedsRedraw("drawing buffer aspect changed");
    }
    this.animationProps.width = width;
    this.animationProps.height = height;
    this.animationProps.aspect = aspect;
    this.animationProps.needsRedraw = this.needsRedraw;
    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
    if (this.timeline) {
      this.timeline.update(this.animationProps.engineTime);
    }
    this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60);
    this.animationProps.tock++;
    this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
  }
  /** Wait for supplied device */
  async _initDevice() {
    this.device = await this.props.device;
    if (!this.device) {
      throw new Error("No device provided");
    }
    this.canvas = this.device.getDefaultCanvasContext().canvas || null;
  }
  _createInfoDiv() {
    if (this.canvas && this.props.onAddHTML) {
      const wrapperDiv = document.createElement("div");
      document.body.appendChild(wrapperDiv);
      wrapperDiv.style.position = "relative";
      const div4 = document.createElement("div");
      div4.style.position = "absolute";
      div4.style.left = "10px";
      div4.style.bottom = "10px";
      div4.style.width = "300px";
      div4.style.background = "white";
      if (this.canvas instanceof HTMLCanvasElement) {
        wrapperDiv.appendChild(this.canvas);
      }
      wrapperDiv.appendChild(div4);
      const html = this.props.onAddHTML(div4);
      if (html) {
        div4.innerHTML = html;
      }
    }
  }
  _getSizeAndAspect() {
    var _a3, _b;
    if (!this.device) {
      return { width: 1, height: 1, aspect: 1 };
    }
    const [width, height] = ((_a3 = this.device) == null ? void 0 : _a3.getDefaultCanvasContext().getDevicePixelSize()) || [1, 1];
    let aspect = 1;
    const canvas2 = (_b = this.device) == null ? void 0 : _b.getDefaultCanvasContext().canvas;
    if (canvas2 && canvas2.clientHeight) {
      aspect = canvas2.clientWidth / canvas2.clientHeight;
    } else if (width > 0 && height > 0) {
      aspect = width / height;
    }
    return { width, height, aspect };
  }
  /** @deprecated Default viewport setup */
  _resizeViewport() {
    if (this.props.autoResizeViewport && this.device.gl) {
      this.device.gl.viewport(
        0,
        0,
        // @ts-expect-error Expose canvasContext
        this.device.gl.drawingBufferWidth,
        // @ts-expect-error Expose canvasContext
        this.device.gl.drawingBufferHeight
      );
    }
  }
  _beginFrameTimers() {
    this.frameRate.timeEnd();
    this.frameRate.timeStart();
    this.cpuTime.timeStart();
  }
  _endFrameTimers() {
    this.cpuTime.timeEnd();
  }
  // Event handling
  _startEventHandling() {
    if (this.canvas) {
      this.canvas.addEventListener("mousemove", this._onMousemove.bind(this));
      this.canvas.addEventListener("mouseleave", this._onMouseleave.bind(this));
    }
  }
  _onMousemove(event) {
    if (event instanceof MouseEvent) {
      this._getAnimationProps()._mousePosition = [event.offsetX, event.offsetY];
    }
  }
  _onMouseleave(event) {
    this._getAnimationProps()._mousePosition = null;
  }
};
__publicField(_AnimationLoop, "defaultAnimationLoopProps", {
  device: null,
  onAddHTML: () => "",
  onInitialize: async () => null,
  onRender: () => {
  },
  onFinalize: () => {
  },
  onError: (error) => console.error(error),
  // eslint-disable-line no-console
  stats: luma.stats.get(`animation-loop-${statIdCounter++}`),
  // view parameters
  autoResizeViewport: false
});
var AnimationLoop = _AnimationLoop;

// node_modules/@luma.gl/engine/dist/compute/buffer-transform.js
var _BufferTransform = class _BufferTransform {
  constructor(device, props = _BufferTransform.defaultProps) {
    __publicField(this, "device");
    __publicField(this, "model");
    __publicField(this, "transformFeedback");
    if (!_BufferTransform.isSupported(device)) {
      throw new Error("BufferTransform not yet implemented on WebGPU");
    }
    this.device = device;
    this.model = new Model(this.device, {
      id: props.id || "buffer-transform-model",
      fs: props.fs || getPassthroughFS(),
      topology: props.topology || "point-list",
      varyings: props.outputs || props.varyings,
      ...props
    });
    this.transformFeedback = this.device.createTransformFeedback({
      layout: this.model.pipeline.shaderLayout,
      // @ts-expect-error TODO
      buffers: props.feedbackBuffers
    });
    this.model.setTransformFeedback(this.transformFeedback);
    Object.seal(this);
  }
  static isSupported(device) {
    var _a3;
    return ((_a3 = device == null ? void 0 : device.info) == null ? void 0 : _a3.type) === "webgl";
  }
  /** Destroy owned resources. */
  destroy() {
    if (this.model) {
      this.model.destroy();
    }
  }
  /** @deprecated Use {@link destroy}. */
  delete() {
    this.destroy();
  }
  /** Run one transform loop. */
  run(options) {
    if (options == null ? void 0 : options.inputBuffers) {
      this.model.setAttributes(options.inputBuffers);
    }
    if (options == null ? void 0 : options.outputBuffers) {
      this.transformFeedback.setBuffers(options.outputBuffers);
    }
    const renderPass = this.device.beginRenderPass(options);
    this.model.draw(renderPass);
    renderPass.end();
  }
  // DEPRECATED METHODS
  /** @deprecated App knows what buffers it is passing in - Returns the {@link Buffer} or {@link BufferRange} for given varying name. */
  getBuffer(varyingName) {
    return this.transformFeedback.getBuffer(varyingName);
  }
  /** @deprecated App knows what buffers it is passing in - Reads the {@link Buffer} or {@link BufferRange} for given varying name. */
  readAsync(varyingName) {
    const result = this.getBuffer(varyingName);
    if (!result) {
      throw new Error("BufferTransform#getBuffer");
    }
    if (result instanceof Buffer) {
      return result.readAsync();
    }
    const { buffer: buffer2, byteOffset = 0, byteLength = buffer2.byteLength } = result;
    return buffer2.readAsync(byteOffset, byteLength);
  }
};
__publicField(_BufferTransform, "defaultProps", {
  ...Model.defaultProps,
  outputs: void 0,
  feedbackBuffers: void 0
});
var BufferTransform = _BufferTransform;

// node_modules/@luma.gl/engine/dist/compute/computation.js
var LOG_DRAW_PRIORITY2 = 2;
var LOG_DRAW_TIMEOUT2 = 1e4;
var _Computation = class _Computation {
  constructor(device, props) {
    __publicField(this, "device");
    __publicField(this, "id");
    __publicField(this, "pipelineFactory");
    __publicField(this, "shaderFactory");
    __publicField(this, "userData", {});
    /** Bindings (textures, samplers, uniform buffers) */
    __publicField(this, "bindings", {});
    /** The underlying GPU pipeline. */
    __publicField(this, "pipeline");
    /** Assembled compute shader source */
    __publicField(this, "source");
    /** the underlying compiled compute shader */
    // @ts-ignore Set in function called from constructor
    __publicField(this, "shader");
    /** ShaderInputs instance */
    __publicField(this, "shaderInputs");
    // @ts-ignore Set in function called from constructor
    __publicField(this, "_uniformStore");
    __publicField(this, "_pipelineNeedsUpdate", "newly created");
    __publicField(this, "_getModuleUniforms");
    __publicField(this, "props");
    __publicField(this, "_destroyed", false);
    /** Throttle draw call logging */
    __publicField(this, "_lastLogTime", 0);
    __publicField(this, "_logOpen", false);
    __publicField(this, "_drawCount", 0);
    var _a3, _b, _c, _d;
    if (device.type !== "webgpu") {
      throw new Error("Computation is only supported in WebGPU");
    }
    this.props = { ..._Computation.defaultProps, ...props };
    props = this.props;
    this.id = props.id || uid("model");
    this.device = device;
    Object.assign(this.userData, props.userData);
    const moduleMap = Object.fromEntries(((_a3 = this.props.modules) == null ? void 0 : _a3.map((module) => [module.name, module])) || []);
    this.shaderInputs = props.shaderInputs || new ShaderInputs(moduleMap);
    this.setShaderInputs(this.shaderInputs);
    (_b = this.props).shaderLayout || (_b.shaderLayout = getShaderLayoutFromWGSL(this.props.source));
    const platformInfo = getPlatformInfo2(device);
    const modules = (((_c = this.props.modules) == null ? void 0 : _c.length) > 0 ? this.props.modules : (_d = this.shaderInputs) == null ? void 0 : _d.getModules()) || [];
    this.pipelineFactory = props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);
    this.shaderFactory = props.shaderFactory || ShaderFactory.getDefaultShaderFactory(this.device);
    const { source: source6, getUniforms: getUniforms5 } = this.props.shaderAssembler.assembleWGSLShader({
      platformInfo,
      ...this.props,
      modules
    });
    this.source = source6;
    this._getModuleUniforms = getUniforms5;
    this.pipeline = this._updatePipeline();
    if (props.bindings) {
      this.setBindings(props.bindings);
    }
    Object.seal(this);
  }
  destroy() {
    if (this._destroyed)
      return;
    this.pipelineFactory.release(this.pipeline);
    this.shaderFactory.release(this.shader);
    this._uniformStore.destroy();
    this._destroyed = true;
  }
  // Draw call
  predraw() {
    this.updateShaderInputs();
  }
  dispatch(computePass, x2, y2, z2) {
    try {
      this._logDrawCallStart();
      this.pipeline = this._updatePipeline();
      this.pipeline.setBindings(this.bindings);
      computePass.setPipeline(this.pipeline);
      computePass.setBindings([]);
      computePass.dispatch(x2, y2, z2);
    } finally {
      this._logDrawCallEnd();
    }
  }
  // Update fixed fields (can trigger pipeline rebuild)
  // Update dynamic fields
  /**
   * Updates the vertex count (used in draw calls)
   * @note Any attributes with stepMode=vertex need to be at least this big
   */
  setVertexCount(vertexCount) {
  }
  /**
   * Updates the instance count (used in draw calls)
   * @note Any attributes with stepMode=instance need to be at least this big
   */
  setInstanceCount(instanceCount) {
  }
  setShaderInputs(shaderInputs) {
    this.shaderInputs = shaderInputs;
    this._uniformStore = new UniformStore(this.shaderInputs.modules);
    for (const moduleName of Object.keys(this.shaderInputs.modules)) {
      const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);
      this.bindings[`${moduleName}Uniforms`] = uniformBuffer;
    }
  }
  /**
   * Updates shader module settings (which results in uniforms being set)
   */
  setShaderModuleProps(props) {
    const uniforms = this._getModuleUniforms(props);
    const keys = Object.keys(uniforms).filter((k2) => {
      const uniform = uniforms[k2];
      return !isNumericArray(uniform) && typeof uniform !== "number" && typeof uniform !== "boolean";
    });
    const bindings = {};
    for (const k2 of keys) {
      bindings[k2] = uniforms[k2];
      delete uniforms[k2];
    }
  }
  updateShaderInputs() {
    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());
  }
  /**
   * Sets bindings (textures, samplers, uniform buffers)
   */
  setBindings(bindings) {
    Object.assign(this.bindings, bindings);
  }
  _setPipelineNeedsUpdate(reason) {
    this._pipelineNeedsUpdate = this._pipelineNeedsUpdate || reason;
  }
  _updatePipeline() {
    if (this._pipelineNeedsUpdate) {
      let prevShader = null;
      if (this.pipeline) {
        log.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)();
        prevShader = this.shader;
      }
      this._pipelineNeedsUpdate = false;
      this.shader = this.shaderFactory.createShader({
        id: `${this.id}-fragment`,
        stage: "compute",
        source: this.source,
        debugShaders: this.props.debugShaders
      });
      this.pipeline = this.pipelineFactory.createComputePipeline({
        ...this.props,
        shader: this.shader
      });
      if (prevShader) {
        this.shaderFactory.release(prevShader);
      }
    }
    return this.pipeline;
  }
  _logDrawCallStart() {
    const logDrawTimeout = log.level > 3 ? 0 : LOG_DRAW_TIMEOUT2;
    if (log.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {
      return;
    }
    this._lastLogTime = Date.now();
    this._logOpen = true;
    log.group(LOG_DRAW_PRIORITY2, `>>> DRAWING MODEL ${this.id}`, { collapsed: log.level <= 2 })();
  }
  _logDrawCallEnd() {
    if (this._logOpen) {
      const uniformTable = this.shaderInputs.getDebugTable();
      log.table(LOG_DRAW_PRIORITY2, uniformTable)();
      log.groupEnd(LOG_DRAW_PRIORITY2)();
      this._logOpen = false;
    }
  }
  // TODO - fix typing of luma data types
  _getBufferOrConstantValues(attribute, dataType) {
    const TypedArrayConstructor = getTypedArrayConstructor(dataType);
    const typedArray = attribute instanceof Buffer ? new TypedArrayConstructor(attribute.debugData) : attribute;
    return typedArray.toString();
  }
};
__publicField(_Computation, "defaultProps", {
  ...ComputePipeline.defaultProps,
  id: "unnamed",
  handle: void 0,
  userData: {},
  source: "",
  modules: [],
  defines: {},
  bindings: void 0,
  shaderInputs: void 0,
  pipelineFactory: void 0,
  shaderFactory: void 0,
  shaderAssembler: ShaderAssembler.getDefaultShaderAssembler(),
  debugShaders: void 0
});
var Computation = _Computation;
function getPlatformInfo2(device) {
  return {
    type: device.type,
    shaderLanguage: device.info.shadingLanguage,
    shaderLanguageVersion: device.info.shadingLanguageVersion,
    gpu: device.info.gpu,
    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API
    features: device.features
  };
}

// node_modules/@luma.gl/engine/dist/modules/picking/picking-uniforms.js
var DEFAULT_HIGHLIGHT_COLOR2 = [0, 1, 1, 1];
var INVALID_INDEX = -1;
var uniformTypes = {
  isActive: "i32",
  indexMode: "i32",
  batchIndex: "i32",
  isHighlightActive: "i32",
  highlightedBatchIndex: "i32",
  highlightedObjectIndex: "i32",
  highlightColor: "vec4<f32>"
};
var GLSL_UNIFORMS = (
  /* glsl */
  `precision highp float;
precision highp int;

uniform pickingUniforms {
  int isActive;
  int indexMode;
  int batchIndex;

  int isHighlightActive;
  int highlightedBatchIndex;
  int highlightedObjectIndex;
  vec4 highlightColor;
} picking;
`
);
var WGSL_UNIFORMS = (
  /* wgsl */
  `struct pickingUniforms {
  isActive: int32;
  indexMode: int32;
  batchIndex: int32;

  isHighlightActive: int32;
  highlightedBatchIndex: int32;
  highlightedObjectIndex: int32;
  highlightColor: vec4<f32>;
} picking;
`
);
function getUniforms4(props = {}, prevUniforms) {
  const uniforms = { ...prevUniforms };
  if (props.isActive !== void 0) {
    uniforms.isActive = Boolean(props.isActive);
  }
  switch (props.indexMode) {
    case "instance":
      uniforms.indexMode = 0;
      break;
    case "custom":
      uniforms.indexMode = 1;
      break;
    case void 0:
      break;
  }
  switch (props.highlightedObjectIndex) {
    case void 0:
      break;
    case null:
      uniforms.isHighlightActive = false;
      uniforms.highlightedObjectIndex = INVALID_INDEX;
      break;
    default:
      uniforms.isHighlightActive = true;
      uniforms.highlightedObjectIndex = props.highlightedObjectIndex;
  }
  if (typeof props.highlightedBatchIndex === "number") {
    uniforms.highlightedBatchIndex = props.highlightedBatchIndex;
  }
  if (props.highlightColor) {
    uniforms.highlightColor = props.highlightColor;
  }
  return uniforms;
}
var pickingUniforms = {
  props: {},
  uniforms: {},
  name: "picking",
  uniformTypes,
  defaultUniforms: {
    isActive: false,
    indexMode: 0,
    batchIndex: 0,
    isHighlightActive: true,
    highlightedBatchIndex: INVALID_INDEX,
    highlightedObjectIndex: INVALID_INDEX,
    highlightColor: DEFAULT_HIGHLIGHT_COLOR2
  },
  getUniforms: getUniforms4
};

// node_modules/@luma.gl/engine/dist/modules/picking/index-picking.js
var source4 = (
  /* wgsl */
  `${WGSL_UNIFORMS}

const INDEX_PICKING_MODE_INSTANCE = 0;
const INDEX_PICKING_MODE_CUSTOM = 1;
const INDEX_PICKING_INVALID_INDEX = ${INVALID_INDEX}; // 2^32 - 1

struct indexPickingFragmentInputs = {
  objectIndex: int32;
};

let indexPickingFragmentInputs: indexPickingFragmentInputs;

/**
 * Vertex shaders should call this function to set the object index.
 * If using instance or vertex mode, argument will be ignored, 0 can be supplied.
 */
fn picking_setObjectIndex(objectIndex: int32) {
  switch (picking.indexMode) {
    case INDEX_PICKING_MODE_INSTANCE, default: {
      picking_objectIndex = instance_index;
    };
    case INDEX_PICKING_MODE_CUSTOM: {
      picking_objectIndex = objectIndex;
    };
  }
}

`
);
var vs6 = (
  /* glsl */
  `${GLSL_UNIFORMS}

const int INDEX_PICKING_MODE_INSTANCE = 0;
const int INDEX_PICKING_MODE_CUSTOM = 1;

const int INDEX_PICKING_INVALID_INDEX = ${INVALID_INDEX}; // 2^32 - 1

flat out int picking_objectIndex;

/**
 * Vertex shaders should call this function to set the object index.
 * If using instance or vertex mode, argument will be ignored, 0 can be supplied.
 */
void picking_setObjectIndex(int objectIndex) {
  switch (picking.indexMode) {
    case INDEX_PICKING_MODE_INSTANCE:
      picking_objectIndex = gl_InstanceID;
      break;
    case INDEX_PICKING_MODE_CUSTOM:
      picking_objectIndex = objectIndex;
      break;
  }
}
`
);
var fs5 = (
  /* glsl */
  `${GLSL_UNIFORMS}

const int INDEX_PICKING_INVALID_INDEX = ${INVALID_INDEX}; // 2^32 - 1

flat in int picking_objectIndex;

/**
 * Check if this vertex is highlighted (part of the selected batch and object)
 */ 
bool picking_isFragmentHighlighted() {
  return 
    bool(picking.isHighlightActive) &&
    picking.highlightedBatchIndex == picking.batchIndex &&
    picking.highlightedObjectIndex == picking_objectIndex
    ;
}

/**
 * Returns highlight color if this item is selected.
 */
vec4 picking_filterHighlightColor(vec4 color) {
  // If we are still picking, we don't highlight
  if (bool(picking.isActive)) {
    return color;
  }

  // If we are not highlighted, return color as is
  if (!picking_isFragmentHighlighted()) {
    return color;
  }
   
  // Blend in highlight color based on its alpha value
  float highLightAlpha = picking.highlightColor.a;
  float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
  float highLightRatio = highLightAlpha / blendedAlpha;

  vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
  return vec4(blendedRGB, blendedAlpha);
}

/*
 * Returns picking color if picking enabled else unmodified argument.
 */
ivec4 picking_getPickingColor() {
  // Assumes that colorAttachment0 is rg32int
  // TODO? - we could render indices into a second color attachment and not mess with fragColor
  return ivec4(picking_objectIndex, picking.batchIndex, 0u, 0u);  
}

vec4 picking_filterPickingColor(vec4 color) {
  if (bool(picking.isActive)) {
    if (picking_objectIndex == INDEX_PICKING_INVALID_INDEX) {
      discard;
    }
  }
  return color;
}

/*
 * Returns picking color if picking is enabled if not
 * highlight color if this item is selected, otherwise unmodified argument.
 */
vec4 picking_filterColor(vec4 color) {
  vec4 outColor = color;
  outColor = picking_filterHighlightColor(outColor);
  outColor = picking_filterPickingColor(outColor);
  return outColor;
}
`
);
var picking2 = {
  ...pickingUniforms,
  name: "picking",
  source: source4,
  vs: vs6,
  fs: fs5
};

// node_modules/@luma.gl/engine/dist/modules/picking/color-picking.js
var source5 = (
  /* wgsl */
  `${WGSL_UNIFORMS}
`
);
var vs7 = (
  /* glsl */
  `${GLSL_UNIFORMS}
out vec4 picking_vRGBcolor_Avalid;

// Normalize unsigned byte color to 0-1 range
vec3 picking_normalizeColor(vec3 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

// Normalize unsigned byte color to 0-1 range
vec4 picking_normalizeColor(vec4 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

bool picking_isColorZero(vec3 color) {
  return dot(color, vec3(1.0)) < 0.00001;
}

bool picking_isColorValid(vec3 color) {
  return dot(color, vec3(1.0)) > 0.00001;
}

// Check if this vertex is highlighted 
bool isVertexHighlighted(vec3 vertexColor) {
  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
  return
    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}

// Set the current picking color
void picking_setPickingColor(vec3 pickingColor) {
  pickingColor = picking_normalizeColor(pickingColor);

  if (bool(picking.isActive)) {
    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable
    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));

    if (!bool(picking.isAttribute)) {
      // Stores the picking color so that the fragment shader can render it during picking
      picking_vRGBcolor_Avalid.rgb = pickingColor;
    }
  } else {
    // Do the comparison with selected item color in vertex shader as it should mean fewer compares
    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
  }
}

void picking_setObjectIndex(uint objectIndex) {
  if (bool(picking.isActive)) {
    uint index = objectIndex;
    if (picking.indexMode == PICKING_INDEX_MODE_INSTANCE) {
      index = uint(gl_InstanceID);
    }
    picking_vRGBcolor_Avalid.r = float(index % 255) / 255.0;
    picking_vRGBcolor_Avalid.g = float((index / 255) % 255) / 255.0;
    picking_vRGBcolor_Avalid.b = float((index / 255 / 255) %255) / 255.0;
  }
}

void picking_setPickingAttribute(float value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.r = value;
  }
}

void picking_setPickingAttribute(vec2 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rg = value;
  }
}

void picking_setPickingAttribute(vec3 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rgb = value;
  }
}
`
);
var fs6 = (
  /* glsl */
  `${GLSL_UNIFORMS}

in vec4 picking_vRGBcolor_Avalid;

/*
 * Returns highlight color if this item is selected.
 */
vec4 picking_filterHighlightColor(vec4 color) {
  // If we are still picking, we don't highlight
  if (picking.isActive > 0.5) {
    return color;
  }

  bool selected = bool(picking_vRGBcolor_Avalid.a);

  if (selected) {
    // Blend in highlight color based on its alpha value
    float highLightAlpha = picking.highlightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}

/*
 * Returns picking color if picking enabled else unmodified argument.
 */
vec4 picking_filterPickingColor(vec4 color) {
  if (bool(picking.isActive)) {
    if (picking_vRGBcolor_Avalid.a == 0.0) {
      discard;
    }
    return picking_vRGBcolor_Avalid;
  }
  return color;
}

/*
 * Returns picking color if picking is enabled if not
 * highlight color if this item is selected, otherwise unmodified argument.
 */
vec4 picking_filterColor(vec4 color) {
  vec4 highlightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highlightColor);
}
`
);
var picking3 = {
  ...pickingUniforms,
  name: "picking",
  source: source5,
  vs: vs7,
  fs: fs6
};

// node_modules/@deck.gl/core/dist/utils/deep-equal.js
function deepEqual2(a2, b2, depth) {
  if (a2 === b2) {
    return true;
  }
  if (!depth || !a2 || !b2) {
    return false;
  }
  if (Array.isArray(a2)) {
    if (!Array.isArray(b2) || a2.length !== b2.length) {
      return false;
    }
    for (let i2 = 0; i2 < a2.length; i2++) {
      if (!deepEqual2(a2[i2], b2[i2], depth - 1)) {
        return false;
      }
    }
    return true;
  }
  if (Array.isArray(b2)) {
    return false;
  }
  if (typeof a2 === "object" && typeof b2 === "object") {
    const aKeys = Object.keys(a2);
    const bKeys = Object.keys(b2);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    for (const key of aKeys) {
      if (!b2.hasOwnProperty(key)) {
        return false;
      }
      if (!deepEqual2(a2[key], b2[key], depth - 1)) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/@deck.gl/core/dist/lifecycle/constants.js
var LIFECYCLE = {
  NO_STATE: "Awaiting state",
  MATCHED: "Matched. State transferred from previous layer",
  INITIALIZED: "Initialized",
  AWAITING_GC: "Discarded. Awaiting garbage collection",
  AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
  FINALIZED: "Finalized! Awaiting garbage collection"
};
var COMPONENT_SYMBOL = Symbol.for("component");
var PROP_TYPES_SYMBOL = Symbol.for("propTypes");
var DEPRECATED_PROPS_SYMBOL = Symbol.for("deprecatedProps");
var ASYNC_DEFAULTS_SYMBOL = Symbol.for("asyncPropDefaults");
var ASYNC_ORIGINAL_SYMBOL = Symbol.for("asyncPropOriginal");
var ASYNC_RESOLVED_SYMBOL = Symbol.for("asyncPropResolved");

// node_modules/@deck.gl/core/dist/debug/loggers.js
var logState = {
  attributeUpdateStart: -1,
  attributeManagerUpdateStart: -1,
  attributeUpdateMessages: []
};
var LOG_LEVEL_MAJOR_UPDATE = 1;
var LOG_LEVEL_MINOR_UPDATE = 2;
var LOG_LEVEL_UPDATE_DETAIL = 3;
var LOG_LEVEL_INFO = 4;
var LOG_LEVEL_DRAW = 2;
var getLoggers = (log4) => ({
  /* Layer events */
  "layer.changeFlag": (layer, key, flags) => {
    log4.log(LOG_LEVEL_UPDATE_DETAIL, `${layer.id} ${key}: `, flags[key])();
  },
  "layer.initialize": (layer) => {
    log4.log(LOG_LEVEL_MAJOR_UPDATE, `Initializing ${layer}`)();
  },
  "layer.update": (layer, needsUpdate) => {
    if (needsUpdate) {
      const flags = layer.getChangeFlags();
      log4.log(LOG_LEVEL_MINOR_UPDATE, `Updating ${layer} because: ${Object.keys(flags).filter((key) => flags[key]).join(", ")}`)();
    } else {
      log4.log(LOG_LEVEL_INFO, `${layer} does not need update`)();
    }
  },
  "layer.matched": (layer, changed) => {
    if (changed) {
      log4.log(LOG_LEVEL_INFO, `Matched ${layer}, state transfered`)();
    }
  },
  "layer.finalize": (layer) => {
    log4.log(LOG_LEVEL_MAJOR_UPDATE, `Finalizing ${layer}`)();
  },
  /* CompositeLayer events */
  "compositeLayer.renderLayers": (layer, updated, subLayers) => {
    if (updated) {
      log4.log(LOG_LEVEL_MINOR_UPDATE, `Composite layer rendered new subLayers ${layer}`, subLayers)();
    } else {
      log4.log(LOG_LEVEL_INFO, `Composite layer reused subLayers ${layer}`, subLayers)();
    }
  },
  /* LayerManager events */
  "layerManager.setLayers": (layerManager, updated, layers) => {
    if (updated) {
      log4.log(LOG_LEVEL_MINOR_UPDATE, `Updating ${layers.length} deck layers`)();
    }
  },
  "layerManager.activateViewport": (layerManager, viewport) => {
    log4.log(LOG_LEVEL_UPDATE_DETAIL, "Viewport changed", viewport)();
  },
  /* AttributeManager events */
  "attributeManager.invalidate": (attributeManager, trigger, attributeNames) => {
    log4.log(LOG_LEVEL_MAJOR_UPDATE, attributeNames ? `invalidated attributes ${attributeNames} (${trigger}) for ${attributeManager.id}` : `invalidated all attributes for ${attributeManager.id}`)();
  },
  "attributeManager.updateStart": (attributeManager) => {
    logState.attributeUpdateMessages.length = 0;
    logState.attributeManagerUpdateStart = Date.now();
  },
  "attributeManager.updateEnd": (attributeManager, numInstances) => {
    const timeMs = Math.round(Date.now() - logState.attributeManagerUpdateStart);
    log4.groupCollapsed(LOG_LEVEL_MINOR_UPDATE, `Updated attributes for ${numInstances} instances in ${attributeManager.id} in ${timeMs}ms`)();
    for (const updateMessage of logState.attributeUpdateMessages) {
      log4.log(LOG_LEVEL_UPDATE_DETAIL, updateMessage)();
    }
    log4.groupEnd(LOG_LEVEL_MINOR_UPDATE)();
  },
  /* Attribute events */
  "attribute.updateStart": (attribute) => {
    logState.attributeUpdateStart = Date.now();
  },
  "attribute.allocate": (attribute, numInstances) => {
    const message = `${attribute.id} allocated ${numInstances}`;
    logState.attributeUpdateMessages.push(message);
  },
  "attribute.updateEnd": (attribute, numInstances) => {
    const timeMs = Math.round(Date.now() - logState.attributeUpdateStart);
    const message = `${attribute.id} updated ${numInstances} in ${timeMs}ms`;
    logState.attributeUpdateMessages.push(message);
  },
  /* Render events */
  "deckRenderer.renderLayers": (deckRenderer, renderStats, opts) => {
    const { pass, redrawReason, stats } = opts;
    for (const status of renderStats) {
      const { totalCount, visibleCount, compositeCount, pickableCount } = status;
      const primitiveCount = totalCount - compositeCount;
      const hiddenCount = primitiveCount - visibleCount;
      log4.log(LOG_LEVEL_DRAW, `RENDER #${deckRenderer.renderCount}   ${visibleCount} (of ${totalCount} layers) to ${pass} because ${redrawReason}   (${hiddenCount} hidden, ${compositeCount} composite ${pickableCount} pickable)`)();
      if (stats) {
        stats.get("Redraw Layers").add(visibleCount);
      }
    }
  }
});

// node_modules/@deck.gl/core/dist/debug/index.js
var loggers = {};
if (true) {
  loggers = getLoggers(log_default);
}
function register(handlers) {
  loggers = handlers;
}
function debug(eventType, arg1, arg2, arg3) {
  if (log_default.level > 0 && loggers[eventType]) {
    loggers[eventType].call(null, arg1, arg2, arg3);
  }
}

// node_modules/@deck.gl/core/dist/utils/flatten.js
function flatten(array, filter = () => true) {
  if (!Array.isArray(array)) {
    return filter(array) ? [array] : [];
  }
  return flattenArray(array, filter, []);
}
function flattenArray(array, filter, result) {
  let index = -1;
  while (++index < array.length) {
    const value = array[index];
    if (Array.isArray(value)) {
      flattenArray(value, filter, result);
    } else if (filter(value)) {
      result.push(value);
    }
  }
  return result;
}
function fillArray({ target, source: source6, start = 0, count: count2 = 1 }) {
  const length5 = source6.length;
  const total = count2 * length5;
  let copied = 0;
  for (let i2 = start; copied < length5; copied++) {
    target[i2++] = source6[copied];
  }
  while (copied < total) {
    if (copied < total - copied) {
      target.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }
  return target;
}

// node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js
function assert4(condition, message) {
  if (!condition) {
    throw new Error(message || "loader assertion failed.");
  }
}

// node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js
var globals = {
  self: typeof self !== "undefined" && self,
  window: typeof window !== "undefined" && window,
  global: typeof global !== "undefined" && global,
  document: typeof document !== "undefined" && document
};
var self_ = globals.self || globals.window || globals.global || {};
var window_2 = globals.window || globals.self || globals.global || {};
var global_ = globals.global || globals.self || globals.window || {};
var document_ = globals.document || {};
var isBrowser = (
  // @ts-ignore process does not exist on browser
  Boolean(typeof process !== "object" || String(process) !== "[object process]" || process.browser)
);
var matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
var nodeVersion = matches && parseFloat(matches[1]) || 0;

// node_modules/@loaders.gl/loader-utils/dist/lib/log-utils/log.js
var VERSION = true ? "4.3.3" : "latest";
var version = VERSION[0] >= "0" && VERSION[0] <= "9" ? `v${VERSION}` : "";
function createLog() {
  const log4 = new Log({ id: "loaders.gl" });
  globalThis.loaders = globalThis.loaders || {};
  globalThis.loaders.log = log4;
  globalThis.loaders.version = version;
  globalThis.probe = globalThis.probe || {};
  globalThis.probe.loaders = log4;
  return log4;
}
var log3 = createLog();

// node_modules/@loaders.gl/loader-utils/dist/lib/option-utils/merge-loader-options.js
function mergeLoaderOptions(baseOptions, newOptions) {
  return mergeOptionsRecursively(baseOptions || {}, newOptions);
}
function mergeOptionsRecursively(baseOptions, newOptions, level = 0) {
  if (level > 3) {
    return newOptions;
  }
  const options = { ...baseOptions };
  for (const [key, newValue] of Object.entries(newOptions)) {
    if (newValue && typeof newValue === "object" && !Array.isArray(newValue)) {
      options[key] = mergeOptionsRecursively(options[key] || {}, newOptions[key], level + 1);
    } else {
      options[key] = newOptions[key];
    }
  }
  return options;
}

// node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js
var NPM_TAG = "latest";
function getVersion() {
  var _a3;
  if (!((_a3 = globalThis._loadersgl_) == null ? void 0 : _a3.version)) {
    globalThis._loadersgl_ = globalThis._loadersgl_ || {};
    if (false) {
      console.warn("loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.");
      globalThis._loadersgl_.version = NPM_TAG;
    } else {
      globalThis._loadersgl_.version = "4.3.3";
    }
  }
  return globalThis._loadersgl_.version;
}
var VERSION2 = getVersion();

// node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js
function assert5(condition, message) {
  if (!condition) {
    throw new Error(message || "loaders.gl assertion failed.");
  }
}

// node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js
var globals2 = {
  self: typeof self !== "undefined" && self,
  window: typeof window !== "undefined" && window,
  global: typeof global !== "undefined" && global,
  document: typeof document !== "undefined" && document
};
var self_2 = globals2.self || globals2.window || globals2.global || {};
var window_3 = globals2.window || globals2.self || globals2.global || {};
var global_2 = globals2.global || globals2.self || globals2.window || {};
var document_2 = globals2.document || {};
var isBrowser2 = (
  // @ts-ignore process.browser
  typeof process !== "object" || String(process) !== "[object process]" || process.browser
);
var isMobile = typeof window !== "undefined" && typeof window.orientation !== "undefined";
var matches2 = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
var nodeVersion2 = matches2 && parseFloat(matches2[1]) || 0;

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-job.js
var WorkerJob = class {
  constructor(jobName, workerThread) {
    __publicField(this, "name");
    __publicField(this, "workerThread");
    __publicField(this, "isRunning", true);
    /** Promise that resolves when Job is done */
    __publicField(this, "result");
    __publicField(this, "_resolve", () => {
    });
    __publicField(this, "_reject", () => {
    });
    this.name = jobName;
    this.workerThread = workerThread;
    this.result = new Promise((resolve2, reject) => {
      this._resolve = resolve2;
      this._reject = reject;
    });
  }
  /**
   * Send a message to the job's worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   */
  postMessage(type, payload) {
    this.workerThread.postMessage({
      source: "loaders.gl",
      // Lets worker ignore unrelated messages
      type,
      payload
    });
  }
  /**
   * Call to resolve the `result` Promise with the supplied value
   */
  done(value) {
    assert5(this.isRunning);
    this.isRunning = false;
    this._resolve(value);
  }
  /**
   * Call to reject the `result` Promise with the supplied error
   */
  error(error) {
    assert5(this.isRunning);
    this.isRunning = false;
    this._reject(error);
  }
};

// node_modules/@loaders.gl/worker-utils/dist/lib/node/worker_threads-browser.js
var NodeWorker = class {
  terminate() {
  }
};

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-loadable-worker-url.js
var workerURLCache = /* @__PURE__ */ new Map();
function getLoadableWorkerURL(props) {
  assert5(props.source && !props.url || !props.source && props.url);
  let workerURL = workerURLCache.get(props.source || props.url);
  if (!workerURL) {
    if (props.url) {
      workerURL = getLoadableWorkerURLFromURL(props.url);
      workerURLCache.set(props.url, workerURL);
    }
    if (props.source) {
      workerURL = getLoadableWorkerURLFromSource(props.source);
      workerURLCache.set(props.source, workerURL);
    }
  }
  assert5(workerURL);
  return workerURL;
}
function getLoadableWorkerURLFromURL(url) {
  if (!url.startsWith("http")) {
    return url;
  }
  const workerSource = buildScriptSource(url);
  return getLoadableWorkerURLFromSource(workerSource);
}
function getLoadableWorkerURLFromSource(workerSource) {
  const blob = new Blob([workerSource], { type: "application/javascript" });
  return URL.createObjectURL(blob);
}
function buildScriptSource(workerUrl) {
  return `try {
  importScripts('${workerUrl}');
} catch (error) {
  console.error(error);
  throw error;
}`;
}

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-transfer-list.js
function getTransferList(object, recursive = true, transfers) {
  const transfersSet = transfers || /* @__PURE__ */ new Set();
  if (!object) {
  } else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {
  } else if (recursive && typeof object === "object") {
    for (const key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }
  return transfers === void 0 ? Array.from(transfersSet) : [];
}
function isTransferable(object) {
  if (!object) {
    return false;
  }
  if (object instanceof ArrayBuffer) {
    return true;
  }
  if (typeof MessagePort !== "undefined" && object instanceof MessagePort) {
    return true;
  }
  if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) {
    return true;
  }
  if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) {
    return true;
  }
  return false;
}

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js
var NOOP = () => {
};
var WorkerThread = class {
  constructor(props) {
    __publicField(this, "name");
    __publicField(this, "source");
    __publicField(this, "url");
    __publicField(this, "terminated", false);
    __publicField(this, "worker");
    __publicField(this, "onMessage");
    __publicField(this, "onError");
    __publicField(this, "_loadableURL", "");
    const { name, source: source6, url } = props;
    assert5(source6 || url);
    this.name = name;
    this.source = source6;
    this.url = url;
    this.onMessage = NOOP;
    this.onError = (error) => console.log(error);
    this.worker = isBrowser2 ? this._createBrowserWorker() : this._createNodeWorker();
  }
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return typeof Worker !== "undefined" && isBrowser2 || typeof NodeWorker !== "undefined" && !isBrowser2;
  }
  /**
   * Terminate this worker thread
   * @note Can free up significant memory
   */
  destroy() {
    this.onMessage = NOOP;
    this.onError = NOOP;
    this.worker.terminate();
    this.terminated = true;
  }
  get isRunning() {
    return Boolean(this.onMessage);
  }
  /**
   * Send a message to this worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   * @param transferList If not supplied, calculated automatically by traversing data
   */
  postMessage(data, transferList) {
    transferList = transferList || getTransferList(data);
    this.worker.postMessage(data, transferList);
  }
  // PRIVATE
  /**
   * Generate a standard Error from an ErrorEvent
   * @param event
   */
  _getErrorFromErrorEvent(event) {
    let message = "Failed to load ";
    message += `worker ${this.name} from ${this.url}. `;
    if (event.message) {
      message += `${event.message} in `;
    }
    if (event.lineno) {
      message += `:${event.lineno}:${event.colno}`;
    }
    return new Error(message);
  }
  /**
   * Creates a worker thread on the browser
   */
  _createBrowserWorker() {
    this._loadableURL = getLoadableWorkerURL({ source: this.source, url: this.url });
    const worker = new Worker(this._loadableURL, { name: this.name });
    worker.onmessage = (event) => {
      if (!event.data) {
        this.onError(new Error("No data received"));
      } else {
        this.onMessage(event.data);
      }
    };
    worker.onerror = (error) => {
      this.onError(this._getErrorFromErrorEvent(error));
      this.terminated = true;
    };
    worker.onmessageerror = (event) => console.error(event);
    return worker;
  }
  /**
   * Creates a worker thread in node.js
   * @todo https://nodejs.org/api/async_hooks.html#async-resource-worker-pool
   */
  _createNodeWorker() {
    let worker;
    if (this.url) {
      const absolute = this.url.includes(":/") || this.url.startsWith("/");
      const url = absolute ? this.url : `./${this.url}`;
      worker = new NodeWorker(url, { eval: false });
    } else if (this.source) {
      worker = new NodeWorker(this.source, { eval: true });
    } else {
      throw new Error("no worker");
    }
    worker.on("message", (data) => {
      this.onMessage(data);
    });
    worker.on("error", (error) => {
      this.onError(error);
    });
    worker.on("exit", (code) => {
    });
    return worker;
  }
};

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-pool.js
var WorkerPool = class {
  /**
   * @param processor - worker function
   * @param maxConcurrency - max count of workers
   */
  constructor(props) {
    __publicField(this, "name", "unnamed");
    __publicField(this, "source");
    // | Function;
    __publicField(this, "url");
    __publicField(this, "maxConcurrency", 1);
    __publicField(this, "maxMobileConcurrency", 1);
    __publicField(this, "onDebug", () => {
    });
    __publicField(this, "reuseWorkers", true);
    __publicField(this, "props", {});
    __publicField(this, "jobQueue", []);
    __publicField(this, "idleQueue", []);
    __publicField(this, "count", 0);
    __publicField(this, "isDestroyed", false);
    this.source = props.source;
    this.url = props.url;
    this.setProps(props);
  }
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return WorkerThread.isSupported();
  }
  /**
   * Terminates all workers in the pool
   * @note Can free up significant memory
   */
  destroy() {
    this.idleQueue.forEach((worker) => worker.destroy());
    this.isDestroyed = true;
  }
  setProps(props) {
    this.props = { ...this.props, ...props };
    if (props.name !== void 0) {
      this.name = props.name;
    }
    if (props.maxConcurrency !== void 0) {
      this.maxConcurrency = props.maxConcurrency;
    }
    if (props.maxMobileConcurrency !== void 0) {
      this.maxMobileConcurrency = props.maxMobileConcurrency;
    }
    if (props.reuseWorkers !== void 0) {
      this.reuseWorkers = props.reuseWorkers;
    }
    if (props.onDebug !== void 0) {
      this.onDebug = props.onDebug;
    }
  }
  async startJob(name, onMessage2 = (job, type, data) => job.done(data), onError = (job, error) => job.error(error)) {
    const startPromise = new Promise((onStart) => {
      this.jobQueue.push({ name, onMessage: onMessage2, onError, onStart });
      return this;
    });
    this._startQueuedJob();
    return await startPromise;
  }
  // PRIVATE
  /**
   * Starts first queued job if worker is available or can be created
   * Called when job is started and whenever a worker returns to the idleQueue
   */
  async _startQueuedJob() {
    if (!this.jobQueue.length) {
      return;
    }
    const workerThread = this._getAvailableWorker();
    if (!workerThread) {
      return;
    }
    const queuedJob = this.jobQueue.shift();
    if (queuedJob) {
      this.onDebug({
        message: "Starting job",
        name: queuedJob.name,
        workerThread,
        backlog: this.jobQueue.length
      });
      const job = new WorkerJob(queuedJob.name, workerThread);
      workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);
      workerThread.onError = (error) => queuedJob.onError(job, error);
      queuedJob.onStart(job);
      try {
        await job.result;
      } catch (error) {
        console.error(`Worker exception: ${error}`);
      } finally {
        this.returnWorkerToQueue(workerThread);
      }
    }
  }
  /**
   * Returns a worker to the idle queue
   * Destroys the worker if
   *  - pool is destroyed
   *  - if this pool doesn't reuse workers
   *  - if maxConcurrency has been lowered
   * @param worker
   */
  returnWorkerToQueue(worker) {
    const shouldDestroyWorker = (
      // Workers on Node.js prevent the process from exiting.
      // Until we figure out how to close them before exit, we always destroy them
      !isBrowser2 || // If the pool is destroyed, there is no reason to keep the worker around
      this.isDestroyed || // If the app has disabled worker reuse, any completed workers should be destroyed
      !this.reuseWorkers || // If concurrency has been lowered, this worker might be surplus to requirements
      this.count > this._getMaxConcurrency()
    );
    if (shouldDestroyWorker) {
      worker.destroy();
      this.count--;
    } else {
      this.idleQueue.push(worker);
    }
    if (!this.isDestroyed) {
      this._startQueuedJob();
    }
  }
  /**
   * Returns idle worker or creates new worker if maxConcurrency has not been reached
   */
  _getAvailableWorker() {
    if (this.idleQueue.length > 0) {
      return this.idleQueue.shift() || null;
    }
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
      return new WorkerThread({ name, source: this.source, url: this.url });
    }
    return null;
  }
  _getMaxConcurrency() {
    return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
  }
};

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js
var DEFAULT_PROPS = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: true,
  onDebug: () => {
  }
};
var _WorkerFarm = class _WorkerFarm {
  /** get global instance with WorkerFarm.getWorkerFarm() */
  constructor(props) {
    __publicField(this, "props");
    __publicField(this, "workerPools", /* @__PURE__ */ new Map());
    this.props = { ...DEFAULT_PROPS };
    this.setProps(props);
    this.workerPools = /* @__PURE__ */ new Map();
  }
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return WorkerThread.isSupported();
  }
  /** Get the singleton instance of the global worker farm */
  static getWorkerFarm(props = {}) {
    _WorkerFarm._workerFarm = _WorkerFarm._workerFarm || new _WorkerFarm({});
    _WorkerFarm._workerFarm.setProps(props);
    return _WorkerFarm._workerFarm;
  }
  /**
   * Terminate all workers in the farm
   * @note Can free up significant memory
   */
  destroy() {
    for (const workerPool of this.workerPools.values()) {
      workerPool.destroy();
    }
    this.workerPools = /* @__PURE__ */ new Map();
  }
  /**
   * Set props used when initializing worker pools
   * @param props
   */
  setProps(props) {
    this.props = { ...this.props, ...props };
    for (const workerPool of this.workerPools.values()) {
      workerPool.setProps(this._getWorkerPoolProps());
    }
  }
  /**
   * Returns a worker pool for the specified worker
   * @param options - only used first time for a specific worker name
   * @param options.name - the name of the worker - used to identify worker pool
   * @param options.url -
   * @param options.source -
   * @example
   *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);
   */
  getWorkerPool(options) {
    const { name, source: source6, url } = options;
    let workerPool = this.workerPools.get(name);
    if (!workerPool) {
      workerPool = new WorkerPool({
        name,
        source: source6,
        url
      });
      workerPool.setProps(this._getWorkerPoolProps());
      this.workerPools.set(name, workerPool);
    }
    return workerPool;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
};
// singleton
__publicField(_WorkerFarm, "_workerFarm");
var WorkerFarm = _WorkerFarm;

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/get-worker-url.js
function getWorkerURL(worker, options = {}) {
  const workerOptions = options[worker.id] || {};
  const workerFile = isBrowser2 ? `${worker.id}-worker.js` : `${worker.id}-worker-node.js`;
  let url = workerOptions.workerUrl;
  if (!url && worker.id === "compression") {
    url = options.workerUrl;
  }
  if (options._workerType === "test") {
    if (isBrowser2) {
      url = `modules/${worker.module}/dist/${workerFile}`;
    } else {
      url = `modules/${worker.module}/src/workers/${worker.id}-worker-node.ts`;
    }
  }
  if (!url) {
    let version2 = worker.version;
    if (version2 === "latest") {
      version2 = NPM_TAG;
    }
    const versionTag = version2 ? `@${version2}` : "";
    url = `https://unpkg.com/@loaders.gl/${worker.module}${versionTag}/dist/${workerFile}`;
  }
  assert5(url);
  return url;
}

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/validate-worker-version.js
function validateWorkerVersion(worker, coreVersion = VERSION2) {
  assert5(worker, "no worker provided");
  const workerVersion = worker.version;
  if (!coreVersion || !workerVersion) {
    return false;
  }
  return true;
}

// node_modules/@loaders.gl/worker-utils/dist/lib/process-utils/child-process-proxy.js
var ChildProcess2 = __toESM(require_child_process(), 1);

// node_modules/@loaders.gl/worker-utils/dist/lib/process-utils/process-utils.js
var import_child_process = __toESM(require_child_process(), 1);

// node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/parse-with-worker.js
function canParseWithWorker(loader, options) {
  if (!WorkerFarm.isSupported()) {
    return false;
  }
  if (!isBrowser2 && !(options == null ? void 0 : options._nodeWorkers)) {
    return false;
  }
  return loader.worker && (options == null ? void 0 : options.worker);
}
async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
  const name = loader.id;
  const url = getWorkerURL(loader, options);
  const workerFarm = WorkerFarm.getWorkerFarm(options);
  const workerPool = workerFarm.getWorkerPool({ name, url });
  options = JSON.parse(JSON.stringify(options));
  context = JSON.parse(JSON.stringify(context || {}));
  const job = await workerPool.startJob(
    "process-on-worker",
    // @ts-expect-error
    onMessage.bind(null, parseOnMainThread)
    // eslint-disable-line @typescript-eslint/no-misused-promises
  );
  job.postMessage("process", {
    // @ts-ignore
    input: data,
    options,
    context
  });
  const result = await job.result;
  return await result.result;
}
async function onMessage(parseOnMainThread, job, type, payload) {
  switch (type) {
    case "done":
      job.done(payload);
      break;
    case "error":
      job.error(new Error(payload.error));
      break;
    case "process":
      const { id, input, options } = payload;
      try {
        const result = await parseOnMainThread(input, options);
        job.postMessage("done", { id, result });
      } catch (error) {
        const message = error instanceof Error ? error.message : "unknown error";
        job.postMessage("error", { id, error: message });
      }
      break;
    default:
      console.warn(`parse-with-worker unknown message ${type}`);
  }
}

// node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js
function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
  byteLength = byteLength || arrayBuffer1.byteLength;
  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
    return false;
  }
  const array1 = new Uint8Array(arrayBuffer1);
  const array2 = new Uint8Array(arrayBuffer2);
  for (let i2 = 0; i2 < array1.length; ++i2) {
    if (array1[i2] !== array2[i2]) {
      return false;
    }
  }
  return true;
}
function concatenateArrayBuffers(...sources) {
  return concatenateArrayBuffersFromArray(sources);
}
function concatenateArrayBuffersFromArray(sources) {
  const sourceArrays = sources.map((source22) => source22 instanceof ArrayBuffer ? new Uint8Array(source22) : source22);
  const byteLength = sourceArrays.reduce((length5, typedArray) => length5 + typedArray.byteLength, 0);
  const result = new Uint8Array(byteLength);
  let offset = 0;
  for (const sourceArray of sourceArrays) {
    result.set(sourceArray, offset);
    offset += sourceArray.byteLength;
  }
  return result.buffer;
}

// node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js
async function concatenateArrayBuffersAsync(asyncIterator) {
  const arrayBuffers = [];
  for await (const chunk of asyncIterator) {
    arrayBuffers.push(chunk);
  }
  return concatenateArrayBuffers(...arrayBuffers);
}

// node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/file-aliases.js
var pathPrefix2 = "";
var fileAliases = {};
function resolvePath(filename2) {
  for (const alias in fileAliases) {
    if (filename2.startsWith(alias)) {
      const replacement = fileAliases[alias];
      filename2 = filename2.replace(alias, replacement);
    }
  }
  if (!filename2.startsWith("http://") && !filename2.startsWith("https://")) {
    filename2 = `${pathPrefix2}${filename2}`;
  }
  return filename2;
}

// node_modules/@loaders.gl/loader-utils/dist/lib/node/buffer.browser.js
function toArrayBuffer(buffer2) {
  return buffer2;
}

// node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js
function isBuffer(value) {
  return value && typeof value === "object" && value.isBuffer;
}
function toArrayBuffer2(data) {
  if (isBuffer(data)) {
    return toArrayBuffer(data);
  }
  if (data instanceof ArrayBuffer) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
  }
  if (typeof data === "string") {
    const text = data;
    const uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }
  if (data && typeof data === "object" && data._toArrayBuffer) {
    return data._toArrayBuffer();
  }
  throw new Error("toArrayBuffer");
}

// node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js
var path_exports = {};
__export(path_exports, {
  dirname: () => dirname,
  filename: () => filename,
  join: () => join,
  resolve: () => resolve
});

// node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/get-cwd.js
function getCWD() {
  var _a3;
  if (typeof process !== "undefined" && typeof process.cwd !== "undefined") {
    return process.cwd();
  }
  const pathname = (_a3 = window.location) == null ? void 0 : _a3.pathname;
  return (pathname == null ? void 0 : pathname.slice(0, pathname.lastIndexOf("/") + 1)) || "";
}

// node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js
function filename(url) {
  const slashIndex = url ? url.lastIndexOf("/") : -1;
  return slashIndex >= 0 ? url.substr(slashIndex + 1) : "";
}
function dirname(url) {
  const slashIndex = url ? url.lastIndexOf("/") : -1;
  return slashIndex >= 0 ? url.substr(0, slashIndex) : "";
}
function join(...parts) {
  const separator = "/";
  parts = parts.map((part, index) => {
    if (index) {
      part = part.replace(new RegExp(`^${separator}`), "");
    }
    if (index !== parts.length - 1) {
      part = part.replace(new RegExp(`${separator}$`), "");
    }
    return part;
  });
  return parts.join(separator);
}
function resolve(...components) {
  const paths = [];
  for (let _i = 0; _i < components.length; _i++) {
    paths[_i] = components[_i];
  }
  let resolvedPath = "";
  let resolvedAbsolute = false;
  let cwd;
  for (let i2 = paths.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
    let path;
    if (i2 >= 0) {
      path = paths[i2];
    } else {
      if (cwd === void 0) {
        cwd = getCWD();
      }
      path = cwd;
    }
    if (path.length === 0) {
      continue;
    }
    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = path.charCodeAt(0) === SLASH;
  }
  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute) {
    return `/${resolvedPath}`;
  } else if (resolvedPath.length > 0) {
    return resolvedPath;
  }
  return ".";
}
var SLASH = 47;
var DOT = 46;
function normalizeStringPosix(path, allowAboveRoot) {
  let res = "";
  let lastSlash = -1;
  let dots = 0;
  let code;
  let isAboveRoot = false;
  for (let i2 = 0; i2 <= path.length; ++i2) {
    if (i2 < path.length) {
      code = path.charCodeAt(i2);
    } else if (code === SLASH) {
      break;
    } else {
      code = SLASH;
    }
    if (code === SLASH) {
      if (lastSlash === i2 - 1 || dots === 1) {
      } else if (lastSlash !== i2 - 1 && dots === 2) {
        if (res.length < 2 || !isAboveRoot || res.charCodeAt(res.length - 1) !== DOT || res.charCodeAt(res.length - 2) !== DOT) {
          if (res.length > 2) {
            const start = res.length - 1;
            let j2 = start;
            for (; j2 >= 0; --j2) {
              if (res.charCodeAt(j2) === SLASH) {
                break;
              }
            }
            if (j2 !== start) {
              res = j2 === -1 ? "" : res.slice(0, j2);
              lastSlash = i2;
              dots = 0;
              isAboveRoot = false;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSlash = i2;
            dots = 0;
            isAboveRoot = false;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          isAboveRoot = true;
        }
      } else {
        const slice = path.slice(lastSlash + 1, i2);
        if (res.length > 0) {
          res += `/${slice}`;
        } else {
          res = slice;
        }
        isAboveRoot = false;
      }
      lastSlash = i2;
      dots = 0;
    } else if (code === DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

// node_modules/@loaders.gl/loader-utils/dist/lib/files/node-file-facade.js
var NOT_IMPLEMENTED = new Error("Not implemented");

// node_modules/@loaders.gl/loader-utils/dist/lib/filesystems/node-filesystem-facade.js
var NOT_IMPLEMENTED2 = new Error("Not implemented");

// node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js
var isBoolean = (x2) => typeof x2 === "boolean";
var isFunction = (x2) => typeof x2 === "function";
var isObject = (x2) => x2 !== null && typeof x2 === "object";
var isPureObject = (x2) => isObject(x2) && x2.constructor === {}.constructor;
var isIterable = (x2) => Boolean(x2) && typeof x2[Symbol.iterator] === "function";
var isAsyncIterable = (x2) => x2 && typeof x2[Symbol.asyncIterator] === "function";
var isResponse = (x2) => typeof Response !== "undefined" && x2 instanceof Response || x2 && x2.arrayBuffer && x2.text && x2.json;
var isBlob = (x2) => typeof Blob !== "undefined" && x2 instanceof Blob;
var isBuffer2 = (x2) => x2 && typeof x2 === "object" && x2.isBuffer;
var isReadableDOMStream = (x2) => typeof ReadableStream !== "undefined" && x2 instanceof ReadableStream || isObject(x2) && isFunction(x2.tee) && isFunction(x2.cancel) && isFunction(x2.getReader);
var isReadableNodeStream = (x2) => isObject(x2) && isFunction(x2.read) && isFunction(x2.pipe) && isBoolean(x2.readable);
var isReadableStream = (x2) => isReadableDOMStream(x2) || isReadableNodeStream(x2);

// node_modules/@loaders.gl/core/dist/lib/fetch/fetch-error.js
var FetchError = class extends Error {
  constructor(message, info) {
    super(message);
    /** A best effort reason for why the fetch failed */
    __publicField(this, "reason");
    /** The URL that failed to load. Empty string if not available. */
    __publicField(this, "url");
    /** The Response object, if any. */
    __publicField(this, "response");
    this.reason = info.reason;
    this.url = info.url;
    this.response = info.response;
  }
};

// node_modules/@loaders.gl/core/dist/lib/utils/mime-type-utils.js
var DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
var MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
function compareMIMETypes(mimeType1, mimeType2) {
  if (mimeType1.toLowerCase() === mimeType2.toLowerCase()) {
    return true;
  }
  return false;
}
function parseMIMEType(mimeString) {
  const matches3 = MIME_TYPE_PATTERN.exec(mimeString);
  if (matches3) {
    return matches3[1];
  }
  return mimeString;
}
function parseMIMETypeFromURL(url) {
  const matches3 = DATA_URL_PATTERN.exec(url);
  if (matches3) {
    return matches3[1];
  }
  return "";
}

// node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js
var QUERY_STRING_PATTERN = /\?.*/;
function extractQueryString(url) {
  const matches3 = url.match(QUERY_STRING_PATTERN);
  return matches3 && matches3[0];
}
function stripQueryString(url) {
  return url.replace(QUERY_STRING_PATTERN, "");
}
function shortenUrlForDisplay(url) {
  if (url.length < 50) {
    return url;
  }
  const urlEnd = url.slice(url.length - 15);
  const urlStart = url.substr(0, 32);
  return `${urlStart}...${urlEnd}`;
}

// node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js
function getResourceUrl(resource) {
  if (isResponse(resource)) {
    const response = resource;
    return response.url;
  }
  if (isBlob(resource)) {
    const blob = resource;
    return blob.name || "";
  }
  if (typeof resource === "string") {
    return resource;
  }
  return "";
}
function getResourceMIMEType(resource) {
  if (isResponse(resource)) {
    const response = resource;
    const contentTypeHeader = response.headers.get("content-type") || "";
    const noQueryUrl = stripQueryString(response.url);
    return parseMIMEType(contentTypeHeader) || parseMIMETypeFromURL(noQueryUrl);
  }
  if (isBlob(resource)) {
    const blob = resource;
    return blob.type || "";
  }
  if (typeof resource === "string") {
    return parseMIMETypeFromURL(resource);
  }
  return "";
}
function getResourceContentLength(resource) {
  if (isResponse(resource)) {
    const response = resource;
    return response.headers["content-length"] || -1;
  }
  if (isBlob(resource)) {
    const blob = resource;
    return blob.size;
  }
  if (typeof resource === "string") {
    return resource.length;
  }
  if (resource instanceof ArrayBuffer) {
    return resource.byteLength;
  }
  if (ArrayBuffer.isView(resource)) {
    return resource.byteLength;
  }
  return -1;
}

// node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js
async function makeResponse(resource) {
  if (isResponse(resource)) {
    return resource;
  }
  const headers = {};
  const contentLength = getResourceContentLength(resource);
  if (contentLength >= 0) {
    headers["content-length"] = String(contentLength);
  }
  const url = getResourceUrl(resource);
  const type = getResourceMIMEType(resource);
  if (type) {
    headers["content-type"] = type;
  }
  const initialDataUrl = await getInitialDataUrl(resource);
  if (initialDataUrl) {
    headers["x-first-bytes"] = initialDataUrl;
  }
  if (typeof resource === "string") {
    resource = new TextEncoder().encode(resource);
  }
  const response = new Response(resource, { headers });
  Object.defineProperty(response, "url", { value: url });
  return response;
}
async function checkResponse(response) {
  if (!response.ok) {
    const error = await getResponseError(response);
    throw error;
  }
}
async function getResponseError(response) {
  const shortUrl = shortenUrlForDisplay(response.url);
  let message = `Failed to fetch resource (${response.status}) ${response.statusText}: ${shortUrl}`;
  message = message.length > 100 ? `${message.slice(0, 100)}...` : message;
  const info = {
    reason: response.statusText,
    url: response.url,
    response
  };
  try {
    const contentType = response.headers.get("Content-Type");
    info.reason = !response.bodyUsed && (contentType == null ? void 0 : contentType.includes("application/json")) ? await response.json() : await response.text();
  } catch (error) {
  }
  return new FetchError(message, info);
}
async function getInitialDataUrl(resource) {
  const INITIAL_DATA_LENGTH = 5;
  if (typeof resource === "string") {
    return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;
  }
  if (resource instanceof Blob) {
    const blobSlice = resource.slice(0, 5);
    return await new Promise((resolve2) => {
      const reader = new FileReader();
      reader.onload = (event) => {
        var _a3;
        return resolve2((_a3 = event == null ? void 0 : event.target) == null ? void 0 : _a3.result);
      };
      reader.readAsDataURL(blobSlice);
    });
  }
  if (resource instanceof ArrayBuffer) {
    const slice = resource.slice(0, INITIAL_DATA_LENGTH);
    const base64 = arrayBufferToBase64(slice);
    return `data:base64,${base64}`;
  }
  return null;
}
function arrayBufferToBase64(buffer2) {
  let binary = "";
  const bytes = new Uint8Array(buffer2);
  for (let i2 = 0; i2 < bytes.byteLength; i2++) {
    binary += String.fromCharCode(bytes[i2]);
  }
  return btoa(binary);
}

// node_modules/@loaders.gl/core/dist/lib/fetch/fetch-file.js
function isNodePath(url) {
  return !isRequestURL(url) && !isDataURL(url);
}
function isRequestURL(url) {
  return url.startsWith("http:") || url.startsWith("https:");
}
function isDataURL(url) {
  return url.startsWith("data:");
}
async function fetchFile(urlOrData, fetchOptions) {
  var _a3, _b;
  if (typeof urlOrData === "string") {
    const url = resolvePath(urlOrData);
    if (isNodePath(url)) {
      if ((_a3 = globalThis.loaders) == null ? void 0 : _a3.fetchNode) {
        return (_b = globalThis.loaders) == null ? void 0 : _b.fetchNode(url, fetchOptions);
      }
    }
    return await fetch(url, fetchOptions);
  }
  return await makeResponse(urlOrData);
}

// node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js
var probeLog = new Log({ id: "loaders.gl" });
var NullLog = class {
  log() {
    return () => {
    };
  }
  info() {
    return () => {
    };
  }
  warn() {
    return () => {
    };
  }
  error() {
    return () => {
    };
  }
};
var ConsoleLog = class {
  constructor() {
    __publicField(this, "console");
    this.console = console;
  }
  log(...args) {
    return this.console.log.bind(this.console, ...args);
  }
  info(...args) {
    return this.console.info.bind(this.console, ...args);
  }
  warn(...args) {
    return this.console.warn.bind(this.console, ...args);
  }
  error(...args) {
    return this.console.error.bind(this.console, ...args);
  }
};

// node_modules/@loaders.gl/core/dist/lib/loader-utils/option-defaults.js
var DEFAULT_LOADER_OPTIONS = {
  // baseUri
  fetch: null,
  mimeType: void 0,
  nothrow: false,
  log: new ConsoleLog(),
  // A probe.gl compatible (`log.log()()` syntax) that just logs to console
  useLocalLibraries: false,
  CDN: "https://unpkg.com/@loaders.gl",
  worker: true,
  // By default, use worker if provided by loader.
  maxConcurrency: 3,
  // How many worker instances should be created for each loader.
  maxMobileConcurrency: 1,
  // How many worker instances should be created for each loader on mobile devices.
  reuseWorkers: isBrowser,
  // By default reuse workers in browser (Node.js refuses to terminate if browsers are running)
  _nodeWorkers: false,
  // By default do not support node workers
  _workerType: "",
  // 'test' to use locally generated workers
  limit: 0,
  _limitMB: 0,
  batchSize: "auto",
  batchDebounceMs: 0,
  metadata: false,
  // TODO - currently only implemented for parseInBatches, adds initial metadata batch,
  transforms: []
};
var REMOVED_LOADER_OPTIONS = {
  throws: "nothrow",
  dataType: "(no longer used)",
  uri: "baseUri",
  // Warn if fetch options are used on top-level
  method: "fetch.method",
  headers: "fetch.headers",
  body: "fetch.body",
  mode: "fetch.mode",
  credentials: "fetch.credentials",
  cache: "fetch.cache",
  redirect: "fetch.redirect",
  referrer: "fetch.referrer",
  referrerPolicy: "fetch.referrerPolicy",
  integrity: "fetch.integrity",
  keepalive: "fetch.keepalive",
  signal: "fetch.signal"
};

// node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js
function getGlobalLoaderState() {
  globalThis.loaders = globalThis.loaders || {};
  const { loaders } = globalThis;
  if (!loaders._state) {
    loaders._state = {};
  }
  return loaders._state;
}
function getGlobalLoaderOptions() {
  const state = getGlobalLoaderState();
  state.globalOptions = state.globalOptions || { ...DEFAULT_LOADER_OPTIONS };
  return state.globalOptions;
}
function normalizeOptions(options, loader, loaders, url) {
  loaders = loaders || [];
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  validateOptions(options, loaders);
  return normalizeOptionsInternal(loader, options, url);
}
function validateOptions(options, loaders) {
  validateOptionsObject(options, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, loaders);
  for (const loader of loaders) {
    const idOptions = options && options[loader.id] || {};
    const loaderOptions = loader.options && loader.options[loader.id] || {};
    const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
    validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
  }
}
function validateOptionsObject(options, id, defaultOptions2, deprecatedOptions, loaders) {
  const loaderName = id || "Top level";
  const prefix = id ? `${id}.` : "";
  for (const key in options) {
    const isSubOptions = !id && isObject(options[key]);
    const isBaseUriOption = key === "baseUri" && !id;
    const isWorkerUrlOption = key === "workerUrl" && id;
    if (!(key in defaultOptions2) && !isBaseUriOption && !isWorkerUrlOption) {
      if (key in deprecatedOptions) {
        probeLog.warn(`${loaderName} loader option '${prefix}${key}' no longer supported, use '${deprecatedOptions[key]}'`)();
      } else if (!isSubOptions) {
        const suggestion = findSimilarOption(key, loaders);
        probeLog.warn(`${loaderName} loader option '${prefix}${key}' not recognized. ${suggestion}`)();
      }
    }
  }
}
function findSimilarOption(optionKey, loaders) {
  const lowerCaseOptionKey = optionKey.toLowerCase();
  let bestSuggestion = "";
  for (const loader of loaders) {
    for (const key in loader.options) {
      if (optionKey === key) {
        return `Did you mean '${loader.id}.${key}'?`;
      }
      const lowerCaseKey = key.toLowerCase();
      const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
      if (isPartialMatch) {
        bestSuggestion = bestSuggestion || `Did you mean '${loader.id}.${key}'?`;
      }
    }
  }
  return bestSuggestion;
}
function normalizeOptionsInternal(loader, options, url) {
  const loaderDefaultOptions = loader.options || {};
  const mergedOptions = { ...loaderDefaultOptions };
  addUrlOptions(mergedOptions, url);
  if (mergedOptions.log === null) {
    mergedOptions.log = new NullLog();
  }
  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
  mergeNestedFields(mergedOptions, options);
  return mergedOptions;
}
function mergeNestedFields(mergedOptions, options) {
  for (const key in options) {
    if (key in options) {
      const value = options[key];
      if (isPureObject(value) && isPureObject(mergedOptions[key])) {
        mergedOptions[key] = {
          ...mergedOptions[key],
          ...options[key]
        };
      } else {
        mergedOptions[key] = options[key];
      }
    }
  }
}
function addUrlOptions(options, url) {
  if (url && !("baseUri" in options)) {
    options.baseUri = url;
  }
}

// node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js
function isLoaderObject(loader) {
  if (!loader) {
    return false;
  }
  if (Array.isArray(loader)) {
    loader = loader[0];
  }
  const hasExtensions = Array.isArray(loader == null ? void 0 : loader.extensions);
  return hasExtensions;
}
function normalizeLoader(loader) {
  assert4(loader, "null loader");
  assert4(isLoaderObject(loader), "invalid loader");
  let options;
  if (Array.isArray(loader)) {
    options = loader[1];
    loader = loader[0];
    loader = {
      ...loader,
      options: { ...loader.options, ...options }
    };
  }
  if ((loader == null ? void 0 : loader.parseTextSync) || (loader == null ? void 0 : loader.parseText)) {
    loader.text = true;
  }
  if (!loader.text) {
    loader.binary = true;
  }
  return loader;
}

// node_modules/@loaders.gl/core/dist/lib/api/register-loaders.js
var getGlobalLoaderRegistry = () => {
  const state = getGlobalLoaderState();
  state.loaderRegistry = state.loaderRegistry || [];
  return state.loaderRegistry;
};
function registerLoaders(loaders) {
  const loaderRegistry = getGlobalLoaderRegistry();
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  for (const loader of loaders) {
    const normalizedLoader = normalizeLoader(loader);
    if (!loaderRegistry.find((registeredLoader) => normalizedLoader === registeredLoader)) {
      loaderRegistry.unshift(normalizedLoader);
    }
  }
}
function getRegisteredLoaders() {
  return getGlobalLoaderRegistry();
}

// node_modules/@loaders.gl/core/dist/lib/api/select-loader.js
var EXT_PATTERN = /\.([^.]+)$/;
async function selectLoader(data, loaders = [], options, context) {
  if (!validHTTPResponse(data)) {
    return null;
  }
  let loader = selectLoaderSync(data, loaders, { ...options, nothrow: true }, context);
  if (loader) {
    return loader;
  }
  if (isBlob(data)) {
    data = await data.slice(0, 10).arrayBuffer();
    loader = selectLoaderSync(data, loaders, options, context);
  }
  if (!loader && !(options == null ? void 0 : options.nothrow)) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderSync(data, loaders = [], options, context) {
  if (!validHTTPResponse(data)) {
    return null;
  }
  if (loaders && !Array.isArray(loaders)) {
    return normalizeLoader(loaders);
  }
  let candidateLoaders = [];
  if (loaders) {
    candidateLoaders = candidateLoaders.concat(loaders);
  }
  if (!(options == null ? void 0 : options.ignoreRegisteredLoaders)) {
    candidateLoaders.push(...getRegisteredLoaders());
  }
  normalizeLoaders(candidateLoaders);
  const loader = selectLoaderInternal(data, candidateLoaders, options, context);
  if (!loader && !(options == null ? void 0 : options.nothrow)) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderInternal(data, loaders, options, context) {
  const url = getResourceUrl(data);
  const type = getResourceMIMEType(data);
  const testUrl = stripQueryString(url) || (context == null ? void 0 : context.url);
  let loader = null;
  let reason = "";
  if (options == null ? void 0 : options.mimeType) {
    loader = findLoaderByMIMEType(loaders, options == null ? void 0 : options.mimeType);
    reason = `match forced by supplied MIME type ${options == null ? void 0 : options.mimeType}`;
  }
  loader = loader || findLoaderByUrl(loaders, testUrl);
  reason = reason || (loader ? `matched url ${testUrl}` : "");
  loader = loader || findLoaderByMIMEType(loaders, type);
  reason = reason || (loader ? `matched MIME type ${type}` : "");
  loader = loader || findLoaderByInitialBytes(loaders, data);
  reason = reason || (loader ? `matched initial data ${getFirstCharacters2(data)}` : "");
  if (options == null ? void 0 : options.fallbackMimeType) {
    loader = loader || findLoaderByMIMEType(loaders, options == null ? void 0 : options.fallbackMimeType);
    reason = reason || (loader ? `matched fallback MIME type ${type}` : "");
  }
  if (reason) {
    log3.log(1, `selectLoader selected ${loader == null ? void 0 : loader.name}: ${reason}.`);
  }
  return loader;
}
function validHTTPResponse(data) {
  if (data instanceof Response) {
    if (data.status === 204) {
      return false;
    }
  }
  return true;
}
function getNoValidLoaderMessage(data) {
  const url = getResourceUrl(data);
  const type = getResourceMIMEType(data);
  let message = "No valid loader found (";
  message += url ? `${path_exports.filename(url)}, ` : "no url provided, ";
  message += `MIME type: ${type ? `"${type}"` : "not provided"}, `;
  const firstCharacters = data ? getFirstCharacters2(data) : "";
  message += firstCharacters ? ` first bytes: "${firstCharacters}"` : "first bytes: not available";
  message += ")";
  return message;
}
function normalizeLoaders(loaders) {
  for (const loader of loaders) {
    normalizeLoader(loader);
  }
}
function findLoaderByUrl(loaders, url) {
  const match = url && EXT_PATTERN.exec(url);
  const extension = match && match[1];
  return extension ? findLoaderByExtension(loaders, extension) : null;
}
function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();
  for (const loader of loaders) {
    for (const loaderExtension of loader.extensions) {
      if (loaderExtension.toLowerCase() === extension) {
        return loader;
      }
    }
  }
  return null;
}
function findLoaderByMIMEType(loaders, mimeType) {
  var _a3;
  for (const loader of loaders) {
    if ((_a3 = loader.mimeTypes) == null ? void 0 : _a3.some((mimeType1) => compareMIMETypes(mimeType, mimeType1))) {
      return loader;
    }
    if (compareMIMETypes(mimeType, `application/x.${loader.id}`)) {
      return loader;
    }
  }
  return null;
}
function findLoaderByInitialBytes(loaders, data) {
  if (!data) {
    return null;
  }
  for (const loader of loaders) {
    if (typeof data === "string") {
      if (testDataAgainstText(data, loader)) {
        return loader;
      }
    } else if (ArrayBuffer.isView(data)) {
      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
        return loader;
      }
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      if (testDataAgainstBinary(data, byteOffset, loader)) {
        return loader;
      }
    }
  }
  return null;
}
function testDataAgainstText(data, loader) {
  if (loader.testText) {
    return loader.testText(data);
  }
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some((test) => data.startsWith(test));
}
function testDataAgainstBinary(data, byteOffset, loader) {
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some((test) => testBinary(data, byteOffset, loader, test));
}
function testBinary(data, byteOffset, loader, test) {
  if (test instanceof ArrayBuffer) {
    return compareArrayBuffers(test, data, test.byteLength);
  }
  switch (typeof test) {
    case "function":
      return test(data);
    case "string":
      const magic = getMagicString2(data, byteOffset, test.length);
      return test === magic;
    default:
      return false;
  }
}
function getFirstCharacters2(data, length5 = 5) {
  if (typeof data === "string") {
    return data.slice(0, length5);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString2(data.buffer, data.byteOffset, length5);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString2(data, byteOffset, length5);
  }
  return "";
}
function getMagicString2(arrayBuffer, byteOffset, length5) {
  if (arrayBuffer.byteLength < byteOffset + length5) {
    return "";
  }
  const dataView = new DataView(arrayBuffer);
  let magic = "";
  for (let i2 = 0; i2 < length5; i2++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i2));
  }
  return magic;
}

// node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-string-iterator.js
var DEFAULT_CHUNK_SIZE = 256 * 1024;
function* makeStringIterator(string, options) {
  const chunkSize = (options == null ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
  let offset = 0;
  const textEncoder = new TextEncoder();
  while (offset < string.length) {
    const chunkLength = Math.min(string.length - offset, chunkSize);
    const chunk = string.slice(offset, offset + chunkLength);
    offset += chunkLength;
    yield textEncoder.encode(chunk);
  }
}

// node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-array-buffer-iterator.js
var DEFAULT_CHUNK_SIZE2 = 256 * 1024;
function* makeArrayBufferIterator(arrayBuffer, options = {}) {
  const { chunkSize = DEFAULT_CHUNK_SIZE2 } = options;
  let byteOffset = 0;
  while (byteOffset < arrayBuffer.byteLength) {
    const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);
    const chunk = new ArrayBuffer(chunkByteLength);
    const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);
    const chunkArray = new Uint8Array(chunk);
    chunkArray.set(sourceArray);
    byteOffset += chunkByteLength;
    yield chunk;
  }
}

// node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-blob-iterator.js
var DEFAULT_CHUNK_SIZE3 = 1024 * 1024;
async function* makeBlobIterator(blob, options) {
  const chunkSize = (options == null ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE3;
  let offset = 0;
  while (offset < blob.size) {
    const end = offset + chunkSize;
    const chunk = await blob.slice(offset, end).arrayBuffer();
    offset = end;
    yield chunk;
  }
}

// node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-stream-iterator.js
function makeStreamIterator(stream, options) {
  return isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
}
async function* makeBrowserStreamIterator(stream, options) {
  const reader = stream.getReader();
  let nextBatchPromise;
  try {
    while (true) {
      const currentBatchPromise = nextBatchPromise || reader.read();
      if (options == null ? void 0 : options._streamReadAhead) {
        nextBatchPromise = reader.read();
      }
      const { done, value } = await currentBatchPromise;
      if (done) {
        return;
      }
      yield toArrayBuffer2(value);
    }
  } catch (error) {
    reader.releaseLock();
  }
}
async function* makeNodeStreamIterator(stream, options) {
  for await (const chunk of stream) {
    yield toArrayBuffer2(chunk);
  }
}

// node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-iterator.js
function makeIterator(data, options) {
  if (typeof data === "string") {
    return makeStringIterator(data, options);
  }
  if (data instanceof ArrayBuffer) {
    return makeArrayBufferIterator(data, options);
  }
  if (isBlob(data)) {
    return makeBlobIterator(data, options);
  }
  if (isReadableStream(data)) {
    return makeStreamIterator(data, options);
  }
  if (isResponse(data)) {
    const response = data;
    return makeStreamIterator(response.body, options);
  }
  throw new Error("makeIterator");
}

// node_modules/@loaders.gl/core/dist/lib/loader-utils/get-data.js
var ERR_DATA = "Cannot convert supplied data type";
function getArrayBufferOrStringFromDataSync(data, loader, options) {
  if (loader.text && typeof data === "string") {
    return data;
  }
  if (isBuffer2(data)) {
    data = data.buffer;
  }
  if (data instanceof ArrayBuffer) {
    const arrayBuffer = data;
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder("utf8");
      return textDecoder.decode(arrayBuffer);
    }
    return arrayBuffer;
  }
  if (ArrayBuffer.isView(data)) {
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder("utf8");
      return textDecoder.decode(data);
    }
    let arrayBuffer = data.buffer;
    const byteLength = data.byteLength || data.length;
    if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {
      arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);
    }
    return arrayBuffer;
  }
  throw new Error(ERR_DATA);
}
async function getArrayBufferOrStringFromData(data, loader, options) {
  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
  if (typeof data === "string" || isArrayBuffer) {
    return getArrayBufferOrStringFromDataSync(data, loader, options);
  }
  if (isBlob(data)) {
    data = await makeResponse(data);
  }
  if (isResponse(data)) {
    const response = data;
    await checkResponse(response);
    return loader.binary ? await response.arrayBuffer() : await response.text();
  }
  if (isReadableStream(data)) {
    data = makeIterator(data, options);
  }
  if (isIterable(data) || isAsyncIterable(data)) {
    return concatenateArrayBuffersAsync(data);
  }
  throw new Error(ERR_DATA);
}

// node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js
function getFetchFunction(options, context) {
  const globalOptions = getGlobalLoaderOptions();
  const loaderOptions = options || globalOptions;
  if (typeof loaderOptions.fetch === "function") {
    return loaderOptions.fetch;
  }
  if (isObject(loaderOptions.fetch)) {
    return (url) => fetchFile(url, loaderOptions.fetch);
  }
  if (context == null ? void 0 : context.fetch) {
    return context == null ? void 0 : context.fetch;
  }
  return fetchFile;
}

// node_modules/@loaders.gl/core/dist/lib/loader-utils/loader-context.js
function getLoaderContext(context, options, parentContext) {
  if (parentContext) {
    return parentContext;
  }
  const newContext = {
    fetch: getFetchFunction(options, context),
    ...context
  };
  if (newContext.url) {
    const baseUrl = stripQueryString(newContext.url);
    newContext.baseUrl = baseUrl;
    newContext.queryString = extractQueryString(newContext.url);
    newContext.filename = path_exports.filename(baseUrl);
    newContext.baseUrl = path_exports.dirname(baseUrl);
  }
  if (!Array.isArray(newContext.loaders)) {
    newContext.loaders = null;
  }
  return newContext;
}
function getLoadersFromContext(loaders, context) {
  if (loaders && !Array.isArray(loaders)) {
    return loaders;
  }
  let candidateLoaders;
  if (loaders) {
    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
  }
  if (context && context.loaders) {
    const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
    candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;
  }
  return candidateLoaders && candidateLoaders.length ? candidateLoaders : void 0;
}

// node_modules/@loaders.gl/core/dist/lib/api/parse.js
async function parse(data, loaders, options, context) {
  if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {
    context = void 0;
    options = loaders;
    loaders = void 0;
  }
  data = await data;
  options = options || {};
  const url = getResourceUrl(data);
  const typedLoaders = loaders;
  const candidateLoaders = getLoadersFromContext(typedLoaders, context);
  const loader = await selectLoader(data, candidateLoaders, options);
  if (!loader) {
    return null;
  }
  options = normalizeOptions(options, loader, candidateLoaders, url);
  context = getLoaderContext(
    // @ts-expect-error
    { url, _parse: parse, loaders: candidateLoaders },
    options,
    context || null
  );
  return await parseWithLoader(loader, data, options, context);
}
async function parseWithLoader(loader, data, options, context) {
  validateWorkerVersion(loader);
  options = mergeLoaderOptions(loader.options, options);
  if (isResponse(data)) {
    const response = data;
    const { ok, redirected, status, statusText, type, url } = response;
    const headers = Object.fromEntries(response.headers.entries());
    context.response = { headers, ok, redirected, status, statusText, type, url };
  }
  data = await getArrayBufferOrStringFromData(data, loader, options);
  const loaderWithParser = loader;
  if (loaderWithParser.parseTextSync && typeof data === "string") {
    return loaderWithParser.parseTextSync(data, options, context);
  }
  if (canParseWithWorker(loader, options)) {
    return await parseWithWorker(loader, data, options, context, parse);
  }
  if (loaderWithParser.parseText && typeof data === "string") {
    return await loaderWithParser.parseText(data, options, context);
  }
  if (loaderWithParser.parse) {
    return await loaderWithParser.parse(data, options, context);
  }
  assert5(!loaderWithParser.parseSync);
  throw new Error(`${loader.id} loader - no parser found and worker is disabled`);
}

// node_modules/@loaders.gl/schema/dist/lib/table/arrow-api/enum.js
var Type;
(function(Type2) {
  Type2[Type2["NONE"] = 0] = "NONE";
  Type2[Type2["Null"] = 1] = "Null";
  Type2[Type2["Int"] = 2] = "Int";
  Type2[Type2["Float"] = 3] = "Float";
  Type2[Type2["Binary"] = 4] = "Binary";
  Type2[Type2["Utf8"] = 5] = "Utf8";
  Type2[Type2["Bool"] = 6] = "Bool";
  Type2[Type2["Decimal"] = 7] = "Decimal";
  Type2[Type2["Date"] = 8] = "Date";
  Type2[Type2["Time"] = 9] = "Time";
  Type2[Type2["Timestamp"] = 10] = "Timestamp";
  Type2[Type2["Interval"] = 11] = "Interval";
  Type2[Type2["List"] = 12] = "List";
  Type2[Type2["Struct"] = 13] = "Struct";
  Type2[Type2["Union"] = 14] = "Union";
  Type2[Type2["FixedSizeBinary"] = 15] = "FixedSizeBinary";
  Type2[Type2["FixedSizeList"] = 16] = "FixedSizeList";
  Type2[Type2["Map"] = 17] = "Map";
  Type2[Type2["Dictionary"] = -1] = "Dictionary";
  Type2[Type2["Int8"] = -2] = "Int8";
  Type2[Type2["Int16"] = -3] = "Int16";
  Type2[Type2["Int32"] = -4] = "Int32";
  Type2[Type2["Int64"] = -5] = "Int64";
  Type2[Type2["Uint8"] = -6] = "Uint8";
  Type2[Type2["Uint16"] = -7] = "Uint16";
  Type2[Type2["Uint32"] = -8] = "Uint32";
  Type2[Type2["Uint64"] = -9] = "Uint64";
  Type2[Type2["Float16"] = -10] = "Float16";
  Type2[Type2["Float32"] = -11] = "Float32";
  Type2[Type2["Float64"] = -12] = "Float64";
  Type2[Type2["DateDay"] = -13] = "DateDay";
  Type2[Type2["DateMillisecond"] = -14] = "DateMillisecond";
  Type2[Type2["TimestampSecond"] = -15] = "TimestampSecond";
  Type2[Type2["TimestampMillisecond"] = -16] = "TimestampMillisecond";
  Type2[Type2["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
  Type2[Type2["TimestampNanosecond"] = -18] = "TimestampNanosecond";
  Type2[Type2["TimeSecond"] = -19] = "TimeSecond";
  Type2[Type2["TimeMillisecond"] = -20] = "TimeMillisecond";
  Type2[Type2["TimeMicrosecond"] = -21] = "TimeMicrosecond";
  Type2[Type2["TimeNanosecond"] = -22] = "TimeNanosecond";
  Type2[Type2["DenseUnion"] = -23] = "DenseUnion";
  Type2[Type2["SparseUnion"] = -24] = "SparseUnion";
  Type2[Type2["IntervalDayTime"] = -25] = "IntervalDayTime";
  Type2[Type2["IntervalYearMonth"] = -26] = "IntervalYearMonth";
})(Type || (Type = {}));

// node_modules/@loaders.gl/core/dist/lib/api/load.js
async function load(url, loaders, options, context) {
  let resolvedLoaders;
  let resolvedOptions;
  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
    resolvedLoaders = [];
    resolvedOptions = loaders;
    context = void 0;
  } else {
    resolvedLoaders = loaders;
    resolvedOptions = options;
  }
  const fetch2 = getFetchFunction(resolvedOptions);
  let data = url;
  if (typeof url === "string") {
    data = await fetch2(url);
  }
  if (isBlob(url)) {
    data = await fetch2(url);
  }
  return Array.isArray(resolvedLoaders) ? await parse(data, resolvedLoaders, resolvedOptions) : await parse(data, resolvedLoaders, resolvedOptions);
}

// node_modules/@deck.gl/core/dist/lib/resource/resource.js
var Resource = class {
  constructor(id, data, context) {
    this._loadCount = 0;
    this._subscribers = /* @__PURE__ */ new Set();
    this.id = id;
    this.context = context;
    this.setData(data);
  }
  // consumer: {onChange: Function}
  subscribe(consumer) {
    this._subscribers.add(consumer);
  }
  unsubscribe(consumer) {
    this._subscribers.delete(consumer);
  }
  inUse() {
    return this._subscribers.size > 0;
  }
  delete() {
  }
  getData() {
    return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
  }
  setData(data, forceUpdate) {
    if (data === this._data && !forceUpdate) {
      return;
    }
    this._data = data;
    const loadCount = ++this._loadCount;
    let loader = data;
    if (typeof data === "string") {
      loader = load(data);
    }
    if (loader instanceof Promise) {
      this.isLoaded = false;
      this._loader = loader.then((result) => {
        if (this._loadCount === loadCount) {
          this.isLoaded = true;
          this._error = void 0;
          this._content = result;
        }
      }).catch((error) => {
        if (this._loadCount === loadCount) {
          this.isLoaded = true;
          this._error = error || true;
        }
      });
    } else {
      this.isLoaded = true;
      this._error = void 0;
      this._content = data;
    }
    for (const subscriber of this._subscribers) {
      subscriber.onChange(this.getData());
    }
  }
};

// node_modules/@deck.gl/core/dist/lib/resource/resource-manager.js
var ResourceManager = class {
  constructor(props) {
    var _a3;
    this.protocol = props.protocol || "resource://";
    this._context = {
      device: props.device,
      // @ts-expect-error
      gl: (_a3 = props.device) == null ? void 0 : _a3.gl,
      resourceManager: this
    };
    this._resources = {};
    this._consumers = {};
    this._pruneRequest = null;
  }
  contains(resourceId) {
    if (resourceId.startsWith(this.protocol)) {
      return true;
    }
    return resourceId in this._resources;
  }
  add({ resourceId, data, forceUpdate = false, persistent = true }) {
    let res = this._resources[resourceId];
    if (res) {
      res.setData(data, forceUpdate);
    } else {
      res = new Resource(resourceId, data, this._context);
      this._resources[resourceId] = res;
    }
    res.persistent = persistent;
  }
  remove(resourceId) {
    const res = this._resources[resourceId];
    if (res) {
      res.delete();
      delete this._resources[resourceId];
    }
  }
  unsubscribe({ consumerId }) {
    const consumer = this._consumers[consumerId];
    if (consumer) {
      for (const requestId in consumer) {
        const request = consumer[requestId];
        const resource = this._resources[request.resourceId];
        if (resource) {
          resource.unsubscribe(request);
        }
      }
      delete this._consumers[consumerId];
      this.prune();
    }
  }
  subscribe({ resourceId, onChange, consumerId, requestId = "default" }) {
    const { _resources: resources, protocol } = this;
    if (resourceId.startsWith(protocol)) {
      resourceId = resourceId.replace(protocol, "");
      if (!resources[resourceId]) {
        this.add({ resourceId, data: null, persistent: false });
      }
    }
    const res = resources[resourceId];
    this._track(consumerId, requestId, res, onChange);
    if (res) {
      return res.getData();
    }
    return void 0;
  }
  prune() {
    if (!this._pruneRequest) {
      this._pruneRequest = setTimeout(() => this._prune(), 0);
    }
  }
  finalize() {
    for (const key in this._resources) {
      this._resources[key].delete();
    }
  }
  _track(consumerId, requestId, resource, onChange) {
    const consumers = this._consumers;
    const consumer = consumers[consumerId] = consumers[consumerId] || {};
    let request = consumer[requestId];
    const oldResource = request && request.resourceId && this._resources[request.resourceId];
    if (oldResource) {
      oldResource.unsubscribe(request);
      this.prune();
    }
    if (resource) {
      if (request) {
        request.onChange = onChange;
        request.resourceId = resource.id;
      } else {
        request = {
          onChange,
          resourceId: resource.id
        };
      }
      consumer[requestId] = request;
      resource.subscribe(request);
    }
  }
  _prune() {
    this._pruneRequest = null;
    for (const key of Object.keys(this._resources)) {
      const res = this._resources[key];
      if (!res.persistent && !res.inUse()) {
        res.delete();
        delete this._resources[key];
      }
    }
  }
};

// node_modules/@deck.gl/core/dist/utils/typed-array-manager.js
var TypedArrayManager = class {
  constructor(options = {}) {
    this._pool = [];
    this.opts = { overAlloc: 2, poolSize: 100 };
    this.setOptions(options);
  }
  setOptions(options) {
    Object.assign(this.opts, options);
  }
  allocate(typedArray, count2, { size = 1, type, padding = 0, copy: copy7 = false, initialize = false, maxCount }) {
    const Type2 = type || typedArray && typedArray.constructor || Float32Array;
    const newSize = count2 * size + padding;
    if (ArrayBuffer.isView(typedArray)) {
      if (newSize <= typedArray.length) {
        return typedArray;
      }
      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {
        return new Type2(typedArray.buffer, 0, newSize);
      }
    }
    let maxSize = Infinity;
    if (maxCount) {
      maxSize = maxCount * size + padding;
    }
    const newArray = this._allocate(Type2, newSize, initialize, maxSize);
    if (typedArray && copy7) {
      newArray.set(typedArray);
    } else if (!initialize) {
      newArray.fill(0, 0, 4);
    }
    this._release(typedArray);
    return newArray;
  }
  release(typedArray) {
    this._release(typedArray);
  }
  _allocate(Type2, size, initialize, maxSize) {
    let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);
    if (sizeToAllocate > maxSize) {
      sizeToAllocate = maxSize;
    }
    const pool = this._pool;
    const byteLength = Type2.BYTES_PER_ELEMENT * sizeToAllocate;
    const i2 = pool.findIndex((b2) => b2.byteLength >= byteLength);
    if (i2 >= 0) {
      const array = new Type2(pool.splice(i2, 1)[0], 0, sizeToAllocate);
      if (initialize) {
        array.fill(0);
      }
      return array;
    }
    return new Type2(sizeToAllocate);
  }
  _release(typedArray) {
    if (!ArrayBuffer.isView(typedArray)) {
      return;
    }
    const pool = this._pool;
    const { buffer: buffer2 } = typedArray;
    const { byteLength } = buffer2;
    const i2 = pool.findIndex((b2) => b2.byteLength >= byteLength);
    if (i2 < 0) {
      pool.push(buffer2);
    } else if (i2 > 0 || pool.length < this.opts.poolSize) {
      pool.splice(i2, 0, buffer2);
    }
    if (pool.length > this.opts.poolSize) {
      pool.shift();
    }
  }
};
var typed_array_manager_default = new TypedArrayManager();

// node_modules/@deck.gl/core/dist/utils/math-utils.js
function createMat42() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function mod2(value, divisor) {
  const modulus = value % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}
function getCameraPosition(viewMatrixInverse) {
  return [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]];
}
function getFrustumPlanes(viewProjectionMatrix) {
  return {
    left: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[0], viewProjectionMatrix[7] + viewProjectionMatrix[4], viewProjectionMatrix[11] + viewProjectionMatrix[8], viewProjectionMatrix[15] + viewProjectionMatrix[12]),
    right: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[0], viewProjectionMatrix[7] - viewProjectionMatrix[4], viewProjectionMatrix[11] - viewProjectionMatrix[8], viewProjectionMatrix[15] - viewProjectionMatrix[12]),
    bottom: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[1], viewProjectionMatrix[7] + viewProjectionMatrix[5], viewProjectionMatrix[11] + viewProjectionMatrix[9], viewProjectionMatrix[15] + viewProjectionMatrix[13]),
    top: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[1], viewProjectionMatrix[7] - viewProjectionMatrix[5], viewProjectionMatrix[11] - viewProjectionMatrix[9], viewProjectionMatrix[15] - viewProjectionMatrix[13]),
    near: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[2], viewProjectionMatrix[7] + viewProjectionMatrix[6], viewProjectionMatrix[11] + viewProjectionMatrix[10], viewProjectionMatrix[15] + viewProjectionMatrix[14]),
    far: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[2], viewProjectionMatrix[7] - viewProjectionMatrix[6], viewProjectionMatrix[11] - viewProjectionMatrix[10], viewProjectionMatrix[15] - viewProjectionMatrix[14])
  };
}
var scratchVector = new Vector3();
function getFrustumPlane(a2, b2, c2, d2) {
  scratchVector.set(a2, b2, c2);
  const L2 = scratchVector.len();
  return { distance: d2 / L2, normal: new Vector3(-a2 / L2, -b2 / L2, -c2 / L2) };
}
function fp64LowPart2(x2) {
  return x2 - Math.fround(x2);
}
var scratchArray;
function toDoublePrecisionArray(typedArray, options) {
  const { size = 1, startIndex = 0 } = options;
  const endIndex = options.endIndex !== void 0 ? options.endIndex : typedArray.length;
  const count2 = (endIndex - startIndex) / size;
  scratchArray = typed_array_manager_default.allocate(scratchArray, count2, {
    type: Float32Array,
    size: size * 2
  });
  let sourceIndex = startIndex;
  let targetIndex = 0;
  while (sourceIndex < endIndex) {
    for (let j2 = 0; j2 < size; j2++) {
      const value = typedArray[sourceIndex++];
      scratchArray[targetIndex + j2] = value;
      scratchArray[targetIndex + j2 + size] = fp64LowPart2(value);
    }
    targetIndex += size * 2;
  }
  return scratchArray.subarray(0, count2 * size * 2);
}
function mergeBounds(boundsList) {
  let mergedBounds = null;
  let isMerged = false;
  for (const bounds of boundsList) {
    if (!bounds)
      continue;
    if (!mergedBounds) {
      mergedBounds = bounds;
    } else {
      if (!isMerged) {
        mergedBounds = [
          [mergedBounds[0][0], mergedBounds[0][1]],
          [mergedBounds[1][0], mergedBounds[1][1]]
        ];
        isMerged = true;
      }
      mergedBounds[0][0] = Math.min(mergedBounds[0][0], bounds[0][0]);
      mergedBounds[0][1] = Math.min(mergedBounds[0][1], bounds[0][1]);
      mergedBounds[1][0] = Math.max(mergedBounds[1][0], bounds[1][0]);
      mergedBounds[1][1] = Math.max(mergedBounds[1][1], bounds[1][1]);
    }
  }
  return mergedBounds;
}

// node_modules/@deck.gl/core/dist/viewports/viewport.js
var DEGREES_TO_RADIANS4 = Math.PI / 180;
var IDENTITY2 = createMat42();
var ZERO_VECTOR2 = [0, 0, 0];
var DEFAULT_DISTANCE_SCALES = {
  unitsPerMeter: [1, 1, 1],
  metersPerUnit: [1, 1, 1]
};
function createProjectionMatrix({ width, height, orthographic, fovyRadians, focalDistance, padding, near, far }) {
  const aspect = width / height;
  const matrix = orthographic ? new Matrix4().orthographic({ fovy: fovyRadians, aspect, focalDistance, near, far }) : new Matrix4().perspective({ fovy: fovyRadians, aspect, near, far });
  if (padding) {
    const { left = 0, right = 0, top = 0, bottom = 0 } = padding;
    const offsetX = clamp((left + width - right) / 2, 0, width) - width / 2;
    const offsetY = clamp((top + height - bottom) / 2, 0, height) - height / 2;
    matrix[8] -= offsetX * 2 / width;
    matrix[9] += offsetY * 2 / height;
  }
  return matrix;
}
var Viewport = class _Viewport {
  // eslint-disable-next-line complexity
  constructor(opts = {}) {
    this._frustumPlanes = {};
    this.id = opts.id || this.constructor.displayName || "viewport";
    this.x = opts.x || 0;
    this.y = opts.y || 0;
    this.width = opts.width || 1;
    this.height = opts.height || 1;
    this.zoom = opts.zoom || 0;
    this.padding = opts.padding;
    this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;
    this.focalDistance = opts.focalDistance || 1;
    this.position = opts.position || ZERO_VECTOR2;
    this.modelMatrix = opts.modelMatrix || null;
    const { longitude, latitude } = opts;
    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
    this._initProps(opts);
    this._initMatrices(opts);
    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectPosition = this.projectPosition.bind(this);
    this.unprojectPosition = this.unprojectPosition.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
  }
  get subViewports() {
    return null;
  }
  get metersPerPixel() {
    return this.distanceScales.metersPerUnit[2] / this.scale;
  }
  get projectionMode() {
    if (this.isGeospatial) {
      return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;
    }
    return PROJECTION_MODE.IDENTITY;
  }
  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.
  equals(viewport) {
    if (!(viewport instanceof _Viewport)) {
      return false;
    }
    if (this === viewport) {
      return true;
    }
    return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && equals(viewport.projectionMatrix, this.projectionMatrix) && equals(viewport.viewMatrix, this.viewMatrix);
  }
  /**
   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
   * using viewport projection parameters
   * - [longitude, latitude] to [x, y]
   * - [longitude, latitude, Z] => [x, y, z]
   * Note: By default, returns top-left coordinates for canvas/SVG type render
   *
   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether projected coords are top left
   * @return {Array} - [x, y] or [x, y, z] in top left coords
   */
  project(xyz, { topLeft = true } = {}) {
    const worldPosition = this.projectPosition(xyz);
    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);
    const [x2, y2] = coord;
    const y22 = topLeft ? y2 : this.height - y2;
    return xyz.length === 2 ? [x2, y22] : [x2, y22, coord[2]];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(xyz, { topLeft = true, targetZ } = {}) {
    const [x2, y2, z2] = xyz;
    const y22 = topLeft ? y2 : this.height - y2;
    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
    const coord = pixelsToWorld([x2, y22, z2], this.pixelUnprojectionMatrix, targetZWorld);
    const [X2, Y2, Z2] = this.unprojectPosition(coord);
    if (Number.isFinite(z2)) {
      return [X2, Y2, Z2];
    }
    return Number.isFinite(targetZ) ? [X2, Y2, targetZ] : [X2, Y2];
  }
  // NON_LINEAR PROJECTION HOOKS
  // Used for web meractor projection
  projectPosition(xyz) {
    const [X2, Y2] = this.projectFlat(xyz);
    const Z2 = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
    return [X2, Y2, Z2];
  }
  unprojectPosition(xyz) {
    const [X2, Y2] = this.unprojectFlat(xyz);
    const Z2 = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
    return [X2, Y2, Z2];
  }
  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */
  projectFlat(xyz) {
    if (this.isGeospatial) {
      const result = lngLatToWorld(xyz);
      result[1] = clamp(result[1], -318, 830);
      return result;
    }
    return xyz;
  }
  /**
   * Unproject world point [x,y] on map onto {lat, lon} on sphere
   * @param {object|Vector} xy - object with {x,y} members
   *  representing point on projected map plane
   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
   *   Has toArray method if you need a GeoJSON Array.
   *   Per cartographic tradition, lat and lon are specified as degrees.
   */
  unprojectFlat(xyz) {
    if (this.isGeospatial) {
      return worldToLngLat(xyz);
    }
    return xyz;
  }
  /**
   * Get bounds of the current viewport
   * @return {Array} - [minX, minY, maxX, maxY]
   */
  getBounds(options = {}) {
    const unprojectOption = { targetZ: options.z || 0 };
    const topLeft = this.unproject([0, 0], unprojectOption);
    const topRight = this.unproject([this.width, 0], unprojectOption);
    const bottomLeft = this.unproject([0, this.height], unprojectOption);
    const bottomRight = this.unproject([this.width, this.height], unprojectOption);
    return [
      Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
      Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),
      Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
      Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])
    ];
  }
  getDistanceScales(coordinateOrigin) {
    if (coordinateOrigin && this.isGeospatial) {
      return getDistanceScales({
        longitude: coordinateOrigin[0],
        latitude: coordinateOrigin[1],
        highPrecision: true
      });
    }
    return this.distanceScales;
  }
  containsPixel({ x: x2, y: y2, width = 1, height = 1 }) {
    return x2 < this.x + this.width && this.x < x2 + width && y2 < this.y + this.height && this.y < y2 + height;
  }
  // Extract frustum planes in common space
  getFrustumPlanes() {
    if (this._frustumPlanes.near) {
      return this._frustumPlanes;
    }
    Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));
    return this._frustumPlanes;
  }
  // EXPERIMENTAL METHODS
  /**
   * Needed by panning and linear transition
   * Pan the viewport to place a given world coordinate at screen point [x, y]
   *
   * @param {Array} coords - world coordinates
   * @param {Array} pixel - [x,y] coordinates on screen
   * @param {Array} startPixel - [x,y] screen position where pan started (optional, for delta-based panning)
   * @return {Object} props of the new viewport
   */
  panByPosition(coords, pixel, startPixel) {
    return null;
  }
  // INTERNAL METHODS
  /* eslint-disable complexity, max-statements */
  _initProps(opts) {
    const longitude = opts.longitude;
    const latitude = opts.latitude;
    if (this.isGeospatial) {
      if (!Number.isFinite(opts.zoom)) {
        this.zoom = getMeterZoom({ latitude }) + Math.log2(this.focalDistance);
      }
      this.distanceScales = opts.distanceScales || getDistanceScales({ latitude, longitude });
    }
    const scale7 = Math.pow(2, this.zoom);
    this.scale = scale7;
    const { position, modelMatrix } = opts;
    let meterOffset = ZERO_VECTOR2;
    if (position) {
      meterOffset = modelMatrix ? new Matrix4(modelMatrix).transformAsVector(position, []) : position;
    }
    if (this.isGeospatial) {
      const center = this.projectPosition([longitude, latitude, 0]);
      this.center = new Vector3(meterOffset).scale(this.distanceScales.unitsPerMeter).add(center);
    } else {
      this.center = this.projectPosition(meterOffset);
    }
  }
  /* eslint-enable complexity, max-statements */
  _initMatrices(opts) {
    const {
      // View matrix
      viewMatrix: viewMatrix2 = IDENTITY2,
      // Projection matrix
      projectionMatrix = null,
      // Projection matrix parameters, used if projectionMatrix not supplied
      orthographic = false,
      fovyRadians,
      fovy = 75,
      near = 0.1,
      // Distance of near clipping plane
      far = 1e3,
      // Distance of far clipping plane
      padding = null,
      // Center offset in pixels
      focalDistance = 1
    } = opts;
    this.viewMatrixUncentered = viewMatrix2;
    this.viewMatrix = new Matrix4().multiplyRight(viewMatrix2).translate(new Vector3(this.center).negate());
    this.projectionMatrix = projectionMatrix || createProjectionMatrix({
      width: this.width,
      height: this.height,
      orthographic,
      fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS4,
      focalDistance,
      padding,
      near,
      far
    });
    const vpm = createMat42();
    mat4_exports.multiply(vpm, vpm, this.projectionMatrix);
    mat4_exports.multiply(vpm, vpm, this.viewMatrix);
    this.viewProjectionMatrix = vpm;
    this.viewMatrixInverse = mat4_exports.invert([], this.viewMatrix) || this.viewMatrix;
    this.cameraPosition = getCameraPosition(this.viewMatrixInverse);
    const viewportMatrix = createMat42();
    const pixelProjectionMatrix = createMat42();
    mat4_exports.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);
    mat4_exports.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);
    mat4_exports.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
    this.pixelProjectionMatrix = pixelProjectionMatrix;
    this.pixelUnprojectionMatrix = mat4_exports.invert(createMat42(), this.pixelProjectionMatrix);
    if (!this.pixelUnprojectionMatrix) {
      log_default.warn("Pixel project matrix not invertible")();
    }
  }
};
Viewport.displayName = "Viewport";
var viewport_default = Viewport;

// node_modules/@deck.gl/core/dist/lib/layer-manager.js
var TRACE_SET_LAYERS = "layerManager.setLayers";
var TRACE_ACTIVATE_VIEWPORT = "layerManager.activateViewport";
var LayerManager = class {
  /**
   * @param device
   * @param param1
   */
  // eslint-disable-next-line
  constructor(device, props) {
    var _a3;
    this._lastRenderedLayers = [];
    this._needsRedraw = false;
    this._needsUpdate = false;
    this._nextLayers = null;
    this._debug = false;
    this._defaultShaderModulesChanged = false;
    this.activateViewport = (viewport2) => {
      debug(TRACE_ACTIVATE_VIEWPORT, this, viewport2);
      if (viewport2) {
        this.context.viewport = viewport2;
      }
    };
    const { deck, stats, viewport, timeline } = props || {};
    this.layers = [];
    this.resourceManager = new ResourceManager({ device, protocol: "deck://" });
    this.context = {
      mousePosition: null,
      userData: {},
      layerManager: this,
      device,
      // @ts-expect-error
      gl: device == null ? void 0 : device.gl,
      deck,
      shaderAssembler: getShaderAssembler(((_a3 = device == null ? void 0 : device.info) == null ? void 0 : _a3.shadingLanguage) || "glsl"),
      defaultShaderModules: [layerUniforms],
      renderPass: void 0,
      stats: stats || new Stats({ id: "deck.gl" }),
      // Make sure context.viewport is not empty on the first layer initialization
      viewport: viewport || new viewport_default({ id: "DEFAULT-INITIAL-VIEWPORT" }),
      // Current viewport, exposed to layers for project* function
      timeline: timeline || new Timeline(),
      resourceManager: this.resourceManager,
      onError: void 0
    };
    Object.seal(this);
  }
  /** Method to call when the layer manager is not needed anymore. */
  finalize() {
    this.resourceManager.finalize();
    for (const layer of this.layers) {
      this._finalizeLayer(layer);
    }
  }
  /** Check if a redraw is needed */
  needsRedraw(opts = { clearRedrawFlags: false }) {
    let redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    for (const layer of this.layers) {
      const layerNeedsRedraw = layer.getNeedsRedraw(opts);
      redraw = redraw || layerNeedsRedraw;
    }
    return redraw;
  }
  /** Check if a deep update of all layers is needed */
  needsUpdate() {
    if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {
      return "layers changed";
    }
    if (this._defaultShaderModulesChanged) {
      return "shader modules changed";
    }
    return this._needsUpdate;
  }
  /** Layers will be redrawn (in next animation frame) */
  setNeedsRedraw(reason) {
    this._needsRedraw = this._needsRedraw || reason;
  }
  /** Layers will be updated deeply (in next animation frame)
    Potentially regenerating attributes and sub layers */
  setNeedsUpdate(reason) {
    this._needsUpdate = this._needsUpdate || reason;
  }
  /** Gets a list of currently rendered layers. Optionally filter by id. */
  getLayers({ layerIds } = {}) {
    return layerIds ? this.layers.filter((layer) => layerIds.find((layerId) => layer.id.indexOf(layerId) === 0)) : this.layers;
  }
  /** Set props needed for layer rendering and picking. */
  setProps(props) {
    if ("debug" in props) {
      this._debug = props.debug;
    }
    if ("userData" in props) {
      this.context.userData = props.userData;
    }
    if ("layers" in props) {
      this._nextLayers = props.layers;
    }
    if ("onError" in props) {
      this.context.onError = props.onError;
    }
  }
  /** Supply a new layer list, initiating sublayer generation and layer matching */
  setLayers(newLayers, reason) {
    debug(TRACE_SET_LAYERS, this, reason, newLayers);
    this._lastRenderedLayers = newLayers;
    const flatLayers = flatten(newLayers, Boolean);
    for (const layer of flatLayers) {
      layer.context = this.context;
    }
    this._updateLayers(this.layers, flatLayers);
  }
  /** Update layers from last cycle if `setNeedsUpdate()` has been called */
  updateLayers() {
    const reason = this.needsUpdate();
    if (reason) {
      this.setNeedsRedraw(`updating layers: ${reason}`);
      this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);
    }
    this._nextLayers = null;
  }
  /** Register a default shader module */
  addDefaultShaderModule(module) {
    const { defaultShaderModules } = this.context;
    if (!defaultShaderModules.find((m2) => m2.name === module.name)) {
      defaultShaderModules.push(module);
      this._defaultShaderModulesChanged = true;
    }
  }
  /** Deregister a default shader module */
  removeDefaultShaderModule(module) {
    const { defaultShaderModules } = this.context;
    const i2 = defaultShaderModules.findIndex((m2) => m2.name === module.name);
    if (i2 >= 0) {
      defaultShaderModules.splice(i2, 1);
      this._defaultShaderModulesChanged = true;
    }
  }
  _handleError(stage, error, layer) {
    layer.raiseError(error, `${stage} of ${layer}`);
  }
  // TODO - mark layers with exceptions as bad and remove from rendering cycle?
  /** Match all layers, checking for caught errors
    to avoid having an exception in one layer disrupt other layers */
  _updateLayers(oldLayers, newLayers) {
    const oldLayerMap = {};
    for (const oldLayer of oldLayers) {
      if (oldLayerMap[oldLayer.id]) {
        log_default.warn(`Multiple old layers with same id ${oldLayer.id}`)();
      } else {
        oldLayerMap[oldLayer.id] = oldLayer;
      }
    }
    if (this._defaultShaderModulesChanged) {
      for (const layer of oldLayers) {
        layer.setNeedsUpdate();
        layer.setChangeFlags({ extensionsChanged: true });
      }
      this._defaultShaderModulesChanged = false;
    }
    const generatedLayers = [];
    this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);
    this._finalizeOldLayers(oldLayerMap);
    let needsUpdate = false;
    for (const layer of generatedLayers) {
      if (layer.hasUniformTransition()) {
        needsUpdate = `Uniform transition in ${layer}`;
        break;
      }
    }
    this._needsUpdate = needsUpdate;
    this.layers = generatedLayers;
  }
  /* eslint-disable complexity,max-statements */
  // Note: adds generated layers to `generatedLayers` array parameter
  _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {
    for (const newLayer of newLayers) {
      newLayer.context = this.context;
      const oldLayer = oldLayerMap[newLayer.id];
      if (oldLayer === null) {
        log_default.warn(`Multiple new layers with same id ${newLayer.id}`)();
      }
      oldLayerMap[newLayer.id] = null;
      let sublayers = null;
      try {
        if (this._debug && oldLayer !== newLayer) {
          newLayer.validateProps();
        }
        if (!oldLayer) {
          this._initializeLayer(newLayer);
        } else {
          this._transferLayerState(oldLayer, newLayer);
          this._updateLayer(newLayer);
        }
        generatedLayers.push(newLayer);
        sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;
      } catch (err) {
        this._handleError("matching", err, newLayer);
      }
      if (sublayers) {
        this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);
      }
    }
  }
  /* eslint-enable complexity,max-statements */
  // Finalize any old layers that were not matched
  _finalizeOldLayers(oldLayerMap) {
    for (const layerId in oldLayerMap) {
      const layer = oldLayerMap[layerId];
      if (layer) {
        this._finalizeLayer(layer);
      }
    }
  }
  // / EXCEPTION SAFE LAYER ACCESS
  /** Safely initializes a single layer, calling layer methods */
  _initializeLayer(layer) {
    try {
      layer._initialize();
      layer.lifecycle = LIFECYCLE.INITIALIZED;
    } catch (err) {
      this._handleError("initialization", err, layer);
    }
  }
  /** Transfer state from one layer to a newer version */
  _transferLayerState(oldLayer, newLayer) {
    newLayer._transferState(oldLayer);
    newLayer.lifecycle = LIFECYCLE.MATCHED;
    if (newLayer !== oldLayer) {
      oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;
    }
  }
  /** Safely updates a single layer, cleaning all flags */
  _updateLayer(layer) {
    try {
      layer._update();
    } catch (err) {
      this._handleError("update", err, layer);
    }
  }
  /** Safely finalizes a single layer, removing all resources */
  _finalizeLayer(layer) {
    this._needsRedraw = this._needsRedraw || `finalized ${layer}`;
    layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;
    try {
      layer._finalize();
      layer.lifecycle = LIFECYCLE.FINALIZED;
    } catch (err) {
      this._handleError("finalization", err, layer);
    }
  }
};

// node_modules/@deck.gl/core/dist/lib/view-manager.js
var ViewManager = class {
  constructor(props) {
    this.views = [];
    this.width = 100;
    this.height = 100;
    this.viewState = {};
    this.controllers = {};
    this.timeline = props.timeline;
    this._viewports = [];
    this._viewportMap = {};
    this._isUpdating = false;
    this._needsRedraw = "First render";
    this._needsUpdate = "Initialize";
    this._eventManager = props.eventManager;
    this._eventCallbacks = {
      onViewStateChange: props.onViewStateChange,
      onInteractionStateChange: props.onInteractionStateChange
    };
    Object.seal(this);
    this.setProps(props);
  }
  /** Remove all resources and event listeners */
  finalize() {
    for (const key in this.controllers) {
      const controller = this.controllers[key];
      if (controller) {
        controller.finalize();
      }
    }
    this.controllers = {};
  }
  /** Check if a redraw is needed */
  needsRedraw(opts = { clearRedrawFlags: false }) {
    const redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    return redraw;
  }
  /** Mark the manager as dirty. Will rebuild all viewports and update controllers. */
  setNeedsUpdate(reason) {
    this._needsUpdate = this._needsUpdate || reason;
    this._needsRedraw = this._needsRedraw || reason;
  }
  /** Checks each viewport for transition updates */
  updateViewStates() {
    for (const viewId in this.controllers) {
      const controller = this.controllers[viewId];
      if (controller) {
        controller.updateTransition();
      }
    }
  }
  /** Get a set of viewports for a given width and height
   * TODO - Intention is for deck.gl to autodeduce width and height and drop the need for props
   * @param rect (object, optional) - filter the viewports
   *   + not provided - return all viewports
   *   + {x, y} - only return viewports that contain this pixel
   *   + {x, y, width, height} - only return viewports that overlap with this rectangle
   */
  getViewports(rect) {
    if (rect) {
      return this._viewports.filter((viewport) => viewport.containsPixel(rect));
    }
    return this._viewports;
  }
  /** Get a map of all views */
  getViews() {
    const viewMap = {};
    this.views.forEach((view) => {
      viewMap[view.id] = view;
    });
    return viewMap;
  }
  /** Resolves a viewId string to a View */
  getView(viewId) {
    return this.views.find((view) => view.id === viewId);
  }
  /** Returns the viewState for a specific viewId. Matches the viewState by
    1. view.viewStateId
    2. view.id
    3. root viewState
    then applies the view's filter if any */
  getViewState(viewOrViewId) {
    const view = typeof viewOrViewId === "string" ? this.getView(viewOrViewId) : viewOrViewId;
    const viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
    return view ? view.filterViewState(viewState) : viewState;
  }
  getViewport(viewId) {
    return this._viewportMap[viewId];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(xyz, opts) {
    const viewports = this.getViewports();
    const pixel = { x: xyz[0], y: xyz[1] };
    for (let i2 = viewports.length - 1; i2 >= 0; --i2) {
      const viewport = viewports[i2];
      if (viewport.containsPixel(pixel)) {
        const p2 = xyz.slice();
        p2[0] -= viewport.x;
        p2[1] -= viewport.y;
        return viewport.unproject(p2, opts);
      }
    }
    return null;
  }
  /** Update the manager with new Deck props */
  setProps(props) {
    if (props.views) {
      this._setViews(props.views);
    }
    if (props.viewState) {
      this._setViewState(props.viewState);
    }
    if ("width" in props || "height" in props) {
      this._setSize(props.width, props.height);
    }
    if (!this._isUpdating) {
      this._update();
    }
  }
  //
  // PRIVATE METHODS
  //
  _update() {
    this._isUpdating = true;
    if (this._needsUpdate) {
      this._needsUpdate = false;
      this._rebuildViewports();
    }
    if (this._needsUpdate) {
      this._needsUpdate = false;
      this._rebuildViewports();
    }
    this._isUpdating = false;
  }
  _setSize(width, height) {
    if (width !== this.width || height !== this.height) {
      this.width = width;
      this.height = height;
      this.setNeedsUpdate("Size changed");
    }
  }
  // Update the view descriptor list and set change flag if needed
  // Does not actually rebuild the `Viewport`s until `getViewports` is called
  _setViews(views) {
    views = flatten(views, Boolean);
    const viewsChanged = this._diffViews(views, this.views);
    if (viewsChanged) {
      this.setNeedsUpdate("views changed");
    }
    this.views = views;
  }
  _setViewState(viewState) {
    if (viewState) {
      const viewStateChanged = !deepEqual2(viewState, this.viewState, 3);
      if (viewStateChanged) {
        this.setNeedsUpdate("viewState changed");
      }
      this.viewState = viewState;
    } else {
      log_default.warn("missing `viewState` or `initialViewState`")();
    }
  }
  _createController(view, props) {
    const Controller2 = props.type;
    const controller = new Controller2({
      timeline: this.timeline,
      eventManager: this._eventManager,
      // Set an internal callback that calls the prop callback if provided
      onViewStateChange: this._eventCallbacks.onViewStateChange,
      onStateChange: this._eventCallbacks.onInteractionStateChange,
      makeViewport: (viewState) => {
        var _a3;
        return (_a3 = this.getView(view.id)) == null ? void 0 : _a3.makeViewport({
          viewState,
          width: this.width,
          height: this.height
        });
      }
    });
    return controller;
  }
  _updateController(view, viewState, viewport, controller) {
    const controllerProps = view.controller;
    if (controllerProps && viewport) {
      const resolvedProps = {
        ...viewState,
        ...controllerProps,
        id: view.id,
        x: viewport.x,
        y: viewport.y,
        width: viewport.width,
        height: viewport.height
      };
      if (!controller || controller.constructor !== controllerProps.type) {
        controller = this._createController(view, resolvedProps);
      }
      if (controller) {
        controller.setProps(resolvedProps);
      }
      return controller;
    }
    return null;
  }
  // Rebuilds viewports from descriptors towards a certain window size
  _rebuildViewports() {
    const { views } = this;
    const oldControllers = this.controllers;
    this._viewports = [];
    this.controllers = {};
    let invalidateControllers = false;
    for (let i2 = views.length; i2--; ) {
      const view = views[i2];
      const viewState = this.getViewState(view);
      const viewport = view.makeViewport({ viewState, width: this.width, height: this.height });
      let oldController = oldControllers[view.id];
      const hasController = Boolean(view.controller);
      if (hasController && !oldController) {
        invalidateControllers = true;
      }
      if ((invalidateControllers || !hasController) && oldController) {
        oldController.finalize();
        oldController = null;
      }
      this.controllers[view.id] = this._updateController(view, viewState, viewport, oldController);
      if (viewport) {
        this._viewports.unshift(viewport);
      }
    }
    for (const id in oldControllers) {
      const oldController = oldControllers[id];
      if (oldController && !this.controllers[id]) {
        oldController.finalize();
      }
    }
    this._buildViewportMap();
  }
  _buildViewportMap() {
    this._viewportMap = {};
    this._viewports.forEach((viewport) => {
      if (viewport.id) {
        this._viewportMap[viewport.id] = this._viewportMap[viewport.id] || viewport;
      }
    });
  }
  // Check if viewport array has changed, returns true if any change
  // Note that descriptors can be the same
  _diffViews(newViews, oldViews) {
    if (newViews.length !== oldViews.length) {
      return true;
    }
    return newViews.some((_2, i2) => !newViews[i2].equals(oldViews[i2]));
  }
};

// node_modules/@deck.gl/core/dist/utils/positions.js
var PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/;
function parsePosition(value) {
  switch (typeof value) {
    case "number":
      return {
        position: value,
        relative: false
      };
    case "string":
      const match = PERCENT_OR_PIXELS_REGEX.exec(value);
      if (match && match.length >= 3) {
        const relative = match[2] === "%";
        const position = parseFloat(match[1]);
        return {
          position: relative ? position / 100 : position,
          relative
        };
      }
    default:
      throw new Error(`Could not parse position string ${value}`);
  }
}
function getPosition(position, extent) {
  return position.relative ? Math.round(position.position * extent) : position.position;
}

// node_modules/@deck.gl/core/dist/views/view.js
var View = class {
  constructor(props) {
    const { id, x: x2 = 0, y: y2 = 0, width = "100%", height = "100%", padding = null } = props;
    this.id = id || this.constructor.displayName || "view";
    this.props = { ...props, id: this.id };
    this._x = parsePosition(x2);
    this._y = parsePosition(y2);
    this._width = parsePosition(width);
    this._height = parsePosition(height);
    this._padding = padding && {
      left: parsePosition(padding.left || 0),
      right: parsePosition(padding.right || 0),
      top: parsePosition(padding.top || 0),
      bottom: parsePosition(padding.bottom || 0)
    };
    this.equals = this.equals.bind(this);
    Object.seal(this);
  }
  equals(view) {
    if (this === view) {
      return true;
    }
    return this.constructor === view.constructor && deepEqual2(this.props, view.props, 2);
  }
  /** Clone this view with modified props */
  clone(newProps) {
    const ViewConstructor = this.constructor;
    return new ViewConstructor({ ...this.props, ...newProps });
  }
  /** Make viewport from canvas dimensions and view state */
  makeViewport({ width, height, viewState }) {
    viewState = this.filterViewState(viewState);
    const viewportDimensions = this.getDimensions({ width, height });
    if (!viewportDimensions.height || !viewportDimensions.width) {
      return null;
    }
    const ViewportType = this.getViewportType(viewState);
    return new ViewportType({ ...viewState, ...this.props, ...viewportDimensions });
  }
  getViewStateId() {
    const { viewState } = this.props;
    if (typeof viewState === "string") {
      return viewState;
    }
    return (viewState == null ? void 0 : viewState.id) || this.id;
  }
  // Allows view to override (or completely define) viewState
  filterViewState(viewState) {
    if (this.props.viewState && typeof this.props.viewState === "object") {
      if (!this.props.viewState.id) {
        return this.props.viewState;
      }
      const newViewState = { ...viewState };
      for (const key in this.props.viewState) {
        if (key !== "id") {
          newViewState[key] = this.props.viewState[key];
        }
      }
      return newViewState;
    }
    return viewState;
  }
  /** Resolve the dimensions of the view from overall canvas dimensions */
  getDimensions({ width, height }) {
    const dimensions = {
      x: getPosition(this._x, width),
      y: getPosition(this._y, height),
      width: getPosition(this._width, width),
      height: getPosition(this._height, height)
    };
    if (this._padding) {
      dimensions.padding = {
        left: getPosition(this._padding.left, width),
        top: getPosition(this._padding.top, height),
        right: getPosition(this._padding.right, width),
        bottom: getPosition(this._padding.bottom, height)
      };
    }
    return dimensions;
  }
  // Used by sub classes to resolve controller props
  get controller() {
    const opts = this.props.controller;
    if (!opts) {
      return null;
    }
    if (opts === true) {
      return { type: this.ControllerType };
    }
    if (typeof opts === "function") {
      return { type: opts };
    }
    return { type: this.ControllerType, ...opts };
  }
};

// node_modules/@deck.gl/core/dist/viewports/web-mercator-viewport.js
var WebMercatorViewport2 = class _WebMercatorViewport extends viewport_default {
  /* eslint-disable complexity, max-statements */
  constructor(opts = {}) {
    const {
      latitude = 0,
      longitude = 0,
      zoom = 0,
      pitch = 0,
      bearing = 0,
      nearZMultiplier = 0.1,
      farZMultiplier = 1.01,
      nearZ,
      farZ,
      orthographic = false,
      projectionMatrix,
      repeat = false,
      worldOffset = 0,
      position,
      padding,
      // backward compatibility
      // TODO: remove in v9
      legacyMeterSizes = false
    } = opts;
    let { width, height, altitude = 1.5 } = opts;
    const scale7 = Math.pow(2, zoom);
    width = width || 1;
    height = height || 1;
    let fovy;
    let projectionParameters = null;
    if (projectionMatrix) {
      altitude = projectionMatrix[5] / 2;
      fovy = altitudeToFovy(altitude);
    } else {
      if (opts.fovy) {
        fovy = opts.fovy;
        altitude = fovyToAltitude(fovy);
      } else {
        fovy = altitudeToFovy(altitude);
      }
      let offset;
      if (padding) {
        const { top = 0, bottom = 0 } = padding;
        offset = [0, clamp((top + height - bottom) / 2, 0, height) - height / 2];
      }
      projectionParameters = getProjectionParameters({
        width,
        height,
        scale: scale7,
        center: position && [0, 0, position[2] * unitsPerMeter(latitude)],
        offset,
        pitch,
        fovy,
        nearZMultiplier,
        farZMultiplier
      });
      if (Number.isFinite(nearZ)) {
        projectionParameters.near = nearZ;
      }
      if (Number.isFinite(farZ)) {
        projectionParameters.far = farZ;
      }
    }
    let viewMatrixUncentered = getViewMatrix({
      height,
      pitch,
      bearing,
      scale: scale7,
      altitude
    });
    if (worldOffset) {
      const viewOffset = new Matrix4().translate([512 * worldOffset, 0, 0]);
      viewMatrixUncentered = viewOffset.multiplyLeft(viewMatrixUncentered);
    }
    super({
      ...opts,
      // x, y,
      width,
      height,
      // view matrix
      viewMatrix: viewMatrixUncentered,
      longitude,
      latitude,
      zoom,
      // projection matrix parameters
      ...projectionParameters,
      fovy,
      focalDistance: altitude
    });
    this.latitude = latitude;
    this.longitude = longitude;
    this.zoom = zoom;
    this.pitch = pitch;
    this.bearing = bearing;
    this.altitude = altitude;
    this.fovy = fovy;
    this.orthographic = orthographic;
    this._subViewports = repeat ? [] : null;
    this._pseudoMeters = legacyMeterSizes;
    Object.freeze(this);
  }
  /* eslint-enable complexity, max-statements */
  get subViewports() {
    if (this._subViewports && !this._subViewports.length) {
      const bounds = this.getBounds();
      const minOffset = Math.floor((bounds[0] + 180) / 360);
      const maxOffset = Math.ceil((bounds[2] - 180) / 360);
      for (let x2 = minOffset; x2 <= maxOffset; x2++) {
        const offsetViewport = x2 ? new _WebMercatorViewport({
          ...this,
          worldOffset: x2
        }) : this;
        this._subViewports.push(offsetViewport);
      }
    }
    return this._subViewports;
  }
  projectPosition(xyz) {
    if (this._pseudoMeters) {
      return super.projectPosition(xyz);
    }
    const [X2, Y2] = this.projectFlat(xyz);
    const Z2 = (xyz[2] || 0) * unitsPerMeter(xyz[1]);
    return [X2, Y2, Z2];
  }
  unprojectPosition(xyz) {
    if (this._pseudoMeters) {
      return super.unprojectPosition(xyz);
    }
    const [X2, Y2] = this.unprojectFlat(xyz);
    const Z2 = (xyz[2] || 0) / unitsPerMeter(Y2);
    return [X2, Y2, Z2];
  }
  /**
   * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
   *
   * Note: Uses simple linear approximation around the viewport center
   * Error increases with size of offset (roughly 1% per 100km)
   *
   * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
   * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
   * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
   */
  addMetersToLngLat(lngLatZ, xyz) {
    return addMetersToLngLat(lngLatZ, xyz);
  }
  panByPosition(coords, pixel, startPixel) {
    const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);
    const toLocation = this.projectFlat(coords);
    const translate3 = vec2_exports.add([], toLocation, vec2_exports.negate([], fromLocation));
    const newCenter = vec2_exports.add([], this.center, translate3);
    const [longitude, latitude] = this.unprojectFlat(newCenter);
    return { longitude, latitude };
  }
  getBounds(options = {}) {
    const corners = getBounds(this, options.z || 0);
    return [
      Math.min(corners[0][0], corners[1][0], corners[2][0], corners[3][0]),
      Math.min(corners[0][1], corners[1][1], corners[2][1], corners[3][1]),
      Math.max(corners[0][0], corners[1][0], corners[2][0], corners[3][0]),
      Math.max(corners[0][1], corners[1][1], corners[2][1], corners[3][1])
    ];
  }
  /**
   * Returns a new viewport that fit around the given rectangle.
   * Only supports non-perspective mode.
   */
  fitBounds(bounds, options = {}) {
    const { width, height } = this;
    const { longitude, latitude, zoom } = fitBounds({ width, height, bounds, ...options });
    return new _WebMercatorViewport({ width, height, longitude, latitude, zoom });
  }
};
WebMercatorViewport2.displayName = "WebMercatorViewport";
var web_mercator_viewport_default = WebMercatorViewport2;

// node_modules/@deck.gl/core/dist/transitions/transition.js
var Transition = class {
  /**
   * @params timeline {Timeline}
   */
  constructor(timeline) {
    this._inProgress = false;
    this._handle = null;
    this.time = 0;
    this.settings = {
      duration: 0
    };
    this._timeline = timeline;
  }
  /* Public API */
  get inProgress() {
    return this._inProgress;
  }
  /**
   * (re)start this transition.
   * @params props {object} - optional overriding props. see constructor
   */
  start(settings) {
    var _a3, _b;
    this.cancel();
    this.settings = settings;
    this._inProgress = true;
    (_b = (_a3 = this.settings).onStart) == null ? void 0 : _b.call(_a3, this);
  }
  /**
   * end this transition if it is in progress.
   */
  end() {
    var _a3, _b;
    if (this._inProgress) {
      this._timeline.removeChannel(this._handle);
      this._handle = null;
      this._inProgress = false;
      (_b = (_a3 = this.settings).onEnd) == null ? void 0 : _b.call(_a3, this);
    }
  }
  /**
   * cancel this transition if it is in progress.
   */
  cancel() {
    var _a3, _b;
    if (this._inProgress) {
      (_b = (_a3 = this.settings).onInterrupt) == null ? void 0 : _b.call(_a3, this);
      this._timeline.removeChannel(this._handle);
      this._handle = null;
      this._inProgress = false;
    }
  }
  /**
   * update this transition. Returns `true` if updated.
   */
  update() {
    var _a3, _b;
    if (!this._inProgress) {
      return false;
    }
    if (this._handle === null) {
      const { _timeline: timeline, settings } = this;
      this._handle = timeline.addChannel({
        delay: timeline.getTime(),
        duration: settings.duration
      });
    }
    this.time = this._timeline.getTime(this._handle);
    this._onUpdate();
    (_b = (_a3 = this.settings).onUpdate) == null ? void 0 : _b.call(_a3, this);
    if (this._timeline.isFinished(this._handle)) {
      this.end();
    }
    return true;
  }
  /* Private API */
  _onUpdate() {
  }
};

// node_modules/@deck.gl/core/dist/controllers/transition-manager.js
var noop = () => {
};
var TRANSITION_EVENTS = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
};
var DEFAULT_EASING = (t2) => t2;
var DEFAULT_INTERRUPTION = TRANSITION_EVENTS.BREAK;
var TransitionManager = class {
  constructor(opts) {
    this._onTransitionUpdate = (transition) => {
      const { time, settings: { interpolator, startProps, endProps, duration, easing } } = transition;
      const t2 = easing(time / duration);
      const viewport = interpolator.interpolateProps(startProps, endProps, t2);
      this.propsInTransition = this.getControllerState({
        ...this.props,
        ...viewport
      }).getViewportProps();
      this.onViewStateChange({
        viewState: this.propsInTransition,
        oldViewState: this.props
      });
    };
    this.getControllerState = opts.getControllerState;
    this.propsInTransition = null;
    this.transition = new Transition(opts.timeline);
    this.onViewStateChange = opts.onViewStateChange || noop;
    this.onStateChange = opts.onStateChange || noop;
  }
  finalize() {
    this.transition.cancel();
  }
  // Returns current transitioned viewport.
  getViewportInTransition() {
    return this.propsInTransition;
  }
  // Process the vewiport change, either ignore or trigger a new transition.
  // Return true if a new transition is triggered, false otherwise.
  processViewStateChange(nextProps) {
    let transitionTriggered = false;
    const currentProps = this.props;
    this.props = nextProps;
    if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {
      return false;
    }
    if (this._isTransitionEnabled(nextProps)) {
      let startProps = currentProps;
      if (this.transition.inProgress) {
        const { interruption, endProps } = this.transition.settings;
        startProps = {
          ...currentProps,
          ...interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps
        };
      }
      this._triggerTransition(startProps, nextProps);
      transitionTriggered = true;
    } else {
      this.transition.cancel();
    }
    return transitionTriggered;
  }
  updateTransition() {
    this.transition.update();
  }
  // Helper methods
  _isTransitionEnabled(props) {
    const { transitionDuration, transitionInterpolator } = props;
    return (transitionDuration > 0 || transitionDuration === "auto") && Boolean(transitionInterpolator);
  }
  _isUpdateDueToCurrentTransition(props) {
    if (this.transition.inProgress && this.propsInTransition) {
      return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);
    }
    return false;
  }
  _shouldIgnoreViewportChange(currentProps, nextProps) {
    if (this.transition.inProgress) {
      const transitionSettings = this.transition.settings;
      return transitionSettings.interruption === TRANSITION_EVENTS.IGNORE || // Ignore update if it is due to current active transition.
      this._isUpdateDueToCurrentTransition(nextProps);
    }
    if (this._isTransitionEnabled(nextProps)) {
      return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
    }
    return true;
  }
  _triggerTransition(startProps, endProps) {
    const startViewstate = this.getControllerState(startProps);
    const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);
    const transitionInterpolator = endProps.transitionInterpolator;
    const duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;
    if (duration === 0) {
      return;
    }
    const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);
    this.propsInTransition = {};
    const transitionSettings = {
      duration,
      easing: endProps.transitionEasing || DEFAULT_EASING,
      interpolator: transitionInterpolator,
      interruption: endProps.transitionInterruption || DEFAULT_INTERRUPTION,
      startProps: initialProps.start,
      endProps: initialProps.end,
      onStart: endProps.onTransitionStart,
      onUpdate: this._onTransitionUpdate,
      onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
      onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
    };
    this.transition.start(transitionSettings);
    this.onStateChange({ inTransition: true });
    this.updateTransition();
  }
  _onTransitionEnd(callback) {
    return (transition) => {
      this.propsInTransition = null;
      this.onStateChange({
        inTransition: false,
        isZooming: false,
        isPanning: false,
        isRotating: false
      });
      callback == null ? void 0 : callback(transition);
    };
  }
};

// node_modules/@deck.gl/core/dist/utils/assert.js
function assert6(condition, message) {
  if (!condition) {
    throw new Error(message || "deck.gl: assertion failed.");
  }
}

// node_modules/@deck.gl/core/dist/transitions/transition-interpolator.js
var TransitionInterpolator = class {
  /**
   * @param opts {array|object}
   * @param opts.compare {array} - prop names used in equality check
   * @param opts.extract {array} - prop names needed for interpolation
   * @param opts.required {array} - prop names that must be supplied
   * alternatively, supply one list of prop names as `opts` if all of the above are the same.
   */
  constructor(opts) {
    const { compare, extract, required } = opts;
    this._propsToCompare = compare;
    this._propsToExtract = extract || compare;
    this._requiredProps = required;
  }
  /**
   * Checks if two sets of props need transition in between
   * @param currentProps {object} - a list of viewport props
   * @param nextProps {object} - a list of viewport props
   * @returns {bool} - true if two props are equivalent
   */
  arePropsEqual(currentProps, nextProps) {
    for (const key of this._propsToCompare) {
      if (!(key in currentProps) || !(key in nextProps) || !equals(currentProps[key], nextProps[key])) {
        return false;
      }
    }
    return true;
  }
  /**
   * Called before transition starts to validate/pre-process start and end props
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Object} {start, end} - start and end props to be passed
   *   to `interpolateProps`
   */
  initializeProps(startProps, endProps) {
    const startViewStateProps = {};
    const endViewStateProps = {};
    for (const key of this._propsToExtract) {
      if (key in startProps || key in endProps) {
        startViewStateProps[key] = startProps[key];
        endViewStateProps[key] = endProps[key];
      }
    }
    this._checkRequiredProps(startViewStateProps);
    this._checkRequiredProps(endViewStateProps);
    return { start: startViewStateProps, end: endViewStateProps };
  }
  /**
   * Returns transition duration
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Number} - transition duration in milliseconds
   */
  getDuration(startProps, endProps) {
    return endProps.transitionDuration;
  }
  _checkRequiredProps(props) {
    if (!this._requiredProps) {
      return;
    }
    this._requiredProps.forEach((propName) => {
      const value = props[propName];
      assert6(Number.isFinite(value) || Array.isArray(value), `${propName} is required for transition`);
    });
  }
};

// node_modules/@deck.gl/core/dist/viewports/globe-viewport.js
var DEGREES_TO_RADIANS5 = Math.PI / 180;
var RADIANS_TO_DEGREES3 = 180 / Math.PI;
var EARTH_RADIUS = 6370972;
var GLOBE_RADIUS = 256;
function getDistanceScales2() {
  const unitsPerMeter2 = GLOBE_RADIUS / EARTH_RADIUS;
  const unitsPerDegree = Math.PI / 180 * GLOBE_RADIUS;
  return {
    unitsPerMeter: [unitsPerMeter2, unitsPerMeter2, unitsPerMeter2],
    unitsPerMeter2: [0, 0, 0],
    metersPerUnit: [1 / unitsPerMeter2, 1 / unitsPerMeter2, 1 / unitsPerMeter2],
    unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter2],
    unitsPerDegree2: [0, 0, 0],
    degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter2]
  };
}
var GlobeViewport = class extends viewport_default {
  constructor(opts = {}) {
    const {
      longitude = 0,
      zoom = 0,
      // Matches Maplibre defaults
      // https://github.com/maplibre/maplibre-gl-js/blob/f8ab4b48d59ab8fe7b068b102538793bbdd4c848/src/geo/projection/globe_transform.ts#L632-L633
      nearZMultiplier = 0.5,
      farZMultiplier = 1,
      resolution = 10
    } = opts;
    let { latitude = 0, height, altitude = 1.5, fovy } = opts;
    latitude = Math.max(Math.min(latitude, MAX_LATITUDE), -MAX_LATITUDE);
    height = height || 1;
    if (fovy) {
      altitude = fovyToAltitude(fovy);
    } else {
      fovy = altitudeToFovy(altitude);
    }
    const scale7 = Math.pow(2, zoom - zoomAdjust(latitude));
    const nearZ = opts.nearZ ?? nearZMultiplier;
    const farZ = opts.farZ ?? (altitude + GLOBE_RADIUS * 2 * scale7 / height) * farZMultiplier;
    const viewMatrix2 = new Matrix4().lookAt({ eye: [0, -altitude, 0], up: [0, 0, 1] });
    viewMatrix2.rotateX(latitude * DEGREES_TO_RADIANS5);
    viewMatrix2.rotateZ(-longitude * DEGREES_TO_RADIANS5);
    viewMatrix2.scale(scale7 / height);
    super({
      ...opts,
      // x, y, width,
      height,
      // view matrix
      viewMatrix: viewMatrix2,
      longitude,
      latitude,
      zoom,
      // projection matrix parameters
      distanceScales: getDistanceScales2(),
      fovy,
      focalDistance: altitude,
      near: nearZ,
      far: farZ
    });
    this.scale = scale7;
    this.latitude = latitude;
    this.longitude = longitude;
    this.fovy = fovy;
    this.resolution = resolution;
  }
  get projectionMode() {
    return PROJECTION_MODE.GLOBE;
  }
  getDistanceScales() {
    return this.distanceScales;
  }
  getBounds(options = {}) {
    const unprojectOption = { targetZ: options.z || 0 };
    const left = this.unproject([0, this.height / 2], unprojectOption);
    const top = this.unproject([this.width / 2, 0], unprojectOption);
    const right = this.unproject([this.width, this.height / 2], unprojectOption);
    const bottom = this.unproject([this.width / 2, this.height], unprojectOption);
    if (right[0] < this.longitude)
      right[0] += 360;
    if (left[0] > this.longitude)
      left[0] -= 360;
    return [
      Math.min(left[0], right[0], top[0], bottom[0]),
      Math.min(left[1], right[1], top[1], bottom[1]),
      Math.max(left[0], right[0], top[0], bottom[0]),
      Math.max(left[1], right[1], top[1], bottom[1])
    ];
  }
  unproject(xyz, { topLeft = true, targetZ } = {}) {
    const [x2, y2, z2] = xyz;
    const y22 = topLeft ? y2 : this.height - y2;
    const { pixelUnprojectionMatrix } = this;
    let coord;
    if (Number.isFinite(z2)) {
      coord = transformVector2(pixelUnprojectionMatrix, [x2, y22, z2, 1]);
    } else {
      const coord0 = transformVector2(pixelUnprojectionMatrix, [x2, y22, -1, 1]);
      const coord1 = transformVector2(pixelUnprojectionMatrix, [x2, y22, 1, 1]);
      const lt2 = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;
      const lSqr = vec3_exports.sqrLen(vec3_exports.sub([], coord0, coord1));
      const l0Sqr = vec3_exports.sqrLen(coord0);
      const l1Sqr = vec3_exports.sqrLen(coord1);
      const sSqr = (4 * l0Sqr * l1Sqr - (lSqr - l0Sqr - l1Sqr) ** 2) / 16;
      const dSqr = 4 * sSqr / lSqr;
      const r0 = Math.sqrt(l0Sqr - dSqr);
      const dr = Math.sqrt(Math.max(0, lt2 * lt2 - dSqr));
      const t2 = (r0 - dr) / Math.sqrt(lSqr);
      coord = vec3_exports.lerp([], coord0, coord1, t2);
    }
    const [X2, Y2, Z2] = this.unprojectPosition(coord);
    if (Number.isFinite(z2)) {
      return [X2, Y2, Z2];
    }
    return Number.isFinite(targetZ) ? [X2, Y2, targetZ] : [X2, Y2];
  }
  projectPosition(xyz) {
    const [lng, lat, Z2 = 0] = xyz;
    const lambda = lng * DEGREES_TO_RADIANS5;
    const phi = lat * DEGREES_TO_RADIANS5;
    const cosPhi = Math.cos(phi);
    const D2 = (Z2 / EARTH_RADIUS + 1) * GLOBE_RADIUS;
    return [Math.sin(lambda) * cosPhi * D2, -Math.cos(lambda) * cosPhi * D2, Math.sin(phi) * D2];
  }
  unprojectPosition(xyz) {
    const [x2, y2, z2] = xyz;
    const D2 = vec3_exports.len(xyz);
    const phi = Math.asin(z2 / D2);
    const lambda = Math.atan2(x2, -y2);
    const lng = lambda * RADIANS_TO_DEGREES3;
    const lat = phi * RADIANS_TO_DEGREES3;
    const Z2 = (D2 / GLOBE_RADIUS - 1) * EARTH_RADIUS;
    return [lng, lat, Z2];
  }
  projectFlat(xyz) {
    return xyz;
  }
  unprojectFlat(xyz) {
    return xyz;
  }
  /**
   * Pan the globe using delta-based movement
   * @param coords - the geographic coordinates where the pan started
   * @param pixel - the current screen position
   * @param startPixel - the screen position where the pan started
   * @returns updated viewport options with new longitude/latitude
   */
  panByPosition([startLng, startLat, startZoom], pixel, startPixel) {
    const scale7 = Math.pow(2, this.zoom - zoomAdjust(this.latitude));
    const rotationSpeed = 0.25 / scale7;
    const longitude = startLng + rotationSpeed * (startPixel[0] - pixel[0]);
    let latitude = startLat - rotationSpeed * (startPixel[1] - pixel[1]);
    latitude = Math.max(Math.min(latitude, MAX_LATITUDE), -MAX_LATITUDE);
    const out = { longitude, latitude, zoom: startZoom - zoomAdjust(startLat) };
    out.zoom += zoomAdjust(out.latitude);
    return out;
  }
};
GlobeViewport.displayName = "GlobeViewport";
var globe_viewport_default = GlobeViewport;
function zoomAdjust(latitude) {
  const scaleAdjust = Math.PI * Math.cos(latitude * Math.PI / 180);
  return Math.log2(scaleAdjust);
}
function transformVector2(matrix, vector) {
  const result = vec4_exports.transformMat4([], vector, matrix);
  vec4_exports.scale(result, result, 1 / result[3]);
  return result;
}

// node_modules/@deck.gl/core/dist/transitions/linear-interpolator.js
var DEFAULT_PROPS2 = ["longitude", "latitude", "zoom", "bearing", "pitch"];
var DEFAULT_REQUIRED_PROPS = ["longitude", "latitude", "zoom"];
var LinearInterpolator = class extends TransitionInterpolator {
  /**
   * @param {Object} opts
   * @param {Array} opts.transitionProps - list of props to apply linear transition to.
   * @param {Array} opts.around - a screen point to zoom/rotate around.
   * @param {Function} opts.makeViewport - construct a viewport instance with given props.
   */
  constructor(opts = {}) {
    const transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;
    const normalizedOpts = Array.isArray(opts) ? {} : opts;
    normalizedOpts.transitionProps = Array.isArray(transitionProps) ? {
      compare: transitionProps,
      required: transitionProps
    } : transitionProps || {
      compare: DEFAULT_PROPS2,
      required: DEFAULT_REQUIRED_PROPS
    };
    super(normalizedOpts.transitionProps);
    this.opts = normalizedOpts;
  }
  initializeProps(startProps, endProps) {
    const result = super.initializeProps(startProps, endProps);
    const { makeViewport, around } = this.opts;
    if (makeViewport && around) {
      const TestViewport = makeViewport(startProps);
      if (TestViewport instanceof globe_viewport_default) {
        log_default.warn("around not supported in GlobeView")();
      } else {
        const startViewport = makeViewport(startProps);
        const endViewport = makeViewport(endProps);
        const aroundPosition = startViewport.unproject(around);
        result.start.around = around;
        Object.assign(result.end, {
          around: endViewport.project(aroundPosition),
          aroundPosition,
          width: endProps.width,
          height: endProps.height
        });
      }
    }
    return result;
  }
  interpolateProps(startProps, endProps, t2) {
    const propsInTransition = {};
    for (const key of this._propsToExtract) {
      propsInTransition[key] = lerp(startProps[key] || 0, endProps[key] || 0, t2);
    }
    if (endProps.aroundPosition && this.opts.makeViewport) {
      const viewport = this.opts.makeViewport({ ...endProps, ...propsInTransition });
      Object.assign(propsInTransition, viewport.panByPosition(
        endProps.aroundPosition,
        // anchor point in current screen coordinates
        lerp(startProps.around, endProps.around, t2)
      ));
    }
    return propsInTransition;
  }
};

// node_modules/@deck.gl/core/dist/controllers/controller.js
var NO_TRANSITION_PROPS = {
  transitionDuration: 0
};
var DEFAULT_INERTIA = 300;
var INERTIA_EASING = (t2) => 1 - (1 - t2) * (1 - t2);
var EVENT_TYPES = {
  WHEEL: ["wheel"],
  PAN: ["panstart", "panmove", "panend"],
  PINCH: ["pinchstart", "pinchmove", "pinchend"],
  MULTI_PAN: ["multipanstart", "multipanmove", "multipanend"],
  DOUBLE_CLICK: ["dblclick"],
  KEYBOARD: ["keydown"]
};
var pinchEventWorkaround = {};
var Controller = class {
  constructor(opts) {
    this.state = {};
    this._events = {};
    this._interactionState = {
      isDragging: false
    };
    this._customEvents = [];
    this._eventStartBlocked = null;
    this._panMove = false;
    this.invertPan = false;
    this.dragMode = "rotate";
    this.inertia = 0;
    this.scrollZoom = true;
    this.dragPan = true;
    this.dragRotate = true;
    this.doubleClickZoom = true;
    this.touchZoom = true;
    this.touchRotate = false;
    this.keyboard = true;
    this.transitionManager = new TransitionManager({
      ...opts,
      getControllerState: (props) => new this.ControllerState(props),
      onViewStateChange: this._onTransition.bind(this),
      onStateChange: this._setInteractionState.bind(this)
    });
    this.handleEvent = this.handleEvent.bind(this);
    this.eventManager = opts.eventManager;
    this.onViewStateChange = opts.onViewStateChange || (() => {
    });
    this.onStateChange = opts.onStateChange || (() => {
    });
    this.makeViewport = opts.makeViewport;
  }
  set events(customEvents) {
    this.toggleEvents(this._customEvents, false);
    this.toggleEvents(customEvents, true);
    this._customEvents = customEvents;
    if (this.props) {
      this.setProps(this.props);
    }
  }
  finalize() {
    var _a3;
    for (const eventName in this._events) {
      if (this._events[eventName]) {
        (_a3 = this.eventManager) == null ? void 0 : _a3.off(eventName, this.handleEvent);
      }
    }
    this.transitionManager.finalize();
  }
  /**
   * Callback for events
   */
  handleEvent(event) {
    this._controllerState = void 0;
    const eventStartBlocked = this._eventStartBlocked;
    switch (event.type) {
      case "panstart":
        return eventStartBlocked ? false : this._onPanStart(event);
      case "panmove":
        return this._onPan(event);
      case "panend":
        return this._onPanEnd(event);
      case "pinchstart":
        return eventStartBlocked ? false : this._onPinchStart(event);
      case "pinchmove":
        return this._onPinch(event);
      case "pinchend":
        return this._onPinchEnd(event);
      case "multipanstart":
        return eventStartBlocked ? false : this._onMultiPanStart(event);
      case "multipanmove":
        return this._onMultiPan(event);
      case "multipanend":
        return this._onMultiPanEnd(event);
      case "dblclick":
        return this._onDoubleClick(event);
      case "wheel":
        return this._onWheel(event);
      case "keydown":
        return this._onKeyDown(event);
      default:
        return false;
    }
  }
  /* Event utils */
  // Event object: http://hammerjs.github.io/api/#event-object
  get controllerState() {
    this._controllerState = this._controllerState || new this.ControllerState({
      makeViewport: this.makeViewport,
      ...this.props,
      ...this.state
    });
    return this._controllerState;
  }
  getCenter(event) {
    const { x: x2, y: y2 } = this.props;
    const { offsetCenter } = event;
    return [offsetCenter.x - x2, offsetCenter.y - y2];
  }
  isPointInBounds(pos, event) {
    const { width, height } = this.props;
    if (event && event.handled) {
      return false;
    }
    const inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;
    if (inside && event) {
      event.stopPropagation();
    }
    return inside;
  }
  isFunctionKeyPressed(event) {
    const { srcEvent } = event;
    return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
  }
  isDragging() {
    return this._interactionState.isDragging || false;
  }
  // When a multi-touch event ends, e.g. pinch, not all pointers are lifted at the same time.
  // This triggers a brief `pan` event.
  // Calling this method will temporarily disable *start events to avoid conflicting transitions.
  blockEvents(timeout) {
    const timer = setTimeout(() => {
      if (this._eventStartBlocked === timer) {
        this._eventStartBlocked = null;
      }
    }, timeout);
    this._eventStartBlocked = timer;
  }
  /**
   * Extract interactivity options
   */
  setProps(props) {
    if (props.dragMode) {
      this.dragMode = props.dragMode;
    }
    this.props = props;
    if (!("transitionInterpolator" in props)) {
      props.transitionInterpolator = this._getTransitionProps().transitionInterpolator;
    }
    this.transitionManager.processViewStateChange(props);
    const { inertia } = props;
    this.inertia = Number.isFinite(inertia) ? inertia : inertia === true ? DEFAULT_INERTIA : 0;
    const { scrollZoom = true, dragPan = true, dragRotate = true, doubleClickZoom = true, touchZoom = true, touchRotate = false, keyboard = true } = props;
    const isInteractive = Boolean(this.onViewStateChange);
    this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
    this.toggleEvents(EVENT_TYPES.PAN, isInteractive);
    this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
    this.toggleEvents(EVENT_TYPES.MULTI_PAN, isInteractive && touchRotate);
    this.toggleEvents(EVENT_TYPES.DOUBLE_CLICK, isInteractive && doubleClickZoom);
    this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);
    this.scrollZoom = scrollZoom;
    this.dragPan = dragPan;
    this.dragRotate = dragRotate;
    this.doubleClickZoom = doubleClickZoom;
    this.touchZoom = touchZoom;
    this.touchRotate = touchRotate;
    this.keyboard = keyboard;
  }
  updateTransition() {
    this.transitionManager.updateTransition();
  }
  toggleEvents(eventNames, enabled) {
    if (this.eventManager) {
      eventNames.forEach((eventName) => {
        if (this._events[eventName] !== enabled) {
          this._events[eventName] = enabled;
          if (enabled) {
            this.eventManager.on(eventName, this.handleEvent);
          } else {
            this.eventManager.off(eventName, this.handleEvent);
          }
        }
      });
    }
  }
  // Private Methods
  /* Callback util */
  // formats map state and invokes callback function
  updateViewport(newControllerState, extraProps = null, interactionState = {}) {
    const viewState = { ...newControllerState.getViewportProps(), ...extraProps };
    const changed = this.controllerState !== newControllerState;
    this.state = newControllerState.getState();
    this._setInteractionState(interactionState);
    if (changed) {
      const oldViewState = this.controllerState && this.controllerState.getViewportProps();
      if (this.onViewStateChange) {
        this.onViewStateChange({ viewState, interactionState: this._interactionState, oldViewState, viewId: this.props.id });
      }
    }
  }
  _onTransition(params) {
    this.onViewStateChange({ ...params, interactionState: this._interactionState, viewId: this.props.id });
  }
  _setInteractionState(newStates) {
    Object.assign(this._interactionState, newStates);
    this.onStateChange(this._interactionState);
  }
  /* Event handlers */
  // Default handler for the `panstart` event.
  _onPanStart(event) {
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    let alternateMode = this.isFunctionKeyPressed(event) || event.rightButton || false;
    if (this.invertPan || this.dragMode === "pan") {
      alternateMode = !alternateMode;
    }
    const newControllerState = this.controllerState[alternateMode ? "panStart" : "rotateStart"]({
      pos
    });
    this._panMove = alternateMode;
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, { isDragging: true });
    return true;
  }
  // Default handler for the `panmove` and `panend` event.
  _onPan(event) {
    if (!this.isDragging()) {
      return false;
    }
    return this._panMove ? this._onPanMove(event) : this._onPanRotate(event);
  }
  _onPanEnd(event) {
    if (!this.isDragging()) {
      return false;
    }
    return this._panMove ? this._onPanMoveEnd(event) : this._onPanRotateEnd(event);
  }
  // Default handler for panning to move.
  // Called by `_onPan` when panning without function key pressed.
  _onPanMove(event) {
    if (!this.dragPan) {
      return false;
    }
    const pos = this.getCenter(event);
    const newControllerState = this.controllerState.pan({ pos });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isPanning: true
    });
    return true;
  }
  _onPanMoveEnd(event) {
    const { inertia } = this;
    if (this.dragPan && inertia && event.velocity) {
      const pos = this.getCenter(event);
      const endPos = [
        pos[0] + event.velocityX * inertia / 2,
        pos[1] + event.velocityY * inertia / 2
      ];
      const newControllerState = this.controllerState.pan({ pos: endPos }).panEnd();
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isPanning: true
      });
    } else {
      const newControllerState = this.controllerState.panEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isPanning: false
      });
    }
    return true;
  }
  // Default handler for panning to rotate.
  // Called by `_onPan` when panning with function key pressed.
  _onPanRotate(event) {
    if (!this.dragRotate) {
      return false;
    }
    const pos = this.getCenter(event);
    const newControllerState = this.controllerState.rotate({ pos });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isRotating: true
    });
    return true;
  }
  _onPanRotateEnd(event) {
    const { inertia } = this;
    if (this.dragRotate && inertia && event.velocity) {
      const pos = this.getCenter(event);
      const endPos = [
        pos[0] + event.velocityX * inertia / 2,
        pos[1] + event.velocityY * inertia / 2
      ];
      const newControllerState = this.controllerState.rotate({ pos: endPos }).rotateEnd();
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isRotating: true
      });
    } else {
      const newControllerState = this.controllerState.rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isRotating: false
      });
    }
    return true;
  }
  // Default handler for the `wheel` event.
  _onWheel(event) {
    if (!this.scrollZoom) {
      return false;
    }
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    event.srcEvent.preventDefault();
    const { speed = 0.01, smooth = false } = this.scrollZoom === true ? {} : this.scrollZoom;
    const { delta } = event;
    let scale7 = 2 / (1 + Math.exp(-Math.abs(delta * speed)));
    if (delta < 0 && scale7 !== 0) {
      scale7 = 1 / scale7;
    }
    const transitionProps = smooth ? { ...this._getTransitionProps({ around: pos }), transitionDuration: 250 } : NO_TRANSITION_PROPS;
    const newControllerState = this.controllerState.zoom({ pos, scale: scale7 });
    this.updateViewport(newControllerState, transitionProps, {
      isZooming: true,
      isPanning: true
    });
    if (!smooth) {
      this._setInteractionState({ isZooming: false, isPanning: false });
    }
    return true;
  }
  _onMultiPanStart(event) {
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    const newControllerState = this.controllerState.rotateStart({ pos });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, { isDragging: true });
    return true;
  }
  _onMultiPan(event) {
    if (!this.touchRotate) {
      return false;
    }
    if (!this.isDragging()) {
      return false;
    }
    const pos = this.getCenter(event);
    pos[0] -= event.deltaX;
    const newControllerState = this.controllerState.rotate({ pos });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isRotating: true
    });
    return true;
  }
  _onMultiPanEnd(event) {
    if (!this.isDragging()) {
      return false;
    }
    const { inertia } = this;
    if (this.touchRotate && inertia && event.velocityY) {
      const pos = this.getCenter(event);
      const endPos = [pos[0], pos[1] += event.velocityY * inertia / 2];
      const newControllerState = this.controllerState.rotate({ pos: endPos });
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isRotating: true
      });
      this.blockEvents(inertia);
    } else {
      const newControllerState = this.controllerState.rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isRotating: false
      });
    }
    return true;
  }
  // Default handler for the `pinchstart` event.
  _onPinchStart(event) {
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    const newControllerState = this.controllerState.zoomStart({ pos }).rotateStart({ pos });
    pinchEventWorkaround._startPinchRotation = event.rotation;
    pinchEventWorkaround._lastPinchEvent = event;
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, { isDragging: true });
    return true;
  }
  // Default handler for the `pinchmove` and `pinchend` events.
  _onPinch(event) {
    if (!this.touchZoom && !this.touchRotate) {
      return false;
    }
    if (!this.isDragging()) {
      return false;
    }
    let newControllerState = this.controllerState;
    if (this.touchZoom) {
      const { scale: scale7 } = event;
      const pos = this.getCenter(event);
      newControllerState = newControllerState.zoom({ pos, scale: scale7 });
    }
    if (this.touchRotate) {
      const { rotation } = event;
      newControllerState = newControllerState.rotate({
        deltaAngleX: pinchEventWorkaround._startPinchRotation - rotation
      });
    }
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isPanning: this.touchZoom,
      isZooming: this.touchZoom,
      isRotating: this.touchRotate
    });
    pinchEventWorkaround._lastPinchEvent = event;
    return true;
  }
  _onPinchEnd(event) {
    if (!this.isDragging()) {
      return false;
    }
    const { inertia } = this;
    const { _lastPinchEvent } = pinchEventWorkaround;
    if (this.touchZoom && inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {
      const pos = this.getCenter(event);
      let newControllerState = this.controllerState.rotateEnd();
      const z2 = Math.log2(event.scale);
      const velocityZ = (z2 - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);
      const endScale = Math.pow(2, z2 + velocityZ * inertia / 2);
      newControllerState = newControllerState.zoom({ pos, scale: endScale }).zoomEnd();
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps({ around: pos }),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: false
      });
      this.blockEvents(inertia);
    } else {
      const newControllerState = this.controllerState.zoomEnd().rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isPanning: false,
        isZooming: false,
        isRotating: false
      });
    }
    pinchEventWorkaround._startPinchRotation = null;
    pinchEventWorkaround._lastPinchEvent = null;
    return true;
  }
  // Default handler for the `dblclick` event.
  _onDoubleClick(event) {
    if (!this.doubleClickZoom) {
      return false;
    }
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    const isZoomOut = this.isFunctionKeyPressed(event);
    const newControllerState = this.controllerState.zoom({ pos, scale: isZoomOut ? 0.5 : 2 });
    this.updateViewport(newControllerState, this._getTransitionProps({ around: pos }), {
      isZooming: true,
      isPanning: true
    });
    this.blockEvents(100);
    return true;
  }
  // Default handler for the `keydown` event
  _onKeyDown(event) {
    if (!this.keyboard) {
      return false;
    }
    const funcKey = this.isFunctionKeyPressed(event);
    const { zoomSpeed, moveSpeed, rotateSpeedX, rotateSpeedY } = this.keyboard === true ? {} : this.keyboard;
    const { controllerState } = this;
    let newControllerState;
    const interactionState = {};
    switch (event.srcEvent.code) {
      case "Minus":
        newControllerState = funcKey ? controllerState.zoomOut(zoomSpeed).zoomOut(zoomSpeed) : controllerState.zoomOut(zoomSpeed);
        interactionState.isZooming = true;
        break;
      case "Equal":
        newControllerState = funcKey ? controllerState.zoomIn(zoomSpeed).zoomIn(zoomSpeed) : controllerState.zoomIn(zoomSpeed);
        interactionState.isZooming = true;
        break;
      case "ArrowLeft":
        if (funcKey) {
          newControllerState = controllerState.rotateLeft(rotateSpeedX);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveLeft(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      case "ArrowRight":
        if (funcKey) {
          newControllerState = controllerState.rotateRight(rotateSpeedX);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveRight(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      case "ArrowUp":
        if (funcKey) {
          newControllerState = controllerState.rotateUp(rotateSpeedY);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveUp(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      case "ArrowDown":
        if (funcKey) {
          newControllerState = controllerState.rotateDown(rotateSpeedY);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveDown(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      default:
        return false;
    }
    this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);
    return true;
  }
  _getTransitionProps(opts) {
    const { transition } = this;
    if (!transition || !transition.transitionInterpolator) {
      return NO_TRANSITION_PROPS;
    }
    return opts ? {
      ...transition,
      transitionInterpolator: new LinearInterpolator({
        ...opts,
        ...transition.transitionInterpolator.opts,
        makeViewport: this.controllerState.makeViewport
      })
    } : transition;
  }
};

// node_modules/@deck.gl/core/dist/controllers/view-state.js
var ViewState = class {
  constructor(props, state) {
    this._viewportProps = this.applyConstraints(props);
    this._state = state;
  }
  getViewportProps() {
    return this._viewportProps;
  }
  getState() {
    return this._state;
  }
};

// node_modules/@deck.gl/core/dist/controllers/map-controller.js
var PITCH_MOUSE_THRESHOLD = 5;
var PITCH_ACCEL = 1.2;
var MapState = class extends ViewState {
  constructor(options) {
    const {
      /** Mapbox viewport properties */
      /** The width of the viewport */
      width,
      /** The height of the viewport */
      height,
      /** The latitude at the center of the viewport */
      latitude,
      /** The longitude at the center of the viewport */
      longitude,
      /** The tile zoom level of the map. */
      zoom,
      /** The bearing of the viewport in degrees */
      bearing = 0,
      /** The pitch of the viewport in degrees */
      pitch = 0,
      /**
       * Specify the altitude of the viewport camera
       * Unit: map heights, default 1.5
       * Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137
       */
      altitude = 1.5,
      /** Viewport position */
      position = [0, 0, 0],
      /** Viewport constraints */
      maxZoom = 20,
      minZoom = 0,
      maxPitch = 60,
      minPitch = 0,
      /** Interaction states, required to calculate change during transform */
      /* The point on map being grabbed when the operation first started */
      startPanLngLat,
      /* Center of the zoom when the operation first started */
      startZoomLngLat,
      /* Pointer position when rotation started */
      startRotatePos,
      /** Bearing when current perspective rotate operation started */
      startBearing,
      /** Pitch when current perspective rotate operation started */
      startPitch,
      /** Zoom when current zoom operation started */
      startZoom,
      /** Normalize viewport props to fit map height into viewport */
      normalize: normalize5 = true
    } = options;
    assert6(Number.isFinite(longitude));
    assert6(Number.isFinite(latitude));
    assert6(Number.isFinite(zoom));
    super({
      width,
      height,
      latitude,
      longitude,
      zoom,
      bearing,
      pitch,
      altitude,
      maxZoom,
      minZoom,
      maxPitch,
      minPitch,
      normalize: normalize5,
      position
    }, {
      startPanLngLat,
      startZoomLngLat,
      startRotatePos,
      startBearing,
      startPitch,
      startZoom
    });
    this.makeViewport = options.makeViewport;
  }
  /**
   * Start panning
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  panStart({ pos }) {
    return this._getUpdatedState({
      startPanLngLat: this._unproject(pos)
    });
  }
  /**
   * Pan
   * @param {[Number, Number]} pos - position on screen where the pointer is
   * @param {[Number, Number], optional} startPos - where the pointer grabbed at
   *   the start of the operation. Must be supplied of `panStart()` was not called
   */
  pan({ pos, startPos }) {
    const startPanLngLat = this.getState().startPanLngLat || this._unproject(startPos);
    if (!startPanLngLat) {
      return this;
    }
    const viewport = this.makeViewport(this.getViewportProps());
    const newProps = viewport.panByPosition(startPanLngLat, pos);
    return this._getUpdatedState(newProps);
  }
  /**
   * End panning
   * Must call if `panStart()` was called
   */
  panEnd() {
    return this._getUpdatedState({
      startPanLngLat: null
    });
  }
  /**
   * Start rotating
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotateStart({ pos }) {
    return this._getUpdatedState({
      startRotatePos: pos,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }
  /**
   * Rotate
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotate({ pos, deltaAngleX = 0, deltaAngleY = 0 }) {
    const { startRotatePos, startBearing, startPitch } = this.getState();
    if (!startRotatePos || startBearing === void 0 || startPitch === void 0) {
      return this;
    }
    let newRotation;
    if (pos) {
      newRotation = this._getNewRotation(pos, startRotatePos, startPitch, startBearing);
    } else {
      newRotation = {
        bearing: startBearing + deltaAngleX,
        pitch: startPitch + deltaAngleY
      };
    }
    return this._getUpdatedState(newRotation);
  }
  /**
   * End rotating
   * Must call if `rotateStart()` was called
   */
  rotateEnd() {
    return this._getUpdatedState({
      startBearing: null,
      startPitch: null
    });
  }
  /**
   * Start zooming
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  zoomStart({ pos }) {
    return this._getUpdatedState({
      startZoomLngLat: this._unproject(pos),
      startZoom: this.getViewportProps().zoom
    });
  }
  /**
   * Zoom
   * @param {[Number, Number]} pos - position on screen where the current center is
   * @param {[Number, Number]} startPos - the center position at
   *   the start of the operation. Must be supplied of `zoomStart()` was not called
   * @param {Number} scale - a number between [0, 1] specifying the accumulated
   *   relative scale.
   */
  zoom({ pos, startPos, scale: scale7 }) {
    let { startZoom, startZoomLngLat } = this.getState();
    if (!startZoomLngLat) {
      startZoom = this.getViewportProps().zoom;
      startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
    }
    if (!startZoomLngLat) {
      return this;
    }
    const { maxZoom, minZoom } = this.getViewportProps();
    let zoom = startZoom + Math.log2(scale7);
    zoom = clamp(zoom, minZoom, maxZoom);
    const zoomedViewport = this.makeViewport({ ...this.getViewportProps(), zoom });
    return this._getUpdatedState({
      zoom,
      ...zoomedViewport.panByPosition(startZoomLngLat, pos)
    });
  }
  /**
   * End zooming
   * Must call if `zoomStart()` was called
   */
  zoomEnd() {
    return this._getUpdatedState({
      startZoomLngLat: null,
      startZoom: null
    });
  }
  zoomIn(speed = 2) {
    return this._zoomFromCenter(speed);
  }
  zoomOut(speed = 2) {
    return this._zoomFromCenter(1 / speed);
  }
  moveLeft(speed = 100) {
    return this._panFromCenter([speed, 0]);
  }
  moveRight(speed = 100) {
    return this._panFromCenter([-speed, 0]);
  }
  moveUp(speed = 100) {
    return this._panFromCenter([0, speed]);
  }
  moveDown(speed = 100) {
    return this._panFromCenter([0, -speed]);
  }
  rotateLeft(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - speed
    });
  }
  rotateRight(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + speed
    });
  }
  rotateUp(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + speed
    });
  }
  rotateDown(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - speed
    });
  }
  shortestPathFrom(viewState) {
    const fromProps = viewState.getViewportProps();
    const props = { ...this.getViewportProps() };
    const { bearing, longitude } = props;
    if (Math.abs(bearing - fromProps.bearing) > 180) {
      props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
    }
    if (Math.abs(longitude - fromProps.longitude) > 180) {
      props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
    }
    return props;
  }
  // Apply any constraints (mathematical or defined by _viewportProps) to map state
  applyConstraints(props) {
    const { maxZoom, minZoom, zoom } = props;
    props.zoom = clamp(zoom, minZoom, maxZoom);
    const { maxPitch, minPitch, pitch } = props;
    props.pitch = clamp(pitch, minPitch, maxPitch);
    const { normalize: normalize5 = true } = props;
    if (normalize5) {
      Object.assign(props, normalizeViewportProps(props));
    }
    return props;
  }
  /* Private methods */
  _zoomFromCenter(scale7) {
    const { width, height } = this.getViewportProps();
    return this.zoom({
      pos: [width / 2, height / 2],
      scale: scale7
    });
  }
  _panFromCenter(offset) {
    const { width, height } = this.getViewportProps();
    return this.pan({
      startPos: [width / 2, height / 2],
      pos: [width / 2 + offset[0], height / 2 + offset[1]]
    });
  }
  _getUpdatedState(newProps) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...newProps
    });
  }
  _unproject(pos) {
    const viewport = this.makeViewport(this.getViewportProps());
    return pos && viewport.unproject(pos);
  }
  _getNewRotation(pos, startPos, startPitch, startBearing) {
    const deltaX = pos[0] - startPos[0];
    const deltaY = pos[1] - startPos[1];
    const centerY = pos[1];
    const startY = startPos[1];
    const { width, height } = this.getViewportProps();
    const deltaScaleX = deltaX / width;
    let deltaScaleY = 0;
    if (deltaY > 0) {
      if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
        deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
      }
    } else if (deltaY < 0) {
      if (startY > PITCH_MOUSE_THRESHOLD) {
        deltaScaleY = 1 - centerY / startY;
      }
    }
    deltaScaleY = clamp(deltaScaleY, -1, 1);
    const { minPitch, maxPitch } = this.getViewportProps();
    const bearing = startBearing + 180 * deltaScaleX;
    let pitch = startPitch;
    if (deltaScaleY > 0) {
      pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
    } else if (deltaScaleY < 0) {
      pitch = startPitch - deltaScaleY * (minPitch - startPitch);
    }
    return {
      pitch,
      bearing
    };
  }
};
var MapController = class extends Controller {
  constructor() {
    super(...arguments);
    this.ControllerState = MapState;
    this.transition = {
      transitionDuration: 300,
      transitionInterpolator: new LinearInterpolator({
        transitionProps: {
          compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
          required: ["longitude", "latitude", "zoom"]
        }
      })
    };
    this.dragMode = "pan";
  }
  setProps(props) {
    props.position = props.position || [0, 0, 0];
    const oldProps = this.props;
    super.setProps(props);
    const dimensionChanged = !oldProps || oldProps.height !== props.height;
    if (dimensionChanged) {
      this.updateViewport(new this.ControllerState({
        makeViewport: this.makeViewport,
        ...props,
        ...this.state
      }));
    }
  }
};

// node_modules/@deck.gl/core/dist/views/map-view.js
var MapView = class extends View {
  constructor(props = {}) {
    super(props);
  }
  getViewportType() {
    return web_mercator_viewport_default;
  }
  get ControllerType() {
    return MapController;
  }
};
MapView.displayName = "MapView";
var map_view_default = MapView;

// node_modules/@deck.gl/core/dist/effects/lighting/ambient-light.js
var DEFAULT_LIGHT_COLOR = [255, 255, 255];
var DEFAULT_LIGHT_INTENSITY = 1;
var idCount = 0;
var AmbientLight = class {
  constructor(props = {}) {
    this.type = "ambient";
    const { color = DEFAULT_LIGHT_COLOR } = props;
    const { intensity = DEFAULT_LIGHT_INTENSITY } = props;
    this.id = props.id || `ambient-${idCount++}`;
    this.color = color;
    this.intensity = intensity;
  }
};

// node_modules/@deck.gl/core/dist/effects/lighting/directional-light.js
var DEFAULT_LIGHT_COLOR2 = [255, 255, 255];
var DEFAULT_LIGHT_INTENSITY2 = 1;
var DEFAULT_LIGHT_DIRECTION = [0, 0, -1];
var idCount2 = 0;
var DirectionalLight = class {
  constructor(props = {}) {
    this.type = "directional";
    const { color = DEFAULT_LIGHT_COLOR2 } = props;
    const { intensity = DEFAULT_LIGHT_INTENSITY2 } = props;
    const { direction = DEFAULT_LIGHT_DIRECTION } = props;
    const { _shadow = false } = props;
    this.id = props.id || `directional-${idCount2++}`;
    this.color = color;
    this.intensity = intensity;
    this.type = "directional";
    this.direction = new Vector3(direction).normalize().toArray();
    this.shadow = _shadow;
  }
  getProjectedLight(opts) {
    return this;
  }
};

// node_modules/@deck.gl/core/dist/passes/pass.js
var Pass = class {
  /** Create a new Pass instance */
  constructor(device, props = { id: "pass" }) {
    const { id } = props;
    this.id = id;
    this.device = device;
    this.props = { ...props };
  }
  setProps(props) {
    Object.assign(this.props, props);
  }
  render(params) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  cleanup() {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
};

// node_modules/@deck.gl/core/dist/passes/layers-pass.js
var LayersPass = class extends Pass {
  constructor() {
    super(...arguments);
    this._lastRenderIndex = -1;
  }
  render(options) {
    const [width, height] = this.device.canvasContext.getDrawingBufferSize();
    const clearCanvas = options.clearCanvas ?? true;
    const clearColor = options.clearColor ?? (clearCanvas ? [0, 0, 0, 0] : false);
    const clearDepth = clearCanvas ? 1 : false;
    const clearStencil = clearCanvas ? 0 : false;
    const colorMask = options.colorMask ?? 15;
    const parameters = { viewport: [0, 0, width, height] };
    if (options.colorMask) {
      parameters.colorMask = colorMask;
    }
    if (options.scissorRect) {
      parameters.scissorRect = options.scissorRect;
    }
    const renderPass = this.device.beginRenderPass({
      framebuffer: options.target,
      parameters,
      clearColor,
      clearDepth,
      clearStencil
    });
    try {
      return this._drawLayers(renderPass, options);
    } finally {
      renderPass.end();
      this.device.submit();
    }
  }
  /** Draw a list of layers in a list of viewports */
  _drawLayers(renderPass, options) {
    const { target, shaderModuleProps, viewports, views, onViewportActive, clearStack = true } = options;
    options.pass = options.pass || "unknown";
    if (clearStack) {
      this._lastRenderIndex = -1;
    }
    const renderStats = [];
    for (const viewport of viewports) {
      const view = views && views[viewport.id];
      onViewportActive == null ? void 0 : onViewportActive(viewport);
      const drawLayerParams = this._getDrawLayerParams(viewport, options);
      const subViewports = viewport.subViewports || [viewport];
      for (const subViewport of subViewports) {
        const stats = this._drawLayersInViewport(renderPass, {
          target,
          shaderModuleProps,
          viewport: subViewport,
          view,
          pass: options.pass,
          layers: options.layers
        }, drawLayerParams);
        renderStats.push(stats);
      }
    }
    return renderStats;
  }
  // When a viewport contains multiple subviewports (e.g. repeated web mercator map),
  // this is only done once for the parent viewport
  /* Resolve the parameters needed to draw each layer */
  _getDrawLayerParams(viewport, { layers, pass, isPicking = false, layerFilter, cullRect, effects, shaderModuleProps }, evaluateShouldDrawOnly = false) {
    var _a3;
    const drawLayerParams = [];
    const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);
    const drawContext = {
      layer: layers[0],
      viewport,
      isPicking,
      renderPass: pass,
      cullRect
    };
    const layerFilterCache = {};
    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
      const layer = layers[layerIndex];
      const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);
      const layerParam = { shouldDrawLayer };
      if (shouldDrawLayer && !evaluateShouldDrawOnly) {
        layerParam.shouldDrawLayer = true;
        layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);
        layerParam.shaderModuleProps = this._getShaderModuleProps(layer, effects, pass, shaderModuleProps);
        layerParam.layerParameters = {
          ...(_a3 = layer.context.deck) == null ? void 0 : _a3.props.parameters,
          ...this.getLayerParameters(layer, layerIndex, viewport)
        };
      }
      drawLayerParams[layerIndex] = layerParam;
    }
    return drawLayerParams;
  }
  // Draws a list of layers in one viewport
  // TODO - when picking we could completely skip rendering viewports that dont
  // intersect with the picking rect
  /* eslint-disable max-depth, max-statements, complexity */
  _drawLayersInViewport(renderPass, { layers, shaderModuleProps: globalModuleParameters, pass, target, viewport, view }, drawLayerParams) {
    const glViewport = getGLViewport(this.device, {
      shaderModuleProps: globalModuleParameters,
      target,
      viewport
    });
    if (view) {
      const { clear, clearColor, clearDepth, clearStencil } = view.props;
      if (clear) {
        let colorToUse = [0, 0, 0, 0];
        let depthToUse = 1;
        let stencilToUse = 0;
        if (Array.isArray(clearColor)) {
          colorToUse = [...clearColor.slice(0, 3), clearColor[3] || 255].map((c2) => c2 / 255);
        } else if (clearColor === false) {
          colorToUse = false;
        }
        if (clearDepth !== void 0) {
          depthToUse = clearDepth;
        }
        if (clearStencil !== void 0) {
          stencilToUse = clearStencil;
        }
        const clearRenderPass = this.device.beginRenderPass({
          framebuffer: target,
          parameters: {
            viewport: glViewport,
            scissorRect: glViewport
          },
          clearColor: colorToUse,
          clearDepth: depthToUse,
          clearStencil: stencilToUse
        });
        clearRenderPass.end();
      }
    }
    const renderStatus = {
      totalCount: layers.length,
      visibleCount: 0,
      compositeCount: 0,
      pickableCount: 0
    };
    renderPass.setParameters({ viewport: glViewport });
    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
      const layer = layers[layerIndex];
      const drawLayerParameters = drawLayerParams[layerIndex];
      const { shouldDrawLayer } = drawLayerParameters;
      if (shouldDrawLayer && layer.props.pickable) {
        renderStatus.pickableCount++;
      }
      if (layer.isComposite) {
        renderStatus.compositeCount++;
      }
      if (layer.isDrawable && drawLayerParameters.shouldDrawLayer) {
        const { layerRenderIndex, shaderModuleProps, layerParameters } = drawLayerParameters;
        renderStatus.visibleCount++;
        this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);
        if (shaderModuleProps.project) {
          shaderModuleProps.project.viewport = viewport;
        }
        layer.context.renderPass = renderPass;
        try {
          layer._drawLayer({
            renderPass,
            shaderModuleProps,
            uniforms: { layerIndex: layerRenderIndex },
            parameters: layerParameters
          });
        } catch (err) {
          layer.raiseError(err, `drawing ${layer} to ${pass}`);
        }
      }
    }
    return renderStatus;
  }
  /* eslint-enable max-depth, max-statements */
  /* Methods for subclass overrides */
  shouldDrawLayer(layer) {
    return true;
  }
  getShaderModuleProps(layer, effects, otherShaderModuleProps) {
    return null;
  }
  getLayerParameters(layer, layerIndex, viewport) {
    return layer.props.parameters;
  }
  /* Private */
  _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {
    const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);
    if (!shouldDrawLayer) {
      return false;
    }
    drawContext.layer = layer;
    let parent = layer.parent;
    while (parent) {
      if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {
        return false;
      }
      drawContext.layer = parent;
      parent = parent.parent;
    }
    if (layerFilter) {
      const rootLayerId = drawContext.layer.id;
      if (!(rootLayerId in layerFilterCache)) {
        layerFilterCache[rootLayerId] = layerFilter(drawContext);
      }
      if (!layerFilterCache[rootLayerId]) {
        return false;
      }
    }
    layer.activateViewport(drawContext.viewport);
    return true;
  }
  _getShaderModuleProps(layer, effects, pass, overrides) {
    var _a3, _b;
    const devicePixelRatio = this.device.canvasContext.cssToDeviceRatio();
    const layerProps = ((_a3 = layer.internalState) == null ? void 0 : _a3.propsInTransition) || layer.props;
    const shaderModuleProps = {
      layer: layerProps,
      picking: {
        isActive: false
      },
      project: {
        viewport: layer.context.viewport,
        devicePixelRatio,
        modelMatrix: layerProps.modelMatrix,
        coordinateSystem: layerProps.coordinateSystem,
        coordinateOrigin: layerProps.coordinateOrigin,
        autoWrapLongitude: layer.wrapLongitude
      }
    };
    if (effects) {
      for (const effect of effects) {
        mergeModuleParameters(shaderModuleProps, (_b = effect.getShaderModuleProps) == null ? void 0 : _b.call(effect, layer, shaderModuleProps));
      }
    }
    return mergeModuleParameters(shaderModuleProps, this.getShaderModuleProps(layer, effects, shaderModuleProps), overrides);
  }
};
function layerIndexResolver(startIndex = 0, layerIndices = {}) {
  const resolvers = {};
  const resolveLayerIndex = (layer, isDrawn) => {
    const indexOverride = layer.props._offset;
    const layerId = layer.id;
    const parentId = layer.parent && layer.parent.id;
    let index;
    if (parentId && !(parentId in layerIndices)) {
      resolveLayerIndex(layer.parent, false);
    }
    if (parentId in resolvers) {
      const resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);
      index = resolver(layer, isDrawn);
      resolvers[layerId] = resolver;
    } else if (Number.isFinite(indexOverride)) {
      index = indexOverride + (layerIndices[parentId] || 0);
      resolvers[layerId] = null;
    } else {
      index = startIndex;
    }
    if (isDrawn && index >= startIndex) {
      startIndex = index + 1;
    }
    layerIndices[layerId] = index;
    return index;
  };
  return resolveLayerIndex;
}
function getGLViewport(device, { shaderModuleProps, target, viewport }) {
  var _a3;
  const pixelRatio = ((_a3 = shaderModuleProps == null ? void 0 : shaderModuleProps.project) == null ? void 0 : _a3.devicePixelRatio) ?? // @ts-expect-error TODO - assuming WebGL context
  device.canvasContext.cssToDeviceRatio();
  const [, drawingBufferHeight] = device.canvasContext.getDrawingBufferSize();
  const height = target ? target.height : drawingBufferHeight;
  const dimensions = viewport;
  return [
    dimensions.x * pixelRatio,
    height - (dimensions.y + dimensions.height) * pixelRatio,
    dimensions.width * pixelRatio,
    dimensions.height * pixelRatio
  ];
}
function mergeModuleParameters(target, ...sources) {
  for (const source6 of sources) {
    if (source6) {
      for (const key in source6) {
        if (target[key]) {
          Object.assign(target[key], source6[key]);
        } else {
          target[key] = source6[key];
        }
      }
    }
  }
  return target;
}

// node_modules/@deck.gl/core/dist/passes/shadow-pass.js
var ShadowPass = class extends LayersPass {
  constructor(device, props) {
    super(device, props);
    const shadowMap = device.createTexture({
      format: "rgba8unorm",
      width: 1,
      height: 1,
      sampler: {
        minFilter: "linear",
        magFilter: "linear",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
      // TODO - texture API change in luma.gl v9.2
      // mipmaps: true
    });
    const depthBuffer = device.createTexture({ format: "depth16unorm", width: 1, height: 1 });
    this.fbo = device.createFramebuffer({
      id: "shadowmap",
      width: 1,
      height: 1,
      colorAttachments: [shadowMap],
      // Depth attachment has to be specified for depth test to work
      depthStencilAttachment: depthBuffer
    });
  }
  delete() {
    if (this.fbo) {
      this.fbo.destroy();
      this.fbo = null;
    }
  }
  getShadowMap() {
    return this.fbo.colorAttachments[0].texture;
  }
  render(params) {
    const target = this.fbo;
    const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
    const viewport = params.viewports[0];
    const width = viewport.width * pixelRatio;
    const height = viewport.height * pixelRatio;
    const clearColor = [1, 1, 1, 1];
    if (width !== target.width || height !== target.height) {
      target.resize({ width, height });
    }
    super.render({ ...params, clearColor, target, pass: "shadow" });
  }
  getLayerParameters(layer, layerIndex, viewport) {
    return {
      ...layer.props.parameters,
      blend: false,
      depthWriteEnabled: true,
      depthCompare: "less-equal"
    };
  }
  shouldDrawLayer(layer) {
    return layer.props.shadowEnabled !== false;
  }
  getShaderModuleProps(layer, effects, otherShaderModuleProps) {
    return {
      shadow: {
        project: otherShaderModuleProps.project,
        drawToShadowMap: true
      }
    };
  }
};

// node_modules/@deck.gl/core/dist/effects/lighting/lighting-effect.js
var DEFAULT_AMBIENT_LIGHT_PROPS = {
  color: [255, 255, 255],
  intensity: 1
};
var DEFAULT_DIRECTIONAL_LIGHT_PROPS = [
  {
    color: [255, 255, 255],
    intensity: 1,
    direction: [-1, 3, -1]
  },
  {
    color: [255, 255, 255],
    intensity: 0.9,
    direction: [1, -8, -2.5]
  }
];
var DEFAULT_SHADOW_COLOR2 = [0, 0, 0, 200 / 255];
var LightingEffect = class {
  constructor(props = {}) {
    this.id = "lighting-effect";
    this.shadowColor = DEFAULT_SHADOW_COLOR2;
    this.shadow = false;
    this.directionalLights = [];
    this.pointLights = [];
    this.shadowPasses = [];
    this.dummyShadowMap = null;
    this.setProps(props);
  }
  setup(context) {
    this.context = context;
    const { device, deck } = context;
    if (this.shadow && !this.dummyShadowMap) {
      this._createShadowPasses(device);
      deck._addDefaultShaderModule(shadow_default);
      this.dummyShadowMap = device.createTexture({
        width: 1,
        height: 1
      });
    }
  }
  setProps(props) {
    this.ambientLight = void 0;
    this.directionalLights = [];
    this.pointLights = [];
    for (const key in props) {
      const lightSource = props[key];
      switch (lightSource.type) {
        case "ambient":
          this.ambientLight = lightSource;
          break;
        case "directional":
          this.directionalLights.push(lightSource);
          break;
        case "point":
          this.pointLights.push(lightSource);
          break;
        default:
      }
    }
    this._applyDefaultLights();
    this.shadow = this.directionalLights.some((light) => light.shadow);
    if (this.context) {
      this.setup(this.context);
    }
    this.props = props;
  }
  preRender({ layers, layerFilter, viewports, onViewportActive, views }) {
    if (!this.shadow)
      return;
    this.shadowMatrices = this._calculateMatrices();
    for (let i2 = 0; i2 < this.shadowPasses.length; i2++) {
      const shadowPass = this.shadowPasses[i2];
      shadowPass.render({
        layers,
        layerFilter,
        viewports,
        onViewportActive,
        views,
        shaderModuleProps: {
          shadow: {
            shadowLightId: i2,
            dummyShadowMap: this.dummyShadowMap,
            shadowMatrices: this.shadowMatrices
          }
        }
      });
    }
  }
  getShaderModuleProps(layer, otherShaderModuleProps) {
    const shadowProps = this.shadow ? {
      project: otherShaderModuleProps.project,
      shadowMaps: this.shadowPasses.map((shadowPass) => shadowPass.getShadowMap()),
      dummyShadowMap: this.dummyShadowMap,
      shadowColor: this.shadowColor,
      shadowMatrices: this.shadowMatrices
    } : {};
    const lightingProps = {
      enabled: true,
      ambientLight: this.ambientLight,
      directionalLights: this.directionalLights.map((directionalLight) => directionalLight.getProjectedLight({ layer })),
      pointLights: this.pointLights.map((pointLight) => pointLight.getProjectedLight({ layer }))
    };
    const materialProps = layer.props.material;
    return {
      shadow: shadowProps,
      lighting: lightingProps,
      phongMaterial: materialProps,
      gouraudMaterial: materialProps
    };
  }
  cleanup(context) {
    for (const shadowPass of this.shadowPasses) {
      shadowPass.delete();
    }
    this.shadowPasses.length = 0;
    if (this.dummyShadowMap) {
      this.dummyShadowMap.destroy();
      this.dummyShadowMap = null;
      context.deck._removeDefaultShaderModule(shadow_default);
    }
  }
  _calculateMatrices() {
    const lightMatrices = [];
    for (const light of this.directionalLights) {
      const viewMatrix2 = new Matrix4().lookAt({
        eye: new Vector3(light.direction).negate()
      });
      lightMatrices.push(viewMatrix2);
    }
    return lightMatrices;
  }
  _createShadowPasses(device) {
    for (let i2 = 0; i2 < this.directionalLights.length; i2++) {
      const shadowPass = new ShadowPass(device);
      this.shadowPasses[i2] = shadowPass;
    }
  }
  _applyDefaultLights() {
    const { ambientLight, pointLights, directionalLights } = this;
    if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {
      this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);
      this.directionalLights.push(new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));
    }
  }
};

// node_modules/@deck.gl/core/dist/lib/effect-manager.js
var DEFAULT_LIGHTING_EFFECT = new LightingEffect();
function compareEffects(e1, e22) {
  const o1 = e1.order ?? Infinity;
  const o2 = e22.order ?? Infinity;
  return o1 - o2;
}
var EffectManager = class {
  constructor(context) {
    this._resolvedEffects = [];
    this._defaultEffects = [];
    this.effects = [];
    this._context = context;
    this._needsRedraw = "Initial render";
    this._setEffects([]);
  }
  /**
   * Register a new default effect, i.e. an effect presents regardless of user supplied props.effects
   */
  addDefaultEffect(effect) {
    const defaultEffects = this._defaultEffects;
    if (!defaultEffects.find((e3) => e3.id === effect.id)) {
      const index = defaultEffects.findIndex((e3) => compareEffects(e3, effect) > 0);
      if (index < 0) {
        defaultEffects.push(effect);
      } else {
        defaultEffects.splice(index, 0, effect);
      }
      effect.setup(this._context);
      this._setEffects(this.effects);
    }
  }
  setProps(props) {
    if ("effects" in props) {
      if (!deepEqual2(props.effects, this.effects, 1)) {
        this._setEffects(props.effects);
      }
    }
  }
  needsRedraw(opts = { clearRedrawFlags: false }) {
    const redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    return redraw;
  }
  getEffects() {
    return this._resolvedEffects;
  }
  _setEffects(effects) {
    const oldEffectsMap = {};
    for (const effect of this.effects) {
      oldEffectsMap[effect.id] = effect;
    }
    const nextEffects = [];
    for (const effect of effects) {
      const oldEffect = oldEffectsMap[effect.id];
      let effectToAdd = effect;
      if (oldEffect && oldEffect !== effect) {
        if (oldEffect.setProps) {
          oldEffect.setProps(effect.props);
          effectToAdd = oldEffect;
        } else {
          oldEffect.cleanup(this._context);
        }
      } else if (!oldEffect) {
        effect.setup(this._context);
      }
      nextEffects.push(effectToAdd);
      delete oldEffectsMap[effect.id];
    }
    for (const removedEffectId in oldEffectsMap) {
      oldEffectsMap[removedEffectId].cleanup(this._context);
    }
    this.effects = nextEffects;
    this._resolvedEffects = nextEffects.concat(this._defaultEffects);
    if (!effects.some((effect) => effect instanceof LightingEffect)) {
      this._resolvedEffects.push(DEFAULT_LIGHTING_EFFECT);
    }
    this._needsRedraw = "effects changed";
  }
  finalize() {
    for (const effect of this._resolvedEffects) {
      effect.cleanup(this._context);
    }
    this.effects.length = 0;
    this._resolvedEffects.length = 0;
    this._defaultEffects.length = 0;
  }
};

// node_modules/@deck.gl/core/dist/passes/draw-layers-pass.js
var DrawLayersPass = class extends LayersPass {
  shouldDrawLayer(layer) {
    const { operation } = layer.props;
    return operation.includes("draw") || operation.includes("terrain");
  }
};

// node_modules/@deck.gl/core/dist/passes/pick-layers-pass.js
var PICKING_BLENDING = {
  blendColorOperation: "add",
  blendColorSrcFactor: "one",
  blendColorDstFactor: "zero",
  blendAlphaOperation: "add",
  blendAlphaSrcFactor: "constant",
  blendAlphaDstFactor: "zero"
};
var PickLayersPass = class extends LayersPass {
  constructor() {
    super(...arguments);
    this._colorEncoderState = null;
  }
  render(props) {
    if ("pickingFBO" in props) {
      return this._drawPickingBuffer(props);
    }
    return super.render(props);
  }
  // Private
  // Draws list of layers and viewports into the picking buffer
  // Note: does not sample the buffer, that has to be done by the caller
  _drawPickingBuffer({ layers, layerFilter, views, viewports, onViewportActive, pickingFBO, deviceRect: { x: x2, y: y2, width, height }, cullRect, effects, pass = "picking", pickZ, shaderModuleProps }) {
    this.pickZ = pickZ;
    const colorEncoderState = this._resetColorEncoder(pickZ);
    const scissorRect = [x2, y2, width, height];
    const renderStatus = super.render({
      target: pickingFBO,
      layers,
      layerFilter,
      views,
      viewports,
      onViewportActive,
      cullRect,
      effects: effects == null ? void 0 : effects.filter((e3) => e3.useInPicking),
      pass,
      isPicking: true,
      shaderModuleProps,
      clearColor: [0, 0, 0, 0],
      colorMask: 15,
      scissorRect
    });
    this._colorEncoderState = null;
    const decodePickingColor = colorEncoderState && decodeColor.bind(null, colorEncoderState);
    return { decodePickingColor, stats: renderStatus };
  }
  shouldDrawLayer(layer) {
    const { pickable, operation } = layer.props;
    return pickable && operation.includes("draw") || operation.includes("terrain") || operation.includes("mask");
  }
  getShaderModuleProps(layer, effects, otherShaderModuleProps) {
    return {
      picking: {
        isActive: 1,
        isAttribute: this.pickZ
      },
      lighting: { enabled: false }
    };
  }
  getLayerParameters(layer, layerIndex, viewport) {
    const pickParameters = {
      ...layer.props.parameters
    };
    const { pickable, operation } = layer.props;
    if (!this._colorEncoderState || operation.includes("terrain")) {
      pickParameters.blend = false;
    } else if (pickable && operation.includes("draw")) {
      Object.assign(pickParameters, PICKING_BLENDING);
      pickParameters.blend = true;
      pickParameters.blendColor = encodeColor(this._colorEncoderState, layer, viewport);
    }
    return pickParameters;
  }
  _resetColorEncoder(pickZ) {
    this._colorEncoderState = pickZ ? null : {
      byLayer: /* @__PURE__ */ new Map(),
      byAlpha: []
    };
    return this._colorEncoderState;
  }
};
function encodeColor(encoded, layer, viewport) {
  const { byLayer, byAlpha } = encoded;
  let a2;
  let entry = byLayer.get(layer);
  if (entry) {
    entry.viewports.push(viewport);
    a2 = entry.a;
  } else {
    a2 = byLayer.size + 1;
    if (a2 <= 255) {
      entry = { a: a2, layer, viewports: [viewport] };
      byLayer.set(layer, entry);
      byAlpha[a2] = entry;
    } else {
      log_default.warn("Too many pickable layers, only picking the first 255")();
      a2 = 0;
    }
  }
  return [0, 0, 0, a2 / 255];
}
function decodeColor(encoded, pickedColor) {
  const entry = encoded.byAlpha[pickedColor[3]];
  return entry && {
    pickedLayer: entry.layer,
    pickedViewports: entry.viewports,
    pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)
  };
}

// node_modules/@deck.gl/core/dist/lib/deck-renderer.js
var TRACE_RENDER_LAYERS = "deckRenderer.renderLayers";
var DeckRenderer = class {
  constructor(device) {
    this.device = device;
    this.layerFilter = null;
    this.drawPickingColors = false;
    this.drawLayersPass = new DrawLayersPass(device);
    this.pickLayersPass = new PickLayersPass(device);
    this.renderCount = 0;
    this._needsRedraw = "Initial render";
    this.renderBuffers = [];
    this.lastPostProcessEffect = null;
  }
  setProps(props) {
    if (this.layerFilter !== props.layerFilter) {
      this.layerFilter = props.layerFilter;
      this._needsRedraw = "layerFilter changed";
    }
    if (this.drawPickingColors !== props.drawPickingColors) {
      this.drawPickingColors = props.drawPickingColors;
      this._needsRedraw = "drawPickingColors changed";
    }
  }
  renderLayers(opts) {
    if (!opts.viewports.length) {
      return;
    }
    const layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
    const renderOpts = {
      layerFilter: this.layerFilter,
      isPicking: this.drawPickingColors,
      ...opts
    };
    if (renderOpts.effects) {
      this._preRender(renderOpts.effects, renderOpts);
    }
    const outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : renderOpts.target;
    if (this.lastPostProcessEffect) {
      renderOpts.clearColor = [0, 0, 0, 0];
      renderOpts.clearCanvas = true;
    }
    const renderStats = layerPass.render({ ...renderOpts, target: outputBuffer });
    if (renderOpts.effects) {
      if (this.lastPostProcessEffect) {
        renderOpts.clearCanvas = opts.clearCanvas === void 0 ? true : opts.clearCanvas;
      }
      this._postRender(renderOpts.effects, renderOpts);
    }
    this.renderCount++;
    debug(TRACE_RENDER_LAYERS, this, renderStats, opts);
  }
  needsRedraw(opts = { clearRedrawFlags: false }) {
    const redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    return redraw;
  }
  finalize() {
    const { renderBuffers } = this;
    for (const buffer2 of renderBuffers) {
      buffer2.delete();
    }
    renderBuffers.length = 0;
  }
  _preRender(effects, opts) {
    this.lastPostProcessEffect = null;
    opts.preRenderStats = opts.preRenderStats || {};
    for (const effect of effects) {
      opts.preRenderStats[effect.id] = effect.preRender(opts);
      if (effect.postRender) {
        this.lastPostProcessEffect = effect.id;
      }
    }
    if (this.lastPostProcessEffect) {
      this._resizeRenderBuffers();
    }
  }
  _resizeRenderBuffers() {
    const { renderBuffers } = this;
    const size = this.device.canvasContext.getDrawingBufferSize();
    const [width, height] = size;
    if (renderBuffers.length === 0) {
      [0, 1].map((i2) => {
        const texture = this.device.createTexture({
          sampler: { minFilter: "linear", magFilter: "linear" },
          width,
          height
        });
        renderBuffers.push(this.device.createFramebuffer({
          id: `deck-renderbuffer-${i2}`,
          colorAttachments: [texture]
        }));
      });
    }
    for (const buffer2 of renderBuffers) {
      buffer2.resize(size);
    }
  }
  _postRender(effects, opts) {
    const { renderBuffers } = this;
    const params = {
      ...opts,
      inputBuffer: renderBuffers[0],
      swapBuffer: renderBuffers[1]
    };
    for (const effect of effects) {
      if (effect.postRender) {
        params.target = effect.id === this.lastPostProcessEffect ? opts.target : void 0;
        const buffer2 = effect.postRender(params);
        params.inputBuffer = buffer2;
        params.swapBuffer = buffer2 === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];
      }
    }
  }
};

// node_modules/@deck.gl/core/dist/lib/picking/query-object.js
var NO_PICKED_OBJECT = {
  pickedColor: null,
  pickedObjectIndex: -1
};
function getClosestObject({ pickedColors, decodePickingColor, deviceX, deviceY, deviceRadius, deviceRect }) {
  const { x: x2, y: y2, width, height } = deviceRect;
  let minSquareDistanceToCenter = deviceRadius * deviceRadius;
  let closestPixelIndex = -1;
  let i2 = 0;
  for (let row = 0; row < height; row++) {
    const dy = row + y2 - deviceY;
    const dy2 = dy * dy;
    if (dy2 > minSquareDistanceToCenter) {
      i2 += 4 * width;
    } else {
      for (let col = 0; col < width; col++) {
        const pickedLayerIndex = pickedColors[i2 + 3] - 1;
        if (pickedLayerIndex >= 0) {
          const dx = col + x2 - deviceX;
          const d2 = dx * dx + dy2;
          if (d2 <= minSquareDistanceToCenter) {
            minSquareDistanceToCenter = d2;
            closestPixelIndex = i2;
          }
        }
        i2 += 4;
      }
    }
  }
  if (closestPixelIndex >= 0) {
    const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
    const pickedObject = decodePickingColor(pickedColor);
    if (pickedObject) {
      const dy = Math.floor(closestPixelIndex / 4 / width);
      const dx = closestPixelIndex / 4 - dy * width;
      return {
        ...pickedObject,
        pickedColor,
        pickedX: x2 + dx,
        pickedY: y2 + dy
      };
    }
    log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
  }
  return NO_PICKED_OBJECT;
}
function getUniqueObjects({ pickedColors, decodePickingColor }) {
  const uniqueColors = /* @__PURE__ */ new Map();
  if (pickedColors) {
    for (let i2 = 0; i2 < pickedColors.length; i2 += 4) {
      const pickedLayerIndex = pickedColors[i2 + 3] - 1;
      if (pickedLayerIndex >= 0) {
        const pickedColor = pickedColors.slice(i2, i2 + 4);
        const colorKey = pickedColor.join(",");
        if (!uniqueColors.has(colorKey)) {
          const pickedObject = decodePickingColor(pickedColor);
          if (pickedObject) {
            uniqueColors.set(colorKey, {
              ...pickedObject,
              color: pickedColor
            });
          } else {
            log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
          }
        }
      }
    }
  }
  return Array.from(uniqueColors.values());
}

// node_modules/@deck.gl/core/dist/lib/picking/pick-info.js
function getEmptyPickingInfo({ pickInfo, viewports, pixelRatio, x: x2, y: y2, z: z2 }) {
  let pickedViewport = viewports[0];
  if (viewports.length > 1) {
    pickedViewport = getViewportFromCoordinates((pickInfo == null ? void 0 : pickInfo.pickedViewports) || viewports, { x: x2, y: y2 });
  }
  let coordinate;
  if (pickedViewport) {
    const point = [x2 - pickedViewport.x, y2 - pickedViewport.y];
    if (z2 !== void 0) {
      point[2] = z2;
    }
    coordinate = pickedViewport.unproject(point);
  }
  return {
    color: null,
    layer: null,
    viewport: pickedViewport,
    index: -1,
    picked: false,
    x: x2,
    y: y2,
    pixel: [x2, y2],
    coordinate,
    devicePixel: pickInfo && "pickedX" in pickInfo ? [pickInfo.pickedX, pickInfo.pickedY] : void 0,
    pixelRatio
  };
}
function processPickInfo(opts) {
  const { pickInfo, lastPickedInfo, mode, layers } = opts;
  const { pickedColor, pickedLayer, pickedObjectIndex } = pickInfo;
  const affectedLayers = pickedLayer ? [pickedLayer] : [];
  if (mode === "hover") {
    const lastPickedPixelIndex = lastPickedInfo.index;
    const lastPickedLayerId = lastPickedInfo.layerId;
    const pickedLayerId = pickedLayer ? pickedLayer.props.id : null;
    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedPixelIndex) {
      if (pickedLayerId !== lastPickedLayerId) {
        const lastPickedLayer = layers.find((layer) => layer.props.id === lastPickedLayerId);
        if (lastPickedLayer) {
          affectedLayers.unshift(lastPickedLayer);
        }
      }
      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
      lastPickedInfo.info = null;
    }
  }
  const baseInfo = getEmptyPickingInfo(opts);
  const infos = /* @__PURE__ */ new Map();
  infos.set(null, baseInfo);
  affectedLayers.forEach((layer) => {
    let info = { ...baseInfo };
    if (layer === pickedLayer) {
      info.color = pickedColor;
      info.index = pickedObjectIndex;
      info.picked = true;
    }
    info = getLayerPickingInfo({ layer, info, mode });
    const rootLayer = info.layer;
    if (layer === pickedLayer && mode === "hover") {
      lastPickedInfo.info = info;
    }
    infos.set(rootLayer.id, info);
    if (mode === "hover") {
      rootLayer.updateAutoHighlight(info);
    }
  });
  return infos;
}
function getLayerPickingInfo({ layer, info, mode }) {
  while (layer && info) {
    const sourceLayer = info.layer || null;
    info.sourceLayer = sourceLayer;
    info.layer = layer;
    info = layer.getPickingInfo({ info, mode, sourceLayer });
    layer = layer.parent;
  }
  return info;
}
function getViewportFromCoordinates(viewports, pixel) {
  for (let i2 = viewports.length - 1; i2 >= 0; i2--) {
    const viewport = viewports[i2];
    if (viewport.containsPixel(pixel)) {
      return viewport;
    }
  }
  return viewports[0];
}

// node_modules/@deck.gl/core/dist/lib/deck-picker.js
var DeckPicker = class {
  constructor(device) {
    this._pickable = true;
    this.device = device;
    this.pickLayersPass = new PickLayersPass(device);
    this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }
  setProps(props) {
    if ("layerFilter" in props) {
      this.layerFilter = props.layerFilter;
    }
    if ("_pickable" in props) {
      this._pickable = props._pickable;
    }
  }
  finalize() {
    if (this.pickingFBO) {
      this.pickingFBO.destroy();
    }
    if (this.depthFBO) {
      this.depthFBO.destroy();
    }
  }
  /**
   * Pick the closest info at given coordinate
   * @returns Promise that resolves with picking info
   */
  pickObjectAsync(opts) {
    return this._pickClosestObjectAsync(opts);
  }
  /**
   * Picks a list of unique infos within a bounding box
   * @returns Promise that resolves to all unique infos within a bounding box
   */
  pickObjectsAsync(opts) {
    return this._pickVisibleObjectsAsync(opts);
  }
  /**
   * Pick the closest info at given coordinate
   * @returns picking info
   * @deprecated WebGL only - use pickObjectAsync instead
   */
  pickObject(opts) {
    return this._pickClosestObject(opts);
  }
  /**
   * Get all unique infos within a bounding box
   * @returns all unique infos within a bounding box
   * @deprecated WebGL only - use pickObjectAsync instead
   */
  pickObjects(opts) {
    return this._pickVisibleObjects(opts);
  }
  // Returns a new picking info object by assuming the last picked object is still picked
  getLastPickedObject({ x: x2, y: y2, layers, viewports }, lastPickedInfo = this.lastPickedInfo.info) {
    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
    const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;
    const layer = lastPickedLayerId ? layers.find((l2) => l2.id === lastPickedLayerId) : null;
    const viewport = lastPickedViewportId && viewports.find((v2) => v2.id === lastPickedViewportId) || viewports[0];
    const coordinate = viewport && viewport.unproject([x2 - viewport.x, y2 - viewport.y]);
    const info = {
      x: x2,
      y: y2,
      viewport,
      coordinate,
      layer
    };
    return { ...lastPickedInfo, ...info };
  }
  // Private
  /** Ensures that picking framebuffer exists and matches the canvas size */
  _resizeBuffer() {
    var _a3, _b;
    if (!this.pickingFBO) {
      this.pickingFBO = this.device.createFramebuffer({
        colorAttachments: ["rgba8unorm"],
        depthStencilAttachment: "depth16unorm"
      });
      if (this.device.isTextureFormatRenderable("rgba32float")) {
        const depthFBO = this.device.createFramebuffer({
          colorAttachments: ["rgba32float"],
          depthStencilAttachment: "depth16unorm"
        });
        this.depthFBO = depthFBO;
      }
    }
    const { canvas: canvas2 } = this.device.getDefaultCanvasContext();
    (_a3 = this.pickingFBO) == null ? void 0 : _a3.resize({ width: canvas2.width, height: canvas2.height });
    (_b = this.depthFBO) == null ? void 0 : _b.resize({ width: canvas2.width, height: canvas2.height });
  }
  /** Preliminary filtering of the layers list. Skid picking pass if no layer is pickable. */
  _getPickable(layers) {
    if (this._pickable === false) {
      return null;
    }
    const pickableLayers = layers.filter((layer) => this.pickLayersPass.shouldDrawLayer(layer) && !layer.isComposite);
    return pickableLayers.length ? pickableLayers : null;
  }
  /**
   * Pick the closest object at the given coordinate
   */
  // eslint-disable-next-line max-statements,complexity
  async _pickClosestObjectAsync({ layers, views, viewports, x: x2, y: y2, radius = 0, depth = 1, mode = "query", unproject3D, onViewportActive, effects }) {
    const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
    const pickableLayers = this._getPickable(layers);
    if (!pickableLayers || viewports.length === 0) {
      return {
        result: [],
        emptyInfo: getEmptyPickingInfo({ viewports, x: x2, y: y2, pixelRatio })
      };
    }
    this._resizeBuffer();
    const devicePixelRange = this.device.canvasContext.cssToDevicePixels([x2, y2], true);
    const devicePixel = [
      devicePixelRange.x + Math.floor(devicePixelRange.width / 2),
      devicePixelRange.y + Math.floor(devicePixelRange.height / 2)
    ];
    const deviceRadius = Math.round(radius * pixelRatio);
    const { width, height } = this.pickingFBO;
    const deviceRect = this._getPickingRect({
      deviceX: devicePixel[0],
      deviceY: devicePixel[1],
      deviceRadius,
      deviceWidth: width,
      deviceHeight: height
    });
    const cullRect = {
      x: x2 - radius,
      y: y2 - radius,
      width: radius * 2 + 1,
      height: radius * 2 + 1
    };
    let infos;
    const result = [];
    const affectedLayers = /* @__PURE__ */ new Set();
    for (let i2 = 0; i2 < depth; i2++) {
      let pickInfo;
      if (deviceRect) {
        const pickedResult = this._drawAndSample({
          layers: pickableLayers,
          views,
          viewports,
          onViewportActive,
          deviceRect,
          cullRect,
          effects,
          pass: `picking:${mode}`
        });
        pickInfo = getClosestObject({
          ...pickedResult,
          deviceX: devicePixel[0],
          deviceY: devicePixel[1],
          deviceRadius,
          deviceRect
        });
      } else {
        pickInfo = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
      }
      let z2;
      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {
        const { pickedColors: pickedColors2 } = this._drawAndSample({
          layers: [pickInfo.pickedLayer],
          views,
          viewports,
          onViewportActive,
          deviceRect: {
            x: pickInfo.pickedX,
            y: pickInfo.pickedY,
            width: 1,
            height: 1
          },
          cullRect,
          effects,
          pass: `picking:${mode}:z`
        }, true);
        if (pickedColors2[3]) {
          z2 = pickedColors2[0];
        }
      }
      if (pickInfo.pickedLayer && i2 + 1 < depth) {
        affectedLayers.add(pickInfo.pickedLayer);
        pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);
      }
      infos = processPickInfo({
        pickInfo,
        lastPickedInfo: this.lastPickedInfo,
        mode,
        layers: pickableLayers,
        viewports,
        x: x2,
        y: y2,
        z: z2,
        pixelRatio
      });
      for (const info of infos.values()) {
        if (info.layer) {
          result.push(info);
        }
      }
      if (!pickInfo.pickedColor) {
        break;
      }
    }
    for (const layer of affectedLayers) {
      layer.restorePickingColors();
    }
    return { result, emptyInfo: infos.get(null) };
  }
  /**
   * Pick the closest object at the given coordinate
   * @deprecated WebGL only
   */
  // eslint-disable-next-line max-statements,complexity
  _pickClosestObject({ layers, views, viewports, x: x2, y: y2, radius = 0, depth = 1, mode = "query", unproject3D, onViewportActive, effects }) {
    const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
    const pickableLayers = this._getPickable(layers);
    if (!pickableLayers || viewports.length === 0) {
      return {
        result: [],
        emptyInfo: getEmptyPickingInfo({ viewports, x: x2, y: y2, pixelRatio })
      };
    }
    this._resizeBuffer();
    const devicePixelRange = this.device.canvasContext.cssToDevicePixels([x2, y2], true);
    const devicePixel = [
      devicePixelRange.x + Math.floor(devicePixelRange.width / 2),
      devicePixelRange.y + Math.floor(devicePixelRange.height / 2)
    ];
    const deviceRadius = Math.round(radius * pixelRatio);
    const { width, height } = this.pickingFBO;
    const deviceRect = this._getPickingRect({
      deviceX: devicePixel[0],
      deviceY: devicePixel[1],
      deviceRadius,
      deviceWidth: width,
      deviceHeight: height
    });
    const cullRect = {
      x: x2 - radius,
      y: y2 - radius,
      width: radius * 2 + 1,
      height: radius * 2 + 1
    };
    let infos;
    const result = [];
    const affectedLayers = /* @__PURE__ */ new Set();
    for (let i2 = 0; i2 < depth; i2++) {
      let pickInfo;
      if (deviceRect) {
        const pickedResult = this._drawAndSample({
          layers: pickableLayers,
          views,
          viewports,
          onViewportActive,
          deviceRect,
          cullRect,
          effects,
          pass: `picking:${mode}`
        });
        pickInfo = getClosestObject({
          ...pickedResult,
          deviceX: devicePixel[0],
          deviceY: devicePixel[1],
          deviceRadius,
          deviceRect
        });
      } else {
        pickInfo = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
      }
      let z2;
      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {
        const { pickedColors: pickedColors2 } = this._drawAndSample({
          layers: [pickInfo.pickedLayer],
          views,
          viewports,
          onViewportActive,
          deviceRect: {
            x: pickInfo.pickedX,
            y: pickInfo.pickedY,
            width: 1,
            height: 1
          },
          cullRect,
          effects,
          pass: `picking:${mode}:z`
        }, true);
        if (pickedColors2[3]) {
          z2 = pickedColors2[0];
        }
      }
      if (pickInfo.pickedLayer && i2 + 1 < depth) {
        affectedLayers.add(pickInfo.pickedLayer);
        pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);
      }
      infos = processPickInfo({
        pickInfo,
        lastPickedInfo: this.lastPickedInfo,
        mode,
        layers: pickableLayers,
        viewports,
        x: x2,
        y: y2,
        z: z2,
        pixelRatio
      });
      for (const info of infos.values()) {
        if (info.layer) {
          result.push(info);
        }
      }
      if (!pickInfo.pickedColor) {
        break;
      }
    }
    for (const layer of affectedLayers) {
      layer.restorePickingColors();
    }
    return { result, emptyInfo: infos.get(null) };
  }
  /**
   * Pick all objects within the given bounding box
   */
  // eslint-disable-next-line max-statements
  async _pickVisibleObjectsAsync({ layers, views, viewports, x: x2, y: y2, width = 1, height = 1, mode = "query", maxObjects = null, onViewportActive, effects }) {
    const pickableLayers = this._getPickable(layers);
    if (!pickableLayers || viewports.length === 0) {
      return [];
    }
    this._resizeBuffer();
    const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
    const leftTop = this.device.canvasContext.cssToDevicePixels([x2, y2], true);
    const deviceLeft = leftTop.x;
    const deviceTop = leftTop.y + leftTop.height;
    const rightBottom = this.device.canvasContext.cssToDevicePixels([x2 + width, y2 + height], true);
    const deviceRight = rightBottom.x + rightBottom.width;
    const deviceBottom = rightBottom.y;
    const deviceRect = {
      x: deviceLeft,
      y: deviceBottom,
      // deviceTop and deviceRight represent the first pixel outside the desired rect
      width: deviceRight - deviceLeft,
      height: deviceTop - deviceBottom
    };
    const pickedResult = this._drawAndSample({
      layers: pickableLayers,
      views,
      viewports,
      onViewportActive,
      deviceRect,
      cullRect: { x: x2, y: y2, width, height },
      effects,
      pass: `picking:${mode}`
    });
    const pickInfos = getUniqueObjects(pickedResult);
    const uniquePickedObjects = /* @__PURE__ */ new Map();
    const uniqueInfos = [];
    const limitMaxObjects = Number.isFinite(maxObjects);
    for (let i2 = 0; i2 < pickInfos.length; i2++) {
      if (limitMaxObjects && uniqueInfos.length >= maxObjects) {
        break;
      }
      const pickInfo = pickInfos[i2];
      let info = {
        color: pickInfo.pickedColor,
        layer: null,
        index: pickInfo.pickedObjectIndex,
        picked: true,
        x: x2,
        y: y2,
        pixelRatio
      };
      info = getLayerPickingInfo({ layer: pickInfo.pickedLayer, info, mode });
      const pickedLayerId = info.layer.id;
      if (!uniquePickedObjects.has(pickedLayerId)) {
        uniquePickedObjects.set(pickedLayerId, /* @__PURE__ */ new Set());
      }
      const uniqueObjectsInLayer = uniquePickedObjects.get(pickedLayerId);
      const pickedObjectKey = info.object ?? info.index;
      if (!uniqueObjectsInLayer.has(pickedObjectKey)) {
        uniqueObjectsInLayer.add(pickedObjectKey);
        uniqueInfos.push(info);
      }
    }
    return uniqueInfos;
  }
  /**
   * Pick all objects within the given bounding box
   * @deprecated WebGL only
   */
  // eslint-disable-next-line max-statements
  _pickVisibleObjects({ layers, views, viewports, x: x2, y: y2, width = 1, height = 1, mode = "query", maxObjects = null, onViewportActive, effects }) {
    const pickableLayers = this._getPickable(layers);
    if (!pickableLayers || viewports.length === 0) {
      return [];
    }
    this._resizeBuffer();
    const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
    const leftTop = this.device.canvasContext.cssToDevicePixels([x2, y2], true);
    const deviceLeft = leftTop.x;
    const deviceTop = leftTop.y + leftTop.height;
    const rightBottom = this.device.canvasContext.cssToDevicePixels([x2 + width, y2 + height], true);
    const deviceRight = rightBottom.x + rightBottom.width;
    const deviceBottom = rightBottom.y;
    const deviceRect = {
      x: deviceLeft,
      y: deviceBottom,
      // deviceTop and deviceRight represent the first pixel outside the desired rect
      width: deviceRight - deviceLeft,
      height: deviceTop - deviceBottom
    };
    const pickedResult = this._drawAndSample({
      layers: pickableLayers,
      views,
      viewports,
      onViewportActive,
      deviceRect,
      cullRect: { x: x2, y: y2, width, height },
      effects,
      pass: `picking:${mode}`
    });
    const pickInfos = getUniqueObjects(pickedResult);
    const uniquePickedObjects = /* @__PURE__ */ new Map();
    const uniqueInfos = [];
    const limitMaxObjects = Number.isFinite(maxObjects);
    for (let i2 = 0; i2 < pickInfos.length; i2++) {
      if (limitMaxObjects && uniqueInfos.length >= maxObjects) {
        break;
      }
      const pickInfo = pickInfos[i2];
      let info = {
        color: pickInfo.pickedColor,
        layer: null,
        index: pickInfo.pickedObjectIndex,
        picked: true,
        x: x2,
        y: y2,
        pixelRatio
      };
      info = getLayerPickingInfo({ layer: pickInfo.pickedLayer, info, mode });
      const pickedLayerId = info.layer.id;
      if (!uniquePickedObjects.has(pickedLayerId)) {
        uniquePickedObjects.set(pickedLayerId, /* @__PURE__ */ new Set());
      }
      const uniqueObjectsInLayer = uniquePickedObjects.get(pickedLayerId);
      const pickedObjectKey = info.object ?? info.index;
      if (!uniqueObjectsInLayer.has(pickedObjectKey)) {
        uniqueObjectsInLayer.add(pickedObjectKey);
        uniqueInfos.push(info);
      }
    }
    return uniqueInfos;
  }
  // Note: Implementation of the overloaded signatures above, TSDoc is on the signatures
  async _drawAndSampleAsync({ layers, views, viewports, onViewportActive, deviceRect, cullRect, effects, pass }, pickZ = false) {
    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;
    const opts = {
      layers,
      layerFilter: this.layerFilter,
      views,
      viewports,
      onViewportActive,
      pickingFBO,
      deviceRect,
      cullRect,
      effects,
      pass,
      pickZ,
      preRenderStats: {},
      isPicking: true
    };
    for (const effect of effects) {
      if (effect.useInPicking) {
        opts.preRenderStats[effect.id] = effect.preRender(opts);
      }
    }
    const { decodePickingColor } = this.pickLayersPass.render(opts);
    const { x: x2, y: y2, width, height } = deviceRect;
    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);
    this.device.readPixelsToArrayWebGL(pickingFBO, {
      sourceX: x2,
      sourceY: y2,
      sourceWidth: width,
      sourceHeight: height,
      target: pickedColors
    });
    return { pickedColors, decodePickingColor };
  }
  // Note: Implementation of the overloaded signatures above, TSDoc is on the signatures
  _drawAndSample({ layers, views, viewports, onViewportActive, deviceRect, cullRect, effects, pass }, pickZ = false) {
    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;
    const opts = {
      layers,
      layerFilter: this.layerFilter,
      views,
      viewports,
      onViewportActive,
      pickingFBO,
      deviceRect,
      cullRect,
      effects,
      pass,
      pickZ,
      preRenderStats: {},
      isPicking: true
    };
    for (const effect of effects) {
      if (effect.useInPicking) {
        opts.preRenderStats[effect.id] = effect.preRender(opts);
      }
    }
    const { decodePickingColor } = this.pickLayersPass.render(opts);
    const { x: x2, y: y2, width, height } = deviceRect;
    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);
    this.device.readPixelsToArrayWebGL(pickingFBO, {
      sourceX: x2,
      sourceY: y2,
      sourceWidth: width,
      sourceHeight: height,
      target: pickedColors
    });
    return { pickedColors, decodePickingColor };
  }
  /**
   * Calculate a picking rect centered on deviceX and deviceY and clipped to device
   * @returns null if pixel is outside of device
   */
  _getPickingRect({ deviceX, deviceY, deviceRadius, deviceWidth, deviceHeight }) {
    const x2 = Math.max(0, deviceX - deviceRadius);
    const y2 = Math.max(0, deviceY - deviceRadius);
    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x2;
    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y2;
    if (width <= 0 || height <= 0) {
      return null;
    }
    return { x: x2, y: y2, width, height };
  }
};

// node_modules/@deck.gl/core/dist/lib/widget-manager.js
var PLACEMENTS = {
  "top-left": { top: 0, left: 0 },
  "top-right": { top: 0, right: 0 },
  "bottom-left": { bottom: 0, left: 0 },
  "bottom-right": { bottom: 0, right: 0 },
  fill: { top: 0, left: 0, bottom: 0, right: 0 }
};
var DEFAULT_PLACEMENT = "top-left";
var ROOT_CONTAINER_ID = "root";
var WidgetManager = class {
  constructor({ deck, parentElement }) {
    this.defaultWidgets = [];
    this.widgets = [];
    this.resolvedWidgets = [];
    this.containers = {};
    this.lastViewports = {};
    this.deck = deck;
    parentElement == null ? void 0 : parentElement.classList.add("deck-widget-container");
    this.parentElement = parentElement;
  }
  getWidgets() {
    return this.resolvedWidgets;
  }
  /** Declarative API to configure widgets */
  setProps(props) {
    if (props.widgets && !deepEqual2(props.widgets, this.widgets, 1)) {
      const nextWidgets = props.widgets.filter(Boolean);
      this._setWidgets(nextWidgets);
    }
  }
  finalize() {
    for (const widget of this.getWidgets()) {
      this._removeWidget(widget);
    }
    this.defaultWidgets.length = 0;
    this.resolvedWidgets.length = 0;
    for (const id in this.containers) {
      this.containers[id].remove();
    }
  }
  /** Imperative API. Widgets added this way are not affected by the declarative prop. */
  addDefault(widget) {
    if (!this.defaultWidgets.find((w2) => w2.id === widget.id)) {
      this._addWidget(widget);
      this.defaultWidgets.push(widget);
      this._setWidgets(this.widgets);
    }
  }
  onRedraw({ viewports, layers }) {
    var _a3, _b;
    const viewportsById = viewports.reduce((acc, v2) => {
      acc[v2.id] = v2;
      return acc;
    }, {});
    for (const widget of this.getWidgets()) {
      const { viewId } = widget;
      if (viewId) {
        const viewport = viewportsById[viewId];
        if (viewport) {
          if (widget.onViewportChange) {
            widget.onViewportChange(viewport);
          }
          (_a3 = widget.onRedraw) == null ? void 0 : _a3.call(widget, { viewports: [viewport], layers });
        }
      } else {
        if (widget.onViewportChange) {
          for (const viewport of viewports) {
            widget.onViewportChange(viewport);
          }
        }
        (_b = widget.onRedraw) == null ? void 0 : _b.call(widget, { viewports, layers });
      }
    }
    this.lastViewports = viewportsById;
    this._updateContainers();
  }
  onHover(info, event) {
    var _a3, _b;
    for (const widget of this.getWidgets()) {
      const { viewId } = widget;
      if (!viewId || viewId === ((_a3 = info.viewport) == null ? void 0 : _a3.id)) {
        (_b = widget.onHover) == null ? void 0 : _b.call(widget, info, event);
      }
    }
  }
  onEvent(info, event) {
    var _a3, _b;
    const eventHandlerProp = EVENT_HANDLERS[event.type];
    if (!eventHandlerProp) {
      return;
    }
    for (const widget of this.getWidgets()) {
      const { viewId } = widget;
      if (!viewId || viewId === ((_a3 = info.viewport) == null ? void 0 : _a3.id)) {
        (_b = widget[eventHandlerProp]) == null ? void 0 : _b.call(widget, info, event);
      }
    }
  }
  // INTERNAL METHODS
  /**
   * Resolve widgets from the declarative prop
   * Initialize new widgets and remove old ones
   * Update props of existing widgets
   */
  _setWidgets(nextWidgets) {
    const oldWidgetMap = {};
    for (const widget of this.resolvedWidgets) {
      oldWidgetMap[widget.id] = widget;
    }
    this.resolvedWidgets.length = 0;
    for (const widget of this.defaultWidgets) {
      oldWidgetMap[widget.id] = null;
      this.resolvedWidgets.push(widget);
    }
    for (let widget of nextWidgets) {
      const oldWidget = oldWidgetMap[widget.id];
      if (!oldWidget) {
        this._addWidget(widget);
      } else if (
        // Widget placement changed
        oldWidget.viewId !== widget.viewId || oldWidget.placement !== widget.placement
      ) {
        this._removeWidget(oldWidget);
        this._addWidget(widget);
      } else if (widget !== oldWidget) {
        oldWidget.setProps(widget.props);
        widget = oldWidget;
      }
      oldWidgetMap[widget.id] = null;
      this.resolvedWidgets.push(widget);
    }
    for (const id in oldWidgetMap) {
      const oldWidget = oldWidgetMap[id];
      if (oldWidget) {
        this._removeWidget(oldWidget);
      }
    }
    this.widgets = nextWidgets;
  }
  /** Initialize new widget */
  _addWidget(widget) {
    const { viewId = null, placement = DEFAULT_PLACEMENT } = widget;
    const container = widget.props._container ?? viewId;
    widget.widgetManager = this;
    widget.deck = this.deck;
    widget.rootElement = widget._onAdd({ deck: this.deck, viewId });
    if (widget.rootElement) {
      this._getContainer(container, placement).append(widget.rootElement);
    }
    widget.updateHTML();
  }
  /** Destroy an old widget */
  _removeWidget(widget) {
    var _a3;
    (_a3 = widget.onRemove) == null ? void 0 : _a3.call(widget);
    if (widget.rootElement) {
      widget.rootElement.remove();
    }
    widget.rootElement = void 0;
    widget.deck = void 0;
    widget.widgetManager = void 0;
  }
  /** Get a container element based on view and placement */
  _getContainer(viewIdOrContainer, placement) {
    var _a3;
    if (viewIdOrContainer && typeof viewIdOrContainer !== "string") {
      return viewIdOrContainer;
    }
    const containerId = viewIdOrContainer || ROOT_CONTAINER_ID;
    let viewContainer = this.containers[containerId];
    if (!viewContainer) {
      viewContainer = document.createElement("div");
      viewContainer.style.pointerEvents = "none";
      viewContainer.style.position = "absolute";
      viewContainer.style.overflow = "hidden";
      (_a3 = this.parentElement) == null ? void 0 : _a3.append(viewContainer);
      this.containers[containerId] = viewContainer;
    }
    let container = viewContainer.querySelector(`.${placement}`);
    if (!container) {
      container = globalThis.document.createElement("div");
      container.className = placement;
      container.style.position = "absolute";
      container.style.zIndex = "2";
      Object.assign(container.style, PLACEMENTS[placement]);
      viewContainer.append(container);
    }
    return container;
  }
  _updateContainers() {
    const canvasWidth = this.deck.width;
    const canvasHeight = this.deck.height;
    for (const id in this.containers) {
      const viewport = this.lastViewports[id] || null;
      const visible = id === ROOT_CONTAINER_ID || viewport;
      const container = this.containers[id];
      if (visible) {
        container.style.display = "block";
        container.style.left = `${viewport ? viewport.x : 0}px`;
        container.style.top = `${viewport ? viewport.y : 0}px`;
        container.style.width = `${viewport ? viewport.width : canvasWidth}px`;
        container.style.height = `${viewport ? viewport.height : canvasHeight}px`;
      } else {
        container.style.display = "none";
      }
    }
  }
};

// node_modules/@deck.gl/core/dist/utils/apply-styles.js
function applyStyles(element, style) {
  if (style) {
    Object.entries(style).map(([key, value]) => {
      if (key.startsWith("--")) {
        element.style.setProperty(key, value);
      } else {
        element.style[key] = value;
      }
    });
  }
}
function removeStyles(element, style) {
  if (style) {
    Object.keys(style).map((key) => {
      if (key.startsWith("--")) {
        element.style.removeProperty(key);
      } else {
        element.style[key] = "";
      }
    });
  }
}

// node_modules/@deck.gl/core/dist/lib/widget.js
var Widget = class {
  constructor(props) {
    this.viewId = null;
    this.props = {
      // @ts-expect-error `defaultProps` may not exist on constructor
      ...this.constructor.defaultProps,
      ...props
    };
    this.id = this.props.id;
  }
  /** Called to update widget options */
  setProps(props) {
    const oldProps = this.props;
    const el = this.rootElement;
    if (el && oldProps.className !== props.className) {
      if (oldProps.className)
        el.classList.remove(oldProps.className);
      if (props.className)
        el.classList.add(props.className);
    }
    if (el && !deepEqual2(oldProps.style, props.style, 1)) {
      removeStyles(el, oldProps.style);
      applyStyles(el, props.style);
    }
    Object.assign(this.props, props);
    this.updateHTML();
  }
  /** Update the HTML to reflect latest props and state */
  updateHTML() {
    if (this.rootElement) {
      this.onRenderHTML(this.rootElement);
    }
  }
  // @note empty method calls have an overhead in V8 but it is very low, ~1ns
  /**
   * Common utility to create the root DOM element for this widget
   * Configures the top-level styles and adds basic class names for theming
   * @returns an UI element that should be appended to the Deck container
   */
  onCreateRootElement() {
    const CLASS_NAMES = [
      // Add class names for theming
      "deck-widget",
      this.className,
      // plus any app-supplied class name
      this.props.className
    ];
    const element = document.createElement("div");
    CLASS_NAMES.filter((cls) => typeof cls === "string" && cls.length > 0).forEach((className) => element.classList.add(className));
    applyStyles(element, this.props.style);
    return element;
  }
  /** Internal API called by Deck when the widget is first added to a Deck instance */
  _onAdd(params) {
    return this.onAdd(params) ?? this.onCreateRootElement();
  }
  /** Overridable by subclass - called when the widget is first added to a Deck instance
   * @returns an optional UI element that should be appended to the Deck container
   */
  onAdd(params) {
  }
  /** Called when the widget is removed */
  onRemove() {
  }
  // deck integration - Event hooks
  /** Called when the containing view is changed */
  onViewportChange(viewport) {
  }
  /** Called when the containing view is redrawn */
  onRedraw(params) {
  }
  /** Called when a hover event occurs */
  onHover(info, event) {
  }
  /** Called when a click event occurs */
  onClick(info, event) {
  }
  /** Called when a drag event occurs */
  onDrag(info, event) {
  }
  /** Called when a dragstart event occurs */
  onDragStart(info, event) {
  }
  /** Called when a dragend event occurs */
  onDragEnd(info, event) {
  }
};
Widget.defaultProps = {
  id: "widget",
  style: {},
  _container: null,
  className: ""
};

// node_modules/@deck.gl/core/dist/lib/tooltip-widget.js
var defaultStyle = {
  zIndex: "1",
  position: "absolute",
  pointerEvents: "none",
  color: "#a0a7b4",
  backgroundColor: "#29323c",
  padding: "10px",
  top: "0",
  left: "0",
  display: "none"
};
var TooltipWidget = class extends Widget {
  constructor(props = {}) {
    super(props);
    this.id = "default-tooltip";
    this.placement = "fill";
    this.className = "deck-tooltip";
    this.isVisible = false;
    this.setProps(props);
  }
  // TODO(ib) - does this really need to be overridden?
  onCreateRootElement() {
    const el = document.createElement("div");
    el.className = this.className;
    Object.assign(el.style, defaultStyle);
    return el;
  }
  onRenderHTML(rootElement) {
  }
  onViewportChange(viewport) {
    var _a3;
    if (this.isVisible && viewport.id === ((_a3 = this.lastViewport) == null ? void 0 : _a3.id) && !viewport.equals(this.lastViewport)) {
      this.setTooltip(null);
    }
    this.lastViewport = viewport;
  }
  onHover(info) {
    const { deck } = this;
    const getTooltip = deck && deck.props.getTooltip;
    if (!getTooltip) {
      return;
    }
    const displayInfo = getTooltip(info);
    this.setTooltip(displayInfo, info.x, info.y);
  }
  setTooltip(displayInfo, x2, y2) {
    const el = this.rootElement;
    if (!el) {
      return;
    }
    if (typeof displayInfo === "string") {
      el.innerText = displayInfo;
    } else if (!displayInfo) {
      this.isVisible = false;
      el.style.display = "none";
      return;
    } else {
      if (displayInfo.text) {
        el.innerText = displayInfo.text;
      }
      if (displayInfo.html) {
        el.innerHTML = displayInfo.html;
      }
      if (displayInfo.className) {
        el.className = displayInfo.className;
      }
    }
    this.isVisible = true;
    el.style.display = "block";
    el.style.transform = `translate(${x2}px, ${y2}px)`;
    if (displayInfo && typeof displayInfo === "object" && "style" in displayInfo) {
      Object.assign(el.style, displayInfo.style);
    }
  }
};
TooltipWidget.defaultProps = {
  ...Widget.defaultProps
};

// node_modules/@loaders.gl/images/dist/lib/utils/version.js
var VERSION3 = true ? "4.3.3" : "latest";

// node_modules/@loaders.gl/images/dist/lib/category-api/image-type.js
var _a;
var parseImageNode = (_a = globalThis.loaders) == null ? void 0 : _a.parseImageNode;
var IMAGE_SUPPORTED = typeof Image !== "undefined";
var IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
var NODE_IMAGE_SUPPORTED = Boolean(parseImageNode);
var DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;
function isImageTypeSupported(type) {
  switch (type) {
    case "auto":
      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
    case "imagebitmap":
      return IMAGE_BITMAP_SUPPORTED;
    case "image":
      return IMAGE_SUPPORTED;
    case "data":
      return DATA_SUPPORTED;
    default:
      throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);
  }
}
function getDefaultImageType() {
  if (IMAGE_BITMAP_SUPPORTED) {
    return "imagebitmap";
  }
  if (IMAGE_SUPPORTED) {
    return "image";
  }
  if (DATA_SUPPORTED) {
    return "data";
  }
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}

// node_modules/@loaders.gl/images/dist/lib/category-api/parsed-image-api.js
function getImageType(image) {
  const format = getImageTypeOrNull(image);
  if (!format) {
    throw new Error("Not an image");
  }
  return format;
}
function getImageData(image) {
  switch (getImageType(image)) {
    case "data":
      return image;
    case "image":
    case "imagebitmap":
      const canvas2 = document.createElement("canvas");
      const context = canvas2.getContext("2d");
      if (!context) {
        throw new Error("getImageData");
      }
      canvas2.width = image.width;
      canvas2.height = image.height;
      context.drawImage(image, 0, 0);
      return context.getImageData(0, 0, image.width, image.height);
    default:
      throw new Error("getImageData");
  }
}
function getImageTypeOrNull(image) {
  if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return "imagebitmap";
  }
  if (typeof Image !== "undefined" && image instanceof Image) {
    return "image";
  }
  if (image && typeof image === "object" && image.data && image.width && image.height) {
    return "data";
  }
  return null;
}

// node_modules/@loaders.gl/images/dist/lib/parsers/svg-utils.js
var SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
var SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
function isSVG(url) {
  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
}
function getBlobOrSVGDataUrl(arrayBuffer, url) {
  if (isSVG(url)) {
    const textDecoder = new TextDecoder();
    let xmlText = textDecoder.decode(arrayBuffer);
    try {
      if (typeof unescape === "function" && typeof encodeURIComponent === "function") {
        xmlText = unescape(encodeURIComponent(xmlText));
      }
    } catch (error) {
      throw new Error(error.message);
    }
    const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;
    return src;
  }
  return getBlob(arrayBuffer, url);
}
function getBlob(arrayBuffer, url) {
  if (isSVG(url)) {
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  }
  return new Blob([new Uint8Array(arrayBuffer)]);
}

// node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image.js
async function parseToImage(arrayBuffer, options, url) {
  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);
  const URL2 = self.URL || self.webkitURL;
  const objectUrl = typeof blobOrDataUrl !== "string" && URL2.createObjectURL(blobOrDataUrl);
  try {
    return await loadToImage(objectUrl || blobOrDataUrl, options);
  } finally {
    if (objectUrl) {
      URL2.revokeObjectURL(objectUrl);
    }
  }
}
async function loadToImage(url, options) {
  const image = new Image();
  image.src = url;
  if (options.image && options.image.decode && image.decode) {
    await image.decode();
    return image;
  }
  return await new Promise((resolve2, reject) => {
    try {
      image.onload = () => resolve2(image);
      image.onerror = (error) => {
        const message = error instanceof Error ? error.message : "error";
        reject(new Error(message));
      };
    } catch (error) {
      reject(error);
    }
  });
}

// node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image-bitmap.js
var EMPTY_OBJECT = {};
var imagebitmapOptionsSupported = true;
async function parseToImageBitmap(arrayBuffer, options, url) {
  let blob;
  if (isSVG(url)) {
    const image = await parseToImage(arrayBuffer, options, url);
    blob = image;
  } else {
    blob = getBlob(arrayBuffer, url);
  }
  const imagebitmapOptions = options && options.imagebitmap;
  return await safeCreateImageBitmap(blob, imagebitmapOptions);
}
async function safeCreateImageBitmap(blob, imagebitmapOptions = null) {
  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
    imagebitmapOptions = null;
  }
  if (imagebitmapOptions) {
    try {
      return await createImageBitmap(blob, imagebitmapOptions);
    } catch (error) {
      console.warn(error);
      imagebitmapOptionsSupported = false;
    }
  }
  return await createImageBitmap(blob);
}
function isEmptyObject(object) {
  for (const key in object || EMPTY_OBJECT) {
    return false;
  }
  return true;
}

// node_modules/@loaders.gl/images/dist/lib/category-api/parse-isobmff-binary.js
function getISOBMFFMediaType(buffer2) {
  if (!checkString(buffer2, "ftyp", 4)) {
    return null;
  }
  if ((buffer2[8] & 96) === 0) {
    return null;
  }
  return decodeMajorBrand(buffer2);
}
function decodeMajorBrand(buffer2) {
  const brandMajor = getUTF8String(buffer2, 8, 12).replace("\0", " ").trim();
  switch (brandMajor) {
    case "avif":
    case "avis":
      return { extension: "avif", mimeType: "image/avif" };
    default:
      return null;
  }
}
function getUTF8String(array, start, end) {
  return String.fromCharCode(...array.slice(start, end));
}
function stringToBytes(string) {
  return [...string].map((character) => character.charCodeAt(0));
}
function checkString(buffer2, header, offset = 0) {
  const headerBytes = stringToBytes(header);
  for (let i2 = 0; i2 < headerBytes.length; ++i2) {
    if (headerBytes[i2] !== buffer2[i2 + offset]) {
      return false;
    }
  }
  return true;
}

// node_modules/@loaders.gl/images/dist/lib/category-api/binary-image-api.js
var BIG_ENDIAN = false;
var LITTLE_ENDIAN = true;
function getBinaryImageMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView) || getISOBMFFMetadata(dataView);
}
function getISOBMFFMetadata(binaryData) {
  const buffer2 = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);
  const mediaType = getISOBMFFMediaType(buffer2);
  if (!mediaType) {
    return null;
  }
  return {
    mimeType: mediaType.mimeType,
    // TODO - decode width and height
    width: 0,
    height: 0
  };
}
function getPngMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 2303741511;
  if (!isPng) {
    return null;
  }
  return {
    mimeType: "image/png",
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}
function getGifMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 1195984440;
  if (!isGif) {
    return null;
  }
  return {
    mimeType: "image/gif",
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}
function getBmpMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 16973 && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
  if (!isBmp) {
    return null;
  }
  return {
    mimeType: "image/bmp",
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}
function getJpegMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 65496 && dataView.getUint8(2) === 255;
  if (!isJpeg) {
    return null;
  }
  const { tableMarkers, sofMarkers } = getJpegMarkers();
  let i2 = 2;
  while (i2 + 9 < dataView.byteLength) {
    const marker = dataView.getUint16(i2, BIG_ENDIAN);
    if (sofMarkers.has(marker)) {
      return {
        mimeType: "image/jpeg",
        height: dataView.getUint16(i2 + 5, BIG_ENDIAN),
        // Number of lines
        width: dataView.getUint16(i2 + 7, BIG_ENDIAN)
        // Number of pixels per line
      };
    }
    if (!tableMarkers.has(marker)) {
      return null;
    }
    i2 += 2;
    i2 += dataView.getUint16(i2, BIG_ENDIAN);
  }
  return null;
}
function getJpegMarkers() {
  const tableMarkers = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
  for (let i2 = 65504; i2 < 65520; ++i2) {
    tableMarkers.add(i2);
  }
  const sofMarkers = /* @__PURE__ */ new Set([
    65472,
    65473,
    65474,
    65475,
    65477,
    65478,
    65479,
    65481,
    65482,
    65483,
    65485,
    65486,
    65487,
    65502
  ]);
  return { tableMarkers, sofMarkers };
}
function toDataView(data) {
  if (data instanceof DataView) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    return new DataView(data.buffer);
  }
  if (data instanceof ArrayBuffer) {
    return new DataView(data);
  }
  throw new Error("toDataView");
}

// node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-node-image.js
async function parseToNodeImage(arrayBuffer, options) {
  var _a3;
  const { mimeType } = getBinaryImageMetadata(arrayBuffer) || {};
  const parseImageNode2 = (_a3 = globalThis.loaders) == null ? void 0 : _a3.parseImageNode;
  assert4(parseImageNode2);
  return await parseImageNode2(arrayBuffer, mimeType);
}

// node_modules/@loaders.gl/images/dist/lib/parsers/parse-image.js
async function parseImage(arrayBuffer, options, context) {
  options = options || {};
  const imageOptions = options.image || {};
  const imageType = imageOptions.type || "auto";
  const { url } = context || {};
  const loadType = getLoadableImageType(imageType);
  let image;
  switch (loadType) {
    case "imagebitmap":
      image = await parseToImageBitmap(arrayBuffer, options, url);
      break;
    case "image":
      image = await parseToImage(arrayBuffer, options, url);
      break;
    case "data":
      image = await parseToNodeImage(arrayBuffer, options);
      break;
    default:
      assert4(false);
  }
  if (imageType === "data") {
    image = getImageData(image);
  }
  return image;
}
function getLoadableImageType(type) {
  switch (type) {
    case "auto":
    case "data":
      return getDefaultImageType();
    default:
      isImageTypeSupported(type);
      return type;
  }
}

// node_modules/@loaders.gl/images/dist/image-loader.js
var EXTENSIONS = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"];
var MIME_TYPES = [
  "image/png",
  "image/jpeg",
  "image/gif",
  "image/webp",
  "image/avif",
  "image/bmp",
  "image/vnd.microsoft.icon",
  "image/svg+xml"
];
var DEFAULT_IMAGE_LOADER_OPTIONS = {
  image: {
    type: "auto",
    decode: true
    // if format is HTML
  }
  // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor
};
var ImageLoader = {
  dataType: null,
  batchType: null,
  id: "image",
  module: "images",
  name: "Images",
  version: VERSION3,
  mimeTypes: MIME_TYPES,
  extensions: EXTENSIONS,
  parse: parseImage,
  // TODO: byteOffset, byteLength;
  tests: [(arrayBuffer) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer)))],
  options: DEFAULT_IMAGE_LOADER_OPTIONS
};

// node_modules/@loaders.gl/images/dist/lib/encoders/encode-image.js
var _a2;
var encodeImageNode = (_a2 = globalThis.loaders) == null ? void 0 : _a2.encodeImageNode;

// node_modules/@deck.gl/core/dist/utils/json-loader.js
function isJSON(text) {
  const firstChar = text[0];
  const lastChar = text[text.length - 1];
  return firstChar === "{" && lastChar === "}" || firstChar === "[" && lastChar === "]";
}
var json_loader_default = {
  dataType: null,
  batchType: null,
  id: "JSON",
  name: "JSON",
  module: "",
  version: "",
  options: {},
  extensions: ["json", "geojson"],
  mimeTypes: ["application/json", "application/geo+json"],
  testText: isJSON,
  parseTextSync: JSON.parse
};

// node_modules/@deck.gl/core/dist/lib/init.js
function checkVersion() {
  const version2 = true ? "9.2.6" : globalThis.DECK_VERSION || "untranspiled source";
  const existingVersion = globalThis.deck && globalThis.deck.VERSION;
  if (existingVersion && existingVersion !== version2) {
    throw new Error(`deck.gl - multiple versions detected: ${existingVersion} vs ${version2}`);
  }
  if (!existingVersion) {
    log_default.log(1, `deck.gl ${version2}`)();
    globalThis.deck = {
      ...globalThis.deck,
      VERSION: version2,
      version: version2,
      log: log_default,
      // experimental
      _registerLoggers: register
    };
    registerLoaders([
      json_loader_default,
      // @ts-expect-error non-standard Loader format
      [ImageLoader, { imagebitmap: { premultiplyAlpha: "none" } }]
    ]);
  }
  return version2;
}
var VERSION4 = checkVersion();

// node_modules/@deck.gl/core/dist/lib/deck.js
function noop2() {
}
var getCursor = ({ isDragging }) => isDragging ? "grabbing" : "grab";
var defaultProps = {
  id: "",
  width: "100%",
  height: "100%",
  style: null,
  viewState: null,
  initialViewState: null,
  pickingRadius: 0,
  layerFilter: null,
  parameters: {},
  parent: null,
  device: null,
  deviceProps: {},
  gl: null,
  canvas: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  // Rely on external controller, e.g. react-map-gl
  useDevicePixels: true,
  touchAction: "none",
  eventRecognizerOptions: {},
  _framebuffer: null,
  _animate: false,
  _pickable: true,
  _typedArrayManagerProps: {},
  _customRender: null,
  widgets: [],
  onDeviceInitialized: noop2,
  onWebGLInitialized: noop2,
  onResize: noop2,
  onViewStateChange: noop2,
  onInteractionStateChange: noop2,
  onBeforeRender: noop2,
  onAfterRender: noop2,
  onLoad: noop2,
  onError: (error) => log_default.error(error.message, error.cause)(),
  onHover: null,
  onClick: null,
  onDragStart: null,
  onDrag: null,
  onDragEnd: null,
  _onMetrics: null,
  getCursor,
  getTooltip: null,
  debug: false,
  drawPickingColors: false
};
var Deck = class {
  constructor(props) {
    var _a3;
    this.width = 0;
    this.height = 0;
    this.userData = {};
    this.device = null;
    this.canvas = null;
    this.viewManager = null;
    this.layerManager = null;
    this.effectManager = null;
    this.deckRenderer = null;
    this.deckPicker = null;
    this.eventManager = null;
    this.widgetManager = null;
    this.tooltip = null;
    this.animationLoop = null;
    this.cursorState = {
      isHovering: false,
      isDragging: false
    };
    this.stats = new Stats({ id: "deck.gl" });
    this.metrics = {
      fps: 0,
      setPropsTime: 0,
      updateAttributesTime: 0,
      framesRedrawn: 0,
      pickTime: 0,
      pickCount: 0,
      gpuTime: 0,
      gpuTimePerFrame: 0,
      cpuTime: 0,
      cpuTimePerFrame: 0,
      bufferMemory: 0,
      textureMemory: 0,
      renderbufferMemory: 0,
      gpuMemory: 0
    };
    this._metricsCounter = 0;
    this._needsRedraw = "Initial render";
    this._pickRequest = {
      mode: "hover",
      x: -1,
      y: -1,
      radius: 0,
      event: null
    };
    this._lastPointerDownInfo = null;
    this._onPointerMove = (event) => {
      const { _pickRequest } = this;
      if (event.type === "pointerleave") {
        _pickRequest.x = -1;
        _pickRequest.y = -1;
        _pickRequest.radius = 0;
      } else if (event.leftButton || event.rightButton) {
        return;
      } else {
        const pos = event.offsetCenter;
        if (!pos) {
          return;
        }
        _pickRequest.x = pos.x;
        _pickRequest.y = pos.y;
        _pickRequest.radius = this.props.pickingRadius;
      }
      if (this.layerManager) {
        this.layerManager.context.mousePosition = { x: _pickRequest.x, y: _pickRequest.y };
      }
      _pickRequest.event = event;
    };
    this._onEvent = (event) => {
      const eventHandlerProp = EVENT_HANDLERS[event.type];
      const pos = event.offsetCenter;
      if (!eventHandlerProp || !pos || !this.layerManager) {
        return;
      }
      const layers = this.layerManager.getLayers();
      const info = this.deckPicker.getLastPickedObject({
        x: pos.x,
        y: pos.y,
        layers,
        viewports: this.getViewports(pos)
      }, this._lastPointerDownInfo);
      const { layer } = info;
      const layerHandler = layer && (layer[eventHandlerProp] || layer.props[eventHandlerProp]);
      const rootHandler = this.props[eventHandlerProp];
      let handled = false;
      if (layerHandler) {
        handled = layerHandler.call(layer, info, event);
      }
      if (!handled) {
        rootHandler == null ? void 0 : rootHandler(info, event);
        this.widgetManager.onEvent(info, event);
      }
    };
    this._onPointerDown = (event) => {
      var _a4;
      if (((_a4 = this.device) == null ? void 0 : _a4.type) === "webgpu") {
        return;
      }
      const pos = event.offsetCenter;
      const pickedInfo = this._pick("pickObject", "pickObject Time", {
        x: pos.x,
        y: pos.y,
        radius: this.props.pickingRadius
      });
      this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;
    };
    this.props = { ...defaultProps, ...props };
    props = this.props;
    if (props.viewState && props.initialViewState) {
      log_default.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")();
    }
    this.viewState = this.props.initialViewState;
    if (props.device) {
      this.device = props.device;
    }
    let deviceOrPromise = this.device;
    if (!deviceOrPromise && props.gl) {
      if (props.gl instanceof WebGLRenderingContext) {
        log_default.error("WebGL1 context not supported.")();
      }
      const userOnResize = (_a3 = this.props.deviceProps) == null ? void 0 : _a3.onResize;
      deviceOrPromise = webgl2Adapter.attach(props.gl, {
        ...this.props.deviceProps,
        onResize: (canvasContext, info) => {
          const { width, height } = canvasContext.canvas;
          canvasContext.drawingBufferWidth = width;
          canvasContext.drawingBufferHeight = height;
          this._needsRedraw = "Canvas resized";
          userOnResize == null ? void 0 : userOnResize(canvasContext, info);
        }
      });
    }
    if (!deviceOrPromise) {
      deviceOrPromise = this._createDevice(props);
    }
    this.animationLoop = this._createAnimationLoop(deviceOrPromise, props);
    this.setProps(props);
    if (props._typedArrayManagerProps) {
      typed_array_manager_default.setOptions(props._typedArrayManagerProps);
    }
    this.animationLoop.start();
  }
  /** Stop rendering and dispose all resources */
  finalize() {
    var _a3, _b, _c, _d, _e2, _f, _g, _h, _i, _j;
    (_a3 = this.animationLoop) == null ? void 0 : _a3.stop();
    (_b = this.animationLoop) == null ? void 0 : _b.destroy();
    this.animationLoop = null;
    this._lastPointerDownInfo = null;
    (_c = this.layerManager) == null ? void 0 : _c.finalize();
    this.layerManager = null;
    (_d = this.viewManager) == null ? void 0 : _d.finalize();
    this.viewManager = null;
    (_e2 = this.effectManager) == null ? void 0 : _e2.finalize();
    this.effectManager = null;
    (_f = this.deckRenderer) == null ? void 0 : _f.finalize();
    this.deckRenderer = null;
    (_g = this.deckPicker) == null ? void 0 : _g.finalize();
    this.deckPicker = null;
    (_h = this.eventManager) == null ? void 0 : _h.destroy();
    this.eventManager = null;
    (_i = this.widgetManager) == null ? void 0 : _i.finalize();
    this.widgetManager = null;
    if (!this.props.canvas && !this.props.device && !this.props.gl && this.canvas) {
      (_j = this.canvas.parentElement) == null ? void 0 : _j.removeChild(this.canvas);
      this.canvas = null;
    }
  }
  /** Partially update props */
  setProps(props) {
    var _a3, _b, _c, _d, _e2, _f, _g;
    this.stats.get("setProps Time").timeStart();
    if ("onLayerHover" in props) {
      log_default.removed("onLayerHover", "onHover")();
    }
    if ("onLayerClick" in props) {
      log_default.removed("onLayerClick", "onClick")();
    }
    if (props.initialViewState && // depth = 3 when comparing viewStates: viewId.position.0
    !deepEqual2(this.props.initialViewState, props.initialViewState, 3)) {
      this.viewState = props.initialViewState;
    }
    Object.assign(this.props, props);
    this._setCanvasSize(this.props);
    const resolvedProps = Object.create(this.props);
    Object.assign(resolvedProps, {
      views: this._getViews(),
      width: this.width,
      height: this.height,
      viewState: this._getViewState()
    });
    if (props.device && props.device.id !== ((_a3 = this.device) == null ? void 0 : _a3.id)) {
      (_b = this.animationLoop) == null ? void 0 : _b.stop();
      if (this.canvas !== ((_c = props.device.canvasContext) == null ? void 0 : _c.canvas)) {
        (_d = this.canvas) == null ? void 0 : _d.remove();
        (_e2 = this.eventManager) == null ? void 0 : _e2.destroy();
        this.canvas = null;
      }
      log_default.log(`recreating animation loop for new device! id=${props.device.id}`)();
      this.animationLoop = this._createAnimationLoop(props.device, props);
      this.animationLoop.start();
    }
    (_f = this.animationLoop) == null ? void 0 : _f.setProps(resolvedProps);
    if (props.useDevicePixels !== void 0 && ((_g = this.device) == null ? void 0 : _g.canvasContext)) {
      this.device.canvasContext.setProps({ useDevicePixels: props.useDevicePixels });
    }
    if (this.layerManager) {
      this.viewManager.setProps(resolvedProps);
      this.layerManager.activateViewport(this.getViewports()[0]);
      this.layerManager.setProps(resolvedProps);
      this.effectManager.setProps(resolvedProps);
      this.deckRenderer.setProps(resolvedProps);
      this.deckPicker.setProps(resolvedProps);
      this.widgetManager.setProps(resolvedProps);
    }
    this.stats.get("setProps Time").timeEnd();
  }
  // Public API
  /**
   * Check if a redraw is needed
   * @returns `false` or a string summarizing the redraw reason
   */
  needsRedraw(opts = { clearRedrawFlags: false }) {
    if (!this.layerManager) {
      return false;
    }
    if (this.props._animate) {
      return "Deck._animate";
    }
    let redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);
    const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);
    const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);
    const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);
    redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;
    return redraw;
  }
  /**
   * Redraw the GL context
   * @param reason If not provided, only redraw if deemed necessary. Otherwise redraw regardless of internal states.
   * @returns
   */
  redraw(reason) {
    if (!this.layerManager) {
      return;
    }
    let redrawReason = this.needsRedraw({ clearRedrawFlags: true });
    redrawReason = reason || redrawReason;
    if (!redrawReason) {
      return;
    }
    this.stats.get("Redraw Count").incrementCount();
    if (this.props._customRender) {
      this.props._customRender(redrawReason);
    } else {
      this._drawLayers(redrawReason);
    }
  }
  /** Flag indicating that the Deck instance has initialized its resources and it's safe to call public methods. */
  get isInitialized() {
    return this.viewManager !== null;
  }
  /** Get a list of views that are currently rendered */
  getViews() {
    assert6(this.viewManager);
    return this.viewManager.views;
  }
  /** Get a list of viewports that are currently rendered.
   * @param rect If provided, only returns viewports within the given bounding box.
   */
  getViewports(rect) {
    assert6(this.viewManager);
    return this.viewManager.getViewports(rect);
  }
  /** Get the current canvas element. */
  getCanvas() {
    return this.canvas;
  }
  /** Query the object rendered on top at a given point */
  pickObject(opts) {
    const infos = this._pick("pickObject", "pickObject Time", opts).result;
    return infos.length ? infos[0] : null;
  }
  /* Query all rendered objects at a given point */
  pickMultipleObjects(opts) {
    opts.depth = opts.depth || 10;
    return this._pick("pickObject", "pickMultipleObjects Time", opts).result;
  }
  /* Query all objects rendered on top within a bounding box */
  pickObjects(opts) {
    return this._pick("pickObjects", "pickObjects Time", opts);
  }
  /** Experimental
   * Add a global resource for sharing among layers
   */
  _addResources(resources, forceUpdate = false) {
    for (const id in resources) {
      this.layerManager.resourceManager.add({ resourceId: id, data: resources[id], forceUpdate });
    }
  }
  /** Experimental
   * Remove a global resource
   */
  _removeResources(resourceIds) {
    for (const id of resourceIds) {
      this.layerManager.resourceManager.remove(id);
    }
  }
  /** Experimental
   * Register a default effect. Effects will be sorted by order, those with a low order will be rendered first
   */
  _addDefaultEffect(effect) {
    this.effectManager.addDefaultEffect(effect);
  }
  _addDefaultShaderModule(module) {
    this.layerManager.addDefaultShaderModule(module);
  }
  _removeDefaultShaderModule(module) {
    var _a3;
    (_a3 = this.layerManager) == null ? void 0 : _a3.removeDefaultShaderModule(module);
  }
  _pick(method, statKey, opts) {
    assert6(this.deckPicker);
    const { stats } = this;
    stats.get("Pick Count").incrementCount();
    stats.get(statKey).timeStart();
    const infos = this.deckPicker[method]({
      // layerManager, viewManager and effectManager are always defined if deckPicker is
      layers: this.layerManager.getLayers(opts),
      views: this.viewManager.getViews(),
      viewports: this.getViewports(opts),
      onViewportActive: this.layerManager.activateViewport,
      effects: this.effectManager.getEffects(),
      ...opts
    });
    stats.get(statKey).timeEnd();
    return infos;
  }
  /** Resolve props.canvas to element */
  _createCanvas(props) {
    let canvas2 = props.canvas;
    if (typeof canvas2 === "string") {
      canvas2 = document.getElementById(canvas2);
      assert6(canvas2);
    }
    if (!canvas2) {
      canvas2 = document.createElement("canvas");
      canvas2.id = props.id || "deckgl-overlay";
      if (props.width && typeof props.width === "number") {
        canvas2.width = props.width;
      }
      if (props.height && typeof props.height === "number") {
        canvas2.height = props.height;
      }
      const parent = props.parent || document.body;
      parent.appendChild(canvas2);
    }
    Object.assign(canvas2.style, props.style);
    return canvas2;
  }
  /** Updates canvas width and/or height, if provided as props */
  _setCanvasSize(props) {
    var _a3;
    if (!this.canvas) {
      return;
    }
    const { width, height } = props;
    if (width || width === 0) {
      const cssWidth = Number.isFinite(width) ? `${width}px` : width;
      this.canvas.style.width = cssWidth;
    }
    if (height || height === 0) {
      const cssHeight = Number.isFinite(height) ? `${height}px` : height;
      this.canvas.style.position = ((_a3 = props.style) == null ? void 0 : _a3.position) || "absolute";
      this.canvas.style.height = cssHeight;
    }
  }
  /** If canvas size has changed, reads out the new size and update */
  _updateCanvasSize() {
    var _a3, _b;
    const { canvas: canvas2 } = this;
    if (!canvas2) {
      return;
    }
    const newWidth = canvas2.clientWidth ?? canvas2.width;
    const newHeight = canvas2.clientHeight ?? canvas2.height;
    if (newWidth !== this.width || newHeight !== this.height) {
      this.width = newWidth;
      this.height = newHeight;
      (_a3 = this.viewManager) == null ? void 0 : _a3.setProps({ width: newWidth, height: newHeight });
      (_b = this.layerManager) == null ? void 0 : _b.activateViewport(this.getViewports()[0]);
      this.props.onResize({ width: newWidth, height: newHeight });
    }
  }
  _createAnimationLoop(deviceOrPromise, props) {
    const {
      // width,
      // height,
      gl,
      // debug,
      onError
      // onBeforeRender,
      // onAfterRender,
    } = props;
    return new AnimationLoop({
      device: deviceOrPromise,
      // TODO v9
      autoResizeDrawingBuffer: !gl,
      // do not auto resize external context
      autoResizeViewport: false,
      // @ts-expect-error luma.gl needs to accept Promise<void> return value
      onInitialize: (context) => this._setDevice(context.device),
      onRender: this._onRenderFrame.bind(this),
      // @ts-expect-error typing mismatch: AnimationLoop does not accept onError:null
      onError
      // onBeforeRender,
      // onAfterRender,
    });
  }
  // Create a device from the deviceProps, assigning required defaults
  _createDevice(props) {
    var _a3, _b, _c;
    const canvasContextUserProps = (_a3 = this.props.deviceProps) == null ? void 0 : _a3.createCanvasContext;
    const canvasContextProps = typeof canvasContextUserProps === "object" ? canvasContextUserProps : void 0;
    const deviceProps = {
      adapters: [],
      _cacheShaders: true,
      _cachePipelines: true,
      ...props.deviceProps
    };
    if (!deviceProps.adapters.includes(webgl2Adapter)) {
      deviceProps.adapters.push(webgl2Adapter);
    }
    const defaultCanvasProps = {
      // we must use 'premultiplied' canvas for webgpu to enable transparency and match shaders
      alphaMode: ((_b = this.props.deviceProps) == null ? void 0 : _b.type) === "webgpu" ? "premultiplied" : void 0
    };
    const userOnResize = (_c = this.props.deviceProps) == null ? void 0 : _c.onResize;
    return luma.createDevice({
      // luma by default throws if a device is already attached
      // asynchronous device creation could happen after finalize() is called
      // TODO - createDevice should support AbortController?
      _reuseDevices: true,
      // tests can't handle WebGPU devices yet so we force WebGL2 unless overridden
      type: "webgl",
      ...deviceProps,
      // In deck.gl v10 we may emphasize multi canvas support and unwind this prop wrapping
      createCanvasContext: {
        ...defaultCanvasProps,
        ...canvasContextProps,
        canvas: this._createCanvas(props),
        useDevicePixels: this.props.useDevicePixels,
        autoResize: true
      },
      onResize: (canvasContext, info) => {
        this._needsRedraw = "Canvas resized";
        userOnResize == null ? void 0 : userOnResize(canvasContext, info);
      }
    });
  }
  // Get the most relevant view state: props.viewState, if supplied, shadows internal viewState
  // TODO: For backwards compatibility ensure numeric width and height is added to the viewState
  _getViewState() {
    return this.props.viewState || this.viewState;
  }
  // Get the view descriptor list
  _getViews() {
    const { views } = this.props;
    const normalizedViews = Array.isArray(views) ? views : (
      // If null, default to a full screen map view port
      views ? [views] : [new map_view_default({ id: "default-view" })]
    );
    if (normalizedViews.length && this.props.controller) {
      normalizedViews[0].props.controller = this.props.controller;
    }
    return normalizedViews;
  }
  _onContextLost() {
    const { onError } = this.props;
    if (this.animationLoop && onError) {
      onError(new Error("WebGL context is lost"));
    }
  }
  /** Actually run picking */
  _pickAndCallback() {
    var _a3, _b, _c, _d;
    if (((_a3 = this.device) == null ? void 0 : _a3.type) === "webgpu") {
      return;
    }
    const { _pickRequest } = this;
    if (_pickRequest.event) {
      const { result, emptyInfo } = this._pick("pickObject", "pickObject Time", _pickRequest);
      this.cursorState.isHovering = result.length > 0;
      let pickedInfo = emptyInfo;
      let handled = false;
      for (const info of result) {
        pickedInfo = info;
        handled = ((_b = info.layer) == null ? void 0 : _b.onHover(info, _pickRequest.event)) || handled;
      }
      if (!handled) {
        (_d = (_c = this.props).onHover) == null ? void 0 : _d.call(_c, pickedInfo, _pickRequest.event);
        this.widgetManager.onHover(pickedInfo, _pickRequest.event);
      }
      _pickRequest.event = null;
    }
  }
  _updateCursor() {
    const container = this.props.parent || this.canvas;
    if (container) {
      container.style.cursor = this.props.getCursor(this.cursorState);
    }
  }
  _setDevice(device) {
    var _a3, _b;
    this.device = device;
    if (!this.animationLoop) {
      return;
    }
    if (!this.canvas) {
      this.canvas = (_a3 = this.device.canvasContext) == null ? void 0 : _a3.canvas;
      if (!this.canvas.isConnected && this.props.parent) {
        this.props.parent.insertBefore(this.canvas, this.props.parent.firstChild);
      }
    }
    if (this.device.type === "webgl") {
      this.device.setParametersWebGL({
        blend: true,
        blendFunc: [770, 771, 1, 771],
        polygonOffsetFill: true,
        depthTest: true,
        depthFunc: 515
      });
    }
    this.props.onDeviceInitialized(this.device);
    if (this.device.type === "webgl") {
      this.props.onWebGLInitialized(this.device.gl);
    }
    const timeline = new Timeline();
    timeline.play();
    this.animationLoop.attachTimeline(timeline);
    this.eventManager = new EventManager(this.props.parent || this.canvas, {
      touchAction: this.props.touchAction,
      recognizers: Object.keys(RECOGNIZERS).map((eventName) => {
        var _a4;
        const [RecognizerConstructor, defaultOptions2, recognizeWith, requestFailure] = RECOGNIZERS[eventName];
        const optionsOverride = (_a4 = this.props.eventRecognizerOptions) == null ? void 0 : _a4[eventName];
        const options = { ...defaultOptions2, ...optionsOverride, event: eventName };
        return {
          recognizer: new RecognizerConstructor(options),
          recognizeWith,
          requestFailure
        };
      }),
      events: {
        pointerdown: this._onPointerDown,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerMove
      }
    });
    for (const eventType in EVENT_HANDLERS) {
      this.eventManager.on(eventType, this._onEvent);
    }
    this.viewManager = new ViewManager({
      timeline,
      eventManager: this.eventManager,
      onViewStateChange: this._onViewStateChange.bind(this),
      onInteractionStateChange: this._onInteractionStateChange.bind(this),
      views: this._getViews(),
      viewState: this._getViewState(),
      width: this.width,
      height: this.height
    });
    const viewport = this.viewManager.getViewports()[0];
    this.layerManager = new LayerManager(this.device, {
      deck: this,
      stats: this.stats,
      viewport,
      timeline
    });
    this.effectManager = new EffectManager({
      deck: this,
      device: this.device
    });
    this.deckRenderer = new DeckRenderer(this.device);
    this.deckPicker = new DeckPicker(this.device);
    this.widgetManager = new WidgetManager({
      deck: this,
      parentElement: (_b = this.canvas) == null ? void 0 : _b.parentElement
    });
    this.widgetManager.addDefault(new TooltipWidget());
    this.setProps(this.props);
    this._updateCanvasSize();
    this.props.onLoad();
  }
  /** Internal only: default render function (redraw all layers and views) */
  _drawLayers(redrawReason, renderOptions) {
    var _a3;
    const { device, gl } = this.layerManager.context;
    this.props.onBeforeRender({ device, gl });
    const opts = {
      target: this.props._framebuffer,
      layers: this.layerManager.getLayers(),
      viewports: this.viewManager.getViewports(),
      onViewportActive: this.layerManager.activateViewport,
      views: this.viewManager.getViews(),
      pass: "screen",
      effects: this.effectManager.getEffects(),
      ...renderOptions
    };
    (_a3 = this.deckRenderer) == null ? void 0 : _a3.renderLayers(opts);
    if (opts.pass === "screen") {
      this.widgetManager.onRedraw({
        viewports: opts.viewports,
        layers: opts.layers
      });
    }
    this.props.onAfterRender({ device, gl });
  }
  // Callbacks
  _onRenderFrame() {
    var _a3;
    this._getFrameStats();
    if (this._metricsCounter++ % 60 === 0) {
      this._getMetrics();
      this.stats.reset();
      log_default.table(4, this.metrics)();
      if (this.props._onMetrics) {
        this.props._onMetrics(this.metrics);
      }
    }
    this._updateCanvasSize();
    this._updateCursor();
    this.layerManager.updateLayers();
    if (((_a3 = this.device) == null ? void 0 : _a3.type) !== "webgpu") {
      this._pickAndCallback();
    }
    this.redraw();
    if (this.viewManager) {
      this.viewManager.updateViewStates();
    }
  }
  // Callbacks
  _onViewStateChange(params) {
    const viewState = this.props.onViewStateChange(params) || params.viewState;
    if (this.viewState) {
      this.viewState = { ...this.viewState, [params.viewId]: viewState };
      if (!this.props.viewState) {
        if (this.viewManager) {
          this.viewManager.setProps({ viewState: this.viewState });
        }
      }
    }
  }
  _onInteractionStateChange(interactionState) {
    this.cursorState.isDragging = interactionState.isDragging || false;
    this.props.onInteractionStateChange(interactionState);
  }
  _getFrameStats() {
    const { stats } = this;
    stats.get("frameRate").timeEnd();
    stats.get("frameRate").timeStart();
    const animationLoopStats = this.animationLoop.stats;
    stats.get("GPU Time").addTime(animationLoopStats.get("GPU Time").lastTiming);
    stats.get("CPU Time").addTime(animationLoopStats.get("CPU Time").lastTiming);
  }
  _getMetrics() {
    const { metrics, stats } = this;
    metrics.fps = stats.get("frameRate").getHz();
    metrics.setPropsTime = stats.get("setProps Time").time;
    metrics.updateAttributesTime = stats.get("Update Attributes").time;
    metrics.framesRedrawn = stats.get("Redraw Count").count;
    metrics.pickTime = stats.get("pickObject Time").time + stats.get("pickMultipleObjects Time").time + stats.get("pickObjects Time").time;
    metrics.pickCount = stats.get("Pick Count").count;
    metrics.gpuTime = stats.get("GPU Time").time;
    metrics.cpuTime = stats.get("CPU Time").time;
    metrics.gpuTimePerFrame = stats.get("GPU Time").getAverageTime();
    metrics.cpuTimePerFrame = stats.get("CPU Time").getAverageTime();
    const memoryStats = luma.stats.get("Memory Usage");
    metrics.bufferMemory = memoryStats.get("Buffer Memory").count;
    metrics.textureMemory = memoryStats.get("Texture Memory").count;
    metrics.renderbufferMemory = memoryStats.get("Renderbuffer Memory").count;
    metrics.gpuMemory = memoryStats.get("GPU Memory").count;
  }
};
Deck.defaultProps = defaultProps;
Deck.VERSION = VERSION4;
var deck_default = Deck;

// node_modules/@deck.gl/core/dist/utils/iterable-utils.js
var EMPTY_ARRAY = [];
var placeholderArray = [];
function createIterable(data, startRow = 0, endRow = Infinity) {
  let iterable = EMPTY_ARRAY;
  const objectInfo = {
    index: -1,
    data,
    // visitor can optionally utilize this to avoid constructing a new array for every object
    target: []
  };
  if (!data) {
    iterable = EMPTY_ARRAY;
  } else if (typeof data[Symbol.iterator] === "function") {
    iterable = data;
  } else if (data.length > 0) {
    placeholderArray.length = data.length;
    iterable = placeholderArray;
  }
  if (startRow > 0 || Number.isFinite(endRow)) {
    iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
    objectInfo.index = startRow - 1;
  }
  return { iterable, objectInfo };
}
function isAsyncIterable2(data) {
  return data && data[Symbol.asyncIterator];
}
function getAccessorFromBuffer(typedArray, options) {
  const { size, stride, offset, startIndices, nested } = options;
  const bytesPerElement = typedArray.BYTES_PER_ELEMENT;
  const elementStride = stride ? stride / bytesPerElement : size;
  const elementOffset = offset ? offset / bytesPerElement : 0;
  const vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);
  return (_2, { index, target }) => {
    if (!startIndices) {
      const sourceIndex = index * elementStride + elementOffset;
      for (let j2 = 0; j2 < size; j2++) {
        target[j2] = typedArray[sourceIndex + j2];
      }
      return target;
    }
    const startIndex = startIndices[index];
    const endIndex = startIndices[index + 1] || vertexCount;
    let result;
    if (nested) {
      result = new Array(endIndex - startIndex);
      for (let i2 = startIndex; i2 < endIndex; i2++) {
        const sourceIndex = i2 * elementStride + elementOffset;
        target = new Array(size);
        for (let j2 = 0; j2 < size; j2++) {
          target[j2] = typedArray[sourceIndex + j2];
        }
        result[i2 - startIndex] = target;
      }
    } else if (elementStride === size) {
      result = typedArray.subarray(startIndex * size + elementOffset, endIndex * size + elementOffset);
    } else {
      result = new typedArray.constructor((endIndex - startIndex) * size);
      let targetIndex = 0;
      for (let i2 = startIndex; i2 < endIndex; i2++) {
        const sourceIndex = i2 * elementStride + elementOffset;
        for (let j2 = 0; j2 < size; j2++) {
          result[targetIndex++] = typedArray[sourceIndex + j2];
        }
      }
    }
    return result;
  };
}

// node_modules/@deck.gl/core/dist/lib/attribute/gl-utils.js
function typedArrayFromDataType(type) {
  switch (type) {
    case "float64":
      return Float64Array;
    case "uint8":
    case "unorm8":
      return Uint8ClampedArray;
    default:
      return getTypedArrayConstructor(type);
  }
}
var dataTypeFromTypedArray = getDataType;
function getBufferAttributeLayout(name, accessor, deviceType) {
  const type = deviceType === "webgpu" && accessor.type === "uint8" ? "unorm8" : accessor.type;
  return {
    attribute: name,
    // @ts-expect-error Not all combinations are valid vertex formats; it's up to DataColumn to ensure
    format: accessor.size > 1 ? `${type}x${accessor.size}` : accessor.type,
    byteOffset: accessor.offset || 0
    // Note stride is set on the top level
  };
}
function getStride(accessor) {
  return accessor.stride || accessor.size * accessor.bytesPerElement;
}
function bufferLayoutEqual(accessor1, accessor2) {
  return accessor1.type === accessor2.type && accessor1.size === accessor2.size && getStride(accessor1) === getStride(accessor2) && (accessor1.offset || 0) === (accessor2.offset || 0);
}

// node_modules/@deck.gl/core/dist/lib/attribute/data-column.js
function resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {
  if (shaderAttributeOptions.offset) {
    log_default.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
  }
  const stride = getStride(baseAccessor);
  const vertexOffset = shaderAttributeOptions.vertexOffset !== void 0 ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;
  const elementOffset = shaderAttributeOptions.elementOffset || 0;
  const offset = (
    // offsets defined by the attribute
    vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + // offsets defined by external buffers if any
    (baseAccessor.offset || 0)
  );
  return {
    ...shaderAttributeOptions,
    offset,
    stride
  };
}
function resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {
  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);
  return {
    high: resolvedOptions,
    low: {
      ...resolvedOptions,
      offset: resolvedOptions.offset + baseAccessor.size * 4
    }
  };
}
var DataColumn = class {
  /* eslint-disable max-statements */
  constructor(device, opts, state) {
    this._buffer = null;
    this.device = device;
    this.id = opts.id || "";
    this.size = opts.size || 1;
    const logicalType = opts.logicalType || opts.type;
    const doublePrecision = logicalType === "float64";
    let { defaultValue } = opts;
    defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);
    let bufferType;
    if (doublePrecision) {
      bufferType = "float32";
    } else if (!logicalType && opts.isIndexed) {
      bufferType = "uint32";
    } else {
      bufferType = logicalType || "float32";
    }
    let defaultType = typedArrayFromDataType(logicalType || bufferType);
    this.doublePrecision = doublePrecision;
    if (doublePrecision && opts.fp64 === false) {
      defaultType = Float32Array;
    }
    this.value = null;
    this.settings = {
      ...opts,
      defaultType,
      defaultValue,
      logicalType,
      type: bufferType,
      normalized: bufferType.includes("norm"),
      size: this.size,
      bytesPerElement: defaultType.BYTES_PER_ELEMENT
    };
    this.state = {
      ...state,
      externalBuffer: null,
      bufferAccessor: this.settings,
      allocatedValue: null,
      numInstances: 0,
      bounds: null,
      constant: false
    };
  }
  /* eslint-enable max-statements */
  get isConstant() {
    return this.state.constant;
  }
  get buffer() {
    return this._buffer;
  }
  get byteOffset() {
    const accessor = this.getAccessor();
    if (accessor.vertexOffset) {
      return accessor.vertexOffset * getStride(accessor);
    }
    return 0;
  }
  get numInstances() {
    return this.state.numInstances;
  }
  set numInstances(n2) {
    this.state.numInstances = n2;
  }
  delete() {
    if (this._buffer) {
      this._buffer.delete();
      this._buffer = null;
    }
    typed_array_manager_default.release(this.state.allocatedValue);
  }
  getBuffer() {
    if (this.state.constant) {
      return null;
    }
    return this.state.externalBuffer || this._buffer;
  }
  getValue(attributeName = this.id, options = null) {
    const result = {};
    if (this.state.constant) {
      const value = this.value;
      if (options) {
        const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);
        const offset = shaderAttributeDef.offset / value.BYTES_PER_ELEMENT;
        const size = shaderAttributeDef.size || this.size;
        result[attributeName] = value.subarray(offset, offset + size);
      } else {
        result[attributeName] = value;
      }
    } else {
      result[attributeName] = this.getBuffer();
    }
    if (this.doublePrecision) {
      if (this.value instanceof Float64Array) {
        result[`${attributeName}64Low`] = result[attributeName];
      } else {
        result[`${attributeName}64Low`] = new Float32Array(this.size);
      }
    }
    return result;
  }
  _getBufferLayout(attributeName = this.id, options = null) {
    const accessor = this.getAccessor();
    const attributes = [];
    const result = {
      name: this.id,
      byteStride: getStride(accessor),
      attributes
    };
    if (this.doublePrecision) {
      const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(accessor, options || {});
      attributes.push(getBufferAttributeLayout(attributeName, { ...accessor, ...doubleShaderAttributeDefs.high }, this.device.type), getBufferAttributeLayout(`${attributeName}64Low`, {
        ...accessor,
        ...doubleShaderAttributeDefs.low
      }, this.device.type));
    } else if (options) {
      const shaderAttributeDef = resolveShaderAttribute(accessor, options);
      attributes.push(getBufferAttributeLayout(attributeName, { ...accessor, ...shaderAttributeDef }, this.device.type));
    } else {
      attributes.push(getBufferAttributeLayout(attributeName, accessor, this.device.type));
    }
    return result;
  }
  setAccessor(accessor) {
    this.state.bufferAccessor = accessor;
  }
  getAccessor() {
    return this.state.bufferAccessor;
  }
  // Returns [min: Array(size), max: Array(size)]
  /* eslint-disable max-depth */
  getBounds() {
    if (this.state.bounds) {
      return this.state.bounds;
    }
    let result = null;
    if (this.state.constant && this.value) {
      const min4 = Array.from(this.value);
      result = [min4, min4];
    } else {
      const { value, numInstances, size } = this;
      const len5 = numInstances * size;
      if (value && len5 && value.length >= len5) {
        const min4 = new Array(size).fill(Infinity);
        const max4 = new Array(size).fill(-Infinity);
        for (let i2 = 0; i2 < len5; ) {
          for (let j2 = 0; j2 < size; j2++) {
            const v2 = value[i2++];
            if (v2 < min4[j2])
              min4[j2] = v2;
            if (v2 > max4[j2])
              max4[j2] = v2;
          }
        }
        result = [min4, max4];
      }
    }
    this.state.bounds = result;
    return result;
  }
  // returns true if success
  // eslint-disable-next-line max-statements
  setData(data) {
    const { state } = this;
    let opts;
    if (ArrayBuffer.isView(data)) {
      opts = { value: data };
    } else if (data instanceof Buffer) {
      opts = { buffer: data };
    } else {
      opts = data;
    }
    const accessor = { ...this.settings, ...opts };
    if (ArrayBuffer.isView(opts.value)) {
      if (!opts.type) {
        const is64Bit = this.doublePrecision && opts.value instanceof Float64Array;
        if (is64Bit) {
          accessor.type = "float32";
        } else {
          const type = dataTypeFromTypedArray(opts.value);
          accessor.type = accessor.normalized ? type.replace("int", "norm") : type;
        }
      }
      accessor.bytesPerElement = opts.value.BYTES_PER_ELEMENT;
      accessor.stride = getStride(accessor);
    }
    state.bounds = null;
    if (opts.constant) {
      let value = opts.value;
      value = this._normalizeValue(value, [], 0);
      if (this.settings.normalized) {
        value = this.normalizeConstant(value);
      }
      const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);
      if (!hasChanged) {
        return false;
      }
      state.externalBuffer = null;
      state.constant = true;
      this.value = ArrayBuffer.isView(value) ? value : new Float32Array(value);
    } else if (opts.buffer) {
      const buffer2 = opts.buffer;
      state.externalBuffer = buffer2;
      state.constant = false;
      this.value = opts.value || null;
    } else if (opts.value) {
      this._checkExternalBuffer(opts);
      let value = opts.value;
      state.externalBuffer = null;
      state.constant = false;
      this.value = value;
      let { buffer: buffer2 } = this;
      const stride = getStride(accessor);
      const byteOffset = (accessor.vertexOffset || 0) * stride;
      if (this.doublePrecision && value instanceof Float64Array) {
        value = toDoublePrecisionArray(value, accessor);
      }
      if (this.settings.isIndexed) {
        const ArrayType = this.settings.defaultType;
        if (value.constructor !== ArrayType) {
          value = new ArrayType(value);
        }
      }
      const requiredBufferSize = value.byteLength + byteOffset + stride * 2;
      if (!buffer2 || buffer2.byteLength < requiredBufferSize) {
        buffer2 = this._createBuffer(requiredBufferSize);
      }
      buffer2.write(value, byteOffset);
    }
    this.setAccessor(accessor);
    return true;
  }
  updateSubBuffer(opts = {}) {
    this.state.bounds = null;
    const value = this.value;
    const { startOffset = 0, endOffset } = opts;
    this.buffer.write(this.doublePrecision && value instanceof Float64Array ? toDoublePrecisionArray(value, {
      size: this.size,
      startIndex: startOffset,
      endIndex: endOffset
    }) : value.subarray(startOffset, endOffset), startOffset * value.BYTES_PER_ELEMENT + this.byteOffset);
  }
  allocate(numInstances, copy7 = false) {
    const { state } = this;
    const oldValue = state.allocatedValue;
    const value = typed_array_manager_default.allocate(oldValue, numInstances + 1, {
      size: this.size,
      type: this.settings.defaultType,
      copy: copy7
    });
    this.value = value;
    const { byteOffset } = this;
    let { buffer: buffer2 } = this;
    if (!buffer2 || buffer2.byteLength < value.byteLength + byteOffset) {
      buffer2 = this._createBuffer(value.byteLength + byteOffset);
      if (copy7 && oldValue) {
        buffer2.write(oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue, byteOffset);
      }
    }
    state.allocatedValue = value;
    state.constant = false;
    state.externalBuffer = null;
    this.setAccessor(this.settings);
    return true;
  }
  // PRIVATE HELPER METHODS
  _checkExternalBuffer(opts) {
    const { value } = opts;
    if (!ArrayBuffer.isView(value)) {
      throw new Error(`Attribute ${this.id} value is not TypedArray`);
    }
    const ArrayType = this.settings.defaultType;
    let illegalArrayType = false;
    if (this.doublePrecision) {
      illegalArrayType = value.BYTES_PER_ELEMENT < 4;
    }
    if (illegalArrayType) {
      throw new Error(`Attribute ${this.id} does not support ${value.constructor.name}`);
    }
    if (!(value instanceof ArrayType) && this.settings.normalized && !("normalized" in opts)) {
      log_default.warn(`Attribute ${this.id} is normalized`)();
    }
  }
  // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
  normalizeConstant(value) {
    switch (this.settings.type) {
      case "snorm8":
        return new Float32Array(value).map((x2) => (x2 + 128) / 255 * 2 - 1);
      case "snorm16":
        return new Float32Array(value).map((x2) => (x2 + 32768) / 65535 * 2 - 1);
      case "unorm8":
        return new Float32Array(value).map((x2) => x2 / 255);
      case "unorm16":
        return new Float32Array(value).map((x2) => x2 / 65535);
      default:
        return value;
    }
  }
  /* check user supplied values and apply fallback */
  _normalizeValue(value, out, start) {
    const { defaultValue, size } = this.settings;
    if (Number.isFinite(value)) {
      out[start] = value;
      return out;
    }
    if (!value) {
      let i2 = size;
      while (--i2 >= 0) {
        out[start + i2] = defaultValue[i2];
      }
      return out;
    }
    switch (size) {
      case 4:
        out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];
      case 3:
        out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];
      case 2:
        out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];
      case 1:
        out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];
        break;
      default:
        let i2 = size;
        while (--i2 >= 0) {
          out[start + i2] = Number.isFinite(value[i2]) ? value[i2] : defaultValue[i2];
        }
    }
    return out;
  }
  _areValuesEqual(value1, value2) {
    if (!value1 || !value2) {
      return false;
    }
    const { size } = this;
    for (let i2 = 0; i2 < size; i2++) {
      if (value1[i2] !== value2[i2]) {
        return false;
      }
    }
    return true;
  }
  _createBuffer(byteLength) {
    var _a3;
    if (this._buffer) {
      this._buffer.destroy();
    }
    const { isIndexed, type } = this.settings;
    this._buffer = this.device.createBuffer({
      ...(_a3 = this._buffer) == null ? void 0 : _a3.props,
      id: this.id,
      // TODO(ibgreen) - WebGPU requires COPY_DST and COPY_SRC to allow write / read
      usage: (isIndexed ? Buffer.INDEX : Buffer.VERTEX) | Buffer.COPY_DST,
      indexType: isIndexed ? type : void 0,
      byteLength
    });
    return this._buffer;
  }
};

// node_modules/@deck.gl/core/dist/utils/range.js
var EMPTY = [];
var FULL = [[0, Infinity]];
function add7(rangeList, range) {
  if (rangeList === FULL) {
    return rangeList;
  }
  if (range[0] < 0) {
    range[0] = 0;
  }
  if (range[0] >= range[1]) {
    return rangeList;
  }
  const newRangeList = [];
  const len5 = rangeList.length;
  let insertPosition = 0;
  for (let i2 = 0; i2 < len5; i2++) {
    const range0 = rangeList[i2];
    if (range0[1] < range[0]) {
      newRangeList.push(range0);
      insertPosition = i2 + 1;
    } else if (range0[0] > range[1]) {
      newRangeList.push(range0);
    } else {
      range = [Math.min(range0[0], range[0]), Math.max(range0[1], range[1])];
    }
  }
  newRangeList.splice(insertPosition, 0, range);
  return newRangeList;
}

// node_modules/@deck.gl/core/dist/lib/attribute/transition-settings.js
var DEFAULT_TRANSITION_SETTINGS = {
  interpolation: {
    duration: 0,
    easing: (t2) => t2
  },
  spring: {
    stiffness: 0.05,
    damping: 0.5
  }
};
function normalizeTransitionSettings(userSettings, layerSettings) {
  if (!userSettings) {
    return null;
  }
  if (Number.isFinite(userSettings)) {
    userSettings = { type: "interpolation", duration: userSettings };
  }
  const type = userSettings.type || "interpolation";
  return {
    ...DEFAULT_TRANSITION_SETTINGS[type],
    ...layerSettings,
    ...userSettings,
    type
  };
}

// node_modules/@deck.gl/core/dist/lib/attribute/attribute.js
var Attribute = class extends DataColumn {
  constructor(device, opts) {
    super(device, opts, {
      startIndices: null,
      lastExternalBuffer: null,
      binaryValue: null,
      binaryAccessor: null,
      needsUpdate: true,
      needsRedraw: false,
      layoutChanged: false,
      updateRanges: FULL
    });
    this.constant = false;
    this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : void 0);
    Object.seal(this.settings);
    Object.seal(this.state);
    this._validateAttributeUpdaters();
  }
  get startIndices() {
    return this.state.startIndices;
  }
  set startIndices(layout) {
    this.state.startIndices = layout;
  }
  needsUpdate() {
    return this.state.needsUpdate;
  }
  needsRedraw({ clearChangedFlags = false } = {}) {
    const needsRedraw = this.state.needsRedraw;
    this.state.needsRedraw = needsRedraw && !clearChangedFlags;
    return needsRedraw;
  }
  layoutChanged() {
    return this.state.layoutChanged;
  }
  setAccessor(accessor) {
    var _a3;
    (_a3 = this.state).layoutChanged || (_a3.layoutChanged = !bufferLayoutEqual(accessor, this.getAccessor()));
    super.setAccessor(accessor);
  }
  getUpdateTriggers() {
    const { accessor } = this.settings;
    return [this.id].concat(typeof accessor !== "function" && accessor || []);
  }
  supportsTransition() {
    return Boolean(this.settings.transition);
  }
  // Resolve transition settings object if transition is enabled, otherwise `null`
  getTransitionSetting(opts) {
    if (!opts || !this.supportsTransition()) {
      return null;
    }
    const { accessor } = this.settings;
    const layerSettings = this.settings.transition;
    const userSettings = Array.isArray(accessor) ? (
      // @ts-ignore
      opts[accessor.find((a2) => opts[a2])]
    ) : (
      // @ts-ignore
      opts[accessor]
    );
    return normalizeTransitionSettings(userSettings, layerSettings);
  }
  setNeedsUpdate(reason = this.id, dataRange) {
    this.state.needsUpdate = this.state.needsUpdate || reason;
    this.setNeedsRedraw(reason);
    if (dataRange) {
      const { startRow = 0, endRow = Infinity } = dataRange;
      this.state.updateRanges = add7(this.state.updateRanges, [startRow, endRow]);
    } else {
      this.state.updateRanges = FULL;
    }
  }
  clearNeedsUpdate() {
    this.state.needsUpdate = false;
    this.state.updateRanges = EMPTY;
  }
  setNeedsRedraw(reason = this.id) {
    this.state.needsRedraw = this.state.needsRedraw || reason;
  }
  allocate(numInstances) {
    const { state, settings } = this;
    if (settings.noAlloc) {
      return false;
    }
    if (settings.update) {
      super.allocate(numInstances, state.updateRanges !== FULL);
      return true;
    }
    return false;
  }
  updateBuffer({ numInstances, data, props, context }) {
    if (!this.needsUpdate()) {
      return false;
    }
    const { state: { updateRanges }, settings: { update, noAlloc } } = this;
    let updated = true;
    if (update) {
      for (const [startRow, endRow] of updateRanges) {
        update.call(context, this, { data, startRow, endRow, props, numInstances });
      }
      if (!this.value) {
      } else if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {
        this.setData({
          value: this.value,
          constant: this.constant
        });
        this.constant = false;
      } else {
        for (const [startRow, endRow] of updateRanges) {
          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;
          const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
          super.updateSubBuffer({ startOffset, endOffset });
        }
      }
      this._checkAttributeArray();
    } else {
      updated = false;
    }
    this.clearNeedsUpdate();
    this.setNeedsRedraw();
    return updated;
  }
  // Use generic value
  // Returns true if successful
  setConstantValue(context, value) {
    const isWebGPU = this.device.type === "webgpu";
    if (isWebGPU || value === void 0 || typeof value === "function") {
      if (isWebGPU && typeof value !== "function") {
        const normalisedValue = this._normalizeValue(value, [], 0);
        if (!this._areValuesEqual(normalisedValue, this.value)) {
          this.setNeedsUpdate("WebGPU constant updated");
        }
      }
      return false;
    }
    const transformedValue = this.settings.transform && context ? this.settings.transform.call(context, value) : value;
    const hasChanged = this.setData({ constant: true, value: transformedValue });
    if (hasChanged) {
      this.setNeedsRedraw();
    }
    this.clearNeedsUpdate();
    return true;
  }
  // Use external buffer
  // Returns true if successful
  // eslint-disable-next-line max-statements
  setExternalBuffer(buffer2) {
    const { state } = this;
    if (!buffer2) {
      state.lastExternalBuffer = null;
      return false;
    }
    this.clearNeedsUpdate();
    if (state.lastExternalBuffer === buffer2) {
      return true;
    }
    state.lastExternalBuffer = buffer2;
    this.setNeedsRedraw();
    this.setData(buffer2);
    return true;
  }
  // Binary value is a typed array packed from mapping the source data with the accessor
  // If the returned value from the accessor is the same as the attribute value, set it directly
  // Otherwise use the auto updater for transform/normalization
  setBinaryValue(buffer2, startIndices = null) {
    const { state, settings } = this;
    if (!buffer2) {
      state.binaryValue = null;
      state.binaryAccessor = null;
      return false;
    }
    if (settings.noAlloc) {
      return false;
    }
    if (state.binaryValue === buffer2) {
      this.clearNeedsUpdate();
      return true;
    }
    state.binaryValue = buffer2;
    this.setNeedsRedraw();
    const needsUpdate = settings.transform || startIndices !== this.startIndices;
    if (needsUpdate) {
      if (ArrayBuffer.isView(buffer2)) {
        buffer2 = { value: buffer2 };
      }
      const binaryValue = buffer2;
      assert6(ArrayBuffer.isView(binaryValue.value), `invalid ${settings.accessor}`);
      const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;
      state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {
        size: binaryValue.size || this.size,
        stride: binaryValue.stride,
        offset: binaryValue.offset,
        startIndices,
        nested: needsNormalize
      });
      return false;
    }
    this.clearNeedsUpdate();
    this.setData(buffer2);
    return true;
  }
  getVertexOffset(row) {
    const { startIndices } = this;
    const vertexIndex = startIndices ? row < startIndices.length ? startIndices[row] : this.numInstances : row;
    return vertexIndex * this.size;
  }
  getValue() {
    const shaderAttributeDefs = this.settings.shaderAttributes;
    const result = super.getValue();
    if (!shaderAttributeDefs) {
      return result;
    }
    for (const shaderAttributeName in shaderAttributeDefs) {
      Object.assign(result, super.getValue(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));
    }
    return result;
  }
  /** Generate WebGPU-style buffer layout descriptor from this attribute */
  getBufferLayout(modelInfo) {
    this.state.layoutChanged = false;
    const shaderAttributeDefs = this.settings.shaderAttributes;
    const result = super._getBufferLayout();
    const { stepMode } = this.settings;
    if (stepMode === "dynamic") {
      result.stepMode = modelInfo ? modelInfo.isInstanced ? "instance" : "vertex" : "instance";
    } else {
      result.stepMode = stepMode ?? "vertex";
    }
    if (!shaderAttributeDefs) {
      return result;
    }
    for (const shaderAttributeName in shaderAttributeDefs) {
      const map2 = super._getBufferLayout(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]);
      result.attributes.push(...map2.attributes);
    }
    return result;
  }
  /* eslint-disable max-depth, max-statements */
  _autoUpdater(attribute, { data, startRow, endRow, props, numInstances }) {
    if (attribute.constant) {
      if (this.context.device.type !== "webgpu") {
        return;
      }
    }
    const { settings, state, value, size, startIndices } = attribute;
    const { accessor, transform } = settings;
    let accessorFunc = state.binaryAccessor || // @ts-ignore
    (typeof accessor === "function" ? accessor : props[accessor]);
    if (typeof accessorFunc !== "function" && typeof accessor === "string") {
      accessorFunc = () => props[accessor];
    }
    assert6(typeof accessorFunc === "function", `accessor "${accessor}" is not a function`);
    let i2 = attribute.getVertexOffset(startRow);
    const { iterable, objectInfo } = createIterable(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      let objectValue = accessorFunc(object, objectInfo);
      if (transform) {
        objectValue = transform.call(this, objectValue);
      }
      if (startIndices) {
        const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];
        if (objectValue && Array.isArray(objectValue[0])) {
          let startIndex = i2;
          for (const item of objectValue) {
            attribute._normalizeValue(item, value, startIndex);
            startIndex += size;
          }
        } else if (objectValue && objectValue.length > size) {
          value.set(objectValue, i2);
        } else {
          attribute._normalizeValue(objectValue, objectInfo.target, 0);
          fillArray({
            target: value,
            source: objectInfo.target,
            start: i2,
            count: numVertices
          });
        }
        i2 += numVertices * size;
      } else {
        attribute._normalizeValue(objectValue, value, i2);
        i2 += size;
      }
    }
  }
  /* eslint-enable max-depth, max-statements */
  // Validate deck.gl level fields
  _validateAttributeUpdaters() {
    const { settings } = this;
    const hasUpdater = settings.noAlloc || typeof settings.update === "function";
    if (!hasUpdater) {
      throw new Error(`Attribute ${this.id} missing update or accessor`);
    }
  }
  // check that the first few elements of the attribute are reasonable
  /* eslint-disable no-fallthrough */
  _checkAttributeArray() {
    const { value } = this;
    const limit = Math.min(4, this.size);
    if (value && value.length >= limit) {
      let valid = true;
      switch (limit) {
        case 4:
          valid = valid && Number.isFinite(value[3]);
        case 3:
          valid = valid && Number.isFinite(value[2]);
        case 2:
          valid = valid && Number.isFinite(value[1]);
        case 1:
          valid = valid && Number.isFinite(value[0]);
          break;
        default:
          valid = false;
      }
      if (!valid) {
        throw new Error(`Illegal attribute generated for ${this.id}`);
      }
    }
  }
};

// node_modules/@deck.gl/core/dist/utils/array-utils.js
function padArrayChunk(options) {
  const { source: source6, target, start = 0, size, getData } = options;
  const end = options.end || target.length;
  const sourceLength = source6.length;
  const targetLength = end - start;
  if (sourceLength > targetLength) {
    target.set(source6.subarray(0, targetLength), start);
    return;
  }
  target.set(source6, start);
  if (!getData) {
    return;
  }
  let i2 = sourceLength;
  while (i2 < targetLength) {
    const datum = getData(i2, source6);
    for (let j2 = 0; j2 < size; j2++) {
      target[start + i2] = datum[j2] || 0;
      i2++;
    }
  }
}
function padArray({ source: source6, target, size, getData, sourceStartIndices, targetStartIndices }) {
  if (!sourceStartIndices || !targetStartIndices) {
    padArrayChunk({
      source: source6,
      target,
      size,
      getData
    });
    return target;
  }
  let sourceIndex = 0;
  let targetIndex = 0;
  const getChunkData = getData && ((i2, chunk) => getData(i2 + targetIndex, chunk));
  const n2 = Math.min(sourceStartIndices.length, targetStartIndices.length);
  for (let i2 = 1; i2 < n2; i2++) {
    const nextSourceIndex = sourceStartIndices[i2] * size;
    const nextTargetIndex = targetStartIndices[i2] * size;
    padArrayChunk({
      source: source6.subarray(sourceIndex, nextSourceIndex),
      target,
      start: targetIndex,
      end: nextTargetIndex,
      size,
      getData: getChunkData
    });
    sourceIndex = nextSourceIndex;
    targetIndex = nextTargetIndex;
  }
  if (targetIndex < target.length) {
    padArrayChunk({
      // @ts-ignore
      source: [],
      target,
      start: targetIndex,
      size,
      getData: getChunkData
    });
  }
  return target;
}

// node_modules/@deck.gl/core/dist/transitions/gpu-transition-utils.js
function cloneAttribute(attribute) {
  const { device, settings, value } = attribute;
  const newAttribute = new Attribute(device, settings);
  newAttribute.setData({
    value: value instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),
    normalized: settings.normalized
  });
  return newAttribute;
}
function getAttributeTypeFromSize(size) {
  switch (size) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`No defined attribute type for size "${size}"`);
  }
}
function getFloat32VertexFormat(size) {
  switch (size) {
    case 1:
      return "float32";
    case 2:
      return "float32x2";
    case 3:
      return "float32x3";
    case 4:
      return "float32x4";
    default:
      throw new Error("invalid type size");
  }
}
function cycleBuffers(buffers) {
  buffers.push(buffers.shift());
}
function getAttributeBufferLength(attribute, numInstances) {
  const { doublePrecision, settings, value, size } = attribute;
  const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;
  let maxVertexOffset = 0;
  const { shaderAttributes } = attribute.settings;
  if (shaderAttributes) {
    for (const shaderAttribute of Object.values(shaderAttributes)) {
      maxVertexOffset = Math.max(maxVertexOffset, shaderAttribute.vertexOffset ?? 0);
    }
  }
  return (settings.noAlloc ? value.length : (numInstances + maxVertexOffset) * size) * multiplier;
}
function matchBuffer({ device, source: source6, target }) {
  if (!target || target.byteLength < source6.byteLength) {
    target == null ? void 0 : target.destroy();
    target = device.createBuffer({
      byteLength: source6.byteLength,
      usage: source6.usage
    });
  }
  return target;
}
function padBuffer({ device, buffer: buffer2, attribute, fromLength, toLength, fromStartIndices, getData = (x2) => x2 }) {
  const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;
  const size = attribute.size * precisionMultiplier;
  const byteOffset = attribute.byteOffset;
  const targetByteOffset = attribute.settings.bytesPerElement < 4 ? byteOffset / attribute.settings.bytesPerElement * 4 : byteOffset;
  const toStartIndices = attribute.startIndices;
  const hasStartIndices = fromStartIndices && toStartIndices;
  const isConstant = attribute.isConstant;
  if (!hasStartIndices && buffer2 && fromLength >= toLength) {
    return buffer2;
  }
  const ArrayType = attribute.value instanceof Float64Array ? Float32Array : attribute.value.constructor;
  const toData = isConstant ? attribute.value : (
    // TODO(v9.1): Avoid non-portable synchronous reads.
    new ArrayType(attribute.getBuffer().readSyncWebGL(byteOffset, toLength * ArrayType.BYTES_PER_ELEMENT).buffer)
  );
  if (attribute.settings.normalized && !isConstant) {
    const getter = getData;
    getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));
  }
  const getMissingData = isConstant ? (i2, chunk) => getData(toData, chunk) : (i2, chunk) => getData(toData.subarray(i2 + byteOffset, i2 + byteOffset + size), chunk);
  const source6 = buffer2 ? new Float32Array(buffer2.readSyncWebGL(targetByteOffset, fromLength * 4).buffer) : new Float32Array(0);
  const target = new Float32Array(toLength);
  padArray({
    source: source6,
    target,
    sourceStartIndices: fromStartIndices,
    targetStartIndices: toStartIndices,
    size,
    getData: getMissingData
  });
  if (!buffer2 || buffer2.byteLength < target.byteLength + targetByteOffset) {
    buffer2 == null ? void 0 : buffer2.destroy();
    buffer2 = device.createBuffer({
      byteLength: target.byteLength + targetByteOffset,
      usage: 35050
    });
  }
  buffer2.write(target, targetByteOffset);
  return buffer2;
}

// node_modules/@deck.gl/core/dist/transitions/gpu-transition.js
var GPUTransitionBase = class {
  constructor({ device, attribute, timeline }) {
    this.buffers = [];
    this.currentLength = 0;
    this.device = device;
    this.transition = new Transition(timeline);
    this.attribute = attribute;
    this.attributeInTransition = cloneAttribute(attribute);
    this.currentStartIndices = attribute.startIndices;
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(transitionSettings, numInstances, duration = Infinity) {
    this.settings = transitionSettings;
    this.currentStartIndices = this.attribute.startIndices;
    this.currentLength = getAttributeBufferLength(this.attribute, numInstances);
    this.transition.start({ ...transitionSettings, duration });
  }
  update() {
    const updated = this.transition.update();
    if (updated) {
      this.onUpdate();
    }
    return updated;
  }
  setBuffer(buffer2) {
    this.attributeInTransition.setData({
      buffer: buffer2,
      normalized: this.attribute.settings.normalized,
      // Retain placeholder value to generate correct shader layout
      value: this.attributeInTransition.value
    });
  }
  cancel() {
    this.transition.cancel();
  }
  delete() {
    this.cancel();
    for (const buffer2 of this.buffers) {
      buffer2.destroy();
    }
    this.buffers.length = 0;
  }
};

// node_modules/@deck.gl/core/dist/transitions/gpu-interpolation-transition.js
var GPUInterpolationTransition = class extends GPUTransitionBase {
  constructor({ device, attribute, timeline }) {
    super({ device, attribute, timeline });
    this.type = "interpolation";
    this.transform = getTransform(device, attribute);
  }
  start(transitionSettings, numInstances) {
    const prevLength = this.currentLength;
    const prevStartIndices = this.currentStartIndices;
    super.start(transitionSettings, numInstances, transitionSettings.duration);
    if (transitionSettings.duration <= 0) {
      this.transition.cancel();
      return;
    }
    const { buffers, attribute } = this;
    cycleBuffers(buffers);
    buffers[0] = padBuffer({
      device: this.device,
      buffer: buffers[0],
      attribute,
      fromLength: prevLength,
      toLength: this.currentLength,
      fromStartIndices: prevStartIndices,
      getData: transitionSettings.enter
    });
    buffers[1] = matchBuffer({
      device: this.device,
      source: buffers[0],
      target: buffers[1]
    });
    this.setBuffer(buffers[1]);
    const { transform } = this;
    const model = transform.model;
    let vertexCount = Math.floor(this.currentLength / attribute.size);
    if (useFp64(attribute)) {
      vertexCount /= 2;
    }
    model.setVertexCount(vertexCount);
    if (attribute.isConstant) {
      model.setAttributes({ aFrom: buffers[0] });
      model.setConstantAttributes({ aTo: attribute.value });
    } else {
      model.setAttributes({
        aFrom: buffers[0],
        aTo: attribute.getBuffer()
      });
    }
    transform.transformFeedback.setBuffers({ vCurrent: buffers[1] });
  }
  onUpdate() {
    const { duration, easing } = this.settings;
    const { time } = this.transition;
    let t2 = time / duration;
    if (easing) {
      t2 = easing(t2);
    }
    const { model } = this.transform;
    const interpolationProps = { time: t2 };
    model.shaderInputs.setProps({ interpolation: interpolationProps });
    this.transform.run({ discard: true });
  }
  delete() {
    super.delete();
    this.transform.destroy();
  }
};
var uniformBlock3 = `uniform interpolationUniforms {
  float time;
} interpolation;
`;
var interpolationUniforms = {
  name: "interpolation",
  vs: uniformBlock3,
  uniformTypes: {
    time: "f32"
  }
};
var vs8 = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, interpolation.time);
  gl_Position = vec4(0.0);
}
`;
var vs64 = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aFrom64Low;
in ATTRIBUTE_TYPE aTo;
in ATTRIBUTE_TYPE aTo64Low;
out ATTRIBUTE_TYPE vCurrent;
out ATTRIBUTE_TYPE vCurrent64Low;

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

void main(void) {
  for (int i=0; i<ATTRIBUTE_SIZE; i++) {
    vec2 value = mix_fp64(vec2(aFrom[i], aFrom64Low[i]), vec2(aTo[i], aTo64Low[i]), interpolation.time);
    vCurrent[i] = value.x;
    vCurrent64Low[i] = value.y;
  }
  gl_Position = vec4(0.0);
}
`;
function useFp64(attribute) {
  return attribute.doublePrecision && attribute.value instanceof Float64Array;
}
function getTransform(device, attribute) {
  const attributeSize = attribute.size;
  const attributeType = getAttributeTypeFromSize(attributeSize);
  const inputFormat = getFloat32VertexFormat(attributeSize);
  const bufferLayout = attribute.getBufferLayout();
  if (useFp64(attribute)) {
    return new BufferTransform(device, {
      vs: vs64,
      bufferLayout: [
        {
          name: "aFrom",
          byteStride: 8 * attributeSize,
          attributes: [
            { attribute: "aFrom", format: inputFormat, byteOffset: 0 },
            { attribute: "aFrom64Low", format: inputFormat, byteOffset: 4 * attributeSize }
          ]
        },
        {
          name: "aTo",
          byteStride: 8 * attributeSize,
          attributes: [
            { attribute: "aTo", format: inputFormat, byteOffset: 0 },
            { attribute: "aTo64Low", format: inputFormat, byteOffset: 4 * attributeSize }
          ]
        }
      ],
      // @ts-expect-error fp64 module only sets ONE uniform via defaultUniforms
      modules: [fp64arithmetic, interpolationUniforms],
      defines: {
        // @ts-expect-error TODO fix luma type
        ATTRIBUTE_TYPE: attributeType,
        // @ts-expect-error TODO fix luma type
        ATTRIBUTE_SIZE: attributeSize
      },
      // Default uniforms are not set without this
      moduleSettings: {},
      varyings: ["vCurrent", "vCurrent64Low"],
      bufferMode: 35980,
      disableWarnings: true
    });
  }
  return new BufferTransform(device, {
    vs: vs8,
    bufferLayout: [
      { name: "aFrom", format: inputFormat },
      { name: "aTo", format: bufferLayout.attributes[0].format }
    ],
    modules: [interpolationUniforms],
    defines: {
      // @ts-expect-error TODO fix luma type
      ATTRIBUTE_TYPE: attributeType
    },
    varyings: ["vCurrent"],
    // TODO investigate why this is needed
    disableWarnings: true
  });
}

// node_modules/@deck.gl/core/dist/transitions/gpu-spring-transition.js
var GPUSpringTransition = class extends GPUTransitionBase {
  constructor({ device, attribute, timeline }) {
    super({ device, attribute, timeline });
    this.type = "spring";
    this.texture = getTexture(device);
    this.framebuffer = getFramebuffer(device, this.texture);
    this.transform = getTransform2(device, attribute);
  }
  start(transitionSettings, numInstances) {
    const prevLength = this.currentLength;
    const prevStartIndices = this.currentStartIndices;
    super.start(transitionSettings, numInstances);
    const { buffers, attribute } = this;
    for (let i2 = 0; i2 < 2; i2++) {
      buffers[i2] = padBuffer({
        device: this.device,
        buffer: buffers[i2],
        attribute,
        fromLength: prevLength,
        toLength: this.currentLength,
        fromStartIndices: prevStartIndices,
        getData: transitionSettings.enter
      });
    }
    buffers[2] = matchBuffer({
      device: this.device,
      source: buffers[0],
      target: buffers[2]
    });
    this.setBuffer(buffers[1]);
    const { model } = this.transform;
    model.setVertexCount(Math.floor(this.currentLength / attribute.size));
    if (attribute.isConstant) {
      model.setConstantAttributes({ aTo: attribute.value });
    } else {
      model.setAttributes({ aTo: attribute.getBuffer() });
    }
  }
  onUpdate() {
    const { buffers, transform, framebuffer, transition } = this;
    const settings = this.settings;
    transform.model.setAttributes({
      aPrev: buffers[0],
      aCur: buffers[1]
    });
    transform.transformFeedback.setBuffers({ vNext: buffers[2] });
    const springProps = {
      stiffness: settings.stiffness,
      damping: settings.damping
    };
    transform.model.shaderInputs.setProps({ spring: springProps });
    transform.run({
      framebuffer,
      discard: false,
      parameters: { viewport: [0, 0, 1, 1] },
      clearColor: [0, 0, 0, 0]
    });
    cycleBuffers(buffers);
    this.setBuffer(buffers[1]);
    const isTransitioning = this.device.readPixelsToArrayWebGL(framebuffer)[0] > 0;
    if (!isTransitioning) {
      transition.end();
    }
  }
  delete() {
    super.delete();
    this.transform.destroy();
    this.texture.destroy();
    this.framebuffer.destroy();
  }
};
var uniformBlock4 = `uniform springUniforms {
  float damping;
  float stiffness;
} spring;
`;
var springUniforms = {
  name: "spring",
  vs: uniformBlock4,
  uniformTypes: {
    damping: "f32",
    stiffness: "f32"
  }
};
var vs9 = `#version 300 es
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

in ATTRIBUTE_TYPE aPrev;
in ATTRIBUTE_TYPE aCur;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vNext;
out float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE force = delta * spring.stiffness;
  ATTRIBUTE_TYPE resistance = velocity * spring.damping;
  return force - resistance + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`;
var fs7 = `#version 300 es
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

in float vIsTransitioningFlag;

out vec4 fragColor;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  fragColor = vec4(1.0);
}`;
function getTransform2(device, attribute) {
  const attributeType = getAttributeTypeFromSize(attribute.size);
  const format = getFloat32VertexFormat(attribute.size);
  return new BufferTransform(device, {
    vs: vs9,
    fs: fs7,
    bufferLayout: [
      { name: "aPrev", format },
      { name: "aCur", format },
      { name: "aTo", format: attribute.getBufferLayout().attributes[0].format }
    ],
    varyings: ["vNext"],
    modules: [springUniforms],
    // @ts-expect-error TODO fix luma type
    defines: { ATTRIBUTE_TYPE: attributeType },
    parameters: {
      depthCompare: "always",
      blendColorOperation: "max",
      blendColorSrcFactor: "one",
      blendColorDstFactor: "one",
      blendAlphaOperation: "max",
      blendAlphaSrcFactor: "one",
      blendAlphaDstFactor: "one"
    }
  });
}
function getTexture(device) {
  return device.createTexture({
    data: new Uint8Array(4),
    format: "rgba8unorm",
    width: 1,
    height: 1
  });
}
function getFramebuffer(device, texture) {
  return device.createFramebuffer({
    id: "spring-transition-is-transitioning-framebuffer",
    width: 1,
    height: 1,
    colorAttachments: [texture]
  });
}

// node_modules/@deck.gl/core/dist/lib/attribute/attribute-transition-manager.js
var TRANSITION_TYPES = {
  interpolation: GPUInterpolationTransition,
  spring: GPUSpringTransition
};
var AttributeTransitionManager = class {
  constructor(device, { id, timeline }) {
    if (!device)
      throw new Error("AttributeTransitionManager is constructed without device");
    this.id = id;
    this.device = device;
    this.timeline = timeline;
    this.transitions = {};
    this.needsRedraw = false;
    this.numInstances = 1;
  }
  finalize() {
    for (const attributeName in this.transitions) {
      this._removeTransition(attributeName);
    }
  }
  /* Public methods */
  // Called when attribute manager updates
  // Check the latest attributes for updates.
  update({ attributes, transitions, numInstances }) {
    this.numInstances = numInstances || 1;
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const settings = attribute.getTransitionSetting(transitions);
      if (!settings)
        continue;
      this._updateAttribute(attributeName, attribute, settings);
    }
    for (const attributeName in this.transitions) {
      const attribute = attributes[attributeName];
      if (!attribute || !attribute.getTransitionSetting(transitions)) {
        this._removeTransition(attributeName);
      }
    }
  }
  // Returns `true` if attribute is transition-enabled
  hasAttribute(attributeName) {
    const transition = this.transitions[attributeName];
    return transition && transition.inProgress;
  }
  // Get all the animated attributes
  getAttributes() {
    const animatedAttributes = {};
    for (const attributeName in this.transitions) {
      const transition = this.transitions[attributeName];
      if (transition.inProgress) {
        animatedAttributes[attributeName] = transition.attributeInTransition;
      }
    }
    return animatedAttributes;
  }
  /* eslint-disable max-statements */
  // Called every render cycle, run transform feedback
  // Returns `true` if anything changes
  run() {
    if (this.numInstances === 0) {
      return false;
    }
    for (const attributeName in this.transitions) {
      const updated = this.transitions[attributeName].update();
      if (updated) {
        this.needsRedraw = true;
      }
    }
    const needsRedraw = this.needsRedraw;
    this.needsRedraw = false;
    return needsRedraw;
  }
  /* eslint-enable max-statements */
  /* Private methods */
  _removeTransition(attributeName) {
    this.transitions[attributeName].delete();
    delete this.transitions[attributeName];
  }
  // Check an attributes for updates
  // Returns a transition object if a new transition is triggered.
  _updateAttribute(attributeName, attribute, settings) {
    const transition = this.transitions[attributeName];
    let isNew = !transition || transition.type !== settings.type;
    if (isNew) {
      if (transition) {
        this._removeTransition(attributeName);
      }
      const TransitionType = TRANSITION_TYPES[settings.type];
      if (TransitionType) {
        this.transitions[attributeName] = new TransitionType({
          attribute,
          timeline: this.timeline,
          device: this.device
        });
      } else {
        log_default.error(`unsupported transition type '${settings.type}'`)();
        isNew = false;
      }
    }
    if (isNew || attribute.needsRedraw()) {
      this.needsRedraw = true;
      this.transitions[attributeName].start(settings, this.numInstances);
    }
  }
};

// node_modules/@deck.gl/core/dist/lib/attribute/attribute-manager.js
var TRACE_INVALIDATE = "attributeManager.invalidate";
var TRACE_UPDATE_START = "attributeManager.updateStart";
var TRACE_UPDATE_END = "attributeManager.updateEnd";
var TRACE_ATTRIBUTE_UPDATE_START = "attribute.updateStart";
var TRACE_ATTRIBUTE_ALLOCATE = "attribute.allocate";
var TRACE_ATTRIBUTE_UPDATE_END = "attribute.updateEnd";
var AttributeManager = class {
  constructor(device, { id = "attribute-manager", stats, timeline } = {}) {
    this.mergeBoundsMemoized = memoize(mergeBounds);
    this.id = id;
    this.device = device;
    this.attributes = {};
    this.updateTriggers = {};
    this.needsRedraw = true;
    this.userData = {};
    this.stats = stats;
    this.attributeTransitionManager = new AttributeTransitionManager(device, {
      id: `${id}-transitions`,
      timeline
    });
    Object.seal(this);
  }
  finalize() {
    for (const attributeName in this.attributes) {
      this.attributes[attributeName].delete();
    }
    this.attributeTransitionManager.finalize();
  }
  // Returns the redraw flag, optionally clearing it.
  // Redraw flag will be set if any attributes attributes changed since
  // flag was last cleared.
  //
  // @param {String} [clearRedrawFlags=false] - whether to clear the flag
  // @return {false|String} - reason a redraw is needed.
  getNeedsRedraw(opts = { clearRedrawFlags: false }) {
    const redraw = this.needsRedraw;
    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
    return redraw && this.id;
  }
  // Sets the redraw flag.
  // @param {Boolean} redraw=true
  setNeedsRedraw() {
    this.needsRedraw = true;
  }
  // Adds attributes
  add(attributes) {
    this._add(attributes);
  }
  // Adds attributes
  addInstanced(attributes) {
    this._add(attributes, { stepMode: "instance" });
  }
  /**
   * Removes attributes
   * Takes an array of attribute names and delete them from
   * the attribute map if they exists
   *
   * @example
   * attributeManager.remove(['position']);
   *
   * @param {Object} attributeNameArray - attribute name array (see above)
   */
  remove(attributeNameArray) {
    for (const name of attributeNameArray) {
      if (this.attributes[name] !== void 0) {
        this.attributes[name].delete();
        delete this.attributes[name];
      }
    }
  }
  // Marks an attribute for update
  invalidate(triggerName, dataRange) {
    const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);
    debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);
  }
  invalidateAll(dataRange) {
    for (const attributeName in this.attributes) {
      this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
    }
    debug(TRACE_INVALIDATE, this, "all");
  }
  // Ensure all attribute buffers are updated from props or data.
  // eslint-disable-next-line complexity
  update({ data, numInstances, startIndices = null, transitions, props = {}, buffers = {}, context = {} }) {
    let updated = false;
    debug(TRACE_UPDATE_START, this);
    if (this.stats) {
      this.stats.get("Update Attributes").timeStart();
    }
    for (const attributeName in this.attributes) {
      const attribute = this.attributes[attributeName];
      const accessorName = attribute.settings.accessor;
      attribute.startIndices = startIndices;
      attribute.numInstances = numInstances;
      if (props[attributeName]) {
        log_default.removed(`props.${attributeName}`, `data.attributes.${attributeName}`)();
      }
      if (attribute.setExternalBuffer(buffers[attributeName])) {
      } else if (attribute.setBinaryValue(typeof accessorName === "string" ? buffers[accessorName] : void 0, data.startIndices)) {
      } else if (typeof accessorName === "string" && !buffers[accessorName] && attribute.setConstantValue(context, props[accessorName])) {
      } else if (attribute.needsUpdate()) {
        updated = true;
        this._updateAttribute({
          attribute,
          numInstances,
          data,
          props,
          context
        });
      }
      this.needsRedraw = this.needsRedraw || attribute.needsRedraw();
    }
    if (updated) {
      debug(TRACE_UPDATE_END, this, numInstances);
    }
    if (this.stats) {
      this.stats.get("Update Attributes").timeEnd();
    }
    this.attributeTransitionManager.update({
      attributes: this.attributes,
      numInstances,
      transitions
    });
  }
  // Update attribute transition to the current timestamp
  // Returns `true` if any transition is in progress
  updateTransition() {
    const { attributeTransitionManager } = this;
    const transitionUpdated = attributeTransitionManager.run();
    this.needsRedraw = this.needsRedraw || transitionUpdated;
    return transitionUpdated;
  }
  /**
   * Returns all attribute descriptors
   * Note: Format matches luma.gl Model/Program.setAttributes()
   * @return {Object} attributes - descriptors
   */
  getAttributes() {
    return { ...this.attributes, ...this.attributeTransitionManager.getAttributes() };
  }
  /**
   * Computes the spatial bounds of a given set of attributes
   */
  getBounds(attributeNames) {
    const bounds = attributeNames.map((attributeName) => {
      var _a3;
      return (_a3 = this.attributes[attributeName]) == null ? void 0 : _a3.getBounds();
    });
    return this.mergeBoundsMemoized(bounds);
  }
  /**
   * Returns changed attribute descriptors
   * This indicates which WebGLBuffers need to be updated
   * @return {Object} attributes - descriptors
   */
  getChangedAttributes(opts = { clearChangedFlags: false }) {
    const { attributes, attributeTransitionManager } = this;
    const changedAttributes = { ...attributeTransitionManager.getAttributes() };
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {
        changedAttributes[attributeName] = attribute;
      }
    }
    return changedAttributes;
  }
  /** Generate WebGPU-style buffer layout descriptors from all attributes */
  getBufferLayouts(modelInfo) {
    return Object.values(this.getAttributes()).map((attribute) => attribute.getBufferLayout(modelInfo));
  }
  // PRIVATE METHODS
  /** Register new attributes */
  _add(attributes, overrideOptions) {
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const props = {
        ...attribute,
        id: attributeName,
        size: attribute.isIndexed && 1 || attribute.size || 1,
        ...overrideOptions
      };
      this.attributes[attributeName] = new Attribute(this.device, props);
    }
    this._mapUpdateTriggersToAttributes();
  }
  // build updateTrigger name to attribute name mapping
  _mapUpdateTriggersToAttributes() {
    const triggers = {};
    for (const attributeName in this.attributes) {
      const attribute = this.attributes[attributeName];
      attribute.getUpdateTriggers().forEach((triggerName) => {
        if (!triggers[triggerName]) {
          triggers[triggerName] = [];
        }
        triggers[triggerName].push(attributeName);
      });
    }
    this.updateTriggers = triggers;
  }
  _invalidateTrigger(triggerName, dataRange) {
    const { attributes, updateTriggers } = this;
    const invalidatedAttributes = updateTriggers[triggerName];
    if (invalidatedAttributes) {
      invalidatedAttributes.forEach((name) => {
        const attribute = attributes[name];
        if (attribute) {
          attribute.setNeedsUpdate(attribute.id, dataRange);
        }
      });
    }
    return invalidatedAttributes;
  }
  _updateAttribute(opts) {
    const { attribute, numInstances } = opts;
    debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);
    if (attribute.constant) {
      attribute.setConstantValue(opts.context, attribute.value);
      return;
    }
    if (attribute.allocate(numInstances)) {
      debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);
    }
    const updated = attribute.updateBuffer(opts);
    if (updated) {
      this.needsRedraw = true;
      debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);
    }
  }
};

// node_modules/@deck.gl/core/dist/transitions/cpu-interpolation-transition.js
var CPUInterpolationTransition = class extends Transition {
  get value() {
    return this._value;
  }
  _onUpdate() {
    const { time, settings: { fromValue, toValue, duration, easing } } = this;
    const t2 = easing(time / duration);
    this._value = lerp(fromValue, toValue, t2);
  }
};

// node_modules/@deck.gl/core/dist/transitions/cpu-spring-transition.js
var EPSILON23 = 1e-5;
function updateSpringElement(prev, cur, dest, damping, stiffness) {
  const velocity = cur - prev;
  const delta = dest - cur;
  const spring = delta * stiffness;
  const damper = -velocity * damping;
  return spring + damper + velocity + cur;
}
function updateSpring(prev, cur, dest, damping, stiffness) {
  if (Array.isArray(dest)) {
    const next = [];
    for (let i2 = 0; i2 < dest.length; i2++) {
      next[i2] = updateSpringElement(prev[i2], cur[i2], dest[i2], damping, stiffness);
    }
    return next;
  }
  return updateSpringElement(prev, cur, dest, damping, stiffness);
}
function distance4(value1, value2) {
  if (Array.isArray(value1)) {
    let distanceSquare = 0;
    for (let i2 = 0; i2 < value1.length; i2++) {
      const d2 = value1[i2] - value2[i2];
      distanceSquare += d2 * d2;
    }
    return Math.sqrt(distanceSquare);
  }
  return Math.abs(value1 - value2);
}
var CPUSpringTransition = class extends Transition {
  get value() {
    return this._currValue;
  }
  _onUpdate() {
    const { fromValue, toValue, damping, stiffness } = this.settings;
    const { _prevValue = fromValue, _currValue = fromValue } = this;
    let nextValue = updateSpring(_prevValue, _currValue, toValue, damping, stiffness);
    const delta = distance4(nextValue, toValue);
    const velocity = distance4(nextValue, _currValue);
    if (delta < EPSILON23 && velocity < EPSILON23) {
      nextValue = toValue;
      this.end();
    }
    this._prevValue = _currValue;
    this._currValue = nextValue;
  }
};

// node_modules/@deck.gl/core/dist/lib/uniform-transition-manager.js
var TRANSITION_TYPES2 = {
  interpolation: CPUInterpolationTransition,
  spring: CPUSpringTransition
};
var UniformTransitionManager = class {
  constructor(timeline) {
    this.transitions = /* @__PURE__ */ new Map();
    this.timeline = timeline;
  }
  get active() {
    return this.transitions.size > 0;
  }
  add(key, fromValue, toValue, settings) {
    const { transitions } = this;
    if (transitions.has(key)) {
      const transition2 = transitions.get(key);
      const { value = transition2.settings.fromValue } = transition2;
      fromValue = value;
      this.remove(key);
    }
    settings = normalizeTransitionSettings(settings);
    if (!settings) {
      return;
    }
    const TransitionType = TRANSITION_TYPES2[settings.type];
    if (!TransitionType) {
      log_default.error(`unsupported transition type '${settings.type}'`)();
      return;
    }
    const transition = new TransitionType(this.timeline);
    transition.start({
      ...settings,
      fromValue,
      toValue
    });
    transitions.set(key, transition);
  }
  remove(key) {
    const { transitions } = this;
    if (transitions.has(key)) {
      transitions.get(key).cancel();
      transitions.delete(key);
    }
  }
  update() {
    const propsInTransition = {};
    for (const [key, transition] of this.transitions) {
      transition.update();
      propsInTransition[key] = transition.value;
      if (!transition.inProgress) {
        this.remove(key);
      }
    }
    return propsInTransition;
  }
  clear() {
    for (const key of this.transitions.keys()) {
      this.remove(key);
    }
  }
};

// node_modules/@deck.gl/core/dist/lifecycle/props.js
function validateProps(props) {
  const propTypes = props[PROP_TYPES_SYMBOL];
  for (const propName in propTypes) {
    const propType = propTypes[propName];
    const { validate } = propType;
    if (validate && !validate(props[propName], propType)) {
      throw new Error(`Invalid prop ${propName}: ${props[propName]}`);
    }
  }
}
function diffProps(props, oldProps) {
  const propsChangedReason = compareProps({
    newProps: props,
    oldProps,
    propTypes: props[PROP_TYPES_SYMBOL],
    ignoreProps: { data: null, updateTriggers: null, extensions: null, transitions: null }
  });
  const dataChangedReason = diffDataProps(props, oldProps);
  let updateTriggersChangedReason = false;
  if (!dataChangedReason) {
    updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
  }
  return {
    dataChanged: dataChangedReason,
    propsChanged: propsChangedReason,
    updateTriggersChanged: updateTriggersChangedReason,
    extensionsChanged: diffExtensions(props, oldProps),
    transitionsChanged: diffTransitions(props, oldProps)
  };
}
function diffTransitions(props, oldProps) {
  if (!props.transitions) {
    return false;
  }
  const result = {};
  const propTypes = props[PROP_TYPES_SYMBOL];
  let changed = false;
  for (const key in props.transitions) {
    const propType = propTypes[key];
    const type = propType && propType.type;
    const isTransitionable = type === "number" || type === "color" || type === "array";
    if (isTransitionable && comparePropValues(props[key], oldProps[key], propType)) {
      result[key] = true;
      changed = true;
    }
  }
  return changed ? result : false;
}
function compareProps({ newProps, oldProps, ignoreProps = {}, propTypes = {}, triggerName = "props" }) {
  if (oldProps === newProps) {
    return false;
  }
  if (typeof newProps !== "object" || newProps === null) {
    return `${triggerName} changed shallowly`;
  }
  if (typeof oldProps !== "object" || oldProps === null) {
    return `${triggerName} changed shallowly`;
  }
  for (const key of Object.keys(newProps)) {
    if (!(key in ignoreProps)) {
      if (!(key in oldProps)) {
        return `${triggerName}.${key} added`;
      }
      const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
      if (changed) {
        return `${triggerName}.${key} ${changed}`;
      }
    }
  }
  for (const key of Object.keys(oldProps)) {
    if (!(key in ignoreProps)) {
      if (!(key in newProps)) {
        return `${triggerName}.${key} dropped`;
      }
      if (!Object.hasOwnProperty.call(newProps, key)) {
        const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
        if (changed) {
          return `${triggerName}.${key} ${changed}`;
        }
      }
    }
  }
  return false;
}
function comparePropValues(newProp, oldProp, propType) {
  let equal = propType && propType.equal;
  if (equal && !equal(newProp, oldProp, propType)) {
    return "changed deeply";
  }
  if (!equal) {
    equal = newProp && oldProp && newProp.equals;
    if (equal && !equal.call(newProp, oldProp)) {
      return "changed deeply";
    }
  }
  if (!equal && oldProp !== newProp) {
    return "changed shallowly";
  }
  return null;
}
function diffDataProps(props, oldProps) {
  if (oldProps === null) {
    return "oldProps is null, initial diff";
  }
  let dataChanged = false;
  const { dataComparator, _dataDiff } = props;
  if (dataComparator) {
    if (!dataComparator(props.data, oldProps.data)) {
      dataChanged = "Data comparator detected a change";
    }
  } else if (props.data !== oldProps.data) {
    dataChanged = "A new data container was supplied";
  }
  if (dataChanged && _dataDiff) {
    dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;
  }
  return dataChanged;
}
function diffUpdateTriggers(props, oldProps) {
  if (oldProps === null) {
    return { all: true };
  }
  if ("all" in props.updateTriggers) {
    const diffReason = diffUpdateTrigger(props, oldProps, "all");
    if (diffReason) {
      return { all: true };
    }
  }
  const reason = {};
  let changed = false;
  for (const triggerName in props.updateTriggers) {
    if (triggerName !== "all") {
      const diffReason = diffUpdateTrigger(props, oldProps, triggerName);
      if (diffReason) {
        reason[triggerName] = true;
        changed = true;
      }
    }
  }
  return changed ? reason : false;
}
function diffExtensions(props, oldProps) {
  if (oldProps === null) {
    return true;
  }
  const oldExtensions = oldProps.extensions;
  const { extensions } = props;
  if (extensions === oldExtensions) {
    return false;
  }
  if (!oldExtensions || !extensions) {
    return true;
  }
  if (extensions.length !== oldExtensions.length) {
    return true;
  }
  for (let i2 = 0; i2 < extensions.length; i2++) {
    if (!extensions[i2].equals(oldExtensions[i2])) {
      return true;
    }
  }
  return false;
}
function diffUpdateTrigger(props, oldProps, triggerName) {
  let newTriggers = props.updateTriggers[triggerName];
  newTriggers = newTriggers === void 0 || newTriggers === null ? {} : newTriggers;
  let oldTriggers = oldProps.updateTriggers[triggerName];
  oldTriggers = oldTriggers === void 0 || oldTriggers === null ? {} : oldTriggers;
  const diffReason = compareProps({
    oldProps: oldTriggers,
    newProps: newTriggers,
    triggerName
  });
  return diffReason;
}

// node_modules/@deck.gl/core/dist/utils/count.js
var ERR_NOT_OBJECT = "count(): argument not an object";
var ERR_NOT_CONTAINER = "count(): argument not a container";
function count(container) {
  if (!isObject2(container)) {
    throw new Error(ERR_NOT_OBJECT);
  }
  if (typeof container.count === "function") {
    return container.count();
  }
  if (Number.isFinite(container.size)) {
    return container.size;
  }
  if (Number.isFinite(container.length)) {
    return container.length;
  }
  if (isPlainObject(container)) {
    return Object.keys(container).length;
  }
  throw new Error(ERR_NOT_CONTAINER);
}
function isPlainObject(value) {
  return value !== null && typeof value === "object" && value.constructor === Object;
}
function isObject2(value) {
  return value !== null && typeof value === "object";
}

// node_modules/@deck.gl/core/dist/utils/shader.js
function mergeShaders(target, source6) {
  if (!source6) {
    return target;
  }
  const result = { ...target, ...source6 };
  if ("defines" in source6) {
    result.defines = { ...target.defines, ...source6.defines };
  }
  if ("modules" in source6) {
    result.modules = (target.modules || []).concat(source6.modules);
    if (source6.modules.some((module) => module.name === "project64")) {
      const index = result.modules.findIndex((module) => module.name === "project32");
      if (index >= 0) {
        result.modules.splice(index, 1);
      }
    }
  }
  if ("inject" in source6) {
    if (!target.inject) {
      result.inject = source6.inject;
    } else {
      const mergedInjection = { ...target.inject };
      for (const key in source6.inject) {
        mergedInjection[key] = (mergedInjection[key] || "") + source6.inject[key];
      }
      result.inject = mergedInjection;
    }
  }
  return result;
}

// node_modules/@deck.gl/core/dist/shaderlib/project/project-functions.js
var DEFAULT_COORDINATE_ORIGIN2 = [0, 0, 0];
function lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {
  const p2 = viewport.projectPosition(lngLatZ);
  if (offsetMode && viewport instanceof web_mercator_viewport_default) {
    const [longitude, latitude, z2 = 0] = lngLatZ;
    const distanceScales = viewport.getDistanceScales([longitude, latitude]);
    p2[2] = z2 * distanceScales.unitsPerMeter[2];
  }
  return p2;
}
function normalizeParameters(opts) {
  const { viewport, modelMatrix, coordinateOrigin } = opts;
  let { coordinateSystem, fromCoordinateSystem, fromCoordinateOrigin } = opts;
  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
  }
  if (fromCoordinateSystem === void 0) {
    fromCoordinateSystem = coordinateSystem;
  }
  if (fromCoordinateOrigin === void 0) {
    fromCoordinateOrigin = coordinateOrigin;
  }
  return {
    viewport,
    coordinateSystem,
    coordinateOrigin,
    modelMatrix,
    fromCoordinateSystem,
    fromCoordinateOrigin
  };
}
function getWorldPosition(position, { viewport, modelMatrix, coordinateSystem, coordinateOrigin, offsetMode }) {
  let [x2, y2, z2 = 0] = position;
  if (modelMatrix) {
    [x2, y2, z2] = vec4_exports.transformMat4([], [x2, y2, z2, 1], modelMatrix);
  }
  switch (coordinateSystem) {
    case COORDINATE_SYSTEM.LNGLAT:
      return lngLatZToWorldPosition([x2, y2, z2], viewport, offsetMode);
    case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
      return lngLatZToWorldPosition([x2 + coordinateOrigin[0], y2 + coordinateOrigin[1], z2 + (coordinateOrigin[2] || 0)], viewport, offsetMode);
    case COORDINATE_SYSTEM.METER_OFFSETS:
      return lngLatZToWorldPosition(addMetersToLngLat(coordinateOrigin, [x2, y2, z2]), viewport, offsetMode);
    case COORDINATE_SYSTEM.CARTESIAN:
    default:
      return viewport.isGeospatial ? [x2 + coordinateOrigin[0], y2 + coordinateOrigin[1], z2 + coordinateOrigin[2]] : viewport.projectPosition([x2, y2, z2]);
  }
}
function projectPosition(position, params) {
  const { viewport, coordinateSystem, coordinateOrigin, modelMatrix, fromCoordinateSystem, fromCoordinateOrigin } = normalizeParameters(params);
  const { autoOffset = true } = params;
  const { geospatialOrigin = DEFAULT_COORDINATE_ORIGIN2, shaderCoordinateOrigin = DEFAULT_COORDINATE_ORIGIN2, offsetMode = false } = autoOffset ? getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin) : {};
  const worldPosition = getWorldPosition(position, {
    viewport,
    modelMatrix,
    coordinateSystem: fromCoordinateSystem,
    coordinateOrigin: fromCoordinateOrigin,
    offsetMode
  });
  if (offsetMode) {
    const positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
    vec3_exports.sub(worldPosition, worldPosition, positionCommonSpace);
  }
  return worldPosition;
}

// node_modules/@deck.gl/core/dist/utils/texture.js
var DEFAULT_TEXTURE_PARAMETERS = {
  minFilter: "linear",
  mipmapFilter: "linear",
  magFilter: "linear",
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge"
};
var internalTextures = {};
function createTexture(owner, device, image, sampler) {
  if (image instanceof Texture) {
    return image;
  } else if (image.constructor && image.constructor.name !== "Object") {
    image = { data: image };
  }
  let samplerParameters = null;
  if (image.compressed) {
    samplerParameters = {
      minFilter: "linear",
      mipmapFilter: image.data.length > 1 ? "nearest" : "linear"
    };
  }
  const { width, height } = image.data;
  const texture = device.createTexture({
    ...image,
    sampler: {
      ...DEFAULT_TEXTURE_PARAMETERS,
      ...samplerParameters,
      ...sampler
    },
    mipLevels: device.getMipLevelCount(width, height)
  });
  texture.generateMipmapsWebGL();
  internalTextures[texture.id] = owner;
  return texture;
}
function destroyTexture(owner, texture) {
  if (!texture || !(texture instanceof Texture)) {
    return;
  }
  if (internalTextures[texture.id] === owner) {
    texture.delete();
    delete internalTextures[texture.id];
  }
}

// node_modules/@deck.gl/core/dist/lifecycle/prop-types.js
var TYPE_DEFINITIONS = {
  boolean: {
    validate(value, propType) {
      return true;
    },
    equal(value1, value2, propType) {
      return Boolean(value1) === Boolean(value2);
    }
  },
  number: {
    validate(value, propType) {
      return Number.isFinite(value) && (!("max" in propType) || value <= propType.max) && (!("min" in propType) || value >= propType.min);
    }
  },
  color: {
    validate(value, propType) {
      return propType.optional && !value || isArray2(value) && (value.length === 3 || value.length === 4);
    },
    equal(value1, value2, propType) {
      return deepEqual2(value1, value2, 1);
    }
  },
  accessor: {
    validate(value, propType) {
      const valueType = getTypeOf2(value);
      return valueType === "function" || valueType === getTypeOf2(propType.value);
    },
    equal(value1, value2, propType) {
      if (typeof value2 === "function") {
        return true;
      }
      return deepEqual2(value1, value2, 1);
    }
  },
  array: {
    validate(value, propType) {
      return propType.optional && !value || isArray2(value);
    },
    equal(value1, value2, propType) {
      const { compare } = propType;
      const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;
      return compare ? deepEqual2(value1, value2, depth) : value1 === value2;
    }
  },
  object: {
    equal(value1, value2, propType) {
      if (propType.ignore) {
        return true;
      }
      const { compare } = propType;
      const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;
      return compare ? deepEqual2(value1, value2, depth) : value1 === value2;
    }
  },
  function: {
    validate(value, propType) {
      return propType.optional && !value || typeof value === "function";
    },
    equal(value1, value2, propType) {
      const shouldIgnore = !propType.compare && propType.ignore !== false;
      return shouldIgnore || value1 === value2;
    }
  },
  data: {
    transform: (value, propType, component) => {
      if (!value) {
        return value;
      }
      const { dataTransform } = component.props;
      if (dataTransform) {
        return dataTransform(value);
      }
      if (typeof value.shape === "string" && value.shape.endsWith("-table") && Array.isArray(value.data)) {
        return value.data;
      }
      return value;
    }
  },
  image: {
    transform: (value, propType, component) => {
      const context = component.context;
      if (!context || !context.device) {
        return null;
      }
      return createTexture(component.id, context.device, value, {
        ...propType.parameters,
        ...component.props.textureParameters
      });
    },
    release: (value, propType, component) => {
      destroyTexture(component.id, value);
    }
  }
};
function parsePropTypes(propDefs) {
  const propTypes = {};
  const defaultProps3 = {};
  const deprecatedProps = {};
  for (const [propName, propDef] of Object.entries(propDefs)) {
    const deprecated = propDef == null ? void 0 : propDef.deprecatedFor;
    if (deprecated) {
      deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];
    } else {
      const propType = parsePropType(propName, propDef);
      propTypes[propName] = propType;
      defaultProps3[propName] = propType.value;
    }
  }
  return { propTypes, defaultProps: defaultProps3, deprecatedProps };
}
function parsePropType(name, propDef) {
  switch (getTypeOf2(propDef)) {
    case "object":
      return normalizePropDefinition(name, propDef);
    case "array":
      return normalizePropDefinition(name, { type: "array", value: propDef, compare: false });
    case "boolean":
      return normalizePropDefinition(name, { type: "boolean", value: propDef });
    case "number":
      return normalizePropDefinition(name, { type: "number", value: propDef });
    case "function":
      return normalizePropDefinition(name, { type: "function", value: propDef, compare: true });
    default:
      return { name, type: "unknown", value: propDef };
  }
}
function normalizePropDefinition(name, propDef) {
  if (!("type" in propDef)) {
    if (!("value" in propDef)) {
      return { name, type: "object", value: propDef };
    }
    return { name, type: getTypeOf2(propDef.value), ...propDef };
  }
  return { name, ...TYPE_DEFINITIONS[propDef.type], ...propDef };
}
function isArray2(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value);
}
function getTypeOf2(value) {
  if (isArray2(value)) {
    return "array";
  }
  if (value === null) {
    return "null";
  }
  return typeof value;
}

// node_modules/@deck.gl/core/dist/lifecycle/create-props.js
function createProps(component, propObjects) {
  let extensions;
  for (let i2 = propObjects.length - 1; i2 >= 0; i2--) {
    const props = propObjects[i2];
    if ("extensions" in props) {
      extensions = props.extensions;
    }
  }
  const propsPrototype = getPropsPrototype(component.constructor, extensions);
  const propsInstance = Object.create(propsPrototype);
  propsInstance[COMPONENT_SYMBOL] = component;
  propsInstance[ASYNC_ORIGINAL_SYMBOL] = {};
  propsInstance[ASYNC_RESOLVED_SYMBOL] = {};
  for (let i2 = 0; i2 < propObjects.length; ++i2) {
    const props = propObjects[i2];
    for (const key in props) {
      propsInstance[key] = props[key];
    }
  }
  Object.freeze(propsInstance);
  return propsInstance;
}
var MergedDefaultPropsCacheKey = "_mergedDefaultProps";
function getPropsPrototype(componentClass, extensions) {
  if (!(componentClass instanceof component_default.constructor))
    return {};
  let cacheKey = MergedDefaultPropsCacheKey;
  if (extensions) {
    for (const extension of extensions) {
      const ExtensionClass = extension.constructor;
      if (ExtensionClass) {
        cacheKey += `:${ExtensionClass.extensionName || ExtensionClass.name}`;
      }
    }
  }
  const defaultProps3 = getOwnProperty(componentClass, cacheKey);
  if (!defaultProps3) {
    return componentClass[cacheKey] = createPropsPrototypeAndTypes(componentClass, extensions || []);
  }
  return defaultProps3;
}
function createPropsPrototypeAndTypes(componentClass, extensions) {
  const parent = componentClass.prototype;
  if (!parent) {
    return null;
  }
  const parentClass = Object.getPrototypeOf(componentClass);
  const parentDefaultProps = getPropsPrototype(parentClass);
  const componentDefaultProps = getOwnProperty(componentClass, "defaultProps") || {};
  const componentPropDefs = parsePropTypes(componentDefaultProps);
  const defaultProps3 = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps, componentPropDefs.defaultProps);
  const propTypes = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps == null ? void 0 : parentDefaultProps[PROP_TYPES_SYMBOL], componentPropDefs.propTypes);
  const deprecatedProps = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps == null ? void 0 : parentDefaultProps[DEPRECATED_PROPS_SYMBOL], componentPropDefs.deprecatedProps);
  for (const extension of extensions) {
    const extensionDefaultProps = getPropsPrototype(extension.constructor);
    if (extensionDefaultProps) {
      Object.assign(defaultProps3, extensionDefaultProps);
      Object.assign(propTypes, extensionDefaultProps[PROP_TYPES_SYMBOL]);
      Object.assign(deprecatedProps, extensionDefaultProps[DEPRECATED_PROPS_SYMBOL]);
    }
  }
  createPropsPrototype(defaultProps3, componentClass);
  addAsyncPropsToPropPrototype(defaultProps3, propTypes);
  addDeprecatedPropsToPropPrototype(defaultProps3, deprecatedProps);
  defaultProps3[PROP_TYPES_SYMBOL] = propTypes;
  defaultProps3[DEPRECATED_PROPS_SYMBOL] = deprecatedProps;
  if (extensions.length === 0 && !hasOwnProperty(componentClass, "_propTypes")) {
    componentClass._propTypes = propTypes;
  }
  return defaultProps3;
}
function createPropsPrototype(defaultProps3, componentClass) {
  const id = getComponentName(componentClass);
  Object.defineProperties(defaultProps3, {
    // `id` is treated specially because layer might need to override it
    id: {
      writable: true,
      value: id
    }
  });
}
function addDeprecatedPropsToPropPrototype(defaultProps3, deprecatedProps) {
  for (const propName in deprecatedProps) {
    Object.defineProperty(defaultProps3, propName, {
      enumerable: false,
      set(newValue) {
        const nameStr = `${this.id}: ${propName}`;
        for (const newPropName of deprecatedProps[propName]) {
          if (!hasOwnProperty(this, newPropName)) {
            this[newPropName] = newValue;
          }
        }
        log_default.deprecated(nameStr, deprecatedProps[propName].join("/"))();
      }
    });
  }
}
function addAsyncPropsToPropPrototype(defaultProps3, propTypes) {
  const defaultValues = {};
  const descriptors = {};
  for (const propName in propTypes) {
    const propType = propTypes[propName];
    const { name, value } = propType;
    if (propType.async) {
      defaultValues[name] = value;
      descriptors[name] = getDescriptorForAsyncProp(name);
    }
  }
  defaultProps3[ASYNC_DEFAULTS_SYMBOL] = defaultValues;
  defaultProps3[ASYNC_ORIGINAL_SYMBOL] = {};
  Object.defineProperties(defaultProps3, descriptors);
}
function getDescriptorForAsyncProp(name) {
  return {
    enumerable: true,
    // Save the provided value for async props in a special map
    set(newValue) {
      if (typeof newValue === "string" || newValue instanceof Promise || isAsyncIterable2(newValue)) {
        this[ASYNC_ORIGINAL_SYMBOL][name] = newValue;
      } else {
        this[ASYNC_RESOLVED_SYMBOL][name] = newValue;
      }
    },
    // Only the component's state knows the true value of async prop
    get() {
      if (this[ASYNC_RESOLVED_SYMBOL]) {
        if (name in this[ASYNC_RESOLVED_SYMBOL]) {
          const value = this[ASYNC_RESOLVED_SYMBOL][name];
          return value || this[ASYNC_DEFAULTS_SYMBOL][name];
        }
        if (name in this[ASYNC_ORIGINAL_SYMBOL]) {
          const state = this[COMPONENT_SYMBOL] && this[COMPONENT_SYMBOL].internalState;
          if (state && state.hasAsyncProp(name)) {
            return state.getAsyncProp(name) || this[ASYNC_DEFAULTS_SYMBOL][name];
          }
        }
      }
      return this[ASYNC_DEFAULTS_SYMBOL][name];
    }
  };
}
function hasOwnProperty(object, prop) {
  return Object.prototype.hasOwnProperty.call(object, prop);
}
function getOwnProperty(object, prop) {
  return hasOwnProperty(object, prop) && object[prop];
}
function getComponentName(componentClass) {
  const componentName = componentClass.componentName;
  if (!componentName) {
    log_default.warn(`${componentClass.name}.componentName not specified`)();
  }
  return componentName || componentClass.name;
}

// node_modules/@deck.gl/core/dist/lifecycle/component.js
var counter = 0;
var Component = class {
  constructor(...propObjects) {
    this.props = createProps(this, propObjects);
    this.id = this.props.id;
    this.count = counter++;
  }
  // clone this layer with modified props
  clone(newProps) {
    const { props } = this;
    const asyncProps = {};
    for (const key in props[ASYNC_DEFAULTS_SYMBOL]) {
      if (key in props[ASYNC_RESOLVED_SYMBOL]) {
        asyncProps[key] = props[ASYNC_RESOLVED_SYMBOL][key];
      } else if (key in props[ASYNC_ORIGINAL_SYMBOL]) {
        asyncProps[key] = props[ASYNC_ORIGINAL_SYMBOL][key];
      }
    }
    return new this.constructor({ ...props, ...asyncProps, ...newProps });
  }
};
Component.componentName = "Component";
Component.defaultProps = {};
var component_default = Component;

// node_modules/@deck.gl/core/dist/lifecycle/component-state.js
var EMPTY_PROPS = Object.freeze({});
var ComponentState = class {
  constructor(component) {
    this.component = component;
    this.asyncProps = {};
    this.onAsyncPropUpdated = () => {
    };
    this.oldProps = null;
    this.oldAsyncProps = null;
  }
  finalize() {
    for (const propName in this.asyncProps) {
      const asyncProp = this.asyncProps[propName];
      if (asyncProp && asyncProp.type && asyncProp.type.release) {
        asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);
      }
    }
    this.asyncProps = {};
    this.component = null;
    this.resetOldProps();
  }
  /* Layer-facing props API */
  getOldProps() {
    return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;
  }
  resetOldProps() {
    this.oldAsyncProps = null;
    this.oldProps = this.component ? this.component.props : null;
  }
  // Checks if a prop is overridden
  hasAsyncProp(propName) {
    return propName in this.asyncProps;
  }
  // Returns value of an overriden prop
  getAsyncProp(propName) {
    const asyncProp = this.asyncProps[propName];
    return asyncProp && asyncProp.resolvedValue;
  }
  isAsyncPropLoading(propName) {
    if (propName) {
      const asyncProp = this.asyncProps[propName];
      return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);
    }
    for (const key in this.asyncProps) {
      if (this.isAsyncPropLoading(key)) {
        return true;
      }
    }
    return false;
  }
  // Without changing the original prop value, swap out the data resolution under the hood
  reloadAsyncProp(propName, value) {
    this._watchPromise(propName, Promise.resolve(value));
  }
  // Updates all async/overridden props (when new props come in)
  // Checks if urls have changed, starts loading, or removes override
  setAsyncProps(props) {
    this.component = props[COMPONENT_SYMBOL] || this.component;
    const resolvedValues = props[ASYNC_RESOLVED_SYMBOL] || {};
    const originalValues = props[ASYNC_ORIGINAL_SYMBOL] || props;
    const defaultValues = props[ASYNC_DEFAULTS_SYMBOL] || {};
    for (const propName in resolvedValues) {
      const value = resolvedValues[propName];
      this._createAsyncPropData(propName, defaultValues[propName]);
      this._updateAsyncProp(propName, value);
      resolvedValues[propName] = this.getAsyncProp(propName);
    }
    for (const propName in originalValues) {
      const value = originalValues[propName];
      this._createAsyncPropData(propName, defaultValues[propName]);
      this._updateAsyncProp(propName, value);
    }
  }
  /* Placeholder methods for subclassing */
  _fetch(propName, url) {
    return null;
  }
  _onResolve(propName, value) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  _onError(propName, error) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  // Intercept strings (URLs) and Promises and activates loading and prop rewriting
  _updateAsyncProp(propName, value) {
    if (!this._didAsyncInputValueChange(propName, value)) {
      return;
    }
    if (typeof value === "string") {
      value = this._fetch(propName, value);
    }
    if (value instanceof Promise) {
      this._watchPromise(propName, value);
      return;
    }
    if (isAsyncIterable2(value)) {
      this._resolveAsyncIterable(propName, value);
      return;
    }
    this._setPropValue(propName, value);
  }
  // Whenever async props are changing, we need to make a copy of oldProps
  // otherwise the prop rewriting will affect the value both in props and oldProps.
  // While the copy is relatively expensive, this only happens on load completion.
  _freezeAsyncOldProps() {
    if (!this.oldAsyncProps && this.oldProps) {
      this.oldAsyncProps = Object.create(this.oldProps);
      for (const propName in this.asyncProps) {
        Object.defineProperty(this.oldAsyncProps, propName, {
          enumerable: true,
          value: this.oldProps[propName]
        });
      }
    }
  }
  // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)
  _didAsyncInputValueChange(propName, value) {
    const asyncProp = this.asyncProps[propName];
    if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {
      return false;
    }
    asyncProp.lastValue = value;
    return true;
  }
  // Set normal, non-async value
  _setPropValue(propName, value) {
    this._freezeAsyncOldProps();
    const asyncProp = this.asyncProps[propName];
    if (asyncProp) {
      value = this._postProcessValue(asyncProp, value);
      asyncProp.resolvedValue = value;
      asyncProp.pendingLoadCount++;
      asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
    }
  }
  // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously
  _setAsyncPropValue(propName, value, loadCount) {
    const asyncProp = this.asyncProps[propName];
    if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== void 0) {
      this._freezeAsyncOldProps();
      asyncProp.resolvedValue = value;
      asyncProp.resolvedLoadCount = loadCount;
      this.onAsyncPropUpdated(propName, value);
    }
  }
  // Tracks a promise, sets the prop when loaded, handles load count
  _watchPromise(propName, promise) {
    const asyncProp = this.asyncProps[propName];
    if (asyncProp) {
      asyncProp.pendingLoadCount++;
      const loadCount = asyncProp.pendingLoadCount;
      promise.then((data) => {
        if (!this.component) {
          return;
        }
        data = this._postProcessValue(asyncProp, data);
        this._setAsyncPropValue(propName, data, loadCount);
        this._onResolve(propName, data);
      }).catch((error) => {
        this._onError(propName, error);
      });
    }
  }
  async _resolveAsyncIterable(propName, iterable) {
    if (propName !== "data") {
      this._setPropValue(propName, iterable);
      return;
    }
    const asyncProp = this.asyncProps[propName];
    if (!asyncProp) {
      return;
    }
    asyncProp.pendingLoadCount++;
    const loadCount = asyncProp.pendingLoadCount;
    let data = [];
    let count2 = 0;
    for await (const chunk of iterable) {
      if (!this.component) {
        return;
      }
      const { dataTransform } = this.component.props;
      if (dataTransform) {
        data = dataTransform(chunk, data);
      } else {
        data = data.concat(chunk);
      }
      Object.defineProperty(data, "__diff", {
        enumerable: false,
        value: [{ startRow: count2, endRow: data.length }]
      });
      count2 = data.length;
      this._setAsyncPropValue(propName, data, loadCount);
    }
    this._onResolve(propName, data);
  }
  // Give the app a chance to post process the loaded data
  _postProcessValue(asyncProp, value) {
    const propType = asyncProp.type;
    if (propType && this.component) {
      if (propType.release) {
        propType.release(asyncProp.resolvedValue, propType, this.component);
      }
      if (propType.transform) {
        return propType.transform(value, propType, this.component);
      }
    }
    return value;
  }
  // Creating an asyncProp record if needed
  _createAsyncPropData(propName, defaultValue) {
    const asyncProp = this.asyncProps[propName];
    if (!asyncProp) {
      const propTypes = this.component && this.component.props[PROP_TYPES_SYMBOL];
      this.asyncProps[propName] = {
        type: propTypes && propTypes[propName],
        lastValue: null,
        resolvedValue: defaultValue,
        pendingLoadCount: 0,
        resolvedLoadCount: 0
      };
    }
  }
};

// node_modules/@deck.gl/core/dist/lib/layer-state.js
var LayerState = class extends ComponentState {
  constructor({ attributeManager, layer }) {
    super(layer);
    this.attributeManager = attributeManager;
    this.needsRedraw = true;
    this.needsUpdate = true;
    this.subLayers = null;
    this.usesPickingColorCache = false;
  }
  get layer() {
    return this.component;
  }
  /* Override base Component methods with Layer-specific handling */
  _fetch(propName, url) {
    const layer = this.layer;
    const fetch2 = layer == null ? void 0 : layer.props.fetch;
    if (fetch2) {
      return fetch2(url, { propName, layer });
    }
    return super._fetch(propName, url);
  }
  _onResolve(propName, value) {
    const layer = this.layer;
    if (layer) {
      const onDataLoad = layer.props.onDataLoad;
      if (propName === "data" && onDataLoad) {
        onDataLoad(value, { propName, layer });
      }
    }
  }
  _onError(propName, error) {
    const layer = this.layer;
    if (layer) {
      layer.raiseError(error, `loading ${propName} of ${this.layer}`);
    }
  }
};

// node_modules/@deck.gl/core/dist/lib/layer.js
var TRACE_CHANGE_FLAG = "layer.changeFlag";
var TRACE_INITIALIZE = "layer.initialize";
var TRACE_UPDATE = "layer.update";
var TRACE_FINALIZE = "layer.finalize";
var TRACE_MATCHED = "layer.matched";
var MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;
var EMPTY_ARRAY2 = Object.freeze([]);
var areViewportsEqual = memoize(({ oldViewport, viewport }) => {
  return oldViewport.equals(viewport);
});
var pickingColorCache = new Uint8ClampedArray(0);
var defaultProps2 = {
  // data: Special handling for null, see below
  data: { type: "data", value: EMPTY_ARRAY2, async: true },
  dataComparator: { type: "function", value: null, optional: true },
  _dataDiff: {
    type: "function",
    // @ts-ignore __diff is not defined on data
    value: (data) => data && data.__diff,
    optional: true
  },
  dataTransform: { type: "function", value: null, optional: true },
  onDataLoad: { type: "function", value: null, optional: true },
  onError: { type: "function", value: null, optional: true },
  fetch: {
    type: "function",
    value: (url, { propName, layer, loaders, loadOptions, signal }) => {
      const { resourceManager } = layer.context;
      loadOptions = loadOptions || layer.getLoadOptions();
      loaders = loaders || layer.props.loaders;
      if (signal) {
        loadOptions = {
          ...loadOptions,
          fetch: {
            ...loadOptions == null ? void 0 : loadOptions.fetch,
            signal
          }
        };
      }
      let inResourceManager = resourceManager.contains(url);
      if (!inResourceManager && !loadOptions) {
        resourceManager.add({ resourceId: url, data: load(url, loaders), persistent: false });
        inResourceManager = true;
      }
      if (inResourceManager) {
        return resourceManager.subscribe({
          resourceId: url,
          onChange: (data) => {
            var _a3;
            return (_a3 = layer.internalState) == null ? void 0 : _a3.reloadAsyncProp(propName, data);
          },
          consumerId: layer.id,
          requestId: propName
        });
      }
      return load(url, loaders, loadOptions);
    }
  },
  updateTriggers: {},
  // Update triggers: a core change detection mechanism in deck.gl
  visible: true,
  pickable: false,
  opacity: { type: "number", min: 0, max: 1, value: 1 },
  operation: "draw",
  onHover: { type: "function", value: null, optional: true },
  onClick: { type: "function", value: null, optional: true },
  onDragStart: { type: "function", value: null, optional: true },
  onDrag: { type: "function", value: null, optional: true },
  onDragEnd: { type: "function", value: null, optional: true },
  coordinateSystem: COORDINATE_SYSTEM.DEFAULT,
  coordinateOrigin: { type: "array", value: [0, 0, 0], compare: true },
  modelMatrix: { type: "array", value: null, compare: true, optional: true },
  wrapLongitude: false,
  positionFormat: "XYZ",
  colorFormat: "RGBA",
  parameters: { type: "object", value: {}, optional: true, compare: 2 },
  loadOptions: { type: "object", value: null, optional: true, ignore: true },
  transitions: null,
  extensions: [],
  loaders: { type: "array", value: [], optional: true, ignore: true },
  // Offset depth based on layer index to avoid z-fighting.
  // Negative values pull layer towards the camera
  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm
  getPolygonOffset: {
    type: "function",
    value: ({ layerIndex }) => [0, -layerIndex * 100]
  },
  // Selection/Highlighting
  highlightedObjectIndex: null,
  autoHighlight: false,
  highlightColor: { type: "accessor", value: [0, 0, 128, 128] }
};
var Layer = class extends component_default {
  constructor() {
    super(...arguments);
    this.internalState = null;
    this.lifecycle = LIFECYCLE.NO_STATE;
    this.parent = null;
  }
  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
  }
  get root() {
    let layer = this;
    while (layer.parent) {
      layer = layer.parent;
    }
    return layer;
  }
  toString() {
    const className = this.constructor.layerName || this.constructor.name;
    return `${className}({id: '${this.props.id}'})`;
  }
  // Public API for users
  /** Projects a point with current view state from the current layer's coordinate system to screen */
  project(xyz) {
    assert6(this.internalState);
    const viewport = this.internalState.viewport || this.context.viewport;
    const worldPosition = getWorldPosition(xyz, {
      viewport,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem
    });
    const [x2, y2, z2] = worldToPixels(worldPosition, viewport.pixelProjectionMatrix);
    return xyz.length === 2 ? [x2, y2] : [x2, y2, z2];
  }
  /** Unprojects a screen pixel to the current view's default coordinate system
      Note: this does not reverse `project`. */
  unproject(xy) {
    assert6(this.internalState);
    const viewport = this.internalState.viewport || this.context.viewport;
    return viewport.unproject(xy);
  }
  /** Projects a point with current view state from the current layer's coordinate system to the world space */
  projectPosition(xyz, params) {
    assert6(this.internalState);
    const viewport = this.internalState.viewport || this.context.viewport;
    return projectPosition(xyz, {
      viewport,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem,
      ...params
    });
  }
  // Public API for custom layer implementation
  /** `true` if this layer renders other layers */
  get isComposite() {
    return false;
  }
  /** `true` if the layer renders to screen */
  get isDrawable() {
    return true;
  }
  /** Updates selected state members and marks the layer for redraw */
  setState(partialState) {
    this.setChangeFlags({ stateChanged: true });
    Object.assign(this.state, partialState);
    this.setNeedsRedraw();
  }
  /** Sets the redraw flag for this layer, will trigger a redraw next animation frame */
  setNeedsRedraw() {
    if (this.internalState) {
      this.internalState.needsRedraw = true;
    }
  }
  /** Mark this layer as needs a deep update */
  setNeedsUpdate() {
    if (this.internalState) {
      this.context.layerManager.setNeedsUpdate(String(this));
      this.internalState.needsUpdate = true;
    }
  }
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return this.internalState ? !this.internalState.isAsyncPropLoading() : false;
  }
  /** Returns true if using shader-based WGS84 longitude wrapping */
  get wrapLongitude() {
    return this.props.wrapLongitude;
  }
  /** @deprecated Returns true if the layer is visible in the picking pass */
  isPickable() {
    return this.props.pickable && this.props.visible;
  }
  /** Returns an array of models used by this layer, can be overriden by layer subclass */
  getModels() {
    const state = this.state;
    return state && (state.models || state.model && [state.model]) || [];
  }
  /** Update shader input parameters */
  setShaderModuleProps(...props) {
    for (const model of this.getModels()) {
      model.shaderInputs.setProps(...props);
    }
  }
  /** Returns the attribute manager of this layer */
  getAttributeManager() {
    return this.internalState && this.internalState.attributeManager;
  }
  /** Returns the most recent layer that matched to this state
    (When reacting to an async event, this layer may no longer be the latest) */
  getCurrentLayer() {
    return this.internalState && this.internalState.layer;
  }
  /** Returns the default parse options for async props */
  getLoadOptions() {
    return this.props.loadOptions;
  }
  use64bitPositions() {
    const { coordinateSystem } = this.props;
    return coordinateSystem === COORDINATE_SYSTEM.DEFAULT || coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN;
  }
  // Event handling
  onHover(info, pickingEvent) {
    if (this.props.onHover) {
      return this.props.onHover(info, pickingEvent) || false;
    }
    return false;
  }
  onClick(info, pickingEvent) {
    if (this.props.onClick) {
      return this.props.onClick(info, pickingEvent) || false;
    }
    return false;
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  // @return {Array} - a black color
  nullPickingColor() {
    return [0, 0, 0];
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  encodePickingColor(i2, target = []) {
    target[0] = i2 + 1 & 255;
    target[1] = i2 + 1 >> 8 & 255;
    target[2] = i2 + 1 >> 8 >> 8 & 255;
    return target;
  }
  // Returns the index corresponding to a picking color that doesn't match any subfeature
  // @param {Uint8Array} color - color array to be decoded
  // @return {Array} - the decoded picking color
  decodePickingColor(color) {
    assert6(color instanceof Uint8Array);
    const [i1, i2, i3] = color;
    const index = i1 + i2 * 256 + i3 * 65536 - 1;
    return index;
  }
  /** Deduces number of instances. Intention is to support:
    - Explicit setting of numInstances
    - Auto-deduction for ES6 containers that define a size member
    - Auto-deduction for Classic Arrays via the built-in length attribute
    - Auto-deduction via arrays */
  getNumInstances() {
    if (Number.isFinite(this.props.numInstances)) {
      return this.props.numInstances;
    }
    if (this.state && this.state.numInstances !== void 0) {
      return this.state.numInstances;
    }
    return count(this.props.data);
  }
  /** Buffer layout describes how many attribute values are packed for each data object
      The default (null) is one value each object.
      Some data formats (e.g. paths, polygons) have various length. Their buffer layout
      is in the form of [L0, L1, L2, ...] */
  getStartIndices() {
    if (this.props.startIndices) {
      return this.props.startIndices;
    }
    if (this.state && this.state.startIndices) {
      return this.state.startIndices;
    }
    return null;
  }
  // Default implementation
  getBounds() {
    var _a3;
    return (_a3 = this.getAttributeManager()) == null ? void 0 : _a3.getBounds(["positions", "instancePositions"]);
  }
  getShaders(shaders) {
    shaders = mergeShaders(shaders, {
      disableWarnings: true,
      modules: this.context.defaultShaderModules
    });
    for (const extension of this.props.extensions) {
      shaders = mergeShaders(shaders, extension.getShaders.call(this, extension));
    }
    return shaders;
  }
  /** Controls if updateState should be called. By default returns true if any prop has changed */
  shouldUpdateState(params) {
    return params.changeFlags.propsOrDataChanged;
  }
  /** Default implementation, all attributes will be invalidated and updated when data changes */
  // eslint-disable-next-line complexity
  updateState(params) {
    const attributeManager = this.getAttributeManager();
    const { dataChanged } = params.changeFlags;
    if (dataChanged && attributeManager) {
      if (Array.isArray(dataChanged)) {
        for (const dataRange of dataChanged) {
          attributeManager.invalidateAll(dataRange);
        }
      } else {
        attributeManager.invalidateAll();
      }
    }
    if (attributeManager) {
      const { props } = params;
      const hasPickingBuffer = this.internalState.hasPickingBuffer;
      const needsPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable || props.extensions.some((extension) => extension.getNeedsPickingBuffer.call(this, extension));
      if (hasPickingBuffer !== needsPickingBuffer) {
        this.internalState.hasPickingBuffer = needsPickingBuffer;
        const { pickingColors, instancePickingColors } = attributeManager.attributes;
        const pickingColorsAttribute = pickingColors || instancePickingColors;
        if (pickingColorsAttribute) {
          if (needsPickingBuffer && pickingColorsAttribute.constant) {
            pickingColorsAttribute.constant = false;
            attributeManager.invalidate(pickingColorsAttribute.id);
          }
          if (!pickingColorsAttribute.value && !needsPickingBuffer) {
            pickingColorsAttribute.constant = true;
            pickingColorsAttribute.value = [0, 0, 0];
          }
        }
      }
    }
  }
  /** Called once when layer is no longer matched and state will be discarded. Layers can destroy WebGL resources here. */
  finalizeState(context) {
    for (const model of this.getModels()) {
      model.destroy();
    }
    const attributeManager = this.getAttributeManager();
    if (attributeManager) {
      attributeManager.finalize();
    }
    if (this.context) {
      this.context.resourceManager.unsubscribe({ consumerId: this.id });
    }
    if (this.internalState) {
      this.internalState.uniformTransitions.clear();
      this.internalState.finalize();
    }
  }
  // If state has a model, draw it with supplied uniforms
  draw(opts) {
    for (const model of this.getModels()) {
      model.draw(opts.renderPass);
    }
  }
  // called to populate the info object that is passed to the event handler
  // @return null to cancel event
  getPickingInfo({ info, mode, sourceLayer }) {
    const { index } = info;
    if (index >= 0) {
      if (Array.isArray(this.props.data)) {
        info.object = this.props.data[index];
      }
    }
    return info;
  }
  // END LIFECYCLE METHODS
  // / INTERNAL METHODS - called by LayerManager, DeckRenderer and DeckPicker
  /** (Internal) Propagate an error event through the system */
  raiseError(error, message) {
    var _a3, _b, _c, _d;
    if (message) {
      error = new Error(`${message}: ${error.message}`, { cause: error });
    }
    if (!((_b = (_a3 = this.props).onError) == null ? void 0 : _b.call(_a3, error))) {
      (_d = (_c = this.context) == null ? void 0 : _c.onError) == null ? void 0 : _d.call(_c, error, this);
    }
  }
  /** (Internal) Checks if this layer needs redraw */
  getNeedsRedraw(opts = { clearRedrawFlags: false }) {
    return this._getNeedsRedraw(opts);
  }
  /** (Internal) Checks if this layer needs a deep update */
  needsUpdate() {
    if (!this.internalState) {
      return false;
    }
    return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
  }
  /** Checks if this layer has ongoing uniform transition */
  hasUniformTransition() {
    var _a3;
    return ((_a3 = this.internalState) == null ? void 0 : _a3.uniformTransitions.active) || false;
  }
  /** Called when this layer is rendered into the given viewport */
  activateViewport(viewport) {
    if (!this.internalState) {
      return;
    }
    const oldViewport = this.internalState.viewport;
    this.internalState.viewport = viewport;
    if (!oldViewport || !areViewportsEqual({ oldViewport, viewport })) {
      this.setChangeFlags({ viewportChanged: true });
      if (this.isComposite) {
        if (this.needsUpdate()) {
          this.setNeedsUpdate();
        }
      } else {
        this._update();
      }
    }
  }
  /** Default implementation of attribute invalidation, can be redefined */
  invalidateAttribute(name = "all") {
    const attributeManager = this.getAttributeManager();
    if (!attributeManager) {
      return;
    }
    if (name === "all") {
      attributeManager.invalidateAll();
    } else {
      attributeManager.invalidate(name);
    }
  }
  /** Send updated attributes to the WebGL model */
  updateAttributes(changedAttributes) {
    let bufferLayoutChanged = false;
    for (const id in changedAttributes) {
      if (changedAttributes[id].layoutChanged()) {
        bufferLayoutChanged = true;
      }
    }
    for (const model of this.getModels()) {
      this._setModelAttributes(model, changedAttributes, bufferLayoutChanged);
    }
  }
  /** Recalculate any attributes if needed */
  _updateAttributes() {
    const attributeManager = this.getAttributeManager();
    if (!attributeManager) {
      return;
    }
    const props = this.props;
    const numInstances = this.getNumInstances();
    const startIndices = this.getStartIndices();
    attributeManager.update({
      data: props.data,
      numInstances,
      startIndices,
      props,
      transitions: props.transitions,
      // @ts-ignore (TS2339) property attribute is not present on some acceptable data types
      buffers: props.data.attributes,
      context: this
    });
    const changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });
    this.updateAttributes(changedAttributes);
  }
  /** Update attribute transitions. This is called in drawLayer, no model updates required. */
  _updateAttributeTransition() {
    const attributeManager = this.getAttributeManager();
    if (attributeManager) {
      attributeManager.updateTransition();
    }
  }
  /** Update uniform (prop) transitions. This is called in updateState, may result in model updates. */
  _updateUniformTransition() {
    const { uniformTransitions } = this.internalState;
    if (uniformTransitions.active) {
      const propsInTransition = uniformTransitions.update();
      const props = Object.create(this.props);
      for (const key in propsInTransition) {
        Object.defineProperty(props, key, { value: propsInTransition[key] });
      }
      return props;
    }
    return this.props;
  }
  /** Updater for the automatically populated instancePickingColors attribute */
  calculateInstancePickingColors(attribute, { numInstances }) {
    if (attribute.constant) {
      return;
    }
    const cacheSize = Math.floor(pickingColorCache.length / 4);
    this.internalState.usesPickingColorCache = true;
    if (cacheSize < numInstances) {
      if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {
        log_default.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")();
      }
      pickingColorCache = typed_array_manager_default.allocate(pickingColorCache, numInstances, {
        size: 4,
        copy: true,
        maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)
      });
      const newCacheSize = Math.floor(pickingColorCache.length / 4);
      const pickingColor = [0, 0, 0];
      for (let i2 = cacheSize; i2 < newCacheSize; i2++) {
        this.encodePickingColor(i2, pickingColor);
        pickingColorCache[i2 * 4 + 0] = pickingColor[0];
        pickingColorCache[i2 * 4 + 1] = pickingColor[1];
        pickingColorCache[i2 * 4 + 2] = pickingColor[2];
        pickingColorCache[i2 * 4 + 3] = 0;
      }
    }
    attribute.value = pickingColorCache.subarray(0, numInstances * 4);
  }
  /** Apply changed attributes to model */
  _setModelAttributes(model, changedAttributes, bufferLayoutChanged = false) {
    var _a3;
    if (!Object.keys(changedAttributes).length) {
      return;
    }
    if (bufferLayoutChanged) {
      const attributeManager = this.getAttributeManager();
      model.setBufferLayout(attributeManager.getBufferLayouts(model));
      changedAttributes = attributeManager.getAttributes();
    }
    const excludeAttributes = ((_a3 = model.userData) == null ? void 0 : _a3.excludeAttributes) || {};
    const attributeBuffers = {};
    const constantAttributes = {};
    for (const name in changedAttributes) {
      if (excludeAttributes[name]) {
        continue;
      }
      const values = changedAttributes[name].getValue();
      for (const attributeName in values) {
        const value = values[attributeName];
        if (value instanceof Buffer) {
          if (changedAttributes[name].settings.isIndexed) {
            model.setIndexBuffer(value);
          } else {
            attributeBuffers[attributeName] = value;
          }
        } else if (value) {
          constantAttributes[attributeName] = value;
        }
      }
    }
    model.setAttributes(attributeBuffers);
    model.setConstantAttributes(constantAttributes);
  }
  /** (Internal) Sets the picking color at the specified index to null picking color. Used for multi-depth picking.
     This method may be overriden by layer implementations */
  disablePickingIndex(objectIndex) {
    const data = this.props.data;
    if (!("attributes" in data)) {
      this._disablePickingIndex(objectIndex);
      return;
    }
    const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;
    const externalColorAttribute = colors && data.attributes && data.attributes[colors.id];
    if (externalColorAttribute && externalColorAttribute.value) {
      const values = externalColorAttribute.value;
      const objectColor = this.encodePickingColor(objectIndex);
      for (let index = 0; index < data.length; index++) {
        const i2 = colors.getVertexOffset(index);
        if (values[i2] === objectColor[0] && values[i2 + 1] === objectColor[1] && values[i2 + 2] === objectColor[2]) {
          this._disablePickingIndex(index);
        }
      }
    } else {
      this._disablePickingIndex(objectIndex);
    }
  }
  // TODO - simplify subclassing interface
  _disablePickingIndex(objectIndex) {
    const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;
    if (!colors) {
      return;
    }
    const start = colors.getVertexOffset(objectIndex);
    const end = colors.getVertexOffset(objectIndex + 1);
    colors.buffer.write(new Uint8Array(end - start), start);
  }
  /** (Internal) Re-enable all picking indices after multi-depth picking */
  restorePickingColors() {
    const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;
    if (!colors) {
      return;
    }
    if (
      // @ts-ignore (TS2531) this method is only called internally with internalState defined
      this.internalState.usesPickingColorCache && colors.value.buffer !== pickingColorCache.buffer
    ) {
      colors.value = pickingColorCache.subarray(0, colors.value.length);
    }
    colors.updateSubBuffer({ startOffset: 0 });
  }
  /* eslint-disable max-statements */
  /* (Internal) Called by layer manager when a new layer is found */
  _initialize() {
    assert6(!this.internalState);
    assert6(Number.isFinite(this.props.coordinateSystem));
    debug(TRACE_INITIALIZE, this);
    const attributeManager = this._getAttributeManager();
    if (attributeManager) {
      attributeManager.addInstanced({
        instancePickingColors: {
          type: "uint8",
          size: 4,
          noAlloc: true,
          // Updaters are always called with `this` pointing to the layer
          // eslint-disable-next-line @typescript-eslint/unbound-method
          update: this.calculateInstancePickingColors
        }
      });
    }
    this.internalState = new LayerState({
      attributeManager,
      layer: this
    });
    this._clearChangeFlags();
    this.state = {};
    Object.defineProperty(this.state, "attributeManager", {
      get: () => {
        log_default.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")();
        return attributeManager;
      }
    });
    this.internalState.uniformTransitions = new UniformTransitionManager(this.context.timeline);
    this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
    this.internalState.setAsyncProps(this.props);
    this.initializeState(this.context);
    for (const extension of this.props.extensions) {
      extension.initializeState.call(this, this.context, extension);
    }
    this.setChangeFlags({
      dataChanged: "init",
      propsChanged: "init",
      viewportChanged: true,
      extensionsChanged: true
    });
    this._update();
  }
  /** (Internal) Called by layer manager to transfer state from an old layer */
  _transferState(oldLayer) {
    debug(TRACE_MATCHED, this, this === oldLayer);
    const { state, internalState } = oldLayer;
    if (this === oldLayer) {
      return;
    }
    this.internalState = internalState;
    this.state = state;
    this.internalState.setAsyncProps(this.props);
    this._diffProps(this.props, this.internalState.getOldProps());
  }
  /** (Internal) Called by layer manager when a new layer is added or an existing layer is matched with a new instance */
  _update() {
    const stateNeedsUpdate = this.needsUpdate();
    debug(TRACE_UPDATE, this, stateNeedsUpdate);
    if (!stateNeedsUpdate) {
      return;
    }
    const currentProps = this.props;
    const context = this.context;
    const internalState = this.internalState;
    const currentViewport = context.viewport;
    const propsInTransition = this._updateUniformTransition();
    internalState.propsInTransition = propsInTransition;
    context.viewport = internalState.viewport || currentViewport;
    this.props = propsInTransition;
    try {
      const updateParams = this._getUpdateParams();
      const oldModels = this.getModels();
      if (context.device) {
        this.updateState(updateParams);
      } else {
        try {
          this.updateState(updateParams);
        } catch (error) {
        }
      }
      for (const extension of this.props.extensions) {
        extension.updateState.call(this, updateParams, extension);
      }
      this.setNeedsRedraw();
      this._updateAttributes();
      const modelChanged = this.getModels()[0] !== oldModels[0];
      this._postUpdate(updateParams, modelChanged);
    } finally {
      context.viewport = currentViewport;
      this.props = currentProps;
      this._clearChangeFlags();
      internalState.needsUpdate = false;
      internalState.resetOldProps();
    }
  }
  /* eslint-enable max-statements */
  /** (Internal) Called by manager when layer is about to be disposed
      Note: not guaranteed to be called on application shutdown */
  _finalize() {
    debug(TRACE_FINALIZE, this);
    this.finalizeState(this.context);
    for (const extension of this.props.extensions) {
      extension.finalizeState.call(this, this.context, extension);
    }
  }
  // Calculates uniforms
  _drawLayer({ renderPass, shaderModuleProps = null, uniforms = {}, parameters = {} }) {
    this._updateAttributeTransition();
    const currentProps = this.props;
    const context = this.context;
    this.props = this.internalState.propsInTransition || currentProps;
    try {
      if (shaderModuleProps) {
        this.setShaderModuleProps(shaderModuleProps);
      }
      const { getPolygonOffset } = this.props;
      const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
      if (context.device instanceof WebGLDevice) {
        context.device.setParametersWebGL({ polygonOffset: offsets });
      }
      for (const model of this.getModels()) {
        if (model.device.type === "webgpu") {
          model.setParameters({ ...model.parameters, ...parameters });
        } else {
          model.setParameters(parameters);
        }
      }
      if (context.device instanceof WebGLDevice) {
        context.device.withParametersWebGL(parameters, () => {
          const opts = { renderPass, shaderModuleProps, uniforms, parameters, context };
          for (const extension of this.props.extensions) {
            extension.draw.call(this, opts, extension);
          }
          this.draw(opts);
        });
      } else {
        const opts = { renderPass, shaderModuleProps, uniforms, parameters, context };
        for (const extension of this.props.extensions) {
          extension.draw.call(this, opts, extension);
        }
        this.draw(opts);
      }
    } finally {
      this.props = currentProps;
    }
  }
  // Helper methods
  /** Returns the current change flags */
  getChangeFlags() {
    var _a3;
    return (_a3 = this.internalState) == null ? void 0 : _a3.changeFlags;
  }
  /* eslint-disable complexity */
  /** Dirty some change flags, will be handled by updateLayer */
  setChangeFlags(flags) {
    if (!this.internalState) {
      return;
    }
    const { changeFlags } = this.internalState;
    for (const key in flags) {
      if (flags[key]) {
        let flagChanged = false;
        switch (key) {
          case "dataChanged":
            const dataChangedReason = flags[key];
            const prevDataChangedReason = changeFlags[key];
            if (dataChangedReason && Array.isArray(prevDataChangedReason)) {
              changeFlags.dataChanged = Array.isArray(dataChangedReason) ? prevDataChangedReason.concat(dataChangedReason) : dataChangedReason;
              flagChanged = true;
            }
          default:
            if (!changeFlags[key]) {
              changeFlags[key] = flags[key];
              flagChanged = true;
            }
        }
        if (flagChanged) {
          debug(TRACE_CHANGE_FLAG, this, key, flags);
        }
      }
    }
    const propsOrDataChanged = Boolean(changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged);
    changeFlags.propsOrDataChanged = propsOrDataChanged;
    changeFlags.somethingChanged = propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;
  }
  /* eslint-enable complexity */
  /** Clear all changeFlags, typically after an update */
  _clearChangeFlags() {
    this.internalState.changeFlags = {
      dataChanged: false,
      propsChanged: false,
      updateTriggersChanged: false,
      viewportChanged: false,
      stateChanged: false,
      extensionsChanged: false,
      propsOrDataChanged: false,
      somethingChanged: false
    };
  }
  /** Compares the layers props with old props from a matched older layer
      and extracts change flags that describe what has change so that state
      can be update correctly with minimal effort */
  _diffProps(newProps, oldProps) {
    var _a3;
    const changeFlags = diffProps(newProps, oldProps);
    if (changeFlags.updateTriggersChanged) {
      for (const key in changeFlags.updateTriggersChanged) {
        if (changeFlags.updateTriggersChanged[key]) {
          this.invalidateAttribute(key);
        }
      }
    }
    if (changeFlags.transitionsChanged) {
      for (const key in changeFlags.transitionsChanged) {
        this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], (_a3 = newProps.transitions) == null ? void 0 : _a3[key]);
      }
    }
    return this.setChangeFlags(changeFlags);
  }
  /** (Internal) called by layer manager to perform extra props validation (in development only) */
  validateProps() {
    validateProps(this.props);
  }
  /** (Internal) Called by deck picker when the hovered object changes to update the auto highlight */
  updateAutoHighlight(info) {
    if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) {
      this._updateAutoHighlight(info);
    }
  }
  // May be overriden by subclasses
  // TODO - simplify subclassing interface
  /** Update picking module parameters to highlight the hovered object */
  _updateAutoHighlight(info) {
    const picking4 = {
      // @ts-ignore
      highlightedObjectColor: info.picked ? info.color : null
    };
    const { highlightColor } = this.props;
    if (info.picked && typeof highlightColor === "function") {
      picking4.highlightColor = highlightColor(info);
    }
    this.setShaderModuleProps({ picking: picking4 });
    this.setNeedsRedraw();
  }
  /** Create new attribute manager */
  _getAttributeManager() {
    const context = this.context;
    return new AttributeManager(context.device, {
      id: this.props.id,
      stats: context.stats,
      timeline: context.timeline
    });
  }
  // Private methods
  /** Called after updateState to perform common tasks */
  // eslint-disable-next-line complexity
  _postUpdate(updateParams, forceUpdate) {
    const { props, oldProps } = updateParams;
    const model = this.state.model;
    if (model == null ? void 0 : model.isInstanced) {
      model.setInstanceCount(this.getNumInstances());
    }
    const { autoHighlight, highlightedObjectIndex, highlightColor } = props;
    if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {
      const picking4 = {};
      if (Array.isArray(highlightColor)) {
        picking4.highlightColor = highlightColor;
      }
      if (forceUpdate || oldProps.autoHighlight !== autoHighlight || highlightedObjectIndex !== oldProps.highlightedObjectIndex) {
        picking4.highlightedObjectColor = Number.isFinite(highlightedObjectIndex) && highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;
      }
      this.setShaderModuleProps({ picking: picking4 });
    }
  }
  _getUpdateParams() {
    return {
      props: this.props,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      oldProps: this.internalState.getOldProps(),
      context: this.context,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      changeFlags: this.internalState.changeFlags
    };
  }
  /** Checks state of attributes and model */
  _getNeedsRedraw(opts) {
    if (!this.internalState) {
      return false;
    }
    let redraw = false;
    redraw = redraw || this.internalState.needsRedraw && this.id;
    const attributeManager = this.getAttributeManager();
    const attributeManagerNeedsRedraw = attributeManager ? attributeManager.getNeedsRedraw(opts) : false;
    redraw = redraw || attributeManagerNeedsRedraw;
    if (redraw) {
      for (const extension of this.props.extensions) {
        extension.onNeedsRedraw.call(this, extension);
      }
    }
    this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
    return redraw;
  }
  /** Callback when asyn prop is loaded */
  _onAsyncPropUpdated() {
    this._diffProps(this.props, this.internalState.getOldProps());
    this.setNeedsUpdate();
  }
};
Layer.defaultProps = defaultProps2;
Layer.layerName = "Layer";
var layer_default = Layer;

// node_modules/@deck.gl/core/dist/lib/composite-layer.js
var TRACE_RENDER_LAYERS2 = "compositeLayer.renderLayers";
var CompositeLayer = class extends layer_default {
  /** `true` if this layer renders other layers */
  get isComposite() {
    return true;
  }
  /** `true` if the layer renders to screen */
  get isDrawable() {
    return false;
  }
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return super.isLoaded && this.getSubLayers().every((layer) => layer.isLoaded);
  }
  /** Return last rendered sub layers */
  getSubLayers() {
    return this.internalState && this.internalState.subLayers || [];
  }
  // initializeState is usually not needed for composite layers
  // Provide empty definition to disable check for missing definition
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  initializeState(context) {
  }
  /** Updates selected state members and marks the composite layer to need rerender */
  setState(updateObject) {
    super.setState(updateObject);
    this.setNeedsUpdate();
  }
  /** called to augment the info object that is bubbled up from a sublayer
      override Layer.getPickingInfo() because decoding / setting uniform do
      not apply to a composite layer. */
  getPickingInfo({ info }) {
    const { object } = info;
    const isDataWrapped = object && object.__source && object.__source.parent && object.__source.parent.id === this.id;
    if (!isDataWrapped) {
      return info;
    }
    info.object = object.__source.object;
    info.index = object.__source.index;
    return info;
  }
  /**
   * Filters sub layers at draw time. Return true if the sub layer should be drawn.
   */
  filterSubLayer(context) {
    return true;
  }
  /** Returns true if sub layer needs to be rendered */
  shouldRenderSubLayer(subLayerId, data) {
    return data && data.length;
  }
  /** Returns sub layer class for a specific sublayer */
  getSubLayerClass(subLayerId, DefaultLayerClass) {
    const { _subLayerProps: overridingProps } = this.props;
    return overridingProps && overridingProps[subLayerId] && overridingProps[subLayerId].type || DefaultLayerClass;
  }
  /** When casting user data into another format to pass to sublayers,
      add reference to the original object and object index */
  getSubLayerRow(row, sourceObject, sourceObjectIndex) {
    row.__source = {
      parent: this,
      object: sourceObject,
      index: sourceObjectIndex
    };
    return row;
  }
  /** Some composite layers cast user data into another format before passing to sublayers
    We need to unwrap them before calling the accessor so that they see the original data
    objects */
  getSubLayerAccessor(accessor) {
    if (typeof accessor === "function") {
      const objectInfo = {
        index: -1,
        // @ts-ignore accessing resolved data
        data: this.props.data,
        target: []
      };
      return (x2, i2) => {
        if (x2 && x2.__source) {
          objectInfo.index = x2.__source.index;
          return accessor(x2.__source.object, objectInfo);
        }
        return accessor(x2, i2);
      };
    }
    return accessor;
  }
  /** Returns sub layer props for a specific sublayer */
  // eslint-disable-next-line complexity
  getSubLayerProps(sublayerProps = {}) {
    var _a3;
    const { opacity, pickable, visible, parameters, getPolygonOffset, highlightedObjectIndex, autoHighlight, highlightColor, coordinateSystem, coordinateOrigin, wrapLongitude, positionFormat, modelMatrix, extensions, fetch: fetch2, operation, _subLayerProps: overridingProps } = this.props;
    const newProps = {
      id: "",
      updateTriggers: {},
      opacity,
      pickable,
      visible,
      parameters,
      getPolygonOffset,
      highlightedObjectIndex,
      autoHighlight,
      highlightColor,
      coordinateSystem,
      coordinateOrigin,
      wrapLongitude,
      positionFormat,
      modelMatrix,
      extensions,
      fetch: fetch2,
      operation
    };
    const overridingSublayerProps = overridingProps && sublayerProps.id && overridingProps[sublayerProps.id];
    const overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;
    const sublayerId = sublayerProps.id || "sublayer";
    if (overridingSublayerProps) {
      const propTypes = this.props[PROP_TYPES_SYMBOL];
      const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};
      for (const key in overridingSublayerProps) {
        const propType = subLayerPropTypes[key] || propTypes[key];
        if (propType && propType.type === "accessor") {
          overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);
        }
      }
    }
    Object.assign(
      newProps,
      sublayerProps,
      // experimental feature that allows users to override sublayer props via parent layer prop
      overridingSublayerProps
    );
    newProps.id = `${this.props.id}-${sublayerId}`;
    newProps.updateTriggers = {
      all: (_a3 = this.props.updateTriggers) == null ? void 0 : _a3.all,
      ...sublayerProps.updateTriggers,
      ...overridingSublayerTriggers
    };
    for (const extension of extensions) {
      const passThroughProps = extension.getSubLayerProps.call(this, extension);
      if (passThroughProps) {
        Object.assign(newProps, passThroughProps, {
          updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)
        });
      }
    }
    return newProps;
  }
  /** Update sub layers to highlight the hovered object */
  _updateAutoHighlight(info) {
    for (const layer of this.getSubLayers()) {
      layer.updateAutoHighlight(info);
    }
  }
  /** Override base Layer method */
  _getAttributeManager() {
    return null;
  }
  /** (Internal) Called after an update to rerender sub layers */
  _postUpdate(updateParams, forceUpdate) {
    let subLayers = this.internalState.subLayers;
    const shouldUpdate = !subLayers || this.needsUpdate();
    if (shouldUpdate) {
      const subLayersList = this.renderLayers();
      subLayers = flatten(subLayersList, Boolean);
      this.internalState.subLayers = subLayers;
    }
    debug(TRACE_RENDER_LAYERS2, this, shouldUpdate, subLayers);
    for (const layer of subLayers) {
      layer.parent = this;
    }
  }
};
CompositeLayer.layerName = "CompositeLayer";
var composite_layer_default = CompositeLayer;

// node_modules/@math.gl/sun/dist/suncalc.js
var DEGREES_TO_RADIANS6 = Math.PI / 180;
var DAY_IN_MS = 1e3 * 60 * 60 * 24;
var e2 = DEGREES_TO_RADIANS6 * 23.4397;

// node_modules/@deck.gl/core/dist/viewports/orbit-viewport.js
var DEGREES_TO_RADIANS7 = Math.PI / 180;
function getViewMatrix2({ height, focalDistance, orbitAxis, rotationX, rotationOrbit, zoom }) {
  const up = orbitAxis === "Z" ? [0, 0, 1] : [0, 1, 0];
  const eye = orbitAxis === "Z" ? [0, -focalDistance, 0] : [0, 0, focalDistance];
  const viewMatrix2 = new Matrix4().lookAt({ eye, up });
  viewMatrix2.rotateX(rotationX * DEGREES_TO_RADIANS7);
  if (orbitAxis === "Z") {
    viewMatrix2.rotateZ(rotationOrbit * DEGREES_TO_RADIANS7);
  } else {
    viewMatrix2.rotateY(rotationOrbit * DEGREES_TO_RADIANS7);
  }
  const projectionScale = Math.pow(2, zoom) / height;
  viewMatrix2.scale(projectionScale);
  return viewMatrix2;
}
var OrbitViewport = class extends viewport_default {
  constructor(props) {
    const {
      height,
      projectionMatrix,
      fovy = 50,
      // For setting camera position
      orbitAxis = "Z",
      // Orbit axis with 360 degrees rotating freedom, can only be 'Y' or 'Z'
      target = [0, 0, 0],
      // Which point is camera looking at, default origin
      rotationX = 0,
      // Rotating angle around X axis
      rotationOrbit = 0,
      // Rotating angle around orbit axis
      zoom = 0
    } = props;
    const focalDistance = projectionMatrix ? projectionMatrix[5] / 2 : fovyToAltitude(fovy);
    super({
      ...props,
      // in case viewState contains longitude/latitude values,
      // make sure that the base Viewport class does not treat this as a geospatial viewport
      longitude: void 0,
      viewMatrix: getViewMatrix2({
        height: height || 1,
        focalDistance,
        orbitAxis,
        rotationX,
        rotationOrbit,
        zoom
      }),
      fovy,
      focalDistance,
      position: target,
      zoom
    });
    this.target = target;
    this.orbitAxis = orbitAxis;
    this.rotationX = rotationX;
    this.rotationOrbit = rotationOrbit;
    this.fovy = fovy;
    this.projectedCenter = this.project(this.center);
  }
  unproject(xyz, { topLeft = true } = {}) {
    const [x2, y2, z2 = this.projectedCenter[2]] = xyz;
    const y22 = topLeft ? y2 : this.height - y2;
    const [X2, Y2, Z2] = pixelsToWorld([x2, y22, z2], this.pixelUnprojectionMatrix);
    return [X2, Y2, Z2];
  }
  panByPosition(coords, pixel, startPixel) {
    const p0 = this.project(coords);
    const nextCenter = [
      this.width / 2 + p0[0] - pixel[0],
      this.height / 2 + p0[1] - pixel[1],
      this.projectedCenter[2]
    ];
    return {
      target: this.unproject(nextCenter)
    };
  }
};
OrbitViewport.displayName = "OrbitViewport";
var orbit_viewport_default = OrbitViewport;

// node_modules/@deck.gl/core/dist/viewports/orthographic-viewport.js
var viewMatrix = new Matrix4().lookAt({ eye: [0, 0, 1] });
function getProjectionMatrix2({ width, height, near, far, padding }) {
  let left = -width / 2;
  let right = width / 2;
  let bottom = -height / 2;
  let top = height / 2;
  if (padding) {
    const { left: l2 = 0, right: r2 = 0, top: t2 = 0, bottom: b2 = 0 } = padding;
    const offsetX = clamp((l2 + width - r2) / 2, 0, width) - width / 2;
    const offsetY = clamp((t2 + height - b2) / 2, 0, height) - height / 2;
    left -= offsetX;
    right -= offsetX;
    bottom += offsetY;
    top += offsetY;
  }
  return new Matrix4().ortho({
    left,
    right,
    bottom,
    top,
    near,
    far
  });
}
var OrthographicViewport = class extends viewport_default {
  constructor(props) {
    const { width, height, near = 0.1, far = 1e3, zoom = 0, target = [0, 0, 0], padding = null, flipY = true } = props;
    const zoomX = props.zoomX ?? (Array.isArray(zoom) ? zoom[0] : zoom);
    const zoomY = props.zoomY ?? (Array.isArray(zoom) ? zoom[1] : zoom);
    const zoom_ = Math.min(zoomX, zoomY);
    const scale7 = Math.pow(2, zoom_);
    let distanceScales;
    if (zoomX !== zoomY) {
      const scaleX = Math.pow(2, zoomX);
      const scaleY = Math.pow(2, zoomY);
      distanceScales = {
        unitsPerMeter: [scaleX / scale7, scaleY / scale7, 1],
        metersPerUnit: [scale7 / scaleX, scale7 / scaleY, 1]
      };
    }
    super({
      ...props,
      // in case viewState contains longitude/latitude values,
      // make sure that the base Viewport class does not treat this as a geospatial viewport
      longitude: void 0,
      position: target,
      viewMatrix: viewMatrix.clone().scale([scale7, scale7 * (flipY ? -1 : 1), scale7]),
      projectionMatrix: getProjectionMatrix2({
        width: width || 1,
        height: height || 1,
        padding,
        near,
        far
      }),
      zoom: zoom_,
      distanceScales
    });
    this.target = target;
    this.zoomX = zoomX;
    this.zoomY = zoomY;
    this.flipY = flipY;
  }
  projectFlat([X2, Y2]) {
    const { unitsPerMeter: unitsPerMeter2 } = this.distanceScales;
    return [X2 * unitsPerMeter2[0], Y2 * unitsPerMeter2[1]];
  }
  unprojectFlat([x2, y2]) {
    const { metersPerUnit } = this.distanceScales;
    return [x2 * metersPerUnit[0], y2 * metersPerUnit[1]];
  }
  /* Needed by LinearInterpolator */
  panByPosition(coords, pixel, startPixel) {
    const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);
    const toLocation = this.projectFlat(coords);
    const translate3 = vec2_exports.add([], toLocation, vec2_exports.negate([], fromLocation));
    const newCenter = vec2_exports.add([], this.center, translate3);
    return { target: this.unprojectFlat(newCenter) };
  }
};
OrthographicViewport.displayName = "OrthographicViewport";
var orthographic_viewport_default = OrthographicViewport;

// node_modules/@deck.gl/core/dist/viewports/first-person-viewport.js
var FirstPersonViewport = class extends viewport_default {
  constructor(props) {
    const { longitude, latitude, modelMatrix, bearing = 0, pitch = 0, up = [0, 0, 1] } = props;
    const spherical = new SphericalCoordinates({
      bearing,
      // Avoid "pixel project matrix not invertible" error
      pitch: pitch === -90 ? 1e-4 : 90 + pitch
    });
    const dir = spherical.toVector3().normalize();
    const center = modelMatrix ? new Matrix4(modelMatrix).transformAsVector(dir) : dir;
    const zoom = Number.isFinite(latitude) ? getMeterZoom({ latitude }) : 0;
    const scale7 = Math.pow(2, zoom);
    const viewMatrix2 = new Matrix4().lookAt({ eye: [0, 0, 0], center, up }).scale(scale7);
    super({
      ...props,
      zoom,
      viewMatrix: viewMatrix2
    });
    this.latitude = latitude;
    this.longitude = longitude;
    this.pitch = pitch;
    this.bearing = bearing;
    this.up = up;
  }
};
FirstPersonViewport.displayName = "FirstPersonViewport";
var first_person_viewport_default = FirstPersonViewport;

// node_modules/@deck.gl/core/dist/controllers/first-person-controller.js
var MOVEMENT_SPEED = 20;
var PAN_SPEED = 500;
var FirstPersonState = class _FirstPersonState extends ViewState {
  constructor(options) {
    const {
      /* Viewport arguments */
      width,
      // Width of viewport
      height,
      // Height of viewport
      // Position and orientation
      position = [0, 0, 0],
      // typically in meters from anchor point
      bearing = 0,
      // Rotation around y axis
      pitch = 0,
      // Rotation around x axis
      // Geospatial anchor
      longitude = null,
      latitude = null,
      maxPitch = 90,
      minPitch = -90,
      // Model state when the rotate operation first started
      startRotatePos,
      startBearing,
      startPitch,
      startZoomPosition,
      startPanPos,
      startPanPosition
    } = options;
    super({
      width,
      height,
      position,
      bearing,
      pitch,
      longitude,
      latitude,
      maxPitch,
      minPitch
    }, {
      startRotatePos,
      startBearing,
      startPitch,
      startZoomPosition,
      startPanPos,
      startPanPosition
    });
    this.makeViewport = options.makeViewport;
  }
  /* Public API */
  /**
   * Start panning
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  panStart({ pos }) {
    const { position } = this.getViewportProps();
    return this._getUpdatedState({
      startPanPos: pos,
      startPanPosition: position
    });
  }
  /**
   * Pan
   * @param {[Number, Number]} pos - position on screen where the pointer is
   */
  pan({ pos }) {
    if (!pos) {
      return this;
    }
    const { startPanPos = [0, 0], startPanPosition = [0, 0] } = this.getState();
    const { width, height, bearing, pitch } = this.getViewportProps();
    const deltaScaleX = PAN_SPEED * (pos[0] - startPanPos[0]) / width;
    const deltaScaleY = PAN_SPEED * (pos[1] - startPanPos[1]) / height;
    const up = new SphericalCoordinates({ bearing, pitch });
    const forward = new SphericalCoordinates({ bearing, pitch: -90 });
    const yDirection = up.toVector3().normalize();
    const xDirection = forward.toVector3().cross(yDirection).normalize();
    return this._getUpdatedState({
      position: new Vector3(startPanPosition).add(xDirection.scale(deltaScaleX)).add(yDirection.scale(deltaScaleY))
    });
  }
  /**
   * End panning
   * Must call if `panStart()` was called
   */
  panEnd() {
    return this._getUpdatedState({
      startPanPos: null,
      startPanPosition: null
    });
  }
  /**
   * Start rotating
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  rotateStart({ pos }) {
    return this._getUpdatedState({
      startRotatePos: pos,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }
  /**
   * Rotate
   * @param {[Number, Number]} pos - position on screen where the pointer is
   */
  rotate({ pos, deltaAngleX = 0, deltaAngleY = 0 }) {
    const { startRotatePos, startBearing, startPitch } = this.getState();
    const { width, height } = this.getViewportProps();
    if (!startRotatePos || startBearing === void 0 || startPitch === void 0) {
      return this;
    }
    let newRotation;
    if (pos) {
      const deltaScaleX = (pos[0] - startRotatePos[0]) / width;
      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
      newRotation = {
        bearing: startBearing - deltaScaleX * 180,
        pitch: startPitch - deltaScaleY * 90
      };
    } else {
      newRotation = {
        bearing: startBearing - deltaAngleX,
        pitch: startPitch - deltaAngleY
      };
    }
    return this._getUpdatedState(newRotation);
  }
  /**
   * End rotating
   * Must call if `rotateStart()` was called
   */
  rotateEnd() {
    return this._getUpdatedState({
      startRotatePos: null,
      startBearing: null,
      startPitch: null
    });
  }
  /**
   * Start zooming
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  zoomStart() {
    return this._getUpdatedState({
      startZoomPosition: this.getViewportProps().position
    });
  }
  /**
   * Zoom
   * @param {[Number, Number]} pos - position on screen where the current center is
   * @param {[Number, Number]} startPos - the center position at
   *   the start of the operation. Must be supplied of `zoomStart()` was not called
   * @param {Number} scale - a number between [0, 1] specifying the accumulated
   *   relative scale.
   */
  zoom({ pos, scale: scale7 }) {
    const viewportProps = this.getViewportProps();
    const startZoomPosition = this.getState().startZoomPosition || viewportProps.position;
    const viewport = this.makeViewport(viewportProps);
    const { projectionMatrix, width } = viewport;
    const fovxRadians = 2 * Math.atan(1 / projectionMatrix[0]);
    const angle3 = fovxRadians * (pos[0] / width - 0.5);
    const direction = this.getDirection(true);
    return this._move(direction.rotateZ({ radians: -angle3 }), Math.log2(scale7) * MOVEMENT_SPEED, startZoomPosition);
  }
  /**
   * End zooming
   * Must call if `zoomStart()` was called
   */
  zoomEnd() {
    return this._getUpdatedState({
      startZoomPosition: null
    });
  }
  moveLeft(speed = MOVEMENT_SPEED) {
    const direction = this.getDirection(true);
    return this._move(direction.rotateZ({ radians: Math.PI / 2 }), speed);
  }
  moveRight(speed = MOVEMENT_SPEED) {
    const direction = this.getDirection(true);
    return this._move(direction.rotateZ({ radians: -Math.PI / 2 }), speed);
  }
  // forward
  moveUp(speed = MOVEMENT_SPEED) {
    const direction = this.getDirection(true);
    return this._move(direction, speed);
  }
  // backward
  moveDown(speed = MOVEMENT_SPEED) {
    const direction = this.getDirection(true);
    return this._move(direction.negate(), speed);
  }
  rotateLeft(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - speed
    });
  }
  rotateRight(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + speed
    });
  }
  rotateUp(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + speed
    });
  }
  rotateDown(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - speed
    });
  }
  zoomIn(speed = MOVEMENT_SPEED) {
    return this._move(new Vector3(0, 0, 1), speed);
  }
  zoomOut(speed = MOVEMENT_SPEED) {
    return this._move(new Vector3(0, 0, -1), speed);
  }
  // shortest path between two view states
  shortestPathFrom(viewState) {
    const fromProps = viewState.getViewportProps();
    const props = { ...this.getViewportProps() };
    const { bearing, longitude } = props;
    if (Math.abs(bearing - fromProps.bearing) > 180) {
      props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
    }
    if (longitude !== null && fromProps.longitude !== null && Math.abs(longitude - fromProps.longitude) > 180) {
      props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
    }
    return props;
  }
  /* Private methods */
  _move(direction, speed, fromPosition = this.getViewportProps().position) {
    const delta = direction.scale(speed);
    return this._getUpdatedState({
      position: new Vector3(fromPosition).add(delta)
    });
  }
  getDirection(use2D = false) {
    const spherical = new SphericalCoordinates({
      bearing: this.getViewportProps().bearing,
      pitch: use2D ? 90 : 90 + this.getViewportProps().pitch
    });
    const direction = spherical.toVector3().normalize();
    return direction;
  }
  _getUpdatedState(newProps) {
    return new _FirstPersonState({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...newProps
    });
  }
  // Apply any constraints (mathematical or defined by _viewportProps) to map state
  applyConstraints(props) {
    const { pitch, maxPitch, minPitch, longitude, bearing } = props;
    props.pitch = clamp(pitch, minPitch, maxPitch);
    if (longitude !== null && (longitude < -180 || longitude > 180)) {
      props.longitude = mod2(longitude + 180, 360) - 180;
    }
    if (bearing < -180 || bearing > 180) {
      props.bearing = mod2(bearing + 180, 360) - 180;
    }
    return props;
  }
};
var FirstPersonController = class extends Controller {
  constructor() {
    super(...arguments);
    this.ControllerState = FirstPersonState;
    this.transition = {
      transitionDuration: 300,
      transitionInterpolator: new LinearInterpolator(["position", "pitch", "bearing"])
    };
  }
};

// node_modules/@deck.gl/core/dist/views/first-person-view.js
var FirstPersonView = class extends View {
  constructor(props = {}) {
    super(props);
  }
  getViewportType() {
    return first_person_viewport_default;
  }
  get ControllerType() {
    return FirstPersonController;
  }
};
FirstPersonView.displayName = "FirstPersonView";

// node_modules/@deck.gl/core/dist/controllers/orbit-controller.js
var OrbitState = class extends ViewState {
  constructor(options) {
    const {
      /* Viewport arguments */
      width,
      // Width of viewport
      height,
      // Height of viewport
      rotationX = 0,
      // Rotation around x axis
      rotationOrbit = 0,
      // Rotation around orbit axis
      target = [0, 0, 0],
      zoom = 0,
      /* Viewport constraints */
      minRotationX = -90,
      maxRotationX = 90,
      minZoom = -Infinity,
      maxZoom = Infinity,
      /** Interaction states, required to calculate change during transform */
      // Model state when the pan operation first started
      startPanPosition,
      // Model state when the rotate operation first started
      startRotatePos,
      startRotationX,
      startRotationOrbit,
      // Model state when the zoom operation first started
      startZoomPosition,
      startZoom
    } = options;
    super({
      width,
      height,
      rotationX,
      rotationOrbit,
      target,
      zoom,
      minRotationX,
      maxRotationX,
      minZoom,
      maxZoom
    }, {
      startPanPosition,
      startRotatePos,
      startRotationX,
      startRotationOrbit,
      startZoomPosition,
      startZoom
    });
    this.makeViewport = options.makeViewport;
  }
  /**
   * Start panning
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  panStart({ pos }) {
    return this._getUpdatedState({
      startPanPosition: this._unproject(pos)
    });
  }
  /**
   * Pan
   * @param {[Number, Number]} pos - position on screen where the pointer is
   */
  pan({ pos, startPosition }) {
    const startPanPosition = this.getState().startPanPosition || startPosition;
    if (!startPanPosition) {
      return this;
    }
    const viewport = this.makeViewport(this.getViewportProps());
    const newProps = viewport.panByPosition(startPanPosition, pos);
    return this._getUpdatedState(newProps);
  }
  /**
   * End panning
   * Must call if `panStart()` was called
   */
  panEnd() {
    return this._getUpdatedState({
      startPanPosition: null
    });
  }
  /**
   * Start rotating
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  rotateStart({ pos }) {
    return this._getUpdatedState({
      startRotatePos: pos,
      startRotationX: this.getViewportProps().rotationX,
      startRotationOrbit: this.getViewportProps().rotationOrbit
    });
  }
  /**
   * Rotate
   * @param {[Number, Number]} pos - position on screen where the pointer is
   */
  rotate({ pos, deltaAngleX = 0, deltaAngleY = 0 }) {
    const { startRotatePos, startRotationX, startRotationOrbit } = this.getState();
    const { width, height } = this.getViewportProps();
    if (!startRotatePos || startRotationX === void 0 || startRotationOrbit === void 0) {
      return this;
    }
    let newRotation;
    if (pos) {
      let deltaScaleX = (pos[0] - startRotatePos[0]) / width;
      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
      if (startRotationX < -90 || startRotationX > 90) {
        deltaScaleX *= -1;
      }
      newRotation = {
        rotationX: startRotationX + deltaScaleY * 180,
        rotationOrbit: startRotationOrbit + deltaScaleX * 180
      };
    } else {
      newRotation = {
        rotationX: startRotationX + deltaAngleY,
        rotationOrbit: startRotationOrbit + deltaAngleX
      };
    }
    return this._getUpdatedState(newRotation);
  }
  /**
   * End rotating
   * Must call if `rotateStart()` was called
   */
  rotateEnd() {
    return this._getUpdatedState({
      startRotationX: null,
      startRotationOrbit: null
    });
  }
  // shortest path between two view states
  shortestPathFrom(viewState) {
    const fromProps = viewState.getViewportProps();
    const props = { ...this.getViewportProps() };
    const { rotationOrbit } = props;
    if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {
      props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;
    }
    return props;
  }
  /**
   * Start zooming
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  zoomStart({ pos }) {
    return this._getUpdatedState({
      startZoomPosition: this._unproject(pos),
      startZoom: this.getViewportProps().zoom
    });
  }
  /**
   * Zoom
   * @param {[Number, Number]} pos - position on screen where the current target is
   * @param {[Number, Number]} startPos - the target position at
   *   the start of the operation. Must be supplied of `zoomStart()` was not called
   * @param {Number} scale - a number between [0, 1] specifying the accumulated
   *   relative scale.
   */
  zoom({ pos, startPos, scale: scale7 }) {
    let { startZoom, startZoomPosition } = this.getState();
    if (!startZoomPosition) {
      startZoom = this.getViewportProps().zoom;
      startZoomPosition = this._unproject(startPos) || this._unproject(pos);
    }
    if (!startZoomPosition) {
      return this;
    }
    const newZoom = this._calculateNewZoom({ scale: scale7, startZoom });
    const zoomedViewport = this.makeViewport({ ...this.getViewportProps(), zoom: newZoom });
    return this._getUpdatedState({
      zoom: newZoom,
      ...zoomedViewport.panByPosition(startZoomPosition, pos)
    });
  }
  /**
   * End zooming
   * Must call if `zoomStart()` was called
   */
  zoomEnd() {
    return this._getUpdatedState({
      startZoomPosition: null,
      startZoom: null
    });
  }
  zoomIn(speed = 2) {
    return this._getUpdatedState({
      zoom: this._calculateNewZoom({ scale: speed })
    });
  }
  zoomOut(speed = 2) {
    return this._getUpdatedState({
      zoom: this._calculateNewZoom({ scale: 1 / speed })
    });
  }
  moveLeft(speed = 50) {
    return this._panFromCenter([-speed, 0]);
  }
  moveRight(speed = 50) {
    return this._panFromCenter([speed, 0]);
  }
  moveUp(speed = 50) {
    return this._panFromCenter([0, -speed]);
  }
  moveDown(speed = 50) {
    return this._panFromCenter([0, speed]);
  }
  rotateLeft(speed = 15) {
    return this._getUpdatedState({
      rotationOrbit: this.getViewportProps().rotationOrbit - speed
    });
  }
  rotateRight(speed = 15) {
    return this._getUpdatedState({
      rotationOrbit: this.getViewportProps().rotationOrbit + speed
    });
  }
  rotateUp(speed = 10) {
    return this._getUpdatedState({
      rotationX: this.getViewportProps().rotationX - speed
    });
  }
  rotateDown(speed = 10) {
    return this._getUpdatedState({
      rotationX: this.getViewportProps().rotationX + speed
    });
  }
  /* Private methods */
  _unproject(pos) {
    const viewport = this.makeViewport(this.getViewportProps());
    return pos && viewport.unproject(pos);
  }
  // Calculates new zoom
  _calculateNewZoom({ scale: scale7, startZoom }) {
    const { maxZoom, minZoom } = this.getViewportProps();
    if (startZoom === void 0) {
      startZoom = this.getViewportProps().zoom;
    }
    const zoom = startZoom + Math.log2(scale7);
    return clamp(zoom, minZoom, maxZoom);
  }
  _panFromCenter(offset) {
    const { width, height, target } = this.getViewportProps();
    return this.pan({
      startPosition: target,
      pos: [width / 2 + offset[0], height / 2 + offset[1]]
    });
  }
  _getUpdatedState(newProps) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...newProps
    });
  }
  // Apply any constraints (mathematical or defined by _viewportProps) to map state
  applyConstraints(props) {
    const { maxZoom, minZoom, zoom, maxRotationX, minRotationX, rotationOrbit } = props;
    props.zoom = Array.isArray(zoom) ? [clamp(zoom[0], minZoom, maxZoom), clamp(zoom[1], minZoom, maxZoom)] : clamp(zoom, minZoom, maxZoom);
    props.rotationX = clamp(props.rotationX, minRotationX, maxRotationX);
    if (rotationOrbit < -180 || rotationOrbit > 180) {
      props.rotationOrbit = mod2(rotationOrbit + 180, 360) - 180;
    }
    return props;
  }
};
var OrbitController = class extends Controller {
  constructor() {
    super(...arguments);
    this.ControllerState = OrbitState;
    this.transition = {
      transitionDuration: 300,
      transitionInterpolator: new LinearInterpolator({
        transitionProps: {
          compare: ["target", "zoom", "rotationX", "rotationOrbit"],
          required: ["target", "zoom"]
        }
      })
    };
  }
};

// node_modules/@deck.gl/core/dist/views/orbit-view.js
var OrbitView = class extends View {
  constructor(props = {}) {
    super(props);
    this.props.orbitAxis = props.orbitAxis || "Z";
  }
  getViewportType() {
    return orbit_viewport_default;
  }
  get ControllerType() {
    return OrbitController;
  }
};
OrbitView.displayName = "OrbitView";

// node_modules/@deck.gl/core/dist/controllers/orthographic-controller.js
var OrthographicState = class extends OrbitState {
  constructor(props) {
    super(props);
    this.zoomAxis = props.zoomAxis || "all";
  }
  _calculateNewZoom({ scale: scale7, startZoom }) {
    const { maxZoom, minZoom } = this.getViewportProps();
    if (startZoom === void 0) {
      startZoom = this.getViewportProps().zoom;
    }
    let deltaZoom = Math.log2(scale7);
    if (Array.isArray(startZoom)) {
      let [newZoomX, newZoomY] = startZoom;
      switch (this.zoomAxis) {
        case "X":
          newZoomX = clamp(newZoomX + deltaZoom, minZoom, maxZoom);
          break;
        case "Y":
          newZoomY = clamp(newZoomY + deltaZoom, minZoom, maxZoom);
          break;
        default:
          let z2 = Math.min(newZoomX + deltaZoom, newZoomY + deltaZoom);
          if (z2 < minZoom) {
            deltaZoom += minZoom - z2;
          }
          z2 = Math.max(newZoomX + deltaZoom, newZoomY + deltaZoom);
          if (z2 > maxZoom) {
            deltaZoom += maxZoom - z2;
          }
          newZoomX += deltaZoom;
          newZoomY += deltaZoom;
      }
      return [newZoomX, newZoomY];
    }
    return clamp(startZoom + deltaZoom, minZoom, maxZoom);
  }
};
var OrthographicController = class extends Controller {
  constructor() {
    super(...arguments);
    this.ControllerState = OrthographicState;
    this.transition = {
      transitionDuration: 300,
      transitionInterpolator: new LinearInterpolator(["target", "zoom"])
    };
    this.dragMode = "pan";
  }
  _onPanRotate() {
    return false;
  }
};

// node_modules/@deck.gl/core/dist/views/orthographic-view.js
var OrthographicView = class extends View {
  constructor(props = {}) {
    super(props);
  }
  getViewportType() {
    return orthographic_viewport_default;
  }
  get ControllerType() {
    return OrthographicController;
  }
};
OrthographicView.displayName = "OrthographicView";

// node_modules/@deck.gl/core/dist/controllers/globe-controller.js
var GlobeState = class extends MapState {
  constructor(options) {
    const { startPanPos, ...mapStateOptions } = options;
    super(mapStateOptions);
    if (startPanPos !== void 0) {
      this._state.startPanPos = startPanPos;
    }
  }
  panStart({ pos }) {
    const { latitude, longitude, zoom } = this.getViewportProps();
    return this._getUpdatedState({
      startPanLngLat: [longitude, latitude],
      startPanPos: pos,
      startZoom: zoom
    });
  }
  pan({ pos, startPos }) {
    const state = this.getState();
    const startPanLngLat = state.startPanLngLat || this._unproject(startPos);
    if (!startPanLngLat)
      return this;
    const startZoom = state.startZoom ?? this.getViewportProps().zoom;
    const startPanPos = state.startPanPos || startPos;
    const coords = [startPanLngLat[0], startPanLngLat[1], startZoom];
    const viewport = this.makeViewport(this.getViewportProps());
    const newProps = viewport.panByPosition(coords, pos, startPanPos);
    return this._getUpdatedState(newProps);
  }
  panEnd() {
    return this._getUpdatedState({
      startPanLngLat: null,
      startPanPos: null,
      startZoom: null
    });
  }
  zoom({ scale: scale7 }) {
    const startZoom = this.getState().startZoom || this.getViewportProps().zoom;
    const zoom = startZoom + Math.log2(scale7);
    return this._getUpdatedState({ zoom });
  }
  applyConstraints(props) {
    const { longitude, latitude, maxZoom, minZoom, zoom } = props;
    const ZOOM0 = zoomAdjust(0);
    const zoomAdjustment = zoomAdjust(latitude) - ZOOM0;
    props.zoom = clamp(zoom, minZoom + zoomAdjustment, maxZoom + zoomAdjustment);
    if (longitude < -180 || longitude > 180) {
      props.longitude = mod2(longitude + 180, 360) - 180;
    }
    props.latitude = clamp(latitude, -MAX_LATITUDE, MAX_LATITUDE);
    return props;
  }
};
var GlobeController = class extends Controller {
  constructor() {
    super(...arguments);
    this.ControllerState = GlobeState;
    this.transition = {
      transitionDuration: 300,
      transitionInterpolator: new LinearInterpolator(["longitude", "latitude", "zoom"])
    };
    this.dragMode = "pan";
  }
  setProps(props) {
    super.setProps(props);
    this.dragRotate = false;
    this.touchRotate = false;
  }
};

// node_modules/@deck.gl/core/dist/views/globe-view.js
var GlobeView = class extends View {
  constructor(props = {}) {
    super(props);
  }
  getViewportType(viewState) {
    return viewState.zoom > 12 ? web_mercator_viewport_default : globe_viewport_default;
  }
  get ControllerType() {
    return GlobeController;
  }
};
GlobeView.displayName = "GlobeView";

// node_modules/@deck.gl/core/dist/lib/layer-extension.js
var LayerExtension = class {
  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, "extensionName") ? this.extensionName : "";
  }
  constructor(opts) {
    if (opts) {
      this.opts = opts;
    }
  }
  /** Returns true if two extensions are equivalent */
  equals(extension) {
    if (this === extension) {
      return true;
    }
    return this.constructor === extension.constructor && deepEqual2(this.opts, extension.opts, 1);
  }
  /** Only called if attached to a primitive layer */
  getShaders(extension) {
    return null;
  }
  /** Only called if attached to a CompositeLayer */
  getSubLayerProps(extension) {
    const { defaultProps: defaultProps3 } = extension.constructor;
    const newProps = {
      updateTriggers: {}
    };
    for (const key in defaultProps3) {
      if (key in this.props) {
        const propDef = defaultProps3[key];
        const propValue = this.props[key];
        newProps[key] = propValue;
        if (propDef && propDef.type === "accessor") {
          newProps.updateTriggers[key] = this.props.updateTriggers[key];
          if (typeof propValue === "function") {
            newProps[key] = this.getSubLayerAccessor(propValue);
          }
        }
      }
    }
    return newProps;
  }
  /* eslint-disable @typescript-eslint/no-empty-function */
  initializeState(context, extension) {
  }
  updateState(params, extension) {
  }
  onNeedsRedraw(extension) {
  }
  getNeedsPickingBuffer(extension) {
    return false;
  }
  draw(params, extension) {
  }
  finalizeState(context, extension) {
  }
};
LayerExtension.defaultProps = {};
LayerExtension.extensionName = "LayerExtension";

// node_modules/@deck.gl/core/dist/transitions/fly-to-interpolator.js
var LINEARLY_INTERPOLATED_PROPS = {
  bearing: 0,
  pitch: 0,
  position: [0, 0, 0]
};
var DEFAULT_OPTS2 = {
  speed: 1.2,
  curve: 1.414
};
var FlyToInterpolator = class extends TransitionInterpolator {
  constructor(opts = {}) {
    super({
      compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
      extract: ["width", "height", "longitude", "latitude", "zoom", "bearing", "pitch", "position"],
      required: ["width", "height", "latitude", "longitude", "zoom"]
    });
    this.opts = { ...DEFAULT_OPTS2, ...opts };
  }
  interpolateProps(startProps, endProps, t2) {
    const viewport = flyToViewport(startProps, endProps, t2, this.opts);
    for (const key in LINEARLY_INTERPOLATED_PROPS) {
      viewport[key] = lerp(startProps[key] || LINEARLY_INTERPOLATED_PROPS[key], endProps[key] || LINEARLY_INTERPOLATED_PROPS[key], t2);
    }
    return viewport;
  }
  // computes the transition duration
  getDuration(startProps, endProps) {
    let { transitionDuration } = endProps;
    if (transitionDuration === "auto") {
      transitionDuration = getFlyToDuration(startProps, endProps, this.opts);
    }
    return transitionDuration;
  }
};

// node_modules/@deck.gl/core/dist/utils/tesselator.js
var Tesselator = class {
  constructor(opts) {
    this.indexStarts = [0];
    this.vertexStarts = [0];
    this.vertexCount = 0;
    this.instanceCount = 0;
    const { attributes = {} } = opts;
    this.typedArrayManager = typed_array_manager_default;
    this.attributes = {};
    this._attributeDefs = attributes;
    this.opts = opts;
    this.updateGeometry(opts);
  }
  /* Public methods */
  updateGeometry(opts) {
    Object.assign(this.opts, opts);
    const { data, buffers = {}, getGeometry, geometryBuffer, positionFormat, dataChanged, normalize: normalize5 = true } = this.opts;
    this.data = data;
    this.getGeometry = getGeometry;
    this.positionSize = // @ts-ignore (2339) when geometryBuffer is a luma Buffer, size falls back to positionFormat
    geometryBuffer && geometryBuffer.size || (positionFormat === "XY" ? 2 : 3);
    this.buffers = buffers;
    this.normalize = normalize5;
    if (geometryBuffer) {
      assert6(data.startIndices);
      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);
      if (!normalize5) {
        buffers.vertexPositions = geometryBuffer;
      }
    }
    this.geometryBuffer = buffers.vertexPositions;
    if (Array.isArray(dataChanged)) {
      for (const dataRange of dataChanged) {
        this._rebuildGeometry(dataRange);
      }
    } else {
      this._rebuildGeometry();
    }
  }
  updatePartialGeometry({ startRow, endRow }) {
    this._rebuildGeometry({ startRow, endRow });
  }
  getGeometryFromBuffer(geometryBuffer) {
    const value = geometryBuffer.value || geometryBuffer;
    if (!ArrayBuffer.isView(value)) {
      return null;
    }
    return getAccessorFromBuffer(value, {
      size: this.positionSize,
      offset: geometryBuffer.offset,
      stride: geometryBuffer.stride,
      startIndices: this.data.startIndices
    });
  }
  /* Private utility methods */
  _allocate(instanceCount, copy7) {
    const { attributes, buffers, _attributeDefs, typedArrayManager } = this;
    for (const name in _attributeDefs) {
      if (name in buffers) {
        typedArrayManager.release(attributes[name]);
        attributes[name] = null;
      } else {
        const def = _attributeDefs[name];
        def.copy = copy7;
        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);
      }
    }
  }
  /**
   * Visit all objects
   * `data` is expected to be an iterable consistent with the base Layer expectation
   */
  _forEachGeometry(visitor, startRow, endRow) {
    const { data, getGeometry } = this;
    const { iterable, objectInfo } = createIterable(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;
      visitor(geometry, objectInfo.index);
    }
  }
  /* eslint-disable complexity,max-statements */
  _rebuildGeometry(dataRange) {
    if (!this.data) {
      return;
    }
    let { indexStarts, vertexStarts, instanceCount } = this;
    const { data, geometryBuffer } = this;
    const { startRow = 0, endRow = Infinity } = dataRange || {};
    const normalizedData = {};
    if (!dataRange) {
      indexStarts = [0];
      vertexStarts = [0];
    }
    if (this.normalize || !geometryBuffer) {
      this._forEachGeometry((geometry, dataIndex) => {
        const normalizedGeometry = geometry && this.normalizeGeometry(geometry);
        normalizedData[dataIndex] = normalizedGeometry;
        vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);
      }, startRow, endRow);
      instanceCount = vertexStarts[vertexStarts.length - 1];
    } else {
      vertexStarts = data.startIndices;
      instanceCount = vertexStarts[data.length] || 0;
      if (ArrayBuffer.isView(geometryBuffer)) {
        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;
      } else if (geometryBuffer instanceof Buffer) {
        const byteStride = this.positionSize * 4;
        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;
      } else if (geometryBuffer.buffer) {
        const byteStride = geometryBuffer.stride || this.positionSize * 4;
        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;
      } else if (geometryBuffer.value) {
        const bufferValue = geometryBuffer.value;
        const elementStride = (
          // @ts-ignore (2339) if stride is not specified, will fall through to positionSize
          geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize
        );
        instanceCount = instanceCount || bufferValue.length / elementStride;
      }
    }
    this._allocate(instanceCount, Boolean(dataRange));
    this.indexStarts = indexStarts;
    this.vertexStarts = vertexStarts;
    this.instanceCount = instanceCount;
    const context = {};
    this._forEachGeometry((geometry, dataIndex) => {
      const normalizedGeometry = normalizedData[dataIndex] || geometry;
      context.vertexStart = vertexStarts[dataIndex];
      context.indexStart = indexStarts[dataIndex];
      const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;
      context.geometrySize = vertexEnd - vertexStarts[dataIndex];
      context.geometryIndex = dataIndex;
      this.updateGeometryAttributes(normalizedGeometry, context);
    }, startRow, endRow);
    this.vertexCount = indexStarts[indexStarts.length - 1];
  }
};

export {
  load,
  log_default,
  lerp,
  gouraudMaterial,
  phongMaterial,
  color_default,
  COORDINATE_SYSTEM,
  UNIT,
  project32_default,
  lngLatToWorld,
  picking_default,
  web_mercator_viewport_default,
  Model,
  Geometry,
  CubeGeometry,
  deepEqual2 as deepEqual,
  View,
  globe_viewport_default,
  LinearInterpolator,
  applyStyles,
  Widget,
  deck_default,
  createIterable,
  layer_default,
  composite_layer_default,
  FlyToInterpolator,
  Tesselator
};
//# sourceMappingURL=chunk-BQZTUO6U.js.map
