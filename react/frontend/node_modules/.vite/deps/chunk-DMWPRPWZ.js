import {
  __publicField
} from "./chunk-DC5AMYBS.js";

// node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js
function getHiResTimestamp() {
  let timestamp;
  if (typeof window !== "undefined" && window.performance) {
    timestamp = window.performance.now();
  } else if (typeof process !== "undefined" && process.hrtime) {
    const timeParts = process.hrtime();
    timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}

// node_modules/@probe.gl/stats/dist/lib/stat.js
var Stat = class {
  constructor(name2, type) {
    this.sampleSize = 1;
    this.time = 0;
    this.count = 0;
    this.samples = 0;
    this.lastTiming = 0;
    this.lastSampleTime = 0;
    this.lastSampleCount = 0;
    this._count = 0;
    this._time = 0;
    this._samples = 0;
    this._startTime = 0;
    this._timerPending = false;
    this.name = name2;
    this.type = type;
    this.reset();
  }
  reset() {
    this.time = 0;
    this.count = 0;
    this.samples = 0;
    this.lastTiming = 0;
    this.lastSampleTime = 0;
    this.lastSampleCount = 0;
    this._count = 0;
    this._time = 0;
    this._samples = 0;
    this._startTime = 0;
    this._timerPending = false;
    return this;
  }
  setSampleSize(samples) {
    this.sampleSize = samples;
    return this;
  }
  /** Call to increment count (+1) */
  incrementCount() {
    this.addCount(1);
    return this;
  }
  /** Call to decrement count (-1) */
  decrementCount() {
    this.subtractCount(1);
    return this;
  }
  /** Increase count */
  addCount(value) {
    this._count += value;
    this._samples++;
    this._checkSampling();
    return this;
  }
  /** Decrease count */
  subtractCount(value) {
    this._count -= value;
    this._samples++;
    this._checkSampling();
    return this;
  }
  /** Add an arbitrary timing and bump the count */
  addTime(time) {
    this._time += time;
    this.lastTiming = time;
    this._samples++;
    this._checkSampling();
    return this;
  }
  /** Start a timer */
  timeStart() {
    this._startTime = getHiResTimestamp();
    this._timerPending = true;
    return this;
  }
  /** End a timer. Adds to time and bumps the timing count. */
  timeEnd() {
    if (!this._timerPending) {
      return this;
    }
    this.addTime(getHiResTimestamp() - this._startTime);
    this._timerPending = false;
    this._checkSampling();
    return this;
  }
  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }
  /** Calculate average time / count for the previous window */
  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }
  /** Calculate counts per second for the previous window */
  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
  }
  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }
  /** Calculate average time / count */
  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }
  /** Calculate counts per second */
  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
  }
  _checkSampling() {
    if (this._samples === this.sampleSize) {
      this.lastSampleTime = this._time;
      this.lastSampleCount = this._count;
      this.count += this._count;
      this.time += this._time;
      this.samples += this._samples;
      this._time = 0;
      this._count = 0;
      this._samples = 0;
    }
  }
};

// node_modules/@probe.gl/stats/dist/lib/stats.js
var Stats = class {
  constructor(options) {
    this.stats = {};
    this.id = options.id;
    this.stats = {};
    this._initializeStats(options.stats);
    Object.seal(this);
  }
  /** Acquire a stat. Create if it doesn't exist. */
  get(name2, type = "count") {
    return this._getOrCreate({ name: name2, type });
  }
  get size() {
    return Object.keys(this.stats).length;
  }
  /** Reset all stats */
  reset() {
    for (const stat of Object.values(this.stats)) {
      stat.reset();
    }
    return this;
  }
  forEach(fn) {
    for (const stat of Object.values(this.stats)) {
      fn(stat);
    }
  }
  getTable() {
    const table = {};
    this.forEach((stat) => {
      table[stat.name] = {
        time: stat.time || 0,
        count: stat.count || 0,
        average: stat.getAverageTime() || 0,
        hz: stat.getHz() || 0
      };
    });
    return table;
  }
  _initializeStats(stats = []) {
    stats.forEach((stat) => this._getOrCreate(stat));
  }
  _getOrCreate(stat) {
    const { name: name2, type } = stat;
    let result = this.stats[name2];
    if (!result) {
      if (stat instanceof Stat) {
        result = stat;
      } else {
        result = new Stat(name2, type);
      }
      this.stats[name2] = result;
    }
    return result;
  }
};

// node_modules/@luma.gl/core/dist/utils/stats-manager.js
var StatsManager = class {
  constructor() {
    __publicField(this, "stats", /* @__PURE__ */ new Map());
  }
  getStats(name2) {
    return this.get(name2);
  }
  get(name2) {
    if (!this.stats.has(name2)) {
      this.stats.set(name2, new Stats({ id: name2 }));
    }
    return this.stats.get(name2);
  }
};
var lumaStats = new StatsManager();

// node_modules/@probe.gl/env/dist/lib/globals.js
var window_ = globalThis;
var document_ = globalThis.document || {};
var process_ = globalThis.process || {};
var console_ = globalThis.console;
var navigator_ = globalThis.navigator || {};

// node_modules/@probe.gl/env/dist/lib/is-electron.js
function isElectron(mockUserAgent) {
  var _a, _b;
  if (typeof window !== "undefined" && ((_a = window.process) == null ? void 0 : _a.type) === "renderer") {
    return true;
  }
  if (typeof process !== "undefined" && Boolean((_b = process.versions) == null ? void 0 : _b["electron"])) {
    return true;
  }
  const realUserAgent = typeof navigator !== "undefined" && navigator.userAgent;
  const userAgent = mockUserAgent || realUserAgent;
  return Boolean(userAgent && userAgent.indexOf("Electron") >= 0);
}

// node_modules/@probe.gl/env/dist/lib/is-browser.js
function isBrowser() {
  const isNode = (
    // @ts-expect-error
    typeof process === "object" && String(process) === "[object process]" && !(process == null ? void 0 : process.browser)
  );
  return !isNode || isElectron();
}

// node_modules/@probe.gl/env/dist/lib/get-browser.js
function getBrowser(mockUserAgent) {
  if (!mockUserAgent && !isBrowser()) {
    return "Node";
  }
  if (isElectron(mockUserAgent)) {
    return "Electron";
  }
  const userAgent = mockUserAgent || navigator_.userAgent || "";
  if (userAgent.indexOf("Edge") > -1) {
    return "Edge";
  }
  if (globalThis.chrome) {
    return "Chrome";
  }
  if (globalThis.safari) {
    return "Safari";
  }
  if (globalThis.mozInnerScreenX) {
    return "Firefox";
  }
  return "Unknown";
}

// node_modules/@probe.gl/env/dist/index.js
var VERSION = true ? "4.1.0" : "untranspiled source";

// node_modules/@probe.gl/log/dist/utils/local-storage.js
function getStorage(type) {
  try {
    const storage = window[type];
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e) {
    return null;
  }
}
var LocalStorage = class {
  constructor(id, defaultConfig, type = "sessionStorage") {
    this.storage = getStorage(type);
    this.id = id;
    this.config = defaultConfig;
    this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(configuration) {
    Object.assign(this.config, configuration);
    if (this.storage) {
      const serialized = JSON.stringify(this.config);
      this.storage.setItem(this.id, serialized);
    }
  }
  // Get config from persistent store, if available
  _loadConfiguration() {
    let configuration = {};
    if (this.storage) {
      const serializedConfiguration = this.storage.getItem(this.id);
      configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
    }
    Object.assign(this.config, configuration);
    return this;
  }
};

// node_modules/@probe.gl/log/dist/utils/formatters.js
function formatTime(ms) {
  let formatted;
  if (ms < 10) {
    formatted = `${ms.toFixed(2)}ms`;
  } else if (ms < 100) {
    formatted = `${ms.toFixed(1)}ms`;
  } else if (ms < 1e3) {
    formatted = `${ms.toFixed(0)}ms`;
  } else {
    formatted = `${(ms / 1e3).toFixed(2)}s`;
  }
  return formatted;
}
function leftPad(string, length = 8) {
  const padLength = Math.max(length - string.length, 0);
  return `${" ".repeat(padLength)}${string}`;
}

// node_modules/@probe.gl/log/dist/utils/color.js
var COLOR;
(function(COLOR2) {
  COLOR2[COLOR2["BLACK"] = 30] = "BLACK";
  COLOR2[COLOR2["RED"] = 31] = "RED";
  COLOR2[COLOR2["GREEN"] = 32] = "GREEN";
  COLOR2[COLOR2["YELLOW"] = 33] = "YELLOW";
  COLOR2[COLOR2["BLUE"] = 34] = "BLUE";
  COLOR2[COLOR2["MAGENTA"] = 35] = "MAGENTA";
  COLOR2[COLOR2["CYAN"] = 36] = "CYAN";
  COLOR2[COLOR2["WHITE"] = 37] = "WHITE";
  COLOR2[COLOR2["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
  COLOR2[COLOR2["BRIGHT_RED"] = 91] = "BRIGHT_RED";
  COLOR2[COLOR2["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
  COLOR2[COLOR2["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
  COLOR2[COLOR2["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
  COLOR2[COLOR2["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
  COLOR2[COLOR2["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
  COLOR2[COLOR2["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
})(COLOR || (COLOR = {}));
var BACKGROUND_INCREMENT = 10;
function getColor(color) {
  if (typeof color !== "string") {
    return color;
  }
  color = color.toUpperCase();
  return COLOR[color] || COLOR.WHITE;
}
function addColor(string, color, background) {
  if (!isBrowser && typeof string === "string") {
    if (color) {
      const colorCode = getColor(color);
      string = `\x1B[${colorCode}m${string}\x1B[39m`;
    }
    if (background) {
      const colorCode = getColor(background);
      string = `\x1B[${colorCode + BACKGROUND_INCREMENT}m${string}\x1B[49m`;
    }
  }
  return string;
}

// node_modules/@probe.gl/log/dist/utils/autobind.js
function autobind(obj, predefined = ["constructor"]) {
  const proto = Object.getPrototypeOf(obj);
  const propNames = Object.getOwnPropertyNames(proto);
  const object = obj;
  for (const key of propNames) {
    const value = object[key];
    if (typeof value === "function") {
      if (!predefined.find((name2) => key === name2)) {
        object[key] = value.bind(obj);
      }
    }
  }
}

// node_modules/@probe.gl/log/dist/utils/assert.js
function assert2(condition, message2) {
  if (!condition) {
    throw new Error(message2 || "Assertion failed");
  }
}

// node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js
function getHiResTimestamp2() {
  var _a, _b, _c, _d, _e;
  let timestamp;
  if (isBrowser() && window_.performance) {
    timestamp = (_c = (_b = (_a = window_) == null ? void 0 : _a.performance) == null ? void 0 : _b.now) == null ? void 0 : _c.call(_b);
  } else if ("hrtime" in process_) {
    const timeParts = (_e = (_d = process_) == null ? void 0 : _d.hrtime) == null ? void 0 : _e.call(_d);
    timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}

// node_modules/@probe.gl/log/dist/log.js
var originalConsole = {
  debug: isBrowser() ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
var DEFAULT_LOG_CONFIGURATION = {
  enabled: true,
  level: 0
};
function noop() {
}
var cache = {};
var ONCE = { once: true };
var Log = class {
  constructor({ id } = { id: "" }) {
    this.VERSION = VERSION;
    this._startTs = getHiResTimestamp2();
    this._deltaTs = getHiResTimestamp2();
    this.userData = {};
    this.LOG_THROTTLE_TIMEOUT = 0;
    this.id = id;
    this.userData = {};
    this._storage = new LocalStorage(`__probe-${this.id}__`, DEFAULT_LOG_CONFIGURATION);
    this.timeStamp(`${this.id} started`);
    autobind(this);
    Object.seal(this);
  }
  set level(newLevel) {
    this.setLevel(newLevel);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  /** @return milliseconds, with fractions */
  getTotal() {
    return Number((getHiResTimestamp2() - this._startTs).toPrecision(10));
  }
  /** @return milliseconds, with fractions */
  getDelta() {
    return Number((getHiResTimestamp2() - this._deltaTs).toPrecision(10));
  }
  /** @deprecated use logLevel */
  set priority(newPriority) {
    this.level = newPriority;
  }
  /** @deprecated use logLevel */
  get priority() {
    return this.level;
  }
  /** @deprecated use logLevel */
  getPriority() {
    return this.level;
  }
  // Configure
  enable(enabled = true) {
    this._storage.setConfiguration({ enabled });
    return this;
  }
  setLevel(level) {
    this._storage.setConfiguration({ level });
    return this;
  }
  /** return the current status of the setting */
  get(setting) {
    return this._storage.config[setting];
  }
  // update the status of the setting
  set(setting, value) {
    this._storage.setConfiguration({ [setting]: value });
  }
  /** Logs the current settings as a table */
  settings() {
    if (console.table) {
      console.table(this._storage.config);
    } else {
      console.log(this._storage.config);
    }
  }
  // Unconditional logging
  assert(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "Assertion failed");
    }
  }
  warn(message2) {
    return this._getLogFunction(0, message2, originalConsole.warn, arguments, ONCE);
  }
  error(message2) {
    return this._getLogFunction(0, message2, originalConsole.error, arguments);
  }
  /** Print a deprecation warning */
  deprecated(oldUsage, newUsage) {
    return this.warn(`\`${oldUsage}\` is deprecated and will be removed in a later version. Use \`${newUsage}\` instead`);
  }
  /** Print a removal warning */
  removed(oldUsage, newUsage) {
    return this.error(`\`${oldUsage}\` has been removed. Use \`${newUsage}\` instead`);
  }
  probe(logLevel, message2) {
    return this._getLogFunction(logLevel, message2, originalConsole.log, arguments, {
      time: true,
      once: true
    });
  }
  log(logLevel, message2) {
    return this._getLogFunction(logLevel, message2, originalConsole.debug, arguments);
  }
  info(logLevel, message2) {
    return this._getLogFunction(logLevel, message2, console.info, arguments);
  }
  once(logLevel, message2) {
    return this._getLogFunction(logLevel, message2, originalConsole.debug || originalConsole.info, arguments, ONCE);
  }
  /** Logs an object as a table */
  table(logLevel, table, columns) {
    if (table) {
      return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
        tag: getTableHeader(table)
      });
    }
    return noop;
  }
  time(logLevel, message2) {
    return this._getLogFunction(logLevel, message2, console.time ? console.time : console.info);
  }
  timeEnd(logLevel, message2) {
    return this._getLogFunction(logLevel, message2, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(logLevel, message2) {
    return this._getLogFunction(logLevel, message2, console.timeStamp || noop);
  }
  group(logLevel, message2, opts = { collapsed: false }) {
    const options = normalizeArguments({ logLevel, message: message2, opts });
    const { collapsed } = opts;
    options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
    return this._getLogFunction(options);
  }
  groupCollapsed(logLevel, message2, opts = {}) {
    return this.group(logLevel, message2, Object.assign({}, opts, { collapsed: true }));
  }
  groupEnd(logLevel) {
    return this._getLogFunction(logLevel, "", console.groupEnd || noop);
  }
  // EXPERIMENTAL
  withGroup(logLevel, message2, func) {
    this.group(logLevel, message2)();
    try {
      func();
    } finally {
      this.groupEnd(logLevel)();
    }
  }
  trace() {
    if (console.trace) {
      console.trace();
    }
  }
  // PRIVATE METHODS
  /** Deduces log level from a variety of arguments */
  _shouldLog(logLevel) {
    return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
  }
  _getLogFunction(logLevel, message2, method, args, opts) {
    if (this._shouldLog(logLevel)) {
      opts = normalizeArguments({ logLevel, message: message2, args, opts });
      method = method || opts.method;
      assert2(method);
      opts.total = this.getTotal();
      opts.delta = this.getDelta();
      this._deltaTs = getHiResTimestamp2();
      const tag = opts.tag || opts.message;
      if (opts.once && tag) {
        if (!cache[tag]) {
          cache[tag] = getHiResTimestamp2();
        } else {
          return noop;
        }
      }
      message2 = decorateMessage(this.id, opts.message, opts);
      return method.bind(console, message2, ...opts.args);
    }
    return noop;
  }
};
Log.VERSION = VERSION;
function normalizeLogLevel(logLevel) {
  if (!logLevel) {
    return 0;
  }
  let resolvedLevel;
  switch (typeof logLevel) {
    case "number":
      resolvedLevel = logLevel;
      break;
    case "object":
      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
      break;
    default:
      return 0;
  }
  assert2(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
  return resolvedLevel;
}
function normalizeArguments(opts) {
  const { logLevel, message: message2 } = opts;
  opts.logLevel = normalizeLogLevel(logLevel);
  const args = opts.args ? Array.from(opts.args) : [];
  while (args.length && args.shift() !== message2) {
  }
  switch (typeof logLevel) {
    case "string":
    case "function":
      if (message2 !== void 0) {
        args.unshift(message2);
      }
      opts.message = logLevel;
      break;
    case "object":
      Object.assign(opts, logLevel);
      break;
    default:
  }
  if (typeof opts.message === "function") {
    opts.message = opts.message();
  }
  const messageType = typeof opts.message;
  assert2(messageType === "string" || messageType === "object");
  return Object.assign(opts, { args }, opts.opts);
}
function decorateMessage(id, message2, opts) {
  if (typeof message2 === "string") {
    const time = opts.time ? leftPad(formatTime(opts.total)) : "";
    message2 = opts.time ? `${id}: ${time}  ${message2}` : `${id}: ${message2}`;
    message2 = addColor(message2, opts.color, opts.background);
  }
  return message2;
}
function getTableHeader(table) {
  for (const key in table) {
    for (const title in table[key]) {
      return title || "untitled";
    }
  }
  return "empty";
}

// node_modules/@probe.gl/log/dist/init.js
globalThis.probe = {};

// node_modules/@probe.gl/log/dist/index.js
var dist_default = new Log({ id: "@probe.gl/log" });

// node_modules/@luma.gl/core/dist/utils/log.js
var log = new Log({ id: "luma.gl" });

// node_modules/@luma.gl/core/dist/utils/uid.js
var uidCounters = {};
function uid(id = "id") {
  uidCounters[id] = uidCounters[id] || 1;
  const count = uidCounters[id]++;
  return `${id}-${count}`;
}

// node_modules/@luma.gl/core/dist/adapter/resources/resource.js
var Resource = class {
  /**
   * Create a new Resource. Called from Subclass
   */
  constructor(device, props, defaultProps) {
    /** props.id, for debugging. */
    __publicField(this, "id");
    __publicField(this, "props");
    __publicField(this, "userData", {});
    __publicField(this, "_device");
    /** Whether this resource has been destroyed */
    __publicField(this, "destroyed", false);
    /** For resources that allocate GPU memory */
    __publicField(this, "allocatedBytes", 0);
    /** Attached resources will be destroyed when this resource is destroyed. Tracks auto-created "sub" resources. */
    __publicField(this, "_attachedResources", /* @__PURE__ */ new Set());
    if (!device) {
      throw new Error("no device");
    }
    this._device = device;
    this.props = selectivelyMerge(props, defaultProps);
    const id = this.props.id !== "undefined" ? this.props.id : uid(this[Symbol.toStringTag]);
    this.props.id = id;
    this.id = id;
    this.userData = this.props.userData || {};
    this.addStats();
  }
  toString() {
    return `${this[Symbol.toStringTag] || this.constructor.name}:"${this.id}"`;
  }
  /**
   * destroy can be called on any resource to release it before it is garbage collected.
   */
  destroy() {
    this.destroyResource();
  }
  /** @deprecated Use destroy() */
  delete() {
    this.destroy();
    return this;
  }
  /**
   * Combines a map of user props and default props, only including props from defaultProps
   * @returns returns a map of overridden default props
   */
  getProps() {
    return this.props;
  }
  // ATTACHED RESOURCES
  /**
   * Attaches a resource. Attached resources are auto destroyed when this resource is destroyed
   * Called automatically when sub resources are auto created but can be called by application
   */
  attachResource(resource) {
    this._attachedResources.add(resource);
  }
  /**
   * Detach an attached resource. The resource will no longer be auto-destroyed when this resource is destroyed.
   */
  detachResource(resource) {
    this._attachedResources.delete(resource);
  }
  /**
   * Destroys a resource (only if owned), and removes from the owned (auto-destroy) list for this resource.
   */
  destroyAttachedResource(resource) {
    if (this._attachedResources.delete(resource)) {
      resource.destroy();
    }
  }
  /** Destroy all owned resources. Make sure the resources are no longer needed before calling. */
  destroyAttachedResources() {
    for (const resource of Object.values(this._attachedResources)) {
      resource.destroy();
    }
    this._attachedResources = /* @__PURE__ */ new Set();
  }
  // PROTECTED METHODS
  /** Perform all destroy steps. Can be called by derived resources when overriding destroy() */
  destroyResource() {
    this.destroyAttachedResources();
    this.removeStats();
    this.destroyed = true;
  }
  /** Called by .destroy() to track object destruction. Subclass must call if overriding destroy() */
  removeStats() {
    const stats = this._device.statsManager.getStats("Resource Counts");
    const name2 = this[Symbol.toStringTag];
    stats.get(`${name2}s Active`).decrementCount();
  }
  /** Called by subclass to track memory allocations */
  trackAllocatedMemory(bytes, name2 = this[Symbol.toStringTag]) {
    const stats = this._device.statsManager.getStats("Resource Counts");
    stats.get("GPU Memory").addCount(bytes);
    stats.get(`${name2} Memory`).addCount(bytes);
    this.allocatedBytes = bytes;
  }
  /** Called by subclass to track memory deallocations */
  trackDeallocatedMemory(name2 = this[Symbol.toStringTag]) {
    const stats = this._device.statsManager.getStats("Resource Counts");
    stats.get("GPU Memory").subtractCount(this.allocatedBytes);
    stats.get(`${name2} Memory`).subtractCount(this.allocatedBytes);
    this.allocatedBytes = 0;
  }
  /** Called by resource constructor to track object creation */
  addStats() {
    const stats = this._device.statsManager.getStats("Resource Counts");
    const name2 = this[Symbol.toStringTag];
    stats.get("Resources Created").incrementCount();
    stats.get(`${name2}s Created`).incrementCount();
    stats.get(`${name2}s Active`).incrementCount();
  }
};
/** Default properties for resource */
__publicField(Resource, "defaultProps", {
  id: "undefined",
  handle: void 0,
  userData: void 0
});
function selectivelyMerge(props, defaultProps) {
  const mergedProps = { ...defaultProps };
  for (const key in props) {
    if (props[key] !== void 0) {
      mergedProps[key] = props[key];
    }
  }
  return mergedProps;
}

// node_modules/@luma.gl/core/dist/adapter/resources/buffer.js
var _Buffer = class _Buffer extends Resource {
  constructor(device, props) {
    const deducedProps = { ...props };
    if ((props.usage || 0) & _Buffer.INDEX && !props.indexType) {
      if (props.data instanceof Uint32Array) {
        deducedProps.indexType = "uint32";
      } else if (props.data instanceof Uint16Array) {
        deducedProps.indexType = "uint16";
      } else if (props.data instanceof Uint8Array) {
        deducedProps.indexType = "uint8";
      }
    }
    delete deducedProps.data;
    super(device, deducedProps, _Buffer.defaultProps);
    /** The usage with which this buffer was created */
    __publicField(this, "usage");
    /** For index buffers, whether indices are 8, 16 or 32 bit. Note: uint8 indices are automatically converted to uint16 for WebGPU compatibility */
    __publicField(this, "indexType");
    /** "Time" of last update, can be used to check if redraw is needed */
    __publicField(this, "updateTimestamp");
    /** A partial CPU-side copy of the data in this buffer, for debugging purposes */
    __publicField(this, "debugData", new ArrayBuffer(0));
    this.usage = deducedProps.usage || 0;
    this.indexType = deducedProps.indexType;
    this.updateTimestamp = device.incrementTimestamp();
  }
  get [Symbol.toStringTag]() {
    return "Buffer";
  }
  /**
   * Create a copy of this Buffer with new byteLength, with same props but of the specified size.
   * @note Does not copy contents of the cloned Buffer.
   */
  clone(props) {
    return this.device.createBuffer({ ...this.props, ...props });
  }
  /** This doesn't handle partial non-zero offset updates correctly */
  _setDebugData(data, byteOffset, byteLength) {
    const arrayBuffer2 = ArrayBuffer.isView(data) ? data.buffer : data;
    const debugDataLength = Math.min(data ? data.byteLength : byteLength, _Buffer.DEBUG_DATA_MAX_LENGTH);
    if (arrayBuffer2 === null) {
      this.debugData = new ArrayBuffer(debugDataLength);
    } else if (byteOffset === 0 && byteLength === arrayBuffer2.byteLength) {
      this.debugData = arrayBuffer2.slice(0, debugDataLength);
    } else {
      this.debugData = arrayBuffer2.slice(byteOffset, byteOffset + debugDataLength);
    }
  }
};
/** Index buffer */
__publicField(_Buffer, "INDEX", 16);
/** Vertex buffer */
__publicField(_Buffer, "VERTEX", 32);
/** Uniform buffer */
__publicField(_Buffer, "UNIFORM", 64);
/** Storage buffer */
__publicField(_Buffer, "STORAGE", 128);
__publicField(_Buffer, "INDIRECT", 256);
__publicField(_Buffer, "QUERY_RESOLVE", 512);
// Usage Flags
__publicField(_Buffer, "MAP_READ", 1);
__publicField(_Buffer, "MAP_WRITE", 2);
__publicField(_Buffer, "COPY_SRC", 4);
__publicField(_Buffer, "COPY_DST", 8);
// PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)
/** Max amount of debug data saved. Two vec4's */
__publicField(_Buffer, "DEBUG_DATA_MAX_LENGTH", 32);
__publicField(_Buffer, "defaultProps", {
  ...Resource.defaultProps,
  usage: 0,
  // Buffer.COPY_DST | Buffer.COPY_SRC
  byteLength: 0,
  byteOffset: 0,
  data: null,
  indexType: "uint16",
  onMapped: void 0
});
var Buffer = _Buffer;

// node_modules/@luma.gl/core/dist/shadertypes/data-types/decode-data-types.js
function getDataTypeInfo(type) {
  const [signedType, primitiveType, byteLength] = NORMALIZED_TYPE_MAP[type];
  const normalized = type.includes("norm");
  const integer = !normalized && !type.startsWith("float");
  const signed = type.startsWith("s");
  return {
    signedType,
    primitiveType,
    byteLength,
    normalized,
    integer,
    signed
  };
}
function getNormalizedDataType(signedDataType) {
  const dataType = signedDataType;
  switch (dataType) {
    case "uint8":
      return "unorm8";
    case "sint8":
      return "snorm8";
    case "uint16":
      return "unorm16";
    case "sint16":
      return "snorm16";
    default:
      return dataType;
  }
}
function alignTo(size, count) {
  switch (count) {
    case 1:
      return size;
    case 2:
      return size + size % 2;
    default:
      return size + (4 - size % 4) % 4;
  }
}
function getDataType(arrayOrType) {
  const Constructor = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
  if (Constructor === Uint8ClampedArray) {
    return "uint8";
  }
  const info = Object.values(NORMALIZED_TYPE_MAP).find((entry) => Constructor === entry[4]);
  if (!info) {
    throw new Error(Constructor.name);
  }
  return info[0];
}
function getTypedArrayConstructor(type) {
  const [, , , , Constructor] = NORMALIZED_TYPE_MAP[type];
  return Constructor;
}
var NORMALIZED_TYPE_MAP = {
  uint8: ["uint8", "u32", 1, false, Uint8Array],
  sint8: ["sint8", "i32", 1, false, Int8Array],
  unorm8: ["uint8", "f32", 1, true, Uint8Array],
  snorm8: ["sint8", "f32", 1, true, Int8Array],
  uint16: ["uint16", "u32", 2, false, Uint16Array],
  sint16: ["sint16", "i32", 2, false, Int16Array],
  unorm16: ["uint16", "u32", 2, true, Uint16Array],
  snorm16: ["sint16", "i32", 2, true, Int16Array],
  float16: ["float16", "f16", 2, false, Uint16Array],
  float32: ["float32", "f32", 4, false, Float32Array],
  uint32: ["uint32", "u32", 4, false, Uint32Array],
  sint32: ["sint32", "i32", 4, false, Int32Array]
};

// node_modules/@luma.gl/core/dist/shadertypes/vertex-arrays/decode-vertex-format.js
function getVertexFormatInfo(format) {
  let webglOnly;
  if (format.endsWith("-webgl")) {
    format.replace("-webgl", "");
    webglOnly = true;
  }
  const [type_, count] = format.split("x");
  const type = type_;
  const components = count ? parseInt(count) : 1;
  const decodedType = getDataTypeInfo(type);
  const result = {
    type,
    components,
    byteLength: decodedType.byteLength * components,
    integer: decodedType.integer,
    signed: decodedType.signed,
    normalized: decodedType.normalized
  };
  if (webglOnly) {
    result.webglOnly = true;
  }
  return result;
}
function makeVertexFormat(signedDataType, components, normalized) {
  const dataType = normalized ? getNormalizedDataType(signedDataType) : signedDataType;
  switch (dataType) {
    case "unorm8":
      if (components === 1) {
        return "unorm8";
      }
      if (components === 3) {
        return "unorm8x3-webgl";
      }
      return `${dataType}x${components}`;
    case "snorm8":
    case "uint8":
    case "sint8":
    case "uint16":
    case "sint16":
    case "unorm16":
    case "snorm16":
    case "float16":
      if (components === 1 || components === 3) {
        throw new Error(`size: ${components}`);
      }
      return `${dataType}x${components}`;
    default:
      return components === 1 ? dataType : `${dataType}x${components}`;
  }
}
function getVertexFormatFromAttribute(typedArray, size, normalized) {
  if (!size || size > 4) {
    throw new Error(`size ${size}`);
  }
  const components = size;
  const signedDataType = getDataType(typedArray);
  return makeVertexFormat(signedDataType, components, normalized);
}
function getCompatibleVertexFormat(opts) {
  let vertexType;
  switch (opts.primitiveType) {
    case "f32":
      vertexType = "float32";
      break;
    case "i32":
      vertexType = "sint32";
      break;
    case "u32":
      vertexType = "uint32";
      break;
    case "f16":
      return opts.components <= 2 ? "float16x2" : "float16x4";
  }
  if (opts.components === 1) {
    return vertexType;
  }
  return `${vertexType}x${opts.components}`;
}

// node_modules/@luma.gl/core/dist/shadertypes/textures/texture-format-table.js
var texture_compression_bc = "texture-compression-bc";
var texture_compression_astc = "texture-compression-astc";
var texture_compression_etc2 = "texture-compression-etc2";
var texture_compression_etc1_webgl = "texture-compression-etc1-webgl";
var texture_compression_pvrtc_webgl = "texture-compression-pvrtc-webgl";
var texture_compression_atc_webgl = "texture-compression-atc-webgl";
var float32_renderable = "float32-renderable-webgl";
var float16_renderable = "float16-renderable-webgl";
var rgb9e5ufloat_renderable = "rgb9e5ufloat-renderable-webgl";
var snorm8_renderable = "snorm8-renderable-webgl";
var norm16_renderable = "norm16-renderable-webgl";
var snorm16_renderable = "snorm16-renderable-webgl";
var float32_filterable = "float32-filterable";
var float16_filterable = "float16-filterable-webgl";
function getTextureFormatDefinition(format) {
  const info = TEXTURE_FORMAT_TABLE[format];
  if (!info) {
    throw new Error(`Unsupported texture format ${format}`);
  }
  return info;
}
var TEXTURE_FORMAT_COLOR_DEPTH_TABLE = {
  // 8-bit formats
  "r8unorm": {},
  "rg8unorm": {},
  "rgb8unorm-webgl": {},
  "rgba8unorm": {},
  "rgba8unorm-srgb": {},
  "r8snorm": { render: snorm8_renderable },
  "rg8snorm": { render: snorm8_renderable },
  "rgb8snorm-webgl": {},
  "rgba8snorm": { render: snorm8_renderable },
  "r8uint": {},
  "rg8uint": {},
  "rgba8uint": {},
  "r8sint": {},
  "rg8sint": {},
  "rgba8sint": {},
  "bgra8unorm": {},
  "bgra8unorm-srgb": {},
  "r16unorm": { f: norm16_renderable },
  "rg16unorm": { render: norm16_renderable },
  "rgb16unorm-webgl": { f: norm16_renderable },
  // rgb not renderable
  "rgba16unorm": { render: norm16_renderable },
  "r16snorm": { f: snorm16_renderable },
  "rg16snorm": { render: snorm16_renderable },
  "rgb16snorm-webgl": { f: norm16_renderable },
  // rgb not renderable
  "rgba16snorm": { render: snorm16_renderable },
  "r16uint": {},
  "rg16uint": {},
  "rgba16uint": {},
  "r16sint": {},
  "rg16sint": {},
  "rgba16sint": {},
  "r16float": { render: float16_renderable, filter: "float16-filterable-webgl" },
  "rg16float": { render: float16_renderable, filter: float16_filterable },
  "rgba16float": { render: float16_renderable, filter: float16_filterable },
  "r32uint": {},
  "rg32uint": {},
  "rgba32uint": {},
  "r32sint": {},
  "rg32sint": {},
  "rgba32sint": {},
  "r32float": { render: float32_renderable, filter: float32_filterable },
  "rg32float": { render: false, filter: float32_filterable },
  "rgb32float-webgl": { render: float32_renderable, filter: float32_filterable },
  "rgba32float": { render: float32_renderable, filter: float32_filterable },
  // Packed 16-bit formats
  "rgba4unorm-webgl": { channels: "rgba", bitsPerChannel: [4, 4, 4, 4], packed: true },
  "rgb565unorm-webgl": { channels: "rgb", bitsPerChannel: [5, 6, 5, 0], packed: true },
  "rgb5a1unorm-webgl": { channels: "rgba", bitsPerChannel: [5, 5, 5, 1], packed: true },
  // Packed 32 bit formats
  "rgb9e5ufloat": { channels: "rgb", packed: true, render: rgb9e5ufloat_renderable },
  // , filter: true},
  "rg11b10ufloat": { channels: "rgb", bitsPerChannel: [11, 11, 10, 0], packed: true, p: 1, render: float32_renderable },
  "rgb10a2unorm": { channels: "rgba", bitsPerChannel: [10, 10, 10, 2], packed: true, p: 1 },
  "rgb10a2uint": { channels: "rgba", bitsPerChannel: [10, 10, 10, 2], packed: true, p: 1 },
  // Depth/stencil Formats
  // Depth and stencil formats
  stencil8: { attachment: "stencil", bitsPerChannel: [8, 0, 0, 0], dataType: "uint8" },
  "depth16unorm": { attachment: "depth", bitsPerChannel: [16, 0, 0, 0], dataType: "uint16" },
  "depth24plus": { attachment: "depth", bitsPerChannel: [24, 0, 0, 0], dataType: "uint32" },
  "depth32float": { attachment: "depth", bitsPerChannel: [32, 0, 0, 0], dataType: "float32" },
  // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
  "depth24plus-stencil8": { attachment: "depth-stencil", bitsPerChannel: [24, 8, 0, 0], packed: true },
  // "depth32float-stencil8" feature
  "depth32float-stencil8": { attachment: "depth-stencil", bitsPerChannel: [32, 8, 0, 0], packed: true }
};
var TEXTURE_FORMAT_COMPRESSED_TABLE = {
  // BC compressed formats: check device.features.has("texture-compression-bc");
  "bc1-rgb-unorm-webgl": { f: texture_compression_bc },
  "bc1-rgb-unorm-srgb-webgl": { f: texture_compression_bc },
  "bc1-rgba-unorm": { f: texture_compression_bc },
  "bc1-rgba-unorm-srgb": { f: texture_compression_bc },
  "bc2-rgba-unorm": { f: texture_compression_bc },
  "bc2-rgba-unorm-srgb": { f: texture_compression_bc },
  "bc3-rgba-unorm": { f: texture_compression_bc },
  "bc3-rgba-unorm-srgb": { f: texture_compression_bc },
  "bc4-r-unorm": { f: texture_compression_bc },
  "bc4-r-snorm": { f: texture_compression_bc },
  "bc5-rg-unorm": { f: texture_compression_bc },
  "bc5-rg-snorm": { f: texture_compression_bc },
  "bc6h-rgb-ufloat": { f: texture_compression_bc },
  "bc6h-rgb-float": { f: texture_compression_bc },
  "bc7-rgba-unorm": { f: texture_compression_bc },
  "bc7-rgba-unorm-srgb": { f: texture_compression_bc },
  // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
  "etc2-rgb8unorm": { f: texture_compression_etc2 },
  "etc2-rgb8unorm-srgb": { f: texture_compression_etc2 },
  "etc2-rgb8a1unorm": { f: texture_compression_etc2 },
  "etc2-rgb8a1unorm-srgb": { f: texture_compression_etc2 },
  "etc2-rgba8unorm": { f: texture_compression_etc2 },
  "etc2-rgba8unorm-srgb": { f: texture_compression_etc2 },
  "eac-r11unorm": { f: texture_compression_etc2 },
  "eac-r11snorm": { f: texture_compression_etc2 },
  "eac-rg11unorm": { f: texture_compression_etc2 },
  "eac-rg11snorm": { f: texture_compression_etc2 },
  // X_ASTC compressed formats: device.features.has("texture-compression-astc")
  "astc-4x4-unorm": { f: texture_compression_astc },
  "astc-4x4-unorm-srgb": { f: texture_compression_astc },
  "astc-5x4-unorm": { f: texture_compression_astc },
  "astc-5x4-unorm-srgb": { f: texture_compression_astc },
  "astc-5x5-unorm": { f: texture_compression_astc },
  "astc-5x5-unorm-srgb": { f: texture_compression_astc },
  "astc-6x5-unorm": { f: texture_compression_astc },
  "astc-6x5-unorm-srgb": { f: texture_compression_astc },
  "astc-6x6-unorm": { f: texture_compression_astc },
  "astc-6x6-unorm-srgb": { f: texture_compression_astc },
  "astc-8x5-unorm": { f: texture_compression_astc },
  "astc-8x5-unorm-srgb": { f: texture_compression_astc },
  "astc-8x6-unorm": { f: texture_compression_astc },
  "astc-8x6-unorm-srgb": { f: texture_compression_astc },
  "astc-8x8-unorm": { f: texture_compression_astc },
  "astc-8x8-unorm-srgb": { f: texture_compression_astc },
  "astc-10x5-unorm": { f: texture_compression_astc },
  "astc-10x5-unorm-srgb": { f: texture_compression_astc },
  "astc-10x6-unorm": { f: texture_compression_astc },
  "astc-10x6-unorm-srgb": { f: texture_compression_astc },
  "astc-10x8-unorm": { f: texture_compression_astc },
  "astc-10x8-unorm-srgb": { f: texture_compression_astc },
  "astc-10x10-unorm": { f: texture_compression_astc },
  "astc-10x10-unorm-srgb": { f: texture_compression_astc },
  "astc-12x10-unorm": { f: texture_compression_astc },
  "astc-12x10-unorm-srgb": { f: texture_compression_astc },
  "astc-12x12-unorm": { f: texture_compression_astc },
  "astc-12x12-unorm-srgb": { f: texture_compression_astc },
  // WEBGL_compressed_texture_pvrtc
  "pvrtc-rgb4unorm-webgl": { f: texture_compression_pvrtc_webgl },
  "pvrtc-rgba4unorm-webgl": { f: texture_compression_pvrtc_webgl },
  "pvrtc-rbg2unorm-webgl": { f: texture_compression_pvrtc_webgl },
  "pvrtc-rgba2unorm-webgl": { f: texture_compression_pvrtc_webgl },
  // WEBGL_compressed_texture_etc1
  "etc1-rbg-unorm-webgl": { f: texture_compression_etc1_webgl },
  // WEBGL_compressed_texture_atc
  "atc-rgb-unorm-webgl": { f: texture_compression_atc_webgl },
  "atc-rgba-unorm-webgl": { f: texture_compression_atc_webgl },
  "atc-rgbai-unorm-webgl": { f: texture_compression_atc_webgl }
};
var TEXTURE_FORMAT_TABLE = {
  ...TEXTURE_FORMAT_COLOR_DEPTH_TABLE,
  ...TEXTURE_FORMAT_COMPRESSED_TABLE
};

// node_modules/@luma.gl/core/dist/shadertypes/textures/texture-format-decoder.js
var COMPRESSED_TEXTURE_FORMAT_PREFIXES = [
  "bc1",
  "bc2",
  "bc3",
  "bc4",
  "bc5",
  "bc6",
  "bc7",
  "etc1",
  "etc2",
  "eac",
  "atc",
  "astc",
  "pvrtc"
];
var RGB_FORMAT_REGEX = /^(r|rg|rgb|rgba|bgra)([0-9]*)([a-z]*)(-srgb)?(-webgl)?$/;
var TextureFormatDecoder = class {
  /** Returns information about a texture format, e.g. attatchment type, components, byte length and flags (integer, signed, normalized) */
  getInfo(format) {
    return getTextureFormatInfo(format);
  }
  /** Checks if a texture format is color */
  isColor(format) {
    return format.startsWith("rgba") || format.startsWith("bgra") || format.startsWith("rgb");
  }
  /** Checks if a texture format is depth or stencil */
  isDepthStencil(format) {
    return format.startsWith("depth") || format.startsWith("stencil");
  }
  /** Checks if a texture format is compressed */
  isCompressed(format) {
    return COMPRESSED_TEXTURE_FORMAT_PREFIXES.some((prefix) => format.startsWith(prefix));
  }
  /**
   * Returns the "static" capabilities of a texture format.
   * @note Needs to be checked against current device
   */
  getCapabilities(format) {
    const info = getTextureFormatDefinition(format);
    const formatCapabilities = {
      format,
      create: info.f ?? true,
      render: info.render ?? true,
      filter: info.filter ?? true,
      blend: info.blend ?? true,
      store: info.store ?? true
    };
    const formatInfo = getTextureFormatInfo(format);
    const isDepthStencil = format.startsWith("depth") || format.startsWith("stencil");
    const isSigned = formatInfo == null ? void 0 : formatInfo.signed;
    const isInteger = formatInfo == null ? void 0 : formatInfo.integer;
    const isWebGLSpecific = formatInfo == null ? void 0 : formatInfo.webgl;
    formatCapabilities.render && (formatCapabilities.render = !isSigned);
    formatCapabilities.filter && (formatCapabilities.filter = !isDepthStencil && !isSigned && !isInteger && !isWebGLSpecific);
    return formatCapabilities;
  }
};
var textureFormatDecoder = new TextureFormatDecoder();
function getTextureFormatInfo(format) {
  let formatInfo = getTextureFormatInfoUsingTable(format);
  if (textureFormatDecoder.isCompressed(format)) {
    formatInfo.channels = "rgb";
    formatInfo.components = 3;
    formatInfo.bytesPerPixel = 1;
    formatInfo.srgb = false;
    formatInfo.compressed = true;
    const blockSize = getCompressedTextureBlockSize(format);
    if (blockSize) {
      formatInfo.blockWidth = blockSize.blockWidth;
      formatInfo.blockHeight = blockSize.blockHeight;
    }
  }
  const matches = RGB_FORMAT_REGEX.exec(format);
  if (matches) {
    const [, channels, length, type, srgb, suffix] = matches;
    const dataType = `${type}${length}`;
    const decodedType = getDataTypeInfo(dataType);
    const bits = decodedType.byteLength * 8;
    const components = channels.length;
    const bitsPerChannel = [
      bits,
      components >= 2 ? bits : 0,
      components >= 3 ? bits : 0,
      components >= 4 ? bits : 0
    ];
    formatInfo = {
      format,
      attachment: formatInfo.attachment,
      dataType: decodedType.signedType,
      components,
      channels,
      integer: decodedType.integer,
      signed: decodedType.signed,
      normalized: decodedType.normalized,
      bitsPerChannel,
      bytesPerPixel: decodedType.byteLength * channels.length,
      packed: formatInfo.packed,
      srgb: formatInfo.srgb
    };
    if (suffix === "-webgl") {
      formatInfo.webgl = true;
    }
    if (srgb === "-srgb") {
      formatInfo.srgb = true;
    }
  }
  if (format.endsWith("-webgl")) {
    formatInfo.webgl = true;
  }
  if (format.endsWith("-srgb")) {
    formatInfo.srgb = true;
  }
  return formatInfo;
}
function getTextureFormatInfoUsingTable(format) {
  var _a;
  const info = getTextureFormatDefinition(format);
  const bytesPerPixel = info.bytesPerPixel || 1;
  const bitsPerChannel = info.bitsPerChannel || [8, 8, 8, 8];
  delete info.bitsPerChannel;
  delete info.bytesPerPixel;
  delete info.f;
  delete info.render;
  delete info.filter;
  delete info.blend;
  delete info.store;
  const formatInfo = {
    ...info,
    format,
    attachment: info.attachment || "color",
    channels: info.channels || "r",
    components: info.components || ((_a = info.channels) == null ? void 0 : _a.length) || 1,
    bytesPerPixel,
    bitsPerChannel,
    dataType: info.dataType || "uint8",
    srgb: info.srgb ?? false,
    packed: info.packed ?? false,
    webgl: info.webgl ?? false,
    integer: info.integer ?? false,
    signed: info.signed ?? false,
    normalized: info.normalized ?? false,
    compressed: info.compressed ?? false
  };
  return formatInfo;
}
function getCompressedTextureBlockSize(format) {
  const REGEX = /.*-(\d+)x(\d+)-.*/;
  const matches = REGEX.exec(format);
  if (matches) {
    const [, blockWidth, blockHeight] = matches;
    return { blockWidth: Number(blockWidth), blockHeight: Number(blockHeight) };
  }
  return null;
}

// node_modules/@luma.gl/core/dist/image-utils/image-types.js
function isExternalImage(data) {
  return typeof ImageData !== "undefined" && data instanceof ImageData || typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap || typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement || typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement || typeof VideoFrame !== "undefined" && data instanceof VideoFrame || typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement || typeof OffscreenCanvas !== "undefined" && data instanceof OffscreenCanvas;
}
function getExternalImageSize(data) {
  if (typeof ImageData !== "undefined" && data instanceof ImageData || typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap || typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement || typeof OffscreenCanvas !== "undefined" && data instanceof OffscreenCanvas) {
    return { width: data.width, height: data.height };
  }
  if (typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement) {
    return { width: data.naturalWidth, height: data.naturalHeight };
  }
  if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) {
    return { width: data.videoWidth, height: data.videoHeight };
  }
  if (typeof VideoFrame !== "undefined" && data instanceof VideoFrame) {
    return { width: data.displayWidth, height: data.displayHeight };
  }
  throw new Error("Unknown image type");
}

// node_modules/@luma.gl/core/dist/adapter/device.js
var DeviceLimits = class {
};
var DeviceFeatures = class {
  constructor(features = [], disabledFeatures) {
    __publicField(this, "features");
    __publicField(this, "disabledFeatures");
    this.features = new Set(features);
    this.disabledFeatures = disabledFeatures || {};
  }
  *[Symbol.iterator]() {
    yield* this.features;
  }
  has(feature) {
    var _a;
    return !((_a = this.disabledFeatures) == null ? void 0 : _a[feature]) && this.features.has(feature);
  }
};
var _Device = class _Device {
  constructor(props) {
    /** id of this device, primarily for debugging */
    __publicField(this, "id");
    /** A copy of the device props  */
    __publicField(this, "props");
    /** Available for the application to store data on the device */
    __publicField(this, "userData", {});
    /** stats */
    __publicField(this, "statsManager", lumaStats);
    /** An abstract timestamp used for change tracking */
    __publicField(this, "timestamp", 0);
    /** True if this device has been reused during device creation (app has multiple references) */
    __publicField(this, "_reused", false);
    /** Used by other luma.gl modules to store data on the device */
    __publicField(this, "_lumaData", {});
    __publicField(this, "_textureCaps", {});
    this.props = { ..._Device.defaultProps, ...props };
    this.id = this.props.id || uid(this[Symbol.toStringTag].toLowerCase());
  }
  get [Symbol.toStringTag]() {
    return "Device";
  }
  toString() {
    return `Device(${this.id})`;
  }
  getVertexFormatInfo(format) {
    return getVertexFormatInfo(format);
  }
  isVertexFormatSupported(format) {
    return true;
  }
  /** Returns information about a texture format, such as data type, channels, bits per channel, compression etc */
  getTextureFormatInfo(format) {
    return textureFormatDecoder.getInfo(format);
  }
  /** Determines what operations are supported on a texture format on this particular device (checks against supported device features) */
  getTextureFormatCapabilities(format) {
    let textureCaps = this._textureCaps[format];
    if (!textureCaps) {
      const capabilities = this._getDeviceTextureFormatCapabilities(format);
      textureCaps = this._getDeviceSpecificTextureFormatCapabilities(capabilities);
      this._textureCaps[format] = textureCaps;
    }
    return textureCaps;
  }
  /** Calculates the number of mip levels for a texture of width, height and in case of 3d textures only, depth */
  getMipLevelCount(width, height, depth3d = 1) {
    const maxSize = Math.max(width, height, depth3d);
    return 1 + Math.floor(Math.log2(maxSize));
  }
  /** Check if data is an external image */
  isExternalImage(data) {
    return isExternalImage(data);
  }
  /** Get the size of an external image */
  getExternalImageSize(data) {
    return getExternalImageSize(data);
  }
  /** Check if device supports a specific texture format (creation and `nearest` sampling) */
  isTextureFormatSupported(format) {
    return this.getTextureFormatCapabilities(format).create;
  }
  /** Check if linear filtering (sampler interpolation) is supported for a specific texture format */
  isTextureFormatFilterable(format) {
    return this.getTextureFormatCapabilities(format).filter;
  }
  /** Check if device supports rendering to a framebuffer color attachment of a specific texture format */
  isTextureFormatRenderable(format) {
    return this.getTextureFormatCapabilities(format).render;
  }
  /** Check if a specific texture format is GPU compressed */
  isTextureFormatCompressed(format) {
    return textureFormatDecoder.isCompressed(format);
  }
  // DEBUG METHODS
  pushDebugGroup(groupLabel) {
    this.commandEncoder.pushDebugGroup(groupLabel);
  }
  popDebugGroup() {
    var _a;
    (_a = this.commandEncoder) == null ? void 0 : _a.popDebugGroup();
  }
  insertDebugMarker(markerLabel) {
    var _a;
    (_a = this.commandEncoder) == null ? void 0 : _a.insertDebugMarker(markerLabel);
  }
  /**
   * Trigger device loss.
   * @returns `true` if context loss could actually be triggered.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    return false;
  }
  /** A monotonic counter for tracking buffer and texture updates */
  incrementTimestamp() {
    return this.timestamp++;
  }
  /**
   * Reports Device errors in a way that optimizes for developer experience / debugging.
   * - Logs so that the console error links directly to the source code that generated the error.
   * - Includes the object that reported the error in the log message, even if the error is asynchronous.
   *
   * Conventions when calling reportError():
   * - Always call the returned function - to ensure error is logged, at the error site
   * - Follow with a call to device.debug() - to ensure that the debugger breaks at the error site
   *
   * @param error - the error to report. If needed, just create a new Error object with the appropriate message.
   * @param context - pass `this` as context, otherwise it may not be available in the debugger for async errors.
   * @returns the logger function returned by device.props.onError() so that it can be called from the error site.
   *
   * @example
   *   device.reportError(new Error(...), this)();
   *   device.debug();
   */
  reportError(error, context, ...args) {
    const isHandled = this.props.onError(error, context);
    if (!isHandled) {
      return log.error(error.message, context, ...args);
    }
    return () => {
    };
  }
  /** Break in the debugger - if device.props.debug is true */
  debug() {
    if (this.props.debug) {
      debugger;
    } else {
      const message2 = `'Type luma.log.set({debug: true}) in console to enable debug breakpoints',
or create a device with the 'debug: true' prop.`;
      log.once(0, message2)();
    }
  }
  /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */
  getDefaultCanvasContext() {
    if (!this.canvasContext) {
      throw new Error("Device has no default CanvasContext. See props.createCanvasContext");
    }
    return this.canvasContext;
  }
  /** Create a RenderPass using the default CommandEncoder */
  beginRenderPass(props) {
    return this.commandEncoder.beginRenderPass(props);
  }
  /** Create a ComputePass using the default CommandEncoder*/
  beginComputePass(props) {
    return this.commandEncoder.beginComputePass(props);
  }
  // DEPRECATED METHODS
  /** @deprecated Use getDefaultCanvasContext() */
  getCanvasContext() {
    return this.getDefaultCanvasContext();
  }
  // WebGL specific HACKS - enables app to remove webgl import
  // Use until we have a better way to handle these
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToArrayWebGL(source, options) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToBufferWebGL(source, options) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  setParametersWebGL(parameters) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  getParametersWebGL(parameters) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  withParametersWebGL(parameters, func) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use clear arguments in RenderPass */
  clearWebGL(options) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use for debugging only */
  resetWebGL() {
    throw new Error("not implemented");
  }
  // IMPLEMENTATION
  /** Helper to get the canvas context props */
  static _getCanvasContextProps(props) {
    return props.createCanvasContext === true ? {} : props.createCanvasContext;
  }
  _getDeviceTextureFormatCapabilities(format) {
    const genericCapabilities = textureFormatDecoder.getCapabilities(format);
    const checkFeature = (feature) => (typeof feature === "string" ? this.features.has(feature) : feature) ?? true;
    const supported = checkFeature(genericCapabilities.create);
    return {
      format,
      create: supported,
      render: supported && checkFeature(genericCapabilities.render),
      filter: supported && checkFeature(genericCapabilities.filter),
      blend: supported && checkFeature(genericCapabilities.blend),
      store: supported && checkFeature(genericCapabilities.store)
    };
  }
  /** Subclasses use this to support .createBuffer() overloads */
  _normalizeBufferProps(props) {
    if (props instanceof ArrayBuffer || ArrayBuffer.isView(props)) {
      props = { data: props };
    }
    const newProps = { ...props };
    const usage = props.usage || 0;
    if (usage & Buffer.INDEX) {
      if (!props.indexType) {
        if (props.data instanceof Uint32Array) {
          newProps.indexType = "uint32";
        } else if (props.data instanceof Uint16Array) {
          newProps.indexType = "uint16";
        } else if (props.data instanceof Uint8Array) {
          newProps.data = new Uint16Array(props.data);
          newProps.indexType = "uint16";
        }
      }
      if (!newProps.indexType) {
        throw new Error("indices buffer content must be of type uint16 or uint32");
      }
    }
    return newProps;
  }
};
__publicField(_Device, "defaultProps", {
  id: null,
  powerPreference: "high-performance",
  failIfMajorPerformanceCaveat: false,
  createCanvasContext: void 0,
  // WebGL specific
  webgl: {},
  // Callbacks
  // eslint-disable-next-line handle-callback-err
  onError: (error, context) => {
  },
  onResize: (context, info) => {
    const [width, height] = context.getDevicePixelSize();
    log.log(1, `${context} resized => ${width}x${height}px`)();
  },
  onPositionChange: (context, info) => {
    const [left, top] = context.getPosition();
    log.log(1, `${context} repositioned => ${left},${top}`)();
  },
  onVisibilityChange: (context) => log.log(1, `${context} Visibility changed ${context.isVisible}`)(),
  onDevicePixelRatioChange: (context, info) => log.log(1, `${context} DPR changed ${info.oldRatio} => ${context.devicePixelRatio}`)(),
  // Debug flags
  debug: log.get("debug") || void 0,
  debugShaders: log.get("debug-shaders") || void 0,
  debugFramebuffers: Boolean(log.get("debug-framebuffers")),
  debugFactories: Boolean(log.get("debug-factories")),
  debugWebGL: Boolean(log.get("debug-webgl")),
  debugSpectorJS: void 0,
  // Note: log setting is queried by the spector.js code
  debugSpectorJSUrl: void 0,
  // Experimental
  _reuseDevices: false,
  _requestMaxLimits: true,
  _cacheShaders: false,
  _cachePipelines: false,
  _cacheDestroyPolicy: "unused",
  // TODO - Change these after confirming things work as expected
  _initializeFeatures: true,
  _disabledFeatures: {
    "compilation-status-async-webgl": true
  },
  // INTERNAL
  _handle: void 0
});
var Device = _Device;

// node_modules/@luma.gl/core/dist/adapter/luma.js
var STARTUP_MESSAGE = "set luma.log.level=1 (or higher) to trace rendering";
var ERROR_MESSAGE = "No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.";
var _Luma = class _Luma {
  constructor() {
    /** Global stats for all devices */
    __publicField(this, "stats", lumaStats);
    /**
     * Global log
     *
     * Assign luma.log.level in console to control logging: \
     * 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs
     * luma.log.break[], set to gl funcs, luma.log.profile[] set to model names`;
     */
    __publicField(this, "log", log);
    /** Version of luma.gl */
    __publicField(
      this,
      "VERSION",
      // Version detection using build plugin
      // @ts-expect-error no-undef
      true ? "9.2.6" : "running from source"
    );
    __publicField(this, "spector");
    __publicField(this, "preregisteredAdapters", /* @__PURE__ */ new Map());
    if (globalThis.luma) {
      if (globalThis.luma.VERSION !== this.VERSION) {
        log.error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)();
        log.error(`'yarn why @luma.gl/core' can help identify the source of the conflict`)();
        throw new Error(`luma.gl - multiple versions detected: see console log`);
      }
      log.error("This version of luma.gl has already been initialized")();
    }
    log.log(1, `${this.VERSION} - ${STARTUP_MESSAGE}`)();
    globalThis.luma = this;
  }
  /** Creates a device. Asynchronously. */
  async createDevice(props_ = {}) {
    const props = { ..._Luma.defaultProps, ...props_ };
    const adapter = this.selectAdapter(props.type, props.adapters);
    if (!adapter) {
      throw new Error(ERROR_MESSAGE);
    }
    if (props.waitForPageLoad) {
      await adapter.pageLoaded;
    }
    return await adapter.create(props);
  }
  /**
   * Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice).
   * @param handle Externally created WebGL context or WebGPU device
   */
  async attachDevice(handle, props) {
    var _a;
    const type = this._getTypeFromHandle(handle, props.adapters);
    const adapter = type && this.selectAdapter(type, props.adapters);
    if (!adapter) {
      throw new Error(ERROR_MESSAGE);
    }
    return await ((_a = adapter == null ? void 0 : adapter.attach) == null ? void 0 : _a.call(adapter, handle, props));
  }
  /**
   * Global adapter registration.
   * @deprecated Use props.adapters instead
   */
  registerAdapters(adapters) {
    for (const deviceClass of adapters) {
      this.preregisteredAdapters.set(deviceClass.type, deviceClass);
    }
  }
  /** Get type strings for supported Devices */
  getSupportedAdapters(adapters = []) {
    const adapterMap = this._getAdapterMap(adapters);
    return Array.from(adapterMap).map(([, adapter]) => adapter).filter((adapter) => {
      var _a;
      return (_a = adapter.isSupported) == null ? void 0 : _a.call(adapter);
    }).map((adapter) => adapter.type);
  }
  /** Get type strings for best available Device */
  getBestAvailableAdapterType(adapters = []) {
    var _a, _b;
    const KNOWN_ADAPTERS = ["webgpu", "webgl", "null"];
    const adapterMap = this._getAdapterMap(adapters);
    for (const type of KNOWN_ADAPTERS) {
      if ((_b = (_a = adapterMap.get(type)) == null ? void 0 : _a.isSupported) == null ? void 0 : _b.call(_a)) {
        return type;
      }
    }
    return null;
  }
  /** Select adapter of type from registered adapters */
  selectAdapter(type, adapters = []) {
    let selectedType = type;
    if (type === "best-available") {
      selectedType = this.getBestAvailableAdapterType(adapters);
    }
    const adapterMap = this._getAdapterMap(adapters);
    return selectedType && adapterMap.get(selectedType) || null;
  }
  /**
   * Override `HTMLCanvasContext.getCanvas()` to always create WebGL2 contexts with additional WebGL1 compatibility.
   * Useful when attaching luma to a context from an external library does not support creating WebGL2 contexts.
   */
  enforceWebGL2(enforce = true, adapters = []) {
    var _a;
    const adapterMap = this._getAdapterMap(adapters);
    const webgl2Adapter2 = adapterMap.get("webgl");
    if (!webgl2Adapter2) {
      log.warn("enforceWebGL2: webgl adapter not found")();
    }
    (_a = webgl2Adapter2 == null ? void 0 : webgl2Adapter2.enforceWebGL2) == null ? void 0 : _a.call(webgl2Adapter2, enforce);
  }
  // DEPRECATED
  /** @deprecated */
  setDefaultDeviceProps(props) {
    Object.assign(_Luma.defaultProps, props);
  }
  // HELPERS
  /** Convert a list of adapters to a map */
  _getAdapterMap(adapters = []) {
    const map2 = new Map(this.preregisteredAdapters);
    for (const adapter of adapters) {
      map2.set(adapter.type, adapter);
    }
    return map2;
  }
  /** Get type of a handle (for attachDevice) */
  _getTypeFromHandle(handle, adapters = []) {
    if (handle instanceof WebGL2RenderingContext) {
      return "webgl";
    }
    if (typeof GPUDevice !== "undefined" && handle instanceof GPUDevice) {
      return "webgpu";
    }
    if (handle == null ? void 0 : handle.queue) {
      return "webgpu";
    }
    if (handle === null) {
      return "null";
    }
    if (handle instanceof WebGLRenderingContext) {
      log.warn("WebGL1 is not supported", handle)();
    } else {
      log.warn("Unknown handle type", handle)();
    }
    return null;
  }
};
__publicField(_Luma, "defaultProps", {
  ...Device.defaultProps,
  type: "best-available",
  adapters: void 0,
  waitForPageLoad: true
});
var Luma = _Luma;
var luma = new Luma();

// node_modules/@luma.gl/core/dist/adapter/adapter.js
var Adapter = class {
  /**
   * Page load promise
   * Resolves when the DOM is loaded.
   * @note Since are be limitations on number of `load` event listeners,
   * it is recommended avoid calling this accessor until actually needed.
   * I.e. we don't call it unless you know that you will be looking up a string in the DOM.
   */
  get pageLoaded() {
    return getPageLoadPromise();
  }
};
var isPage = isBrowser() && typeof document !== "undefined";
var isPageLoaded = () => isPage && document.readyState === "complete";
var pageLoadPromise = null;
function getPageLoadPromise() {
  if (!pageLoadPromise) {
    if (isPageLoaded() || typeof window === "undefined") {
      pageLoadPromise = Promise.resolve();
    } else {
      pageLoadPromise = new Promise((resolve) => window.addEventListener("load", () => resolve()));
    }
  }
  return pageLoadPromise;
}

// node_modules/@luma.gl/core/dist/utils/promise-utils.js
function withResolvers() {
  let resolve;
  let reject;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  return { promise, resolve, reject };
}

// node_modules/@luma.gl/core/dist/adapter/canvas-context.js
var _CanvasContext = class _CanvasContext {
  constructor(props) {
    __publicField(this, "id");
    __publicField(this, "props");
    __publicField(this, "canvas");
    /** Handle to HTML canvas */
    __publicField(this, "htmlCanvas");
    /** Handle to wrapped OffScreenCanvas */
    __publicField(this, "offscreenCanvas");
    __publicField(this, "type");
    /** Promise that resolved once the resize observer has updated the pixel size */
    __publicField(this, "initialized");
    __publicField(this, "isInitialized", false);
    /** Visibility is automatically updated (via an IntersectionObserver) */
    __publicField(this, "isVisible", true);
    /** Width of canvas in CSS units (tracked by a ResizeObserver) */
    __publicField(this, "cssWidth");
    /** Height of canvas in CSS units (tracked by a ResizeObserver) */
    __publicField(this, "cssHeight");
    /** Device pixel ratio. Automatically updated via media queries */
    __publicField(this, "devicePixelRatio");
    /** Exact width of canvas in physical pixels (tracked by a ResizeObserver) */
    __publicField(this, "devicePixelWidth");
    /** Exact height of canvas in physical pixels (tracked by a ResizeObserver) */
    __publicField(this, "devicePixelHeight");
    /** Width of drawing buffer: automatically tracks this.pixelWidth if props.autoResize is true */
    __publicField(this, "drawingBufferWidth");
    /** Height of drawing buffer: automatically tracks this.pixelHeight if props.autoResize is true */
    __publicField(this, "drawingBufferHeight");
    __publicField(this, "_initializedResolvers", withResolvers());
    __publicField(this, "_resizeObserver");
    __publicField(this, "_intersectionObserver");
    __publicField(this, "_position");
    __publicField(this, "destroyed", false);
    var _a, _b;
    this.props = { ..._CanvasContext.defaultProps, ...props };
    props = this.props;
    this.initialized = this._initializedResolvers.promise;
    if (!isBrowser()) {
      this.canvas = { width: props.width || 1, height: props.height || 1 };
    } else if (!props.canvas) {
      this.canvas = createCanvasElement(props);
    } else if (typeof props.canvas === "string") {
      this.canvas = getCanvasFromDOM(props.canvas);
    } else {
      this.canvas = props.canvas;
    }
    if (_CanvasContext.isHTMLCanvas(this.canvas)) {
      this.id = props.id || this.canvas.id;
      this.type = "html-canvas";
      this.htmlCanvas = this.canvas;
    } else if (_CanvasContext.isOffscreenCanvas(this.canvas)) {
      this.id = props.id || "offscreen-canvas";
      this.type = "offscreen-canvas";
      this.offscreenCanvas = this.canvas;
    } else {
      this.id = props.id || "node-canvas-context";
      this.type = "node";
    }
    this.cssWidth = ((_a = this.htmlCanvas) == null ? void 0 : _a.clientWidth) || this.canvas.width;
    this.cssHeight = ((_b = this.htmlCanvas) == null ? void 0 : _b.clientHeight) || this.canvas.height;
    this.devicePixelWidth = this.canvas.width;
    this.devicePixelHeight = this.canvas.height;
    this.drawingBufferWidth = this.canvas.width;
    this.drawingBufferHeight = this.canvas.height;
    this.devicePixelRatio = globalThis.devicePixelRatio || 1;
    this._position = [0, 0];
    if (_CanvasContext.isHTMLCanvas(this.canvas)) {
      this._intersectionObserver = new IntersectionObserver((entries) => this._handleIntersection(entries));
      this._intersectionObserver.observe(this.canvas);
      this._resizeObserver = new ResizeObserver((entries) => this._handleResize(entries));
      try {
        this._resizeObserver.observe(this.canvas, { box: "device-pixel-content-box" });
      } catch {
        this._resizeObserver.observe(this.canvas, { box: "content-box" });
      }
      setTimeout(() => this._observeDevicePixelRatio(), 0);
      if (this.props.trackPosition) {
        this._trackPosition();
      }
    }
  }
  static isHTMLCanvas(canvas) {
    return typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement;
  }
  static isOffscreenCanvas(canvas) {
    return typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas;
  }
  toString() {
    return `${this[Symbol.toStringTag]}(${this.id})`;
  }
  destroy() {
    this.destroyed = true;
  }
  setProps(props) {
    if ("useDevicePixels" in props) {
      this.props.useDevicePixels = props.useDevicePixels || false;
      this._updateDrawingBufferSize();
    }
    return this;
  }
  // SIZE METHODS
  /**
   * Returns the size covered by the canvas in CSS pixels
   * @note This can be different from the actual device pixel size of a canvas due to DPR scaling, and rounding to integer pixels
   * @note This is independent of the canvas' internal drawing buffer size (.width, .height).
   */
  getCSSSize() {
    return [this.cssWidth, this.cssHeight];
  }
  getPosition() {
    return this._position;
  }
  /**
   * Returns the size covered by the canvas in actual device pixels.
   * @note This can be different from the 'CSS' size of a canvas due to DPR scaling, and rounding to integer pixels
   * @note This is independent of the canvas' internal drawing buffer size (.width, .height).
   */
  getDevicePixelSize() {
    return [this.devicePixelWidth, this.devicePixelHeight];
  }
  /** Get the drawing buffer size (number of pixels GPU is rendering into, can be different from CSS size) */
  getDrawingBufferSize() {
    return [this.drawingBufferWidth, this.drawingBufferHeight];
  }
  /** Returns the biggest allowed framebuffer size. @todo Allow the application to limit this? */
  getMaxDrawingBufferSize() {
    const maxTextureDimension = this.device.limits.maxTextureDimension2D;
    return [maxTextureDimension, maxTextureDimension];
  }
  /** Update the canvas drawing buffer size. Called automatically if props.autoResize is true. */
  setDrawingBufferSize(width, height) {
    this.canvas.width = width;
    this.canvas.height = height;
    this.drawingBufferWidth = width;
    this.drawingBufferHeight = height;
  }
  /**
   * Returns the current DPR (number of physical pixels per CSS pixel), if props.useDevicePixels is true
   * @note This can be a fractional (non-integer) number, e.g. when the user zooms in the browser.
   * @note This function handles the non-HTML canvas cases
   */
  getDevicePixelRatio() {
    const dpr = typeof window !== "undefined" && window.devicePixelRatio;
    return dpr || 1;
  }
  // DEPRECATED METHODS
  /**
   * Maps CSS pixel position to device pixel position
   */
  cssToDevicePixels(cssPixel, yInvert = true) {
    const ratio = this.cssToDeviceRatio();
    const [width, height] = this.getDrawingBufferSize();
    return scalePixels(cssPixel, ratio, width, height, yInvert);
  }
  /** @deprecated - use .getDevicePixelSize() */
  getPixelSize() {
    return this.getDevicePixelSize();
  }
  /** @deprecated - TODO which values should we use for aspect */
  getAspect() {
    const [width, height] = this.getDevicePixelSize();
    return width / height;
  }
  /** @deprecated Returns multiplier need to convert CSS size to Device size */
  cssToDeviceRatio() {
    try {
      const [drawingBufferWidth] = this.getDrawingBufferSize();
      const [cssWidth] = this.getCSSSize();
      return cssWidth ? drawingBufferWidth / cssWidth : 1;
    } catch {
      return 1;
    }
  }
  /** @deprecated Use canvasContext.setDrawingBufferSize() */
  resize(size) {
    this.setDrawingBufferSize(size.width, size.height);
  }
  // IMPLEMENTATION
  /**
   * Allows subclass constructor to override the canvas id for auto created canvases.
   * This can really help when debugging DOM in apps that create multiple devices
   */
  _setAutoCreatedCanvasId(id) {
    var _a;
    if (((_a = this.htmlCanvas) == null ? void 0 : _a.id) === "lumagl-auto-created-canvas") {
      this.htmlCanvas.id = id;
    }
  }
  /** reacts to an observed intersection */
  _handleIntersection(entries) {
    const entry = entries.find((entry_) => entry_.target === this.canvas);
    if (!entry) {
      return;
    }
    const isVisible = entry.isIntersecting;
    if (this.isVisible !== isVisible) {
      this.isVisible = isVisible;
      this.device.props.onVisibilityChange(this);
    }
  }
  /**
   * Reacts to an observed resize by using the most accurate pixel size information the browser can provide
   * @see https://web.dev/articles/device-pixel-content-box
   * @see https://webgpufundamentals.org/webgpu/lessons/webgpu-resizing-the-canvas.html
   */
  _handleResize(entries) {
    var _a, _b;
    const entry = entries.find((entry_) => entry_.target === this.canvas);
    if (!entry) {
      return;
    }
    this.cssWidth = entry.contentBoxSize[0].inlineSize;
    this.cssHeight = entry.contentBoxSize[0].blockSize;
    const oldPixelSize = this.getDevicePixelSize();
    const devicePixelWidth = ((_a = entry.devicePixelContentBoxSize) == null ? void 0 : _a[0].inlineSize) || entry.contentBoxSize[0].inlineSize * devicePixelRatio;
    const devicePixelHeight = ((_b = entry.devicePixelContentBoxSize) == null ? void 0 : _b[0].blockSize) || entry.contentBoxSize[0].blockSize * devicePixelRatio;
    const [maxDevicePixelWidth, maxDevicePixelHeight] = this.getMaxDrawingBufferSize();
    this.devicePixelWidth = Math.max(1, Math.min(devicePixelWidth, maxDevicePixelWidth));
    this.devicePixelHeight = Math.max(1, Math.min(devicePixelHeight, maxDevicePixelHeight));
    this._updateDrawingBufferSize();
    this.device.props.onResize(this, { oldPixelSize });
  }
  _updateDrawingBufferSize() {
    if (this.props.autoResize) {
      if (typeof this.props.useDevicePixels === "number") {
        const dpr = this.props.useDevicePixels;
        this.setDrawingBufferSize(this.cssWidth * dpr, this.cssHeight * dpr);
      } else if (this.props.useDevicePixels) {
        this.setDrawingBufferSize(this.devicePixelWidth, this.devicePixelHeight);
      } else {
        this.setDrawingBufferSize(this.cssWidth, this.cssHeight);
      }
      this._updateDevice();
    }
    this._initializedResolvers.resolve();
    this.isInitialized = true;
    this.updatePosition();
  }
  /** Monitor DPR changes */
  _observeDevicePixelRatio() {
    const oldRatio = this.devicePixelRatio;
    this.devicePixelRatio = window.devicePixelRatio;
    this.updatePosition();
    this.device.props.onDevicePixelRatioChange(this, { oldRatio });
    matchMedia(`(resolution: ${this.devicePixelRatio}dppx)`).addEventListener("change", () => this._observeDevicePixelRatio(), { once: true });
  }
  /** Start tracking positions with a timer */
  _trackPosition(intervalMs = 100) {
    const intervalId = setInterval(() => {
      if (this.destroyed) {
        clearInterval(intervalId);
      } else {
        this.updatePosition();
      }
    }, intervalMs);
  }
  /**
   * Calculated the absolute position of the canvas
   * @note - getBoundingClientRect() is normally cheap but can be expensive
   * if called before browser has finished a reflow. Should not be the case here.
   */
  updatePosition() {
    var _a, _b, _c;
    const newRect = (_a = this.htmlCanvas) == null ? void 0 : _a.getBoundingClientRect();
    if (newRect) {
      const position = [newRect.left, newRect.top];
      this._position ?? (this._position = position);
      const positionChanged = position[0] !== this._position[0] || position[1] !== this._position[1];
      if (positionChanged) {
        const oldPosition = this._position;
        this._position = position;
        (_c = (_b = this.device.props).onPositionChange) == null ? void 0 : _c.call(_b, this, { oldPosition });
      }
    }
  }
};
__publicField(_CanvasContext, "defaultProps", {
  id: void 0,
  canvas: null,
  width: 800,
  height: 600,
  useDevicePixels: true,
  autoResize: true,
  container: null,
  visible: true,
  alphaMode: "opaque",
  colorSpace: "srgb",
  trackPosition: false
});
var CanvasContext = _CanvasContext;
function getContainer(container) {
  if (typeof container === "string") {
    const element = document.getElementById(container);
    if (!element) {
      throw new Error(`${container} is not an HTML element`);
    }
    return element;
  }
  if (container) {
    return container;
  }
  return document.body;
}
function getCanvasFromDOM(canvasId) {
  const canvas = document.getElementById(canvasId);
  if (!CanvasContext.isHTMLCanvas(canvas)) {
    throw new Error("Object is not a canvas element");
  }
  return canvas;
}
function createCanvasElement(props) {
  const { width, height } = props;
  const newCanvas = document.createElement("canvas");
  newCanvas.id = uid("lumagl-auto-created-canvas");
  newCanvas.width = width || 1;
  newCanvas.height = height || 1;
  newCanvas.style.width = Number.isFinite(width) ? `${width}px` : "100%";
  newCanvas.style.height = Number.isFinite(height) ? `${height}px` : "100%";
  if (!(props == null ? void 0 : props.visible)) {
    newCanvas.style.visibility = "hidden";
  }
  const container = getContainer((props == null ? void 0 : props.container) || null);
  container.insertBefore(newCanvas, container.firstChild);
  return newCanvas;
}
function scalePixels(pixel, ratio, width, height, yInvert) {
  const point = pixel;
  const x = scaleX(point[0], ratio, width);
  let y = scaleY(point[1], ratio, height, yInvert);
  let t = scaleX(point[0] + 1, ratio, width);
  const xHigh = t === width - 1 ? t : t - 1;
  t = scaleY(point[1] + 1, ratio, height, yInvert);
  let yHigh;
  if (yInvert) {
    t = t === 0 ? t : t + 1;
    yHigh = y;
    y = t;
  } else {
    yHigh = t === height - 1 ? t : t - 1;
  }
  return {
    x,
    y,
    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.
    width: Math.max(xHigh - x + 1, 1),
    height: Math.max(yHigh - y + 1, 1)
  };
}
function scaleX(x, ratio, width) {
  const r = Math.min(Math.round(x * ratio), width - 1);
  return r;
}
function scaleY(y, ratio, height, yInvert) {
  return yInvert ? Math.max(0, height - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height - 1);
}

// node_modules/@luma.gl/core/dist/adapter/resources/sampler.js
var _Sampler = class _Sampler extends Resource {
  get [Symbol.toStringTag]() {
    return "Sampler";
  }
  constructor(device, props) {
    props = _Sampler.normalizeProps(device, props);
    super(device, props, _Sampler.defaultProps);
  }
  static normalizeProps(device, props) {
    return props;
  }
};
__publicField(_Sampler, "defaultProps", {
  ...Resource.defaultProps,
  type: "color-sampler",
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge",
  addressModeW: "clamp-to-edge",
  magFilter: "nearest",
  minFilter: "nearest",
  mipmapFilter: "none",
  lodMinClamp: 0,
  lodMaxClamp: 32,
  // Per WebGPU spec
  compare: "less-equal",
  maxAnisotropy: 1
});
var Sampler = _Sampler;

// node_modules/@luma.gl/core/dist/adapter/resources/texture.js
var BASE_DIMENSIONS = {
  "1d": "1d",
  "2d": "2d",
  "2d-array": "2d",
  cube: "2d",
  "cube-array": "2d",
  "3d": "3d"
};
var _Texture = class _Texture extends Resource {
  /** Do not use directly. Create with device.createTexture() */
  constructor(device, props) {
    props = _Texture.normalizeProps(device, props);
    super(device, props, _Texture.defaultProps);
    /** dimension of this texture */
    __publicField(this, "dimension");
    /** base dimension of this texture */
    __publicField(this, "baseDimension");
    /** format of this texture */
    __publicField(this, "format");
    /** width in pixels of this texture */
    __publicField(this, "width");
    /** height in pixels of this texture */
    __publicField(this, "height");
    /** depth of this texture */
    __publicField(this, "depth");
    /** mip levels in this texture */
    __publicField(this, "mipLevels");
    /** "Time" of last update. Monotonically increasing timestamp. TODO move to AsyncTexture? */
    __publicField(this, "updateTimestamp");
    this.dimension = this.props.dimension;
    this.baseDimension = BASE_DIMENSIONS[this.dimension];
    this.format = this.props.format;
    this.width = this.props.width;
    this.height = this.props.height;
    this.depth = this.props.depth;
    this.mipLevels = this.props.mipLevels;
    if (this.props.width === void 0 || this.props.height === void 0) {
      if (device.isExternalImage(props.data)) {
        const size = device.getExternalImageSize(props.data);
        this.width = (size == null ? void 0 : size.width) || 1;
        this.height = (size == null ? void 0 : size.height) || 1;
      } else {
        this.width = 1;
        this.height = 1;
        if (this.props.width === void 0 || this.props.height === void 0) {
          log.warn(`${this} created with undefined width or height. This is deprecated. Use AsyncTexture instead.`)();
        }
      }
    }
    this.updateTimestamp = device.incrementTimestamp();
  }
  get [Symbol.toStringTag]() {
    return "Texture";
  }
  toString() {
    return `Texture(${this.id},${this.format},${this.width}x${this.height})`;
  }
  /** Set sampler props associated with this texture */
  setSampler(sampler) {
    this.sampler = sampler instanceof Sampler ? sampler : this.device.createSampler(sampler);
  }
  /**
   * Create a new texture with the same parameters and optionally a different size
   * @note Textures are immutable and cannot be resized after creation, but we can create a similar texture with the same parameters but a new size.
   * @note Does not copy contents of the texture
   */
  clone(size) {
    return this.device.createTexture({ ...this.props, ...size });
  }
  /** Ensure we have integer coordinates */
  static normalizeProps(device, props) {
    const newProps = { ...props };
    const { width, height } = newProps;
    if (typeof width === "number") {
      newProps.width = Math.max(1, Math.ceil(width));
    }
    if (typeof height === "number") {
      newProps.height = Math.max(1, Math.ceil(height));
    }
    return newProps;
  }
  // HELPERS
  /** Initialize texture with supplied props */
  // eslint-disable-next-line max-statements
  _initializeData(data) {
    if (this.device.isExternalImage(data)) {
      this.copyExternalImage({
        image: data,
        width: this.width,
        height: this.height,
        depth: this.depth,
        mipLevel: 0,
        x: 0,
        y: 0,
        z: 0,
        aspect: "all",
        colorSpace: "srgb",
        premultipliedAlpha: false,
        flipY: false
      });
    } else if (data) {
      this.copyImageData({
        data,
        // width: this.width,
        // height: this.height,
        // depth: this.depth,
        mipLevel: 0,
        x: 0,
        y: 0,
        z: 0,
        aspect: "all"
      });
    }
  }
  _normalizeCopyImageDataOptions(options_) {
    const { width, height, depth } = this;
    const options = { ..._Texture.defaultCopyDataOptions, width, height, depth, ...options_ };
    const info = this.device.getTextureFormatInfo(this.format);
    if (!options_.bytesPerRow && !info.bytesPerPixel) {
      throw new Error(`bytesPerRow must be provided for texture format ${this.format}`);
    }
    options.bytesPerRow = options_.bytesPerRow || width * (info.bytesPerPixel || 4);
    options.rowsPerImage = options_.rowsPerImage || height;
    return options;
  }
  _normalizeCopyExternalImageOptions(options_) {
    const size = this.device.getExternalImageSize(options_.image);
    const options = { ..._Texture.defaultCopyExternalImageOptions, ...size, ...options_ };
    options.width = Math.min(options.width, this.width - options.x);
    options.height = Math.min(options.height, this.height - options.y);
    return options;
  }
};
/** The texture can be bound for use as a sampled texture in a shader */
__publicField(_Texture, "SAMPLE", 4);
/** The texture can be bound for use as a storage texture in a shader */
__publicField(_Texture, "STORAGE", 8);
/** The texture can be used as a color or depth/stencil attachment in a render pass */
__publicField(_Texture, "RENDER", 16);
/** The texture can be used as the source of a copy operation */
__publicField(_Texture, "COPY_SRC", 1);
/** he texture can be used as the destination of a copy or write operation */
__publicField(_Texture, "COPY_DST", 2);
/** @deprecated Use Texture.SAMPLE */
__publicField(_Texture, "TEXTURE", 4);
/** @deprecated Use Texture.RENDER */
__publicField(_Texture, "RENDER_ATTACHMENT", 16);
/** Default options */
__publicField(_Texture, "defaultProps", {
  ...Resource.defaultProps,
  data: null,
  dimension: "2d",
  format: "rgba8unorm",
  usage: _Texture.TEXTURE | _Texture.RENDER_ATTACHMENT | _Texture.COPY_DST,
  width: void 0,
  height: void 0,
  depth: 1,
  mipLevels: 1,
  samples: void 0,
  sampler: {},
  view: void 0
});
__publicField(_Texture, "defaultCopyDataOptions", {
  data: void 0,
  byteOffset: 0,
  bytesPerRow: void 0,
  rowsPerImage: void 0,
  mipLevel: 0,
  x: 0,
  y: 0,
  z: 0,
  aspect: "all"
});
/** Default options */
__publicField(_Texture, "defaultCopyExternalImageOptions", {
  image: void 0,
  sourceX: 0,
  sourceY: 0,
  width: void 0,
  height: void 0,
  depth: 1,
  mipLevel: 0,
  x: 0,
  y: 0,
  z: 0,
  aspect: "all",
  colorSpace: "srgb",
  premultipliedAlpha: false,
  flipY: false
});
var Texture = _Texture;

// node_modules/@luma.gl/core/dist/adapter/resources/texture-view.js
var _TextureView = class _TextureView extends Resource {
  get [Symbol.toStringTag]() {
    return "TextureView";
  }
  /** Should not be constructed directly. Use `texture.createView(props)` */
  constructor(device, props) {
    super(device, props, _TextureView.defaultProps);
  }
};
__publicField(_TextureView, "defaultProps", {
  ...Resource.defaultProps,
  format: void 0,
  dimension: void 0,
  aspect: "all",
  baseMipLevel: 0,
  mipLevelCount: void 0,
  baseArrayLayer: 0,
  arrayLayerCount: void 0
});
var TextureView = _TextureView;

// node_modules/@luma.gl/core/dist/adapter/resources/external-texture.js
var _ExternalTexture = class _ExternalTexture extends Resource {
  get [Symbol.toStringTag]() {
    return "ExternalTexture";
  }
  constructor(device, props) {
    super(device, props, _ExternalTexture.defaultProps);
  }
};
__publicField(_ExternalTexture, "defaultProps", {
  ...Resource.defaultProps,
  source: void 0,
  colorSpace: "srgb"
});
var ExternalTexture = _ExternalTexture;

// node_modules/@luma.gl/core/dist/adapter-utils/format-compiler-log.js
function formatCompilerLog(shaderLog, source, options) {
  let formattedLog = "";
  const lines = source.split(/\r?\n/);
  const log2 = shaderLog.slice().sort((a, b) => a.lineNum - b.lineNum);
  switch ((options == null ? void 0 : options.showSourceCode) || "no") {
    case "all":
      let currentMessage = 0;
      for (let lineNum = 1; lineNum <= lines.length; lineNum++) {
        formattedLog += getNumberedLine(lines[lineNum - 1], lineNum, options);
        while (log2.length > currentMessage && log2[currentMessage].lineNum === lineNum) {
          const message2 = log2[currentMessage++];
          formattedLog += formatCompilerMessage(message2, lines, message2.lineNum, {
            ...options,
            inlineSource: false
          });
        }
      }
      while (log2.length > currentMessage) {
        const message2 = log2[currentMessage++];
        formattedLog += formatCompilerMessage(message2, [], 0, {
          ...options,
          inlineSource: false
        });
      }
      return formattedLog;
    case "issues":
    case "no":
      for (const message2 of shaderLog) {
        formattedLog += formatCompilerMessage(message2, lines, message2.lineNum, {
          inlineSource: (options == null ? void 0 : options.showSourceCode) !== "no"
        });
      }
      return formattedLog;
  }
}
function formatCompilerMessage(message2, lines, lineNum, options) {
  if (options == null ? void 0 : options.inlineSource) {
    const numberedLines = getNumberedLines(lines, lineNum);
    const positionIndicator = message2.linePos > 0 ? `${" ".repeat(message2.linePos + 5)}^^^
` : "";
    return `
${numberedLines}${positionIndicator}${message2.type.toUpperCase()}: ${message2.message}

`;
  }
  const color = message2.type === "error" ? "red" : "#8B4000";
  return (options == null ? void 0 : options.html) ? `<div class='luma-compiler-log-error' style="color:${color};"><b> ${message2.type.toUpperCase()}: ${message2.message}</b></div>` : `${message2.type.toUpperCase()}: ${message2.message}`;
}
function getNumberedLines(lines, lineNum, options) {
  let numberedLines = "";
  for (let lineIndex = lineNum - 2; lineIndex <= lineNum; lineIndex++) {
    const sourceLine = lines[lineIndex - 1];
    if (sourceLine !== void 0) {
      numberedLines += getNumberedLine(sourceLine, lineNum, options);
    }
  }
  return numberedLines;
}
function getNumberedLine(line, lineNum, options) {
  const escapedLine = (options == null ? void 0 : options.html) ? escapeHTML(line) : line;
  return `${padLeft(String(lineNum), 4)}: ${escapedLine}${(options == null ? void 0 : options.html) ? "<br/>" : "\n"}`;
}
function padLeft(string, paddedLength) {
  let result = "";
  for (let i = string.length; i < paddedLength; ++i) {
    result += " ";
  }
  return result + string;
}
function escapeHTML(unsafe) {
  return unsafe.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;");
}

// node_modules/@luma.gl/core/dist/adapter/resources/shader.js
var _Shader = class _Shader extends Resource {
  /** Create a new Shader instance */
  constructor(device, props) {
    props = { ...props, debugShaders: props.debugShaders || device.props.debugShaders || "errors" };
    super(device, { id: getShaderIdFromProps(props), ...props }, _Shader.defaultProps);
    /** The stage of this shader */
    __publicField(this, "stage");
    /** The source code of this shader */
    __publicField(this, "source");
    /** The compilation status of the shader. 'pending' if compilation is asynchronous, and on production */
    __publicField(this, "compilationStatus", "pending");
    this.stage = this.props.stage;
    this.source = this.props.source;
  }
  get [Symbol.toStringTag]() {
    return "Shader";
  }
  /** Get compiler log synchronously (WebGL only) */
  getCompilationInfoSync() {
    return null;
  }
  /** Get translated shader source in host platform's native language (HLSL, GLSL, and even GLSL ES), if available */
  getTranslatedSource() {
    return null;
  }
  // PORTABLE HELPERS
  /** In browser logging of errors */
  async debugShader() {
    const trigger = this.props.debugShaders;
    switch (trigger) {
      case "never":
        return;
      case "errors":
        if (this.compilationStatus === "success") {
          return;
        }
        break;
      case "warnings":
      case "always":
        break;
    }
    const messages = await this.getCompilationInfo();
    if (trigger === "warnings" && (messages == null ? void 0 : messages.length) === 0) {
      return;
    }
    this._displayShaderLog(messages, this.id);
  }
  // PRIVATE
  /**
   * In-browser UI logging of errors
   * TODO - this HTML formatting code should not be in Device, should be pluggable
   */
  _displayShaderLog(messages, shaderId) {
    var _a;
    if (typeof document === "undefined" || !(document == null ? void 0 : document.createElement)) {
      return;
    }
    const shaderName = shaderId;
    const shaderTitle = `${this.stage} shader "${shaderName}"`;
    let htmlLog = formatCompilerLog(messages, this.source, { showSourceCode: "all", html: true });
    const translatedSource = this.getTranslatedSource();
    if (translatedSource) {
      htmlLog += `<br /><br /><h1>Translated Source</h1><br /><br /><code style="user-select:text;"><pre>${translatedSource}</pre></code>`;
    }
    const button = document.createElement("Button");
    button.innerHTML = `
<h1>Compilation error in ${shaderTitle}</h1><br /><br />
<code style="user-select:text;"><pre>
${htmlLog}
</pre></code>`;
    button.style.top = "10px";
    button.style.left = "10px";
    button.style.position = "absolute";
    button.style.zIndex = "9999";
    button.style.width = "100%";
    button.style.textAlign = "left";
    document.body.appendChild(button);
    const errors = document.getElementsByClassName("luma-compiler-log-error");
    (_a = errors[0]) == null ? void 0 : _a.scrollIntoView();
    button.onclick = () => {
      const dataURI = `data:text/plain,${encodeURIComponent(this.source)}`;
      navigator.clipboard.writeText(dataURI);
    };
  }
};
__publicField(_Shader, "defaultProps", {
  ...Resource.defaultProps,
  language: "auto",
  stage: void 0,
  source: "",
  sourceMap: null,
  entryPoint: "main",
  debugShaders: void 0
});
var Shader = _Shader;
function getShaderIdFromProps(props) {
  return getShaderName(props.source) || props.id || uid(`unnamed ${props.stage}-shader`);
}
function getShaderName(shader, defaultName = "unnamed") {
  const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
  const match = SHADER_NAME_REGEXP.exec(shader);
  return match ? match[1] : defaultName;
}

// node_modules/@luma.gl/core/dist/adapter/resources/framebuffer.js
var _Framebuffer = class _Framebuffer extends Resource {
  constructor(device, props = {}) {
    super(device, props, _Framebuffer.defaultProps);
    /** Width of all attachments in this framebuffer */
    __publicField(this, "width");
    /** Height of all attachments in this framebuffer */
    __publicField(this, "height");
    this.width = this.props.width;
    this.height = this.props.height;
  }
  get [Symbol.toStringTag]() {
    return "Framebuffer";
  }
  /**
   * Create a copy of this framebuffer with new attached textures, with same props but of the specified size.
   * @note Does not copy contents of the attached textures.
   */
  clone(size) {
    const colorAttachments = this.colorAttachments.map((colorAttachment) => colorAttachment.texture.clone(size));
    const depthStencilAttachment = this.depthStencilAttachment && this.depthStencilAttachment.texture.clone(size);
    return this.device.createFramebuffer({ ...this.props, colorAttachments, depthStencilAttachment });
  }
  resize(size) {
    let updateSize = !size;
    if (size) {
      const [width, height] = Array.isArray(size) ? size : [size.width, size.height];
      updateSize = updateSize || height !== this.height || width !== this.width;
      this.width = width;
      this.height = height;
    }
    if (updateSize) {
      log.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)();
      this.resizeAttachments(this.width, this.height);
    }
  }
  /** Auto creates any textures */
  autoCreateAttachmentTextures() {
    if (this.props.colorAttachments.length === 0 && !this.props.depthStencilAttachment) {
      throw new Error("Framebuffer has noattachments");
    }
    this.colorAttachments = this.props.colorAttachments.map((attachment2, index) => {
      if (typeof attachment2 === "string") {
        const texture = this.createColorTexture(attachment2, index);
        this.attachResource(texture);
        return texture.view;
      }
      if (attachment2 instanceof Texture) {
        return attachment2.view;
      }
      return attachment2;
    });
    const attachment = this.props.depthStencilAttachment;
    if (attachment) {
      if (typeof attachment === "string") {
        const texture = this.createDepthStencilTexture(attachment);
        this.attachResource(texture);
        this.depthStencilAttachment = texture.view;
      } else if (attachment instanceof Texture) {
        this.depthStencilAttachment = attachment.view;
      } else {
        this.depthStencilAttachment = attachment;
      }
    }
  }
  /** Create a color texture */
  createColorTexture(format, index) {
    return this.device.createTexture({
      id: `${this.id}-color-attachment-${index}`,
      usage: Texture.RENDER_ATTACHMENT,
      format,
      width: this.width,
      height: this.height,
      // TODO deprecated? - luma.gl v8 compatibility
      sampler: {
        magFilter: "linear",
        minFilter: "linear"
      }
    });
  }
  /** Create depth stencil texture */
  createDepthStencilTexture(format) {
    return this.device.createTexture({
      id: `${this.id}-depth-stencil-attachment`,
      usage: Texture.RENDER_ATTACHMENT,
      format,
      width: this.width,
      height: this.height
    });
  }
  /**
   * Default implementation of resize
   * Creates new textures with correct size for all attachments.
   * and destroys existing textures if owned
   */
  resizeAttachments(width, height) {
    for (let i = 0; i < this.colorAttachments.length; ++i) {
      if (this.colorAttachments[i]) {
        const resizedTexture = this.colorAttachments[i].texture.clone({
          width,
          height
        });
        this.destroyAttachedResource(this.colorAttachments[i]);
        this.colorAttachments[i] = resizedTexture.view;
        this.attachResource(resizedTexture.view);
      }
    }
    if (this.depthStencilAttachment) {
      const resizedTexture = this.depthStencilAttachment.texture.clone({
        width,
        height
      });
      this.destroyAttachedResource(this.depthStencilAttachment);
      this.depthStencilAttachment = resizedTexture.view;
      this.attachResource(resizedTexture);
    }
    this.updateAttachments();
  }
};
__publicField(_Framebuffer, "defaultProps", {
  ...Resource.defaultProps,
  width: 1,
  height: 1,
  colorAttachments: [],
  // ['rgba8unorm'],
  depthStencilAttachment: null
  // 'depth24plus-stencil8'
});
var Framebuffer = _Framebuffer;

// node_modules/@luma.gl/core/dist/adapter/resources/render-pipeline.js
var _RenderPipeline = class _RenderPipeline extends Resource {
  constructor(device, props) {
    super(device, props, _RenderPipeline.defaultProps);
    /** The merged layout */
    __publicField(this, "shaderLayout");
    /** Buffer map describing buffer interleaving etc */
    __publicField(this, "bufferLayout");
    /** The linking status of the pipeline. 'pending' if linking is asynchronous, and on production */
    __publicField(this, "linkStatus", "pending");
    /** The hash of the pipeline */
    __publicField(this, "hash", "");
    this.shaderLayout = this.props.shaderLayout;
    this.bufferLayout = this.props.bufferLayout || [];
  }
  get [Symbol.toStringTag]() {
    return "RenderPipeline";
  }
};
__publicField(_RenderPipeline, "defaultProps", {
  ...Resource.defaultProps,
  vs: null,
  vertexEntryPoint: "vertexMain",
  vsConstants: {},
  fs: null,
  fragmentEntryPoint: "fragmentMain",
  fsConstants: {},
  shaderLayout: null,
  bufferLayout: [],
  topology: "triangle-list",
  colorAttachmentFormats: void 0,
  depthStencilAttachmentFormat: void 0,
  parameters: {},
  bindings: {},
  uniforms: {}
});
var RenderPipeline = _RenderPipeline;

// node_modules/@luma.gl/core/dist/adapter/resources/render-pass.js
var _RenderPass = class _RenderPass extends Resource {
  get [Symbol.toStringTag]() {
    return "RenderPass";
  }
  constructor(device, props) {
    props = _RenderPass.normalizeProps(device, props);
    super(device, props, _RenderPass.defaultProps);
  }
  static normalizeProps(device, props) {
    return props;
  }
};
/** TODO - should be [0, 0, 0, 0], update once deck.gl tests run clean */
__publicField(_RenderPass, "defaultClearColor", [0, 0, 0, 1]);
/** Depth 1.0 represents the far plance */
__publicField(_RenderPass, "defaultClearDepth", 1);
/** Clears all stencil bits */
__publicField(_RenderPass, "defaultClearStencil", 0);
/** Default properties for RenderPass */
__publicField(_RenderPass, "defaultProps", {
  ...Resource.defaultProps,
  framebuffer: null,
  parameters: void 0,
  clearColor: _RenderPass.defaultClearColor,
  clearColors: void 0,
  clearDepth: _RenderPass.defaultClearDepth,
  clearStencil: _RenderPass.defaultClearStencil,
  depthReadOnly: false,
  stencilReadOnly: false,
  discard: false,
  occlusionQuerySet: void 0,
  timestampQuerySet: void 0,
  beginTimestampIndex: void 0,
  endTimestampIndex: void 0
});
var RenderPass = _RenderPass;

// node_modules/@luma.gl/core/dist/adapter/resources/compute-pipeline.js
var _ComputePipeline = class _ComputePipeline extends Resource {
  constructor(device, props) {
    super(device, props, _ComputePipeline.defaultProps);
    __publicField(this, "hash", "");
    /** The merged shader layout */
    __publicField(this, "shaderLayout");
    this.shaderLayout = props.shaderLayout;
  }
  get [Symbol.toStringTag]() {
    return "ComputePipeline";
  }
};
__publicField(_ComputePipeline, "defaultProps", {
  ...Resource.defaultProps,
  shader: void 0,
  entryPoint: void 0,
  constants: {},
  shaderLayout: void 0
});
var ComputePipeline = _ComputePipeline;

// node_modules/@luma.gl/core/dist/adapter/resources/compute-pass.js
var _ComputePass = class _ComputePass extends Resource {
  constructor(device, props) {
    super(device, props, _ComputePass.defaultProps);
  }
  get [Symbol.toStringTag]() {
    return "ComputePass";
  }
};
__publicField(_ComputePass, "defaultProps", {
  ...Resource.defaultProps,
  timestampQuerySet: void 0,
  beginTimestampIndex: void 0,
  endTimestampIndex: void 0
});
var ComputePass = _ComputePass;

// node_modules/@luma.gl/core/dist/adapter/resources/command-encoder.js
var _CommandEncoder = class _CommandEncoder extends Resource {
  get [Symbol.toStringTag]() {
    return "CommandEncoder";
  }
  constructor(device, props) {
    super(device, props, _CommandEncoder.defaultProps);
  }
};
// TODO - luma.gl has these on the device, should we align with WebGPU API?
// beginRenderPass(GPURenderPassDescriptor descriptor): GPURenderPassEncoder;
// beginComputePass(optional GPUComputePassDescriptor descriptor = {}): GPUComputePassEncoder;
__publicField(_CommandEncoder, "defaultProps", {
  ...Resource.defaultProps,
  measureExecutionTime: void 0
});
var CommandEncoder = _CommandEncoder;

// node_modules/@luma.gl/core/dist/adapter/resources/command-buffer.js
var _CommandBuffer = class _CommandBuffer extends Resource {
  get [Symbol.toStringTag]() {
    return "CommandBuffer";
  }
  constructor(device, props) {
    super(device, props, _CommandBuffer.defaultProps);
  }
};
__publicField(_CommandBuffer, "defaultProps", {
  ...Resource.defaultProps
});
var CommandBuffer = _CommandBuffer;

// node_modules/@luma.gl/core/dist/shadertypes/data-types/decode-shader-types.js
function getVariableShaderTypeInfo(format) {
  const decoded = UNIFORM_FORMATS[format];
  return decoded;
}
function getAttributeShaderTypeInfo(attributeType) {
  const [primitiveType, components] = TYPE_INFO[attributeType];
  const integer = primitiveType === "i32" || primitiveType === "u32";
  const signed = primitiveType !== "u32";
  const byteLength = PRIMITIVE_TYPE_SIZES[primitiveType] * components;
  return {
    primitiveType,
    components,
    byteLength,
    integer,
    signed
  };
}
var PRIMITIVE_TYPE_SIZES = {
  f32: 4,
  f16: 2,
  i32: 4,
  u32: 4
  // 'bool-webgl': 4,
};
var TYPE_INFO = {
  f32: ["f32", 1],
  "vec2<f32>": ["f32", 2],
  "vec3<f32>": ["f32", 3],
  "vec4<f32>": ["f32", 4],
  f16: ["f16", 1],
  "vec2<f16>": ["f16", 2],
  "vec3<f16>": ["f16", 3],
  "vec4<f16>": ["f16", 4],
  i32: ["i32", 1],
  "vec2<i32>": ["i32", 2],
  "vec3<i32>": ["i32", 3],
  "vec4<i32>": ["i32", 4],
  u32: ["u32", 1],
  "vec2<u32>": ["u32", 2],
  "vec3<u32>": ["u32", 3],
  "vec4<u32>": ["u32", 4]
};
var UNIFORM_FORMATS = {
  f32: { type: "f32", components: 1 },
  f16: { type: "f16", components: 1 },
  i32: { type: "i32", components: 1 },
  u32: { type: "u32", components: 1 },
  // 'bool-webgl': {type: 'bool-webgl', components: 1},
  "vec2<f32>": { type: "f32", components: 2 },
  "vec3<f32>": { type: "f32", components: 3 },
  "vec4<f32>": { type: "f32", components: 4 },
  "vec2<f16>": { type: "f16", components: 2 },
  "vec3<f16>": { type: "f16", components: 3 },
  "vec4<f16>": { type: "f16", components: 4 },
  "vec2<i32>": { type: "i32", components: 2 },
  "vec3<i32>": { type: "i32", components: 3 },
  "vec4<i32>": { type: "i32", components: 4 },
  "vec2<u32>": { type: "u32", components: 2 },
  "vec3<u32>": { type: "u32", components: 3 },
  "vec4<u32>": { type: "u32", components: 4 },
  "mat2x2<f32>": { type: "f32", components: 4 },
  "mat2x3<f32>": { type: "f32", components: 6 },
  "mat2x4<f32>": { type: "f32", components: 8 },
  "mat3x2<f32>": { type: "f32", components: 6 },
  "mat3x3<f32>": { type: "f32", components: 9 },
  "mat3x4<f32>": { type: "f32", components: 12 },
  "mat4x2<f32>": { type: "f32", components: 8 },
  "mat4x3<f32>": { type: "f32", components: 12 },
  "mat4x4<f32>": { type: "f32", components: 16 },
  "mat2x2<f16>": { type: "f16", components: 4 },
  "mat2x3<f16>": { type: "f16", components: 6 },
  "mat2x4<f16>": { type: "f16", components: 8 },
  "mat3x2<f16>": { type: "f16", components: 6 },
  "mat3x3<f16>": { type: "f16", components: 9 },
  "mat3x4<f16>": { type: "f16", components: 12 },
  "mat4x2<f16>": { type: "f16", components: 8 },
  "mat4x3<f16>": { type: "f16", components: 12 },
  "mat4x4<f16>": { type: "f16", components: 16 },
  "mat2x2<i32>": { type: "i32", components: 4 },
  "mat2x3<i32>": { type: "i32", components: 6 },
  "mat2x4<i32>": { type: "i32", components: 8 },
  "mat3x2<i32>": { type: "i32", components: 6 },
  "mat3x3<i32>": { type: "i32", components: 9 },
  "mat3x4<i32>": { type: "i32", components: 12 },
  "mat4x2<i32>": { type: "i32", components: 8 },
  "mat4x3<i32>": { type: "i32", components: 12 },
  "mat4x4<i32>": { type: "i32", components: 16 },
  "mat2x2<u32>": { type: "u32", components: 4 },
  "mat2x3<u32>": { type: "u32", components: 6 },
  "mat2x4<u32>": { type: "u32", components: 8 },
  "mat3x2<u32>": { type: "u32", components: 6 },
  "mat3x3<u32>": { type: "u32", components: 9 },
  "mat3x4<u32>": { type: "u32", components: 12 },
  "mat4x2<u32>": { type: "u32", components: 8 },
  "mat4x3<u32>": { type: "u32", components: 12 },
  "mat4x4<u32>": { type: "u32", components: 16 }
};
var WGSL_ATTRIBUTE_TYPE_ALIAS_MAP = {
  vec2i: "vec2<i32>",
  vec3i: "vec3<i32>",
  vec4i: "vec4<i32>",
  vec2u: "vec2<u32>",
  vec3u: "vec3<u32>",
  vec4u: "vec4<u32>",
  vec2f: "vec2<f32>",
  vec3f: "vec3<f32>",
  vec4f: "vec4<f32>",
  // Requires the f16 extension.
  vec2h: "vec2<f16>",
  vec3h: "vec3<f16>",
  vec4h: "vec4<f16>"
};
var WGSL_VARIABLE_TYPE_ALIAS_MAP = {
  ...WGSL_ATTRIBUTE_TYPE_ALIAS_MAP,
  mat2x2f: "mat2x2<f32>",
  mat2x3f: "mat2x3<f32>",
  mat2x4f: "mat2x4<f32>",
  mat3x2f: "mat3x2<f32>",
  mat3x3f: "mat3x3<f32>",
  mat3x4f: "mat3x4<f32>",
  mat4x2f: "mat4x2<f32>",
  mat4x3f: "mat4x3<f32>",
  mat4x4f: "mat4x4<f32>",
  mat2x2i: "mat2x2<i32>",
  mat2x3i: "mat2x3<i32>",
  mat2x4i: "mat2x4<i32>",
  mat3x2i: "mat3x2<i32>",
  mat3x3i: "mat3x3<i32>",
  mat3x4i: "mat3x4<i32>",
  mat4x2i: "mat4x2<i32>",
  mat4x3i: "mat4x3<i32>",
  mat4x4i: "mat4x4<i32>",
  mat2x2u: "mat2x2<u32>",
  mat2x3u: "mat2x3<u32>",
  mat2x4u: "mat2x4<u32>",
  mat3x2u: "mat3x2<u32>",
  mat3x3u: "mat3x3<u32>",
  mat3x4u: "mat3x4<u32>",
  mat4x2u: "mat4x2<u32>",
  mat4x3u: "mat4x3<u32>",
  mat4x4u: "mat4x4<u32>",
  mat2x2h: "mat2x2<f16>",
  mat2x3h: "mat2x3<f16>",
  mat2x4h: "mat2x4<f16>",
  mat3x2h: "mat3x2<f16>",
  mat3x3h: "mat3x3<f16>",
  mat3x4h: "mat3x4<f16>",
  mat4x2h: "mat4x2<f16>",
  mat4x3h: "mat4x3<f16>",
  mat4x4h: "mat4x4<f16>"
};

// node_modules/@luma.gl/core/dist/adapter-utils/get-attribute-from-layouts.js
function getAttributeInfosFromLayouts(shaderLayout, bufferLayout) {
  const attributeInfos = {};
  for (const attribute of shaderLayout.attributes) {
    const attributeInfo = getAttributeInfoFromLayouts(shaderLayout, bufferLayout, attribute.name);
    if (attributeInfo) {
      attributeInfos[attribute.name] = attributeInfo;
    }
  }
  return attributeInfos;
}
function getAttributeInfosByLocation(shaderLayout, bufferLayout, maxVertexAttributes = 16) {
  const attributeInfos = getAttributeInfosFromLayouts(shaderLayout, bufferLayout);
  const locationInfos = new Array(maxVertexAttributes).fill(null);
  for (const attributeInfo of Object.values(attributeInfos)) {
    locationInfos[attributeInfo.location] = attributeInfo;
  }
  return locationInfos;
}
function getAttributeInfoFromLayouts(shaderLayout, bufferLayout, name2) {
  const shaderDeclaration = getAttributeFromShaderLayout(shaderLayout, name2);
  const bufferMapping = getAttributeFromBufferLayout(bufferLayout, name2);
  if (!shaderDeclaration) {
    return null;
  }
  const attributeTypeInfo = getAttributeShaderTypeInfo(shaderDeclaration.type);
  const defaultVertexFormat = getCompatibleVertexFormat(attributeTypeInfo);
  const vertexFormat = (bufferMapping == null ? void 0 : bufferMapping.vertexFormat) || defaultVertexFormat;
  const vertexFormatInfo = getVertexFormatInfo(vertexFormat);
  return {
    attributeName: (bufferMapping == null ? void 0 : bufferMapping.attributeName) || shaderDeclaration.name,
    bufferName: (bufferMapping == null ? void 0 : bufferMapping.bufferName) || shaderDeclaration.name,
    location: shaderDeclaration.location,
    shaderType: shaderDeclaration.type,
    primitiveType: attributeTypeInfo.primitiveType,
    shaderComponents: attributeTypeInfo.components,
    vertexFormat,
    bufferDataType: vertexFormatInfo.type,
    bufferComponents: vertexFormatInfo.components,
    // normalized is a property of the buffer's vertex format
    normalized: vertexFormatInfo.normalized,
    // integer is a property of the shader declaration
    integer: attributeTypeInfo.integer,
    stepMode: (bufferMapping == null ? void 0 : bufferMapping.stepMode) || shaderDeclaration.stepMode || "vertex",
    byteOffset: (bufferMapping == null ? void 0 : bufferMapping.byteOffset) || 0,
    byteStride: (bufferMapping == null ? void 0 : bufferMapping.byteStride) || 0
  };
}
function getAttributeFromShaderLayout(shaderLayout, name2) {
  const attribute = shaderLayout.attributes.find((attr) => attr.name === name2);
  if (!attribute) {
    log.warn(`shader layout attribute "${name2}" not present in shader`);
  }
  return attribute || null;
}
function getAttributeFromBufferLayout(bufferLayouts, name2) {
  checkBufferLayouts(bufferLayouts);
  let bufferLayoutInfo = getAttributeFromShortHand(bufferLayouts, name2);
  if (bufferLayoutInfo) {
    return bufferLayoutInfo;
  }
  bufferLayoutInfo = getAttributeFromAttributesList(bufferLayouts, name2);
  if (bufferLayoutInfo) {
    return bufferLayoutInfo;
  }
  log.warn(`layout for attribute "${name2}" not present in buffer layout`);
  return null;
}
function checkBufferLayouts(bufferLayouts) {
  for (const bufferLayout of bufferLayouts) {
    if (bufferLayout.attributes && bufferLayout.format || !bufferLayout.attributes && !bufferLayout.format) {
      log.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);
    }
  }
}
function getAttributeFromShortHand(bufferLayouts, name2) {
  for (const bufferLayout of bufferLayouts) {
    if (bufferLayout.format && bufferLayout.name === name2) {
      return {
        attributeName: bufferLayout.name,
        bufferName: name2,
        stepMode: bufferLayout.stepMode,
        vertexFormat: bufferLayout.format,
        // If offset is needed, use `attributes` field.
        byteOffset: 0,
        byteStride: bufferLayout.byteStride || 0
      };
    }
  }
  return null;
}
function getAttributeFromAttributesList(bufferLayouts, name2) {
  var _a;
  for (const bufferLayout of bufferLayouts) {
    let byteStride = bufferLayout.byteStride;
    if (typeof bufferLayout.byteStride !== "number") {
      for (const attributeMapping2 of bufferLayout.attributes || []) {
        const info = getVertexFormatInfo(attributeMapping2.format);
        byteStride += info.byteLength;
      }
    }
    const attributeMapping = (_a = bufferLayout.attributes) == null ? void 0 : _a.find((mapping) => mapping.attribute === name2);
    if (attributeMapping) {
      return {
        attributeName: attributeMapping.attribute,
        bufferName: bufferLayout.name,
        stepMode: bufferLayout.stepMode,
        vertexFormat: attributeMapping.format,
        byteOffset: attributeMapping.byteOffset,
        // @ts-ignore
        byteStride
      };
    }
  }
  return null;
}

// node_modules/@luma.gl/core/dist/adapter/resources/vertex-array.js
var _VertexArray = class _VertexArray extends Resource {
  constructor(device, props) {
    super(device, props, _VertexArray.defaultProps);
    /** Max number of vertex attributes */
    __publicField(this, "maxVertexAttributes");
    /** Attribute infos indexed by location - TODO only needed by webgl module? */
    __publicField(this, "attributeInfos");
    /** Index buffer */
    __publicField(this, "indexBuffer", null);
    /** Attributes indexed by buffer slot */
    __publicField(this, "attributes");
    this.maxVertexAttributes = device.limits.maxVertexAttributes;
    this.attributes = new Array(this.maxVertexAttributes).fill(null);
    this.attributeInfos = getAttributeInfosByLocation(props.shaderLayout, props.bufferLayout, this.maxVertexAttributes);
  }
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  // DEPRECATED METHODS
  /** @deprecated Set constant attributes (WebGL only) */
  setConstantWebGL(location, value) {
    this.device.reportError(new Error("constant attributes not supported"), this)();
  }
};
__publicField(_VertexArray, "defaultProps", {
  ...Resource.defaultProps,
  shaderLayout: void 0,
  bufferLayout: []
});
var VertexArray = _VertexArray;

// node_modules/@luma.gl/core/dist/adapter/resources/transform-feedback.js
var _TransformFeedback = class _TransformFeedback extends Resource {
  get [Symbol.toStringTag]() {
    return "TransformFeedback";
  }
  constructor(device, props) {
    super(device, props, _TransformFeedback.defaultProps);
  }
};
__publicField(_TransformFeedback, "defaultProps", {
  ...Resource.defaultProps,
  layout: void 0,
  buffers: {}
});
var TransformFeedback = _TransformFeedback;

// node_modules/@luma.gl/core/dist/adapter/resources/query-set.js
var _QuerySet = class _QuerySet extends Resource {
  get [Symbol.toStringTag]() {
    return "QuerySet";
  }
  constructor(device, props) {
    super(device, props, _QuerySet.defaultProps);
  }
};
__publicField(_QuerySet, "defaultProps", {
  ...Resource.defaultProps,
  type: void 0,
  count: void 0
});
var QuerySet = _QuerySet;

// node_modules/@luma.gl/core/dist/adapter/resources/pipeline-layout.js
var _PipelineLayout = class _PipelineLayout extends Resource {
  get [Symbol.toStringTag]() {
    return "PipelineLayout";
  }
  constructor(device, props) {
    super(device, props, _PipelineLayout.defaultProps);
  }
};
__publicField(_PipelineLayout, "defaultProps", {
  ...Resource.defaultProps,
  shaderLayout: {
    attributes: [],
    bindings: []
  }
});
var PipelineLayout = _PipelineLayout;

// node_modules/@luma.gl/core/dist/utils/array-utils-flat.js
var arrayBuffer;
function getScratchArrayBuffer(byteLength) {
  if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
    arrayBuffer = new ArrayBuffer(byteLength);
  }
  return arrayBuffer;
}
function getScratchArray(Type, length) {
  const scratchArrayBuffer = getScratchArrayBuffer(Type.BYTES_PER_ELEMENT * length);
  return new Type(scratchArrayBuffer, 0, length);
}

// node_modules/@luma.gl/core/dist/utils/is-array.js
function isTypedArray(value) {
  return ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function isNumberArray(value) {
  if (Array.isArray(value)) {
    return value.length === 0 || typeof value[0] === "number";
  }
  return isTypedArray(value);
}

// node_modules/@luma.gl/core/dist/portable/uniform-buffer-layout.js
var minBufferSize = 1024;
var UniformBufferLayout = class {
  /** Create a new UniformBufferLayout given a map of attributes. */
  constructor(uniformTypes, uniformSizes = {}) {
    __publicField(this, "layout", {});
    /** number of bytes needed for buffer allocation */
    __publicField(this, "byteLength");
    let size = 0;
    for (const [key, uniformType] of Object.entries(uniformTypes)) {
      const typeAndComponents = getVariableShaderTypeInfo(uniformType);
      const { type, components } = typeAndComponents;
      const count = components * ((uniformSizes == null ? void 0 : uniformSizes[key]) ?? 1);
      size = alignTo(size, count);
      const offset = size;
      size += count;
      this.layout[key] = { type, size: count, offset };
    }
    size += (4 - size % 4) % 4;
    const actualByteLength = size * 4;
    this.byteLength = Math.max(actualByteLength, minBufferSize);
  }
  /** Get the data for the complete buffer */
  getData(uniformValues) {
    const arrayBuffer2 = getScratchArrayBuffer(this.byteLength);
    const typedArrays = {
      i32: new Int32Array(arrayBuffer2),
      u32: new Uint32Array(arrayBuffer2),
      f32: new Float32Array(arrayBuffer2),
      // TODO not implemented
      f16: new Uint16Array(arrayBuffer2)
    };
    for (const [name2, value] of Object.entries(uniformValues)) {
      const uniformLayout = this.layout[name2];
      if (!uniformLayout) {
        log.warn(`Supplied uniform value ${name2} not present in uniform block layout`)();
        continue;
      }
      const { type, size, offset } = uniformLayout;
      const typedArray = typedArrays[type];
      if (size === 1) {
        if (typeof value !== "number" && typeof value !== "boolean") {
          log.warn(`Supplied value for single component uniform ${name2} is not a number: ${value}`)();
          continue;
        }
        typedArray[offset] = Number(value);
      } else {
        if (!isNumberArray(value)) {
          log.warn(`Supplied value for multi component / array uniform ${name2} is not a numeric array: ${value}`)();
          continue;
        }
        typedArray.set(value, offset);
      }
    }
    return new Uint8Array(arrayBuffer2, 0, this.byteLength);
  }
  /** Does this layout have a field with specified name */
  has(name2) {
    return Boolean(this.layout[name2]);
  }
  /** Get offset and size for a field with specified name */
  get(name2) {
    const layout = this.layout[name2];
    return layout;
  }
};

// node_modules/@luma.gl/core/dist/utils/array-equal.js
function arrayEqual(a, b, limit = 16) {
  if (a !== b) {
    return false;
  }
  const arrayA = a;
  const arrayB = b;
  if (!isNumberArray(arrayA)) {
    return false;
  }
  if (isNumberArray(arrayB) && arrayA.length === arrayB.length) {
    for (let i = 0; i < arrayA.length; ++i) {
      if (arrayB[i] !== arrayA[i]) {
        return false;
      }
    }
  }
  return true;
}
function arrayCopy(a) {
  if (isNumberArray(a)) {
    return a.slice();
  }
  return a;
}

// node_modules/@luma.gl/core/dist/portable/uniform-block.js
var UniformBlock = class {
  constructor(props) {
    __publicField(this, "name");
    __publicField(this, "uniforms", {});
    __publicField(this, "modifiedUniforms", {});
    __publicField(this, "modified", true);
    __publicField(this, "bindingLayout", {});
    __publicField(this, "needsRedraw", "initialized");
    var _a;
    this.name = (props == null ? void 0 : props.name) || "unnamed";
    if ((props == null ? void 0 : props.name) && (props == null ? void 0 : props.shaderLayout)) {
      const binding = (_a = props == null ? void 0 : props.shaderLayout.bindings) == null ? void 0 : _a.find((binding_) => binding_.type === "uniform" && binding_.name === (props == null ? void 0 : props.name));
      if (!binding) {
        throw new Error(props == null ? void 0 : props.name);
      }
      const uniformBlock = binding;
      for (const uniform of uniformBlock.uniforms || []) {
        this.bindingLayout[uniform.name] = uniform;
      }
    }
  }
  /** Set a map of uniforms */
  setUniforms(uniforms) {
    for (const [key, value] of Object.entries(uniforms)) {
      this._setUniform(key, value);
      if (!this.needsRedraw) {
        this.setNeedsRedraw(`${this.name}.${key}=${value}`);
      }
    }
  }
  setNeedsRedraw(reason) {
    this.needsRedraw = this.needsRedraw || reason;
  }
  /** Returns all uniforms */
  getAllUniforms() {
    this.modifiedUniforms = {};
    this.needsRedraw = false;
    return this.uniforms || {};
  }
  /** Set a single uniform */
  _setUniform(key, value) {
    if (arrayEqual(this.uniforms[key], value)) {
      return;
    }
    this.uniforms[key] = arrayCopy(value);
    this.modifiedUniforms[key] = true;
    this.modified = true;
  }
};

// node_modules/@luma.gl/core/dist/portable/uniform-store.js
var UniformStore = class {
  /**
   * Create a new UniformStore instance
   * @param blocks
   */
  constructor(blocks) {
    /** Stores the uniform values for each uniform block */
    __publicField(this, "uniformBlocks", /* @__PURE__ */ new Map());
    /** Can generate data for a uniform buffer for each block from data */
    __publicField(this, "uniformBufferLayouts", /* @__PURE__ */ new Map());
    /** Actual buffer for the blocks */
    __publicField(this, "uniformBuffers", /* @__PURE__ */ new Map());
    for (const [bufferName, block] of Object.entries(blocks)) {
      const uniformBufferName = bufferName;
      const uniformBufferLayout = new UniformBufferLayout(block.uniformTypes ?? {}, block.uniformSizes ?? {});
      this.uniformBufferLayouts.set(uniformBufferName, uniformBufferLayout);
      const uniformBlock = new UniformBlock({ name: bufferName });
      uniformBlock.setUniforms(block.defaultUniforms || {});
      this.uniformBlocks.set(uniformBufferName, uniformBlock);
    }
  }
  /** Destroy any managed uniform buffers */
  destroy() {
    for (const uniformBuffer of this.uniformBuffers.values()) {
      uniformBuffer.destroy();
    }
  }
  /**
   * Set uniforms
   * Makes all properties partial
   */
  setUniforms(uniforms) {
    var _a;
    for (const [blockName, uniformValues] of Object.entries(uniforms)) {
      (_a = this.uniformBlocks.get(blockName)) == null ? void 0 : _a.setUniforms(uniformValues);
    }
    this.updateUniformBuffers();
  }
  /** Get the required minimum length of the uniform buffer */
  getUniformBufferByteLength(uniformBufferName) {
    var _a;
    return ((_a = this.uniformBufferLayouts.get(uniformBufferName)) == null ? void 0 : _a.byteLength) || 0;
  }
  /** Get formatted binary memory that can be uploaded to a buffer */
  getUniformBufferData(uniformBufferName) {
    var _a, _b;
    const uniformValues = ((_a = this.uniformBlocks.get(uniformBufferName)) == null ? void 0 : _a.getAllUniforms()) || {};
    return (_b = this.uniformBufferLayouts.get(uniformBufferName)) == null ? void 0 : _b.getData(uniformValues);
  }
  /**
   * Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)
   * The new buffer is initialized with current / supplied values
   */
  createUniformBuffer(device, uniformBufferName, uniforms) {
    if (uniforms) {
      this.setUniforms(uniforms);
    }
    const byteLength = this.getUniformBufferByteLength(uniformBufferName);
    const uniformBuffer = device.createBuffer({
      usage: Buffer.UNIFORM | Buffer.COPY_DST,
      byteLength
    });
    const uniformBufferData = this.getUniformBufferData(uniformBufferName);
    uniformBuffer.write(uniformBufferData);
    return uniformBuffer;
  }
  /** Get the managed uniform buffer. "managed" resources are destroyed when the uniformStore is destroyed. */
  getManagedUniformBuffer(device, uniformBufferName) {
    if (!this.uniformBuffers.get(uniformBufferName)) {
      const byteLength = this.getUniformBufferByteLength(uniformBufferName);
      const uniformBuffer = device.createBuffer({
        usage: Buffer.UNIFORM | Buffer.COPY_DST,
        byteLength
      });
      this.uniformBuffers.set(uniformBufferName, uniformBuffer);
    }
    return this.uniformBuffers.get(uniformBufferName);
  }
  /** Updates all uniform buffers where values have changed */
  updateUniformBuffers() {
    let reason = false;
    for (const uniformBufferName of this.uniformBlocks.keys()) {
      const bufferReason = this.updateUniformBuffer(uniformBufferName);
      reason || (reason = bufferReason);
    }
    if (reason) {
      log.log(3, `UniformStore.updateUniformBuffers(): ${reason}`)();
    }
    return reason;
  }
  /** Update one uniform buffer. Only updates if values have changed */
  updateUniformBuffer(uniformBufferName) {
    var _a;
    const uniformBlock = this.uniformBlocks.get(uniformBufferName);
    let uniformBuffer = this.uniformBuffers.get(uniformBufferName);
    let reason = false;
    if (uniformBuffer && (uniformBlock == null ? void 0 : uniformBlock.needsRedraw)) {
      reason || (reason = uniformBlock.needsRedraw);
      const uniformBufferData = this.getUniformBufferData(uniformBufferName);
      uniformBuffer = this.uniformBuffers.get(uniformBufferName);
      uniformBuffer == null ? void 0 : uniformBuffer.write(uniformBufferData);
      const uniformValues = (_a = this.uniformBlocks.get(uniformBufferName)) == null ? void 0 : _a.getAllUniforms();
      log.log(4, `Writing to uniform buffer ${String(uniformBufferName)}`, uniformBufferData, uniformValues)();
    }
    return reason;
  }
};

// node_modules/@luma.gl/constants/dist/webgl-constants.js
var GLEnum;
(function(GLEnum2) {
  GLEnum2[GLEnum2["DEPTH_BUFFER_BIT"] = 256] = "DEPTH_BUFFER_BIT";
  GLEnum2[GLEnum2["STENCIL_BUFFER_BIT"] = 1024] = "STENCIL_BUFFER_BIT";
  GLEnum2[GLEnum2["COLOR_BUFFER_BIT"] = 16384] = "COLOR_BUFFER_BIT";
  GLEnum2[GLEnum2["POINTS"] = 0] = "POINTS";
  GLEnum2[GLEnum2["LINES"] = 1] = "LINES";
  GLEnum2[GLEnum2["LINE_LOOP"] = 2] = "LINE_LOOP";
  GLEnum2[GLEnum2["LINE_STRIP"] = 3] = "LINE_STRIP";
  GLEnum2[GLEnum2["TRIANGLES"] = 4] = "TRIANGLES";
  GLEnum2[GLEnum2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  GLEnum2[GLEnum2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
  GLEnum2[GLEnum2["ZERO"] = 0] = "ZERO";
  GLEnum2[GLEnum2["ONE"] = 1] = "ONE";
  GLEnum2[GLEnum2["SRC_COLOR"] = 768] = "SRC_COLOR";
  GLEnum2[GLEnum2["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
  GLEnum2[GLEnum2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
  GLEnum2[GLEnum2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
  GLEnum2[GLEnum2["DST_ALPHA"] = 772] = "DST_ALPHA";
  GLEnum2[GLEnum2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
  GLEnum2[GLEnum2["DST_COLOR"] = 774] = "DST_COLOR";
  GLEnum2[GLEnum2["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
  GLEnum2[GLEnum2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
  GLEnum2[GLEnum2["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
  GLEnum2[GLEnum2["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
  GLEnum2[GLEnum2["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
  GLEnum2[GLEnum2["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
  GLEnum2[GLEnum2["FUNC_ADD"] = 32774] = "FUNC_ADD";
  GLEnum2[GLEnum2["FUNC_SUBTRACT"] = 32778] = "FUNC_SUBTRACT";
  GLEnum2[GLEnum2["FUNC_REVERSE_SUBTRACT"] = 32779] = "FUNC_REVERSE_SUBTRACT";
  GLEnum2[GLEnum2["BLEND_EQUATION"] = 32777] = "BLEND_EQUATION";
  GLEnum2[GLEnum2["BLEND_EQUATION_RGB"] = 32777] = "BLEND_EQUATION_RGB";
  GLEnum2[GLEnum2["BLEND_EQUATION_ALPHA"] = 34877] = "BLEND_EQUATION_ALPHA";
  GLEnum2[GLEnum2["BLEND_DST_RGB"] = 32968] = "BLEND_DST_RGB";
  GLEnum2[GLEnum2["BLEND_SRC_RGB"] = 32969] = "BLEND_SRC_RGB";
  GLEnum2[GLEnum2["BLEND_DST_ALPHA"] = 32970] = "BLEND_DST_ALPHA";
  GLEnum2[GLEnum2["BLEND_SRC_ALPHA"] = 32971] = "BLEND_SRC_ALPHA";
  GLEnum2[GLEnum2["BLEND_COLOR"] = 32773] = "BLEND_COLOR";
  GLEnum2[GLEnum2["ARRAY_BUFFER_BINDING"] = 34964] = "ARRAY_BUFFER_BINDING";
  GLEnum2[GLEnum2["ELEMENT_ARRAY_BUFFER_BINDING"] = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING";
  GLEnum2[GLEnum2["LINE_WIDTH"] = 2849] = "LINE_WIDTH";
  GLEnum2[GLEnum2["ALIASED_POINT_SIZE_RANGE"] = 33901] = "ALIASED_POINT_SIZE_RANGE";
  GLEnum2[GLEnum2["ALIASED_LINE_WIDTH_RANGE"] = 33902] = "ALIASED_LINE_WIDTH_RANGE";
  GLEnum2[GLEnum2["CULL_FACE_MODE"] = 2885] = "CULL_FACE_MODE";
  GLEnum2[GLEnum2["FRONT_FACE"] = 2886] = "FRONT_FACE";
  GLEnum2[GLEnum2["DEPTH_RANGE"] = 2928] = "DEPTH_RANGE";
  GLEnum2[GLEnum2["DEPTH_WRITEMASK"] = 2930] = "DEPTH_WRITEMASK";
  GLEnum2[GLEnum2["DEPTH_CLEAR_VALUE"] = 2931] = "DEPTH_CLEAR_VALUE";
  GLEnum2[GLEnum2["DEPTH_FUNC"] = 2932] = "DEPTH_FUNC";
  GLEnum2[GLEnum2["STENCIL_CLEAR_VALUE"] = 2961] = "STENCIL_CLEAR_VALUE";
  GLEnum2[GLEnum2["STENCIL_FUNC"] = 2962] = "STENCIL_FUNC";
  GLEnum2[GLEnum2["STENCIL_FAIL"] = 2964] = "STENCIL_FAIL";
  GLEnum2[GLEnum2["STENCIL_PASS_DEPTH_FAIL"] = 2965] = "STENCIL_PASS_DEPTH_FAIL";
  GLEnum2[GLEnum2["STENCIL_PASS_DEPTH_PASS"] = 2966] = "STENCIL_PASS_DEPTH_PASS";
  GLEnum2[GLEnum2["STENCIL_REF"] = 2967] = "STENCIL_REF";
  GLEnum2[GLEnum2["STENCIL_VALUE_MASK"] = 2963] = "STENCIL_VALUE_MASK";
  GLEnum2[GLEnum2["STENCIL_WRITEMASK"] = 2968] = "STENCIL_WRITEMASK";
  GLEnum2[GLEnum2["STENCIL_BACK_FUNC"] = 34816] = "STENCIL_BACK_FUNC";
  GLEnum2[GLEnum2["STENCIL_BACK_FAIL"] = 34817] = "STENCIL_BACK_FAIL";
  GLEnum2[GLEnum2["STENCIL_BACK_PASS_DEPTH_FAIL"] = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL";
  GLEnum2[GLEnum2["STENCIL_BACK_PASS_DEPTH_PASS"] = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS";
  GLEnum2[GLEnum2["STENCIL_BACK_REF"] = 36003] = "STENCIL_BACK_REF";
  GLEnum2[GLEnum2["STENCIL_BACK_VALUE_MASK"] = 36004] = "STENCIL_BACK_VALUE_MASK";
  GLEnum2[GLEnum2["STENCIL_BACK_WRITEMASK"] = 36005] = "STENCIL_BACK_WRITEMASK";
  GLEnum2[GLEnum2["VIEWPORT"] = 2978] = "VIEWPORT";
  GLEnum2[GLEnum2["SCISSOR_BOX"] = 3088] = "SCISSOR_BOX";
  GLEnum2[GLEnum2["COLOR_CLEAR_VALUE"] = 3106] = "COLOR_CLEAR_VALUE";
  GLEnum2[GLEnum2["COLOR_WRITEMASK"] = 3107] = "COLOR_WRITEMASK";
  GLEnum2[GLEnum2["UNPACK_ALIGNMENT"] = 3317] = "UNPACK_ALIGNMENT";
  GLEnum2[GLEnum2["PACK_ALIGNMENT"] = 3333] = "PACK_ALIGNMENT";
  GLEnum2[GLEnum2["MAX_TEXTURE_SIZE"] = 3379] = "MAX_TEXTURE_SIZE";
  GLEnum2[GLEnum2["MAX_VIEWPORT_DIMS"] = 3386] = "MAX_VIEWPORT_DIMS";
  GLEnum2[GLEnum2["SUBPIXEL_BITS"] = 3408] = "SUBPIXEL_BITS";
  GLEnum2[GLEnum2["RED_BITS"] = 3410] = "RED_BITS";
  GLEnum2[GLEnum2["GREEN_BITS"] = 3411] = "GREEN_BITS";
  GLEnum2[GLEnum2["BLUE_BITS"] = 3412] = "BLUE_BITS";
  GLEnum2[GLEnum2["ALPHA_BITS"] = 3413] = "ALPHA_BITS";
  GLEnum2[GLEnum2["DEPTH_BITS"] = 3414] = "DEPTH_BITS";
  GLEnum2[GLEnum2["STENCIL_BITS"] = 3415] = "STENCIL_BITS";
  GLEnum2[GLEnum2["POLYGON_OFFSET_UNITS"] = 10752] = "POLYGON_OFFSET_UNITS";
  GLEnum2[GLEnum2["POLYGON_OFFSET_FACTOR"] = 32824] = "POLYGON_OFFSET_FACTOR";
  GLEnum2[GLEnum2["TEXTURE_BINDING_2D"] = 32873] = "TEXTURE_BINDING_2D";
  GLEnum2[GLEnum2["SAMPLE_BUFFERS"] = 32936] = "SAMPLE_BUFFERS";
  GLEnum2[GLEnum2["SAMPLES"] = 32937] = "SAMPLES";
  GLEnum2[GLEnum2["SAMPLE_COVERAGE_VALUE"] = 32938] = "SAMPLE_COVERAGE_VALUE";
  GLEnum2[GLEnum2["SAMPLE_COVERAGE_INVERT"] = 32939] = "SAMPLE_COVERAGE_INVERT";
  GLEnum2[GLEnum2["COMPRESSED_TEXTURE_FORMATS"] = 34467] = "COMPRESSED_TEXTURE_FORMATS";
  GLEnum2[GLEnum2["VENDOR"] = 7936] = "VENDOR";
  GLEnum2[GLEnum2["RENDERER"] = 7937] = "RENDERER";
  GLEnum2[GLEnum2["VERSION"] = 7938] = "VERSION";
  GLEnum2[GLEnum2["IMPLEMENTATION_COLOR_READ_TYPE"] = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE";
  GLEnum2[GLEnum2["IMPLEMENTATION_COLOR_READ_FORMAT"] = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT";
  GLEnum2[GLEnum2["BROWSER_DEFAULT_WEBGL"] = 37444] = "BROWSER_DEFAULT_WEBGL";
  GLEnum2[GLEnum2["STATIC_DRAW"] = 35044] = "STATIC_DRAW";
  GLEnum2[GLEnum2["STREAM_DRAW"] = 35040] = "STREAM_DRAW";
  GLEnum2[GLEnum2["DYNAMIC_DRAW"] = 35048] = "DYNAMIC_DRAW";
  GLEnum2[GLEnum2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  GLEnum2[GLEnum2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  GLEnum2[GLEnum2["BUFFER_SIZE"] = 34660] = "BUFFER_SIZE";
  GLEnum2[GLEnum2["BUFFER_USAGE"] = 34661] = "BUFFER_USAGE";
  GLEnum2[GLEnum2["CURRENT_VERTEX_ATTRIB"] = 34342] = "CURRENT_VERTEX_ATTRIB";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_ENABLED"] = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_SIZE"] = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_STRIDE"] = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_TYPE"] = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_NORMALIZED"] = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_POINTER"] = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"] = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
  GLEnum2[GLEnum2["CULL_FACE"] = 2884] = "CULL_FACE";
  GLEnum2[GLEnum2["FRONT"] = 1028] = "FRONT";
  GLEnum2[GLEnum2["BACK"] = 1029] = "BACK";
  GLEnum2[GLEnum2["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
  GLEnum2[GLEnum2["BLEND"] = 3042] = "BLEND";
  GLEnum2[GLEnum2["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
  GLEnum2[GLEnum2["DITHER"] = 3024] = "DITHER";
  GLEnum2[GLEnum2["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
  GLEnum2[GLEnum2["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
  GLEnum2[GLEnum2["SAMPLE_COVERAGE"] = 32928] = "SAMPLE_COVERAGE";
  GLEnum2[GLEnum2["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
  GLEnum2[GLEnum2["STENCIL_TEST"] = 2960] = "STENCIL_TEST";
  GLEnum2[GLEnum2["NO_ERROR"] = 0] = "NO_ERROR";
  GLEnum2[GLEnum2["INVALID_ENUM"] = 1280] = "INVALID_ENUM";
  GLEnum2[GLEnum2["INVALID_VALUE"] = 1281] = "INVALID_VALUE";
  GLEnum2[GLEnum2["INVALID_OPERATION"] = 1282] = "INVALID_OPERATION";
  GLEnum2[GLEnum2["OUT_OF_MEMORY"] = 1285] = "OUT_OF_MEMORY";
  GLEnum2[GLEnum2["CONTEXT_LOST_WEBGL"] = 37442] = "CONTEXT_LOST_WEBGL";
  GLEnum2[GLEnum2["CW"] = 2304] = "CW";
  GLEnum2[GLEnum2["CCW"] = 2305] = "CCW";
  GLEnum2[GLEnum2["DONT_CARE"] = 4352] = "DONT_CARE";
  GLEnum2[GLEnum2["FASTEST"] = 4353] = "FASTEST";
  GLEnum2[GLEnum2["NICEST"] = 4354] = "NICEST";
  GLEnum2[GLEnum2["GENERATE_MIPMAP_HINT"] = 33170] = "GENERATE_MIPMAP_HINT";
  GLEnum2[GLEnum2["BYTE"] = 5120] = "BYTE";
  GLEnum2[GLEnum2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  GLEnum2[GLEnum2["SHORT"] = 5122] = "SHORT";
  GLEnum2[GLEnum2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  GLEnum2[GLEnum2["INT"] = 5124] = "INT";
  GLEnum2[GLEnum2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  GLEnum2[GLEnum2["FLOAT"] = 5126] = "FLOAT";
  GLEnum2[GLEnum2["DOUBLE"] = 5130] = "DOUBLE";
  GLEnum2[GLEnum2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  GLEnum2[GLEnum2["ALPHA"] = 6406] = "ALPHA";
  GLEnum2[GLEnum2["RGB"] = 6407] = "RGB";
  GLEnum2[GLEnum2["RGBA"] = 6408] = "RGBA";
  GLEnum2[GLEnum2["LUMINANCE"] = 6409] = "LUMINANCE";
  GLEnum2[GLEnum2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  GLEnum2[GLEnum2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  GLEnum2[GLEnum2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  GLEnum2[GLEnum2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  GLEnum2[GLEnum2["FRAGMENT_SHADER"] = 35632] = "FRAGMENT_SHADER";
  GLEnum2[GLEnum2["VERTEX_SHADER"] = 35633] = "VERTEX_SHADER";
  GLEnum2[GLEnum2["COMPILE_STATUS"] = 35713] = "COMPILE_STATUS";
  GLEnum2[GLEnum2["DELETE_STATUS"] = 35712] = "DELETE_STATUS";
  GLEnum2[GLEnum2["LINK_STATUS"] = 35714] = "LINK_STATUS";
  GLEnum2[GLEnum2["VALIDATE_STATUS"] = 35715] = "VALIDATE_STATUS";
  GLEnum2[GLEnum2["ATTACHED_SHADERS"] = 35717] = "ATTACHED_SHADERS";
  GLEnum2[GLEnum2["ACTIVE_ATTRIBUTES"] = 35721] = "ACTIVE_ATTRIBUTES";
  GLEnum2[GLEnum2["ACTIVE_UNIFORMS"] = 35718] = "ACTIVE_UNIFORMS";
  GLEnum2[GLEnum2["MAX_VERTEX_ATTRIBS"] = 34921] = "MAX_VERTEX_ATTRIBS";
  GLEnum2[GLEnum2["MAX_VERTEX_UNIFORM_VECTORS"] = 36347] = "MAX_VERTEX_UNIFORM_VECTORS";
  GLEnum2[GLEnum2["MAX_VARYING_VECTORS"] = 36348] = "MAX_VARYING_VECTORS";
  GLEnum2[GLEnum2["MAX_COMBINED_TEXTURE_IMAGE_UNITS"] = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
  GLEnum2[GLEnum2["MAX_VERTEX_TEXTURE_IMAGE_UNITS"] = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
  GLEnum2[GLEnum2["MAX_TEXTURE_IMAGE_UNITS"] = 34930] = "MAX_TEXTURE_IMAGE_UNITS";
  GLEnum2[GLEnum2["MAX_FRAGMENT_UNIFORM_VECTORS"] = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS";
  GLEnum2[GLEnum2["SHADER_TYPE"] = 35663] = "SHADER_TYPE";
  GLEnum2[GLEnum2["SHADING_LANGUAGE_VERSION"] = 35724] = "SHADING_LANGUAGE_VERSION";
  GLEnum2[GLEnum2["CURRENT_PROGRAM"] = 35725] = "CURRENT_PROGRAM";
  GLEnum2[GLEnum2["NEVER"] = 512] = "NEVER";
  GLEnum2[GLEnum2["LESS"] = 513] = "LESS";
  GLEnum2[GLEnum2["EQUAL"] = 514] = "EQUAL";
  GLEnum2[GLEnum2["LEQUAL"] = 515] = "LEQUAL";
  GLEnum2[GLEnum2["GREATER"] = 516] = "GREATER";
  GLEnum2[GLEnum2["NOTEQUAL"] = 517] = "NOTEQUAL";
  GLEnum2[GLEnum2["GEQUAL"] = 518] = "GEQUAL";
  GLEnum2[GLEnum2["ALWAYS"] = 519] = "ALWAYS";
  GLEnum2[GLEnum2["KEEP"] = 7680] = "KEEP";
  GLEnum2[GLEnum2["REPLACE"] = 7681] = "REPLACE";
  GLEnum2[GLEnum2["INCR"] = 7682] = "INCR";
  GLEnum2[GLEnum2["DECR"] = 7683] = "DECR";
  GLEnum2[GLEnum2["INVERT"] = 5386] = "INVERT";
  GLEnum2[GLEnum2["INCR_WRAP"] = 34055] = "INCR_WRAP";
  GLEnum2[GLEnum2["DECR_WRAP"] = 34056] = "DECR_WRAP";
  GLEnum2[GLEnum2["NEAREST"] = 9728] = "NEAREST";
  GLEnum2[GLEnum2["LINEAR"] = 9729] = "LINEAR";
  GLEnum2[GLEnum2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
  GLEnum2[GLEnum2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
  GLEnum2[GLEnum2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
  GLEnum2[GLEnum2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
  GLEnum2[GLEnum2["TEXTURE_MAG_FILTER"] = 10240] = "TEXTURE_MAG_FILTER";
  GLEnum2[GLEnum2["TEXTURE_MIN_FILTER"] = 10241] = "TEXTURE_MIN_FILTER";
  GLEnum2[GLEnum2["TEXTURE_WRAP_S"] = 10242] = "TEXTURE_WRAP_S";
  GLEnum2[GLEnum2["TEXTURE_WRAP_T"] = 10243] = "TEXTURE_WRAP_T";
  GLEnum2[GLEnum2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  GLEnum2[GLEnum2["TEXTURE"] = 5890] = "TEXTURE";
  GLEnum2[GLEnum2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  GLEnum2[GLEnum2["TEXTURE_BINDING_CUBE_MAP"] = 34068] = "TEXTURE_BINDING_CUBE_MAP";
  GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  GLEnum2[GLEnum2["MAX_CUBE_MAP_TEXTURE_SIZE"] = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE";
  GLEnum2[GLEnum2["TEXTURE0"] = 33984] = "TEXTURE0";
  GLEnum2[GLEnum2["ACTIVE_TEXTURE"] = 34016] = "ACTIVE_TEXTURE";
  GLEnum2[GLEnum2["REPEAT"] = 10497] = "REPEAT";
  GLEnum2[GLEnum2["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
  GLEnum2[GLEnum2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  GLEnum2[GLEnum2["TEXTURE_WIDTH"] = 4096] = "TEXTURE_WIDTH";
  GLEnum2[GLEnum2["TEXTURE_HEIGHT"] = 4097] = "TEXTURE_HEIGHT";
  GLEnum2[GLEnum2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
  GLEnum2[GLEnum2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
  GLEnum2[GLEnum2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
  GLEnum2[GLEnum2["INT_VEC2"] = 35667] = "INT_VEC2";
  GLEnum2[GLEnum2["INT_VEC3"] = 35668] = "INT_VEC3";
  GLEnum2[GLEnum2["INT_VEC4"] = 35669] = "INT_VEC4";
  GLEnum2[GLEnum2["BOOL"] = 35670] = "BOOL";
  GLEnum2[GLEnum2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
  GLEnum2[GLEnum2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
  GLEnum2[GLEnum2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
  GLEnum2[GLEnum2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
  GLEnum2[GLEnum2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
  GLEnum2[GLEnum2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
  GLEnum2[GLEnum2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
  GLEnum2[GLEnum2["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
  GLEnum2[GLEnum2["LOW_FLOAT"] = 36336] = "LOW_FLOAT";
  GLEnum2[GLEnum2["MEDIUM_FLOAT"] = 36337] = "MEDIUM_FLOAT";
  GLEnum2[GLEnum2["HIGH_FLOAT"] = 36338] = "HIGH_FLOAT";
  GLEnum2[GLEnum2["LOW_INT"] = 36339] = "LOW_INT";
  GLEnum2[GLEnum2["MEDIUM_INT"] = 36340] = "MEDIUM_INT";
  GLEnum2[GLEnum2["HIGH_INT"] = 36341] = "HIGH_INT";
  GLEnum2[GLEnum2["FRAMEBUFFER"] = 36160] = "FRAMEBUFFER";
  GLEnum2[GLEnum2["RENDERBUFFER"] = 36161] = "RENDERBUFFER";
  GLEnum2[GLEnum2["RGBA4"] = 32854] = "RGBA4";
  GLEnum2[GLEnum2["RGB5_A1"] = 32855] = "RGB5_A1";
  GLEnum2[GLEnum2["RGB565"] = 36194] = "RGB565";
  GLEnum2[GLEnum2["DEPTH_COMPONENT16"] = 33189] = "DEPTH_COMPONENT16";
  GLEnum2[GLEnum2["STENCIL_INDEX"] = 6401] = "STENCIL_INDEX";
  GLEnum2[GLEnum2["STENCIL_INDEX8"] = 36168] = "STENCIL_INDEX8";
  GLEnum2[GLEnum2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  GLEnum2[GLEnum2["RENDERBUFFER_WIDTH"] = 36162] = "RENDERBUFFER_WIDTH";
  GLEnum2[GLEnum2["RENDERBUFFER_HEIGHT"] = 36163] = "RENDERBUFFER_HEIGHT";
  GLEnum2[GLEnum2["RENDERBUFFER_INTERNAL_FORMAT"] = 36164] = "RENDERBUFFER_INTERNAL_FORMAT";
  GLEnum2[GLEnum2["RENDERBUFFER_RED_SIZE"] = 36176] = "RENDERBUFFER_RED_SIZE";
  GLEnum2[GLEnum2["RENDERBUFFER_GREEN_SIZE"] = 36177] = "RENDERBUFFER_GREEN_SIZE";
  GLEnum2[GLEnum2["RENDERBUFFER_BLUE_SIZE"] = 36178] = "RENDERBUFFER_BLUE_SIZE";
  GLEnum2[GLEnum2["RENDERBUFFER_ALPHA_SIZE"] = 36179] = "RENDERBUFFER_ALPHA_SIZE";
  GLEnum2[GLEnum2["RENDERBUFFER_DEPTH_SIZE"] = 36180] = "RENDERBUFFER_DEPTH_SIZE";
  GLEnum2[GLEnum2["RENDERBUFFER_STENCIL_SIZE"] = 36181] = "RENDERBUFFER_STENCIL_SIZE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"] = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"] = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"] = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"] = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT0"] = 36064] = "COLOR_ATTACHMENT0";
  GLEnum2[GLEnum2["DEPTH_ATTACHMENT"] = 36096] = "DEPTH_ATTACHMENT";
  GLEnum2[GLEnum2["STENCIL_ATTACHMENT"] = 36128] = "STENCIL_ATTACHMENT";
  GLEnum2[GLEnum2["DEPTH_STENCIL_ATTACHMENT"] = 33306] = "DEPTH_STENCIL_ATTACHMENT";
  GLEnum2[GLEnum2["NONE"] = 0] = "NONE";
  GLEnum2[GLEnum2["FRAMEBUFFER_COMPLETE"] = 36053] = "FRAMEBUFFER_COMPLETE";
  GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_ATTACHMENT"] = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
  GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"] = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
  GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_DIMENSIONS"] = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
  GLEnum2[GLEnum2["FRAMEBUFFER_UNSUPPORTED"] = 36061] = "FRAMEBUFFER_UNSUPPORTED";
  GLEnum2[GLEnum2["FRAMEBUFFER_BINDING"] = 36006] = "FRAMEBUFFER_BINDING";
  GLEnum2[GLEnum2["RENDERBUFFER_BINDING"] = 36007] = "RENDERBUFFER_BINDING";
  GLEnum2[GLEnum2["READ_FRAMEBUFFER"] = 36008] = "READ_FRAMEBUFFER";
  GLEnum2[GLEnum2["DRAW_FRAMEBUFFER"] = 36009] = "DRAW_FRAMEBUFFER";
  GLEnum2[GLEnum2["MAX_RENDERBUFFER_SIZE"] = 34024] = "MAX_RENDERBUFFER_SIZE";
  GLEnum2[GLEnum2["INVALID_FRAMEBUFFER_OPERATION"] = 1286] = "INVALID_FRAMEBUFFER_OPERATION";
  GLEnum2[GLEnum2["UNPACK_FLIP_Y_WEBGL"] = 37440] = "UNPACK_FLIP_Y_WEBGL";
  GLEnum2[GLEnum2["UNPACK_PREMULTIPLY_ALPHA_WEBGL"] = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL";
  GLEnum2[GLEnum2["UNPACK_COLORSPACE_CONVERSION_WEBGL"] = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL";
  GLEnum2[GLEnum2["READ_BUFFER"] = 3074] = "READ_BUFFER";
  GLEnum2[GLEnum2["UNPACK_ROW_LENGTH"] = 3314] = "UNPACK_ROW_LENGTH";
  GLEnum2[GLEnum2["UNPACK_SKIP_ROWS"] = 3315] = "UNPACK_SKIP_ROWS";
  GLEnum2[GLEnum2["UNPACK_SKIP_PIXELS"] = 3316] = "UNPACK_SKIP_PIXELS";
  GLEnum2[GLEnum2["PACK_ROW_LENGTH"] = 3330] = "PACK_ROW_LENGTH";
  GLEnum2[GLEnum2["PACK_SKIP_ROWS"] = 3331] = "PACK_SKIP_ROWS";
  GLEnum2[GLEnum2["PACK_SKIP_PIXELS"] = 3332] = "PACK_SKIP_PIXELS";
  GLEnum2[GLEnum2["TEXTURE_BINDING_3D"] = 32874] = "TEXTURE_BINDING_3D";
  GLEnum2[GLEnum2["UNPACK_SKIP_IMAGES"] = 32877] = "UNPACK_SKIP_IMAGES";
  GLEnum2[GLEnum2["UNPACK_IMAGE_HEIGHT"] = 32878] = "UNPACK_IMAGE_HEIGHT";
  GLEnum2[GLEnum2["MAX_3D_TEXTURE_SIZE"] = 32883] = "MAX_3D_TEXTURE_SIZE";
  GLEnum2[GLEnum2["MAX_ELEMENTS_VERTICES"] = 33e3] = "MAX_ELEMENTS_VERTICES";
  GLEnum2[GLEnum2["MAX_ELEMENTS_INDICES"] = 33001] = "MAX_ELEMENTS_INDICES";
  GLEnum2[GLEnum2["MAX_TEXTURE_LOD_BIAS"] = 34045] = "MAX_TEXTURE_LOD_BIAS";
  GLEnum2[GLEnum2["MAX_FRAGMENT_UNIFORM_COMPONENTS"] = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS";
  GLEnum2[GLEnum2["MAX_VERTEX_UNIFORM_COMPONENTS"] = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS";
  GLEnum2[GLEnum2["MAX_ARRAY_TEXTURE_LAYERS"] = 35071] = "MAX_ARRAY_TEXTURE_LAYERS";
  GLEnum2[GLEnum2["MIN_PROGRAM_TEXEL_OFFSET"] = 35076] = "MIN_PROGRAM_TEXEL_OFFSET";
  GLEnum2[GLEnum2["MAX_PROGRAM_TEXEL_OFFSET"] = 35077] = "MAX_PROGRAM_TEXEL_OFFSET";
  GLEnum2[GLEnum2["MAX_VARYING_COMPONENTS"] = 35659] = "MAX_VARYING_COMPONENTS";
  GLEnum2[GLEnum2["FRAGMENT_SHADER_DERIVATIVE_HINT"] = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT";
  GLEnum2[GLEnum2["RASTERIZER_DISCARD"] = 35977] = "RASTERIZER_DISCARD";
  GLEnum2[GLEnum2["VERTEX_ARRAY_BINDING"] = 34229] = "VERTEX_ARRAY_BINDING";
  GLEnum2[GLEnum2["MAX_VERTEX_OUTPUT_COMPONENTS"] = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS";
  GLEnum2[GLEnum2["MAX_FRAGMENT_INPUT_COMPONENTS"] = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS";
  GLEnum2[GLEnum2["MAX_SERVER_WAIT_TIMEOUT"] = 37137] = "MAX_SERVER_WAIT_TIMEOUT";
  GLEnum2[GLEnum2["MAX_ELEMENT_INDEX"] = 36203] = "MAX_ELEMENT_INDEX";
  GLEnum2[GLEnum2["RED"] = 6403] = "RED";
  GLEnum2[GLEnum2["RGB8"] = 32849] = "RGB8";
  GLEnum2[GLEnum2["RGBA8"] = 32856] = "RGBA8";
  GLEnum2[GLEnum2["RGB10_A2"] = 32857] = "RGB10_A2";
  GLEnum2[GLEnum2["TEXTURE_3D"] = 32879] = "TEXTURE_3D";
  GLEnum2[GLEnum2["TEXTURE_WRAP_R"] = 32882] = "TEXTURE_WRAP_R";
  GLEnum2[GLEnum2["TEXTURE_MIN_LOD"] = 33082] = "TEXTURE_MIN_LOD";
  GLEnum2[GLEnum2["TEXTURE_MAX_LOD"] = 33083] = "TEXTURE_MAX_LOD";
  GLEnum2[GLEnum2["TEXTURE_BASE_LEVEL"] = 33084] = "TEXTURE_BASE_LEVEL";
  GLEnum2[GLEnum2["TEXTURE_MAX_LEVEL"] = 33085] = "TEXTURE_MAX_LEVEL";
  GLEnum2[GLEnum2["TEXTURE_COMPARE_MODE"] = 34892] = "TEXTURE_COMPARE_MODE";
  GLEnum2[GLEnum2["TEXTURE_COMPARE_FUNC"] = 34893] = "TEXTURE_COMPARE_FUNC";
  GLEnum2[GLEnum2["SRGB"] = 35904] = "SRGB";
  GLEnum2[GLEnum2["SRGB8"] = 35905] = "SRGB8";
  GLEnum2[GLEnum2["SRGB8_ALPHA8"] = 35907] = "SRGB8_ALPHA8";
  GLEnum2[GLEnum2["COMPARE_REF_TO_TEXTURE"] = 34894] = "COMPARE_REF_TO_TEXTURE";
  GLEnum2[GLEnum2["RGBA32F"] = 34836] = "RGBA32F";
  GLEnum2[GLEnum2["RGB32F"] = 34837] = "RGB32F";
  GLEnum2[GLEnum2["RGBA16F"] = 34842] = "RGBA16F";
  GLEnum2[GLEnum2["RGB16F"] = 34843] = "RGB16F";
  GLEnum2[GLEnum2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  GLEnum2[GLEnum2["TEXTURE_BINDING_2D_ARRAY"] = 35869] = "TEXTURE_BINDING_2D_ARRAY";
  GLEnum2[GLEnum2["R11F_G11F_B10F"] = 35898] = "R11F_G11F_B10F";
  GLEnum2[GLEnum2["RGB9_E5"] = 35901] = "RGB9_E5";
  GLEnum2[GLEnum2["RGBA32UI"] = 36208] = "RGBA32UI";
  GLEnum2[GLEnum2["RGB32UI"] = 36209] = "RGB32UI";
  GLEnum2[GLEnum2["RGBA16UI"] = 36214] = "RGBA16UI";
  GLEnum2[GLEnum2["RGB16UI"] = 36215] = "RGB16UI";
  GLEnum2[GLEnum2["RGBA8UI"] = 36220] = "RGBA8UI";
  GLEnum2[GLEnum2["RGB8UI"] = 36221] = "RGB8UI";
  GLEnum2[GLEnum2["RGBA32I"] = 36226] = "RGBA32I";
  GLEnum2[GLEnum2["RGB32I"] = 36227] = "RGB32I";
  GLEnum2[GLEnum2["RGBA16I"] = 36232] = "RGBA16I";
  GLEnum2[GLEnum2["RGB16I"] = 36233] = "RGB16I";
  GLEnum2[GLEnum2["RGBA8I"] = 36238] = "RGBA8I";
  GLEnum2[GLEnum2["RGB8I"] = 36239] = "RGB8I";
  GLEnum2[GLEnum2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  GLEnum2[GLEnum2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  GLEnum2[GLEnum2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  GLEnum2[GLEnum2["R8"] = 33321] = "R8";
  GLEnum2[GLEnum2["RG8"] = 33323] = "RG8";
  GLEnum2[GLEnum2["R16F"] = 33325] = "R16F";
  GLEnum2[GLEnum2["R32F"] = 33326] = "R32F";
  GLEnum2[GLEnum2["RG16F"] = 33327] = "RG16F";
  GLEnum2[GLEnum2["RG32F"] = 33328] = "RG32F";
  GLEnum2[GLEnum2["R8I"] = 33329] = "R8I";
  GLEnum2[GLEnum2["R8UI"] = 33330] = "R8UI";
  GLEnum2[GLEnum2["R16I"] = 33331] = "R16I";
  GLEnum2[GLEnum2["R16UI"] = 33332] = "R16UI";
  GLEnum2[GLEnum2["R32I"] = 33333] = "R32I";
  GLEnum2[GLEnum2["R32UI"] = 33334] = "R32UI";
  GLEnum2[GLEnum2["RG8I"] = 33335] = "RG8I";
  GLEnum2[GLEnum2["RG8UI"] = 33336] = "RG8UI";
  GLEnum2[GLEnum2["RG16I"] = 33337] = "RG16I";
  GLEnum2[GLEnum2["RG16UI"] = 33338] = "RG16UI";
  GLEnum2[GLEnum2["RG32I"] = 33339] = "RG32I";
  GLEnum2[GLEnum2["RG32UI"] = 33340] = "RG32UI";
  GLEnum2[GLEnum2["R8_SNORM"] = 36756] = "R8_SNORM";
  GLEnum2[GLEnum2["RG8_SNORM"] = 36757] = "RG8_SNORM";
  GLEnum2[GLEnum2["RGB8_SNORM"] = 36758] = "RGB8_SNORM";
  GLEnum2[GLEnum2["RGBA8_SNORM"] = 36759] = "RGBA8_SNORM";
  GLEnum2[GLEnum2["RGB10_A2UI"] = 36975] = "RGB10_A2UI";
  GLEnum2[GLEnum2["TEXTURE_IMMUTABLE_FORMAT"] = 37167] = "TEXTURE_IMMUTABLE_FORMAT";
  GLEnum2[GLEnum2["TEXTURE_IMMUTABLE_LEVELS"] = 33503] = "TEXTURE_IMMUTABLE_LEVELS";
  GLEnum2[GLEnum2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  GLEnum2[GLEnum2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  GLEnum2[GLEnum2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  GLEnum2[GLEnum2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  GLEnum2[GLEnum2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  GLEnum2[GLEnum2["HALF_FLOAT"] = 5131] = "HALF_FLOAT";
  GLEnum2[GLEnum2["RG"] = 33319] = "RG";
  GLEnum2[GLEnum2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  GLEnum2[GLEnum2["INT_2_10_10_10_REV"] = 36255] = "INT_2_10_10_10_REV";
  GLEnum2[GLEnum2["CURRENT_QUERY"] = 34917] = "CURRENT_QUERY";
  GLEnum2[GLEnum2["QUERY_RESULT"] = 34918] = "QUERY_RESULT";
  GLEnum2[GLEnum2["QUERY_RESULT_AVAILABLE"] = 34919] = "QUERY_RESULT_AVAILABLE";
  GLEnum2[GLEnum2["ANY_SAMPLES_PASSED"] = 35887] = "ANY_SAMPLES_PASSED";
  GLEnum2[GLEnum2["ANY_SAMPLES_PASSED_CONSERVATIVE"] = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE";
  GLEnum2[GLEnum2["MAX_DRAW_BUFFERS"] = 34852] = "MAX_DRAW_BUFFERS";
  GLEnum2[GLEnum2["DRAW_BUFFER0"] = 34853] = "DRAW_BUFFER0";
  GLEnum2[GLEnum2["DRAW_BUFFER1"] = 34854] = "DRAW_BUFFER1";
  GLEnum2[GLEnum2["DRAW_BUFFER2"] = 34855] = "DRAW_BUFFER2";
  GLEnum2[GLEnum2["DRAW_BUFFER3"] = 34856] = "DRAW_BUFFER3";
  GLEnum2[GLEnum2["DRAW_BUFFER4"] = 34857] = "DRAW_BUFFER4";
  GLEnum2[GLEnum2["DRAW_BUFFER5"] = 34858] = "DRAW_BUFFER5";
  GLEnum2[GLEnum2["DRAW_BUFFER6"] = 34859] = "DRAW_BUFFER6";
  GLEnum2[GLEnum2["DRAW_BUFFER7"] = 34860] = "DRAW_BUFFER7";
  GLEnum2[GLEnum2["DRAW_BUFFER8"] = 34861] = "DRAW_BUFFER8";
  GLEnum2[GLEnum2["DRAW_BUFFER9"] = 34862] = "DRAW_BUFFER9";
  GLEnum2[GLEnum2["DRAW_BUFFER10"] = 34863] = "DRAW_BUFFER10";
  GLEnum2[GLEnum2["DRAW_BUFFER11"] = 34864] = "DRAW_BUFFER11";
  GLEnum2[GLEnum2["DRAW_BUFFER12"] = 34865] = "DRAW_BUFFER12";
  GLEnum2[GLEnum2["DRAW_BUFFER13"] = 34866] = "DRAW_BUFFER13";
  GLEnum2[GLEnum2["DRAW_BUFFER14"] = 34867] = "DRAW_BUFFER14";
  GLEnum2[GLEnum2["DRAW_BUFFER15"] = 34868] = "DRAW_BUFFER15";
  GLEnum2[GLEnum2["MAX_COLOR_ATTACHMENTS"] = 36063] = "MAX_COLOR_ATTACHMENTS";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT1"] = 36065] = "COLOR_ATTACHMENT1";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT2"] = 36066] = "COLOR_ATTACHMENT2";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT3"] = 36067] = "COLOR_ATTACHMENT3";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT4"] = 36068] = "COLOR_ATTACHMENT4";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT5"] = 36069] = "COLOR_ATTACHMENT5";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT6"] = 36070] = "COLOR_ATTACHMENT6";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT7"] = 36071] = "COLOR_ATTACHMENT7";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT8"] = 36072] = "COLOR_ATTACHMENT8";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT9"] = 36073] = "COLOR_ATTACHMENT9";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT10"] = 36074] = "COLOR_ATTACHMENT10";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT11"] = 36075] = "COLOR_ATTACHMENT11";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT12"] = 36076] = "COLOR_ATTACHMENT12";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT13"] = 36077] = "COLOR_ATTACHMENT13";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT14"] = 36078] = "COLOR_ATTACHMENT14";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT15"] = 36079] = "COLOR_ATTACHMENT15";
  GLEnum2[GLEnum2["SAMPLER_3D"] = 35679] = "SAMPLER_3D";
  GLEnum2[GLEnum2["SAMPLER_2D_SHADOW"] = 35682] = "SAMPLER_2D_SHADOW";
  GLEnum2[GLEnum2["SAMPLER_2D_ARRAY"] = 36289] = "SAMPLER_2D_ARRAY";
  GLEnum2[GLEnum2["SAMPLER_2D_ARRAY_SHADOW"] = 36292] = "SAMPLER_2D_ARRAY_SHADOW";
  GLEnum2[GLEnum2["SAMPLER_CUBE_SHADOW"] = 36293] = "SAMPLER_CUBE_SHADOW";
  GLEnum2[GLEnum2["INT_SAMPLER_2D"] = 36298] = "INT_SAMPLER_2D";
  GLEnum2[GLEnum2["INT_SAMPLER_3D"] = 36299] = "INT_SAMPLER_3D";
  GLEnum2[GLEnum2["INT_SAMPLER_CUBE"] = 36300] = "INT_SAMPLER_CUBE";
  GLEnum2[GLEnum2["INT_SAMPLER_2D_ARRAY"] = 36303] = "INT_SAMPLER_2D_ARRAY";
  GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_2D"] = 36306] = "UNSIGNED_INT_SAMPLER_2D";
  GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_3D"] = 36307] = "UNSIGNED_INT_SAMPLER_3D";
  GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_CUBE"] = 36308] = "UNSIGNED_INT_SAMPLER_CUBE";
  GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_2D_ARRAY"] = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY";
  GLEnum2[GLEnum2["MAX_SAMPLES"] = 36183] = "MAX_SAMPLES";
  GLEnum2[GLEnum2["SAMPLER_BINDING"] = 35097] = "SAMPLER_BINDING";
  GLEnum2[GLEnum2["PIXEL_PACK_BUFFER"] = 35051] = "PIXEL_PACK_BUFFER";
  GLEnum2[GLEnum2["PIXEL_UNPACK_BUFFER"] = 35052] = "PIXEL_UNPACK_BUFFER";
  GLEnum2[GLEnum2["PIXEL_PACK_BUFFER_BINDING"] = 35053] = "PIXEL_PACK_BUFFER_BINDING";
  GLEnum2[GLEnum2["PIXEL_UNPACK_BUFFER_BINDING"] = 35055] = "PIXEL_UNPACK_BUFFER_BINDING";
  GLEnum2[GLEnum2["COPY_READ_BUFFER"] = 36662] = "COPY_READ_BUFFER";
  GLEnum2[GLEnum2["COPY_WRITE_BUFFER"] = 36663] = "COPY_WRITE_BUFFER";
  GLEnum2[GLEnum2["COPY_READ_BUFFER_BINDING"] = 36662] = "COPY_READ_BUFFER_BINDING";
  GLEnum2[GLEnum2["COPY_WRITE_BUFFER_BINDING"] = 36663] = "COPY_WRITE_BUFFER_BINDING";
  GLEnum2[GLEnum2["FLOAT_MAT2x3"] = 35685] = "FLOAT_MAT2x3";
  GLEnum2[GLEnum2["FLOAT_MAT2x4"] = 35686] = "FLOAT_MAT2x4";
  GLEnum2[GLEnum2["FLOAT_MAT3x2"] = 35687] = "FLOAT_MAT3x2";
  GLEnum2[GLEnum2["FLOAT_MAT3x4"] = 35688] = "FLOAT_MAT3x4";
  GLEnum2[GLEnum2["FLOAT_MAT4x2"] = 35689] = "FLOAT_MAT4x2";
  GLEnum2[GLEnum2["FLOAT_MAT4x3"] = 35690] = "FLOAT_MAT4x3";
  GLEnum2[GLEnum2["UNSIGNED_INT_VEC2"] = 36294] = "UNSIGNED_INT_VEC2";
  GLEnum2[GLEnum2["UNSIGNED_INT_VEC3"] = 36295] = "UNSIGNED_INT_VEC3";
  GLEnum2[GLEnum2["UNSIGNED_INT_VEC4"] = 36296] = "UNSIGNED_INT_VEC4";
  GLEnum2[GLEnum2["UNSIGNED_NORMALIZED"] = 35863] = "UNSIGNED_NORMALIZED";
  GLEnum2[GLEnum2["SIGNED_NORMALIZED"] = 36764] = "SIGNED_NORMALIZED";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_INTEGER"] = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_DIVISOR"] = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_MODE"] = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE";
  GLEnum2[GLEnum2["MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"] = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_VARYINGS"] = 35971] = "TRANSFORM_FEEDBACK_VARYINGS";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_START"] = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_SIZE"] = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"] = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN";
  GLEnum2[GLEnum2["MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"] = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS";
  GLEnum2[GLEnum2["MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"] = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS";
  GLEnum2[GLEnum2["INTERLEAVED_ATTRIBS"] = 35980] = "INTERLEAVED_ATTRIBS";
  GLEnum2[GLEnum2["SEPARATE_ATTRIBS"] = 35981] = "SEPARATE_ATTRIBS";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER"] = 35982] = "TRANSFORM_FEEDBACK_BUFFER";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_BINDING"] = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK"] = 36386] = "TRANSFORM_FEEDBACK";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_PAUSED"] = 36387] = "TRANSFORM_FEEDBACK_PAUSED";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_ACTIVE"] = 36388] = "TRANSFORM_FEEDBACK_ACTIVE";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BINDING"] = 36389] = "TRANSFORM_FEEDBACK_BINDING";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"] = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_RED_SIZE"] = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"] = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"] = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"] = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"] = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"] = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE";
  GLEnum2[GLEnum2["FRAMEBUFFER_DEFAULT"] = 33304] = "FRAMEBUFFER_DEFAULT";
  GLEnum2[GLEnum2["DEPTH24_STENCIL8"] = 35056] = "DEPTH24_STENCIL8";
  GLEnum2[GLEnum2["DRAW_FRAMEBUFFER_BINDING"] = 36006] = "DRAW_FRAMEBUFFER_BINDING";
  GLEnum2[GLEnum2["READ_FRAMEBUFFER_BINDING"] = 36010] = "READ_FRAMEBUFFER_BINDING";
  GLEnum2[GLEnum2["RENDERBUFFER_SAMPLES"] = 36011] = "RENDERBUFFER_SAMPLES";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"] = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER";
  GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"] = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";
  GLEnum2[GLEnum2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
  GLEnum2[GLEnum2["UNIFORM_BUFFER_BINDING"] = 35368] = "UNIFORM_BUFFER_BINDING";
  GLEnum2[GLEnum2["UNIFORM_BUFFER_START"] = 35369] = "UNIFORM_BUFFER_START";
  GLEnum2[GLEnum2["UNIFORM_BUFFER_SIZE"] = 35370] = "UNIFORM_BUFFER_SIZE";
  GLEnum2[GLEnum2["MAX_VERTEX_UNIFORM_BLOCKS"] = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS";
  GLEnum2[GLEnum2["MAX_FRAGMENT_UNIFORM_BLOCKS"] = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS";
  GLEnum2[GLEnum2["MAX_COMBINED_UNIFORM_BLOCKS"] = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS";
  GLEnum2[GLEnum2["MAX_UNIFORM_BUFFER_BINDINGS"] = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS";
  GLEnum2[GLEnum2["MAX_UNIFORM_BLOCK_SIZE"] = 35376] = "MAX_UNIFORM_BLOCK_SIZE";
  GLEnum2[GLEnum2["MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"] = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS";
  GLEnum2[GLEnum2["MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"] = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS";
  GLEnum2[GLEnum2["UNIFORM_BUFFER_OFFSET_ALIGNMENT"] = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT";
  GLEnum2[GLEnum2["ACTIVE_UNIFORM_BLOCKS"] = 35382] = "ACTIVE_UNIFORM_BLOCKS";
  GLEnum2[GLEnum2["UNIFORM_TYPE"] = 35383] = "UNIFORM_TYPE";
  GLEnum2[GLEnum2["UNIFORM_SIZE"] = 35384] = "UNIFORM_SIZE";
  GLEnum2[GLEnum2["UNIFORM_BLOCK_INDEX"] = 35386] = "UNIFORM_BLOCK_INDEX";
  GLEnum2[GLEnum2["UNIFORM_OFFSET"] = 35387] = "UNIFORM_OFFSET";
  GLEnum2[GLEnum2["UNIFORM_ARRAY_STRIDE"] = 35388] = "UNIFORM_ARRAY_STRIDE";
  GLEnum2[GLEnum2["UNIFORM_MATRIX_STRIDE"] = 35389] = "UNIFORM_MATRIX_STRIDE";
  GLEnum2[GLEnum2["UNIFORM_IS_ROW_MAJOR"] = 35390] = "UNIFORM_IS_ROW_MAJOR";
  GLEnum2[GLEnum2["UNIFORM_BLOCK_BINDING"] = 35391] = "UNIFORM_BLOCK_BINDING";
  GLEnum2[GLEnum2["UNIFORM_BLOCK_DATA_SIZE"] = 35392] = "UNIFORM_BLOCK_DATA_SIZE";
  GLEnum2[GLEnum2["UNIFORM_BLOCK_ACTIVE_UNIFORMS"] = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS";
  GLEnum2[GLEnum2["UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"] = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES";
  GLEnum2[GLEnum2["UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"] = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER";
  GLEnum2[GLEnum2["UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"] = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER";
  GLEnum2[GLEnum2["OBJECT_TYPE"] = 37138] = "OBJECT_TYPE";
  GLEnum2[GLEnum2["SYNC_CONDITION"] = 37139] = "SYNC_CONDITION";
  GLEnum2[GLEnum2["SYNC_STATUS"] = 37140] = "SYNC_STATUS";
  GLEnum2[GLEnum2["SYNC_FLAGS"] = 37141] = "SYNC_FLAGS";
  GLEnum2[GLEnum2["SYNC_FENCE"] = 37142] = "SYNC_FENCE";
  GLEnum2[GLEnum2["SYNC_GPU_COMMANDS_COMPLETE"] = 37143] = "SYNC_GPU_COMMANDS_COMPLETE";
  GLEnum2[GLEnum2["UNSIGNALED"] = 37144] = "UNSIGNALED";
  GLEnum2[GLEnum2["SIGNALED"] = 37145] = "SIGNALED";
  GLEnum2[GLEnum2["ALREADY_SIGNALED"] = 37146] = "ALREADY_SIGNALED";
  GLEnum2[GLEnum2["TIMEOUT_EXPIRED"] = 37147] = "TIMEOUT_EXPIRED";
  GLEnum2[GLEnum2["CONDITION_SATISFIED"] = 37148] = "CONDITION_SATISFIED";
  GLEnum2[GLEnum2["WAIT_FAILED"] = 37149] = "WAIT_FAILED";
  GLEnum2[GLEnum2["SYNC_FLUSH_COMMANDS_BIT"] = 1] = "SYNC_FLUSH_COMMANDS_BIT";
  GLEnum2[GLEnum2["COLOR"] = 6144] = "COLOR";
  GLEnum2[GLEnum2["DEPTH"] = 6145] = "DEPTH";
  GLEnum2[GLEnum2["STENCIL"] = 6146] = "STENCIL";
  GLEnum2[GLEnum2["MIN"] = 32775] = "MIN";
  GLEnum2[GLEnum2["MAX"] = 32776] = "MAX";
  GLEnum2[GLEnum2["DEPTH_COMPONENT24"] = 33190] = "DEPTH_COMPONENT24";
  GLEnum2[GLEnum2["STREAM_READ"] = 35041] = "STREAM_READ";
  GLEnum2[GLEnum2["STREAM_COPY"] = 35042] = "STREAM_COPY";
  GLEnum2[GLEnum2["STATIC_READ"] = 35045] = "STATIC_READ";
  GLEnum2[GLEnum2["STATIC_COPY"] = 35046] = "STATIC_COPY";
  GLEnum2[GLEnum2["DYNAMIC_READ"] = 35049] = "DYNAMIC_READ";
  GLEnum2[GLEnum2["DYNAMIC_COPY"] = 35050] = "DYNAMIC_COPY";
  GLEnum2[GLEnum2["DEPTH_COMPONENT32F"] = 36012] = "DEPTH_COMPONENT32F";
  GLEnum2[GLEnum2["DEPTH32F_STENCIL8"] = 36013] = "DEPTH32F_STENCIL8";
  GLEnum2[GLEnum2["INVALID_INDEX"] = 4294967295] = "INVALID_INDEX";
  GLEnum2[GLEnum2["TIMEOUT_IGNORED"] = -1] = "TIMEOUT_IGNORED";
  GLEnum2[GLEnum2["MAX_CLIENT_WAIT_TIMEOUT_WEBGL"] = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL";
  GLEnum2[GLEnum2["UNMASKED_VENDOR_WEBGL"] = 37445] = "UNMASKED_VENDOR_WEBGL";
  GLEnum2[GLEnum2["UNMASKED_RENDERER_WEBGL"] = 37446] = "UNMASKED_RENDERER_WEBGL";
  GLEnum2[GLEnum2["MAX_TEXTURE_MAX_ANISOTROPY_EXT"] = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT";
  GLEnum2[GLEnum2["TEXTURE_MAX_ANISOTROPY_EXT"] = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT";
  GLEnum2[GLEnum2["R16_EXT"] = 33322] = "R16_EXT";
  GLEnum2[GLEnum2["RG16_EXT"] = 33324] = "RG16_EXT";
  GLEnum2[GLEnum2["RGB16_EXT"] = 32852] = "RGB16_EXT";
  GLEnum2[GLEnum2["RGBA16_EXT"] = 32859] = "RGBA16_EXT";
  GLEnum2[GLEnum2["R16_SNORM_EXT"] = 36760] = "R16_SNORM_EXT";
  GLEnum2[GLEnum2["RG16_SNORM_EXT"] = 36761] = "RG16_SNORM_EXT";
  GLEnum2[GLEnum2["RGB16_SNORM_EXT"] = 36762] = "RGB16_SNORM_EXT";
  GLEnum2[GLEnum2["RGBA16_SNORM_EXT"] = 36763] = "RGBA16_SNORM_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
  GLEnum2[GLEnum2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
  GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
  GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
  GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RED_RGTC1_EXT"] = 36283] = "COMPRESSED_RED_RGTC1_EXT";
  GLEnum2[GLEnum2["COMPRESSED_SIGNED_RED_RGTC1_EXT"] = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RED_GREEN_RGTC2_EXT"] = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT";
  GLEnum2[GLEnum2["COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT"] = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_BPTC_UNORM_EXT"] = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT";
  GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT"] = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT"] = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT"] = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT";
  GLEnum2[GLEnum2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
  GLEnum2[GLEnum2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
  GLEnum2[GLEnum2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
  GLEnum2[GLEnum2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
  GLEnum2[GLEnum2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
  GLEnum2[GLEnum2["COMPRESSED_RGBA8_ETC2_EAC"] = 37493] = "COMPRESSED_RGBA8_ETC2_EAC";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ETC2"] = 37494] = "COMPRESSED_SRGB8_ETC2";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
  GLEnum2[GLEnum2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GLEnum2[GLEnum2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
  GLEnum2[GLEnum2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
  GLEnum2[GLEnum2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
  GLEnum2[GLEnum2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
  GLEnum2[GLEnum2["QUERY_COUNTER_BITS_EXT"] = 34916] = "QUERY_COUNTER_BITS_EXT";
  GLEnum2[GLEnum2["CURRENT_QUERY_EXT"] = 34917] = "CURRENT_QUERY_EXT";
  GLEnum2[GLEnum2["QUERY_RESULT_EXT"] = 34918] = "QUERY_RESULT_EXT";
  GLEnum2[GLEnum2["QUERY_RESULT_AVAILABLE_EXT"] = 34919] = "QUERY_RESULT_AVAILABLE_EXT";
  GLEnum2[GLEnum2["TIME_ELAPSED_EXT"] = 35007] = "TIME_ELAPSED_EXT";
  GLEnum2[GLEnum2["TIMESTAMP_EXT"] = 36392] = "TIMESTAMP_EXT";
  GLEnum2[GLEnum2["GPU_DISJOINT_EXT"] = 36795] = "GPU_DISJOINT_EXT";
  GLEnum2[GLEnum2["COMPLETION_STATUS_KHR"] = 37297] = "COMPLETION_STATUS_KHR";
  GLEnum2[GLEnum2["DEPTH_CLAMP_EXT"] = 34383] = "DEPTH_CLAMP_EXT";
  GLEnum2[GLEnum2["FIRST_VERTEX_CONVENTION_WEBGL"] = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL";
  GLEnum2[GLEnum2["LAST_VERTEX_CONVENTION_WEBGL"] = 36430] = "LAST_VERTEX_CONVENTION_WEBGL";
  GLEnum2[GLEnum2["PROVOKING_VERTEX_WEBL"] = 36431] = "PROVOKING_VERTEX_WEBL";
  GLEnum2[GLEnum2["POLYGON_MODE_WEBGL"] = 2880] = "POLYGON_MODE_WEBGL";
  GLEnum2[GLEnum2["POLYGON_OFFSET_LINE_WEBGL"] = 10754] = "POLYGON_OFFSET_LINE_WEBGL";
  GLEnum2[GLEnum2["LINE_WEBGL"] = 6913] = "LINE_WEBGL";
  GLEnum2[GLEnum2["FILL_WEBGL"] = 6914] = "FILL_WEBGL";
  GLEnum2[GLEnum2["MAX_CLIP_DISTANCES_WEBGL"] = 3378] = "MAX_CLIP_DISTANCES_WEBGL";
  GLEnum2[GLEnum2["MAX_CULL_DISTANCES_WEBGL"] = 33529] = "MAX_CULL_DISTANCES_WEBGL";
  GLEnum2[GLEnum2["MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL"] = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE0_WEBGL"] = 12288] = "CLIP_DISTANCE0_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE1_WEBGL"] = 12289] = "CLIP_DISTANCE1_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE2_WEBGL"] = 12290] = "CLIP_DISTANCE2_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE3_WEBGL"] = 12291] = "CLIP_DISTANCE3_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE4_WEBGL"] = 12292] = "CLIP_DISTANCE4_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE5_WEBGL"] = 12293] = "CLIP_DISTANCE5_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE6_WEBGL"] = 12294] = "CLIP_DISTANCE6_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE7_WEBGL"] = 12295] = "CLIP_DISTANCE7_WEBGL";
  GLEnum2[GLEnum2["POLYGON_OFFSET_CLAMP_EXT"] = 36379] = "POLYGON_OFFSET_CLAMP_EXT";
  GLEnum2[GLEnum2["LOWER_LEFT_EXT"] = 36001] = "LOWER_LEFT_EXT";
  GLEnum2[GLEnum2["UPPER_LEFT_EXT"] = 36002] = "UPPER_LEFT_EXT";
  GLEnum2[GLEnum2["NEGATIVE_ONE_TO_ONE_EXT"] = 37726] = "NEGATIVE_ONE_TO_ONE_EXT";
  GLEnum2[GLEnum2["ZERO_TO_ONE_EXT"] = 37727] = "ZERO_TO_ONE_EXT";
  GLEnum2[GLEnum2["CLIP_ORIGIN_EXT"] = 37724] = "CLIP_ORIGIN_EXT";
  GLEnum2[GLEnum2["CLIP_DEPTH_MODE_EXT"] = 37725] = "CLIP_DEPTH_MODE_EXT";
  GLEnum2[GLEnum2["SRC1_COLOR_WEBGL"] = 35065] = "SRC1_COLOR_WEBGL";
  GLEnum2[GLEnum2["SRC1_ALPHA_WEBGL"] = 34185] = "SRC1_ALPHA_WEBGL";
  GLEnum2[GLEnum2["ONE_MINUS_SRC1_COLOR_WEBGL"] = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL";
  GLEnum2[GLEnum2["ONE_MINUS_SRC1_ALPHA_WEBGL"] = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL";
  GLEnum2[GLEnum2["MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL"] = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL";
  GLEnum2[GLEnum2["MIRROR_CLAMP_TO_EDGE_EXT"] = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT";
})(GLEnum || (GLEnum = {}));

// node_modules/@luma.gl/webgl/dist/context/parameters/webgl-parameter-tables.js
var GL_PARAMETER_DEFAULTS = {
  [3042]: false,
  [32773]: new Float32Array([0, 0, 0, 0]),
  [32777]: 32774,
  [34877]: 32774,
  [32969]: 1,
  [32968]: 0,
  [32971]: 1,
  [32970]: 0,
  [3106]: new Float32Array([0, 0, 0, 0]),
  // TBD
  [3107]: [true, true, true, true],
  [2884]: false,
  [2885]: 1029,
  [2929]: false,
  [2931]: 1,
  [2932]: 513,
  [2928]: new Float32Array([0, 1]),
  // TBD
  [2930]: true,
  [3024]: true,
  [35725]: null,
  // FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  [36006]: null,
  [36007]: null,
  [34229]: null,
  [34964]: null,
  [2886]: 2305,
  [33170]: 4352,
  [2849]: 1,
  [32823]: false,
  [32824]: 0,
  [10752]: 0,
  [32926]: false,
  [32928]: false,
  [32938]: 1,
  [32939]: false,
  [3089]: false,
  // Note: Dynamic value. If scissor test enabled we expect users to set correct scissor box
  [3088]: new Int32Array([0, 0, 1024, 1024]),
  [2960]: false,
  [2961]: 0,
  [2968]: 4294967295,
  [36005]: 4294967295,
  [2962]: 519,
  [2967]: 0,
  [2963]: 4294967295,
  [34816]: 519,
  [36003]: 0,
  [36004]: 4294967295,
  [2964]: 7680,
  [2965]: 7680,
  [2966]: 7680,
  [34817]: 7680,
  [34818]: 7680,
  [34819]: 7680,
  // Dynamic value: We use [0, 0, 1024, 1024] as default, but usually this is updated in each frame.
  [2978]: [0, 0, 1024, 1024],
  [36389]: null,
  [36662]: null,
  [36663]: null,
  [35053]: null,
  [35055]: null,
  [35723]: 4352,
  [36010]: null,
  [35977]: false,
  [3333]: 4,
  [3317]: 4,
  [37440]: false,
  [37441]: false,
  [37443]: 37444,
  [3330]: 0,
  [3332]: 0,
  [3331]: 0,
  [3314]: 0,
  [32878]: 0,
  [3316]: 0,
  [3315]: 0,
  [32877]: 0
};
var enable = (gl, value, key) => value ? gl.enable(key) : gl.disable(key);
var hint = (gl, value, key) => gl.hint(key, value);
var pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);
var bindFramebuffer = (gl, value, key) => {
  const target2 = key === 36006 ? 36009 : 36008;
  return gl.bindFramebuffer(target2, value);
};
var bindBuffer = (gl, value, key) => {
  const bindingMap = {
    [34964]: 34962,
    [36662]: 36662,
    [36663]: 36663,
    [35053]: 35051,
    [35055]: 35052
  };
  const glTarget = bindingMap[key];
  gl.bindBuffer(glTarget, value);
};
function isArray(array) {
  return Array.isArray(array) || ArrayBuffer.isView(array) && !(array instanceof DataView);
}
var GL_PARAMETER_SETTERS = {
  [3042]: enable,
  [32773]: (gl, value) => gl.blendColor(...value),
  [32777]: "blendEquation",
  [34877]: "blendEquation",
  [32969]: "blendFunc",
  [32968]: "blendFunc",
  [32971]: "blendFunc",
  [32970]: "blendFunc",
  [3106]: (gl, value) => gl.clearColor(...value),
  [3107]: (gl, value) => gl.colorMask(...value),
  [2884]: enable,
  [2885]: (gl, value) => gl.cullFace(value),
  [2929]: enable,
  [2931]: (gl, value) => gl.clearDepth(value),
  [2932]: (gl, value) => gl.depthFunc(value),
  [2928]: (gl, value) => gl.depthRange(...value),
  [2930]: (gl, value) => gl.depthMask(value),
  [3024]: enable,
  [35723]: hint,
  [35725]: (gl, value) => gl.useProgram(value),
  [36007]: (gl, value) => gl.bindRenderbuffer(36161, value),
  [36389]: (gl, value) => {
    var _a;
    return (_a = gl.bindTransformFeedback) == null ? void 0 : _a.call(gl, 36386, value);
  },
  [34229]: (gl, value) => gl.bindVertexArray(value),
  // NOTE: FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  [36006]: bindFramebuffer,
  [36010]: bindFramebuffer,
  // Buffers
  [34964]: bindBuffer,
  [36662]: bindBuffer,
  [36663]: bindBuffer,
  [35053]: bindBuffer,
  [35055]: bindBuffer,
  [2886]: (gl, value) => gl.frontFace(value),
  [33170]: hint,
  [2849]: (gl, value) => gl.lineWidth(value),
  [32823]: enable,
  [32824]: "polygonOffset",
  [10752]: "polygonOffset",
  [35977]: enable,
  [32926]: enable,
  [32928]: enable,
  [32938]: "sampleCoverage",
  [32939]: "sampleCoverage",
  [3089]: enable,
  [3088]: (gl, value) => gl.scissor(...value),
  [2960]: enable,
  [2961]: (gl, value) => gl.clearStencil(value),
  [2968]: (gl, value) => gl.stencilMaskSeparate(1028, value),
  [36005]: (gl, value) => gl.stencilMaskSeparate(1029, value),
  [2962]: "stencilFuncFront",
  [2967]: "stencilFuncFront",
  [2963]: "stencilFuncFront",
  [34816]: "stencilFuncBack",
  [36003]: "stencilFuncBack",
  [36004]: "stencilFuncBack",
  [2964]: "stencilOpFront",
  [2965]: "stencilOpFront",
  [2966]: "stencilOpFront",
  [34817]: "stencilOpBack",
  [34818]: "stencilOpBack",
  [34819]: "stencilOpBack",
  [2978]: (gl, value) => gl.viewport(...value),
  // WEBGL2 EXTENSIONS
  // EXT_depth_clamp https://registry.khronos.org/webgl/extensions/EXT_depth_clamp/
  [34383]: enable,
  // WEBGL_provoking_vertex https://registry.khronos.org/webgl/extensions/WEBGL_provoking_vertex/
  // [GL.PROVOKING_VERTEX_WEBL]: TODO - extension function needed
  // WEBGL_polygon_mode https://registry.khronos.org/webgl/extensions/WEBGL_polygon_mode/
  // POLYGON_MODE_WEBGL  TODO - extension function needed
  [10754]: enable,
  // WEBGL_clip_cull_distance https://registry.khronos.org/webgl/extensions/WEBGL_clip_cull_distance/
  [12288]: enable,
  [12289]: enable,
  [12290]: enable,
  [12291]: enable,
  [12292]: enable,
  [12293]: enable,
  [12294]: enable,
  [12295]: enable,
  // PIXEL PACK/UNPACK MODES
  [3333]: pixelStorei,
  [3317]: pixelStorei,
  [37440]: pixelStorei,
  [37441]: pixelStorei,
  [37443]: pixelStorei,
  [3330]: pixelStorei,
  [3332]: pixelStorei,
  [3331]: pixelStorei,
  [3314]: pixelStorei,
  [32878]: pixelStorei,
  [3316]: pixelStorei,
  [3315]: pixelStorei,
  [32877]: pixelStorei,
  // Function-style setters
  framebuffer: (gl, framebuffer) => {
    const handle = framebuffer && "handle" in framebuffer ? framebuffer.handle : framebuffer;
    return gl.bindFramebuffer(36160, handle);
  },
  blend: (gl, value) => value ? gl.enable(3042) : gl.disable(3042),
  blendColor: (gl, value) => gl.blendColor(...value),
  blendEquation: (gl, args) => {
    const separateModes = typeof args === "number" ? [args, args] : args;
    gl.blendEquationSeparate(...separateModes);
  },
  blendFunc: (gl, args) => {
    const separateFuncs = (args == null ? void 0 : args.length) === 2 ? [...args, ...args] : args;
    gl.blendFuncSeparate(...separateFuncs);
  },
  clearColor: (gl, value) => gl.clearColor(...value),
  clearDepth: (gl, value) => gl.clearDepth(value),
  clearStencil: (gl, value) => gl.clearStencil(value),
  colorMask: (gl, value) => gl.colorMask(...value),
  cull: (gl, value) => value ? gl.enable(2884) : gl.disable(2884),
  cullFace: (gl, value) => gl.cullFace(value),
  depthTest: (gl, value) => value ? gl.enable(2929) : gl.disable(2929),
  depthFunc: (gl, value) => gl.depthFunc(value),
  depthMask: (gl, value) => gl.depthMask(value),
  depthRange: (gl, value) => gl.depthRange(...value),
  dither: (gl, value) => value ? gl.enable(3024) : gl.disable(3024),
  derivativeHint: (gl, value) => {
    gl.hint(35723, value);
  },
  frontFace: (gl, value) => gl.frontFace(value),
  mipmapHint: (gl, value) => gl.hint(33170, value),
  lineWidth: (gl, value) => gl.lineWidth(value),
  polygonOffsetFill: (gl, value) => value ? gl.enable(32823) : gl.disable(32823),
  polygonOffset: (gl, value) => gl.polygonOffset(...value),
  sampleCoverage: (gl, value) => gl.sampleCoverage(value[0], value[1] || false),
  scissorTest: (gl, value) => value ? gl.enable(3089) : gl.disable(3089),
  scissor: (gl, value) => gl.scissor(...value),
  stencilTest: (gl, value) => value ? gl.enable(2960) : gl.disable(2960),
  stencilMask: (gl, value) => {
    value = isArray(value) ? value : [value, value];
    const [mask, backMask] = value;
    gl.stencilMaskSeparate(1028, mask);
    gl.stencilMaskSeparate(1029, backMask);
  },
  stencilFunc: (gl, args) => {
    args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
    const [func, ref, mask, backFunc, backRef, backMask] = args;
    gl.stencilFuncSeparate(1028, func, ref, mask);
    gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
  },
  stencilOp: (gl, args) => {
    args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
    const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
    gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
    gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
  },
  viewport: (gl, value) => gl.viewport(...value)
};
function getValue(glEnum, values, cache2) {
  return values[glEnum] !== void 0 ? values[glEnum] : cache2[glEnum];
}
var GL_COMPOSITE_PARAMETER_SETTERS = {
  blendEquation: (gl, values, cache2) => gl.blendEquationSeparate(getValue(32777, values, cache2), getValue(34877, values, cache2)),
  blendFunc: (gl, values, cache2) => gl.blendFuncSeparate(getValue(32969, values, cache2), getValue(32968, values, cache2), getValue(32971, values, cache2), getValue(32970, values, cache2)),
  polygonOffset: (gl, values, cache2) => gl.polygonOffset(getValue(32824, values, cache2), getValue(10752, values, cache2)),
  sampleCoverage: (gl, values, cache2) => gl.sampleCoverage(getValue(32938, values, cache2), getValue(32939, values, cache2)),
  stencilFuncFront: (gl, values, cache2) => gl.stencilFuncSeparate(1028, getValue(2962, values, cache2), getValue(2967, values, cache2), getValue(2963, values, cache2)),
  stencilFuncBack: (gl, values, cache2) => gl.stencilFuncSeparate(1029, getValue(34816, values, cache2), getValue(36003, values, cache2), getValue(36004, values, cache2)),
  stencilOpFront: (gl, values, cache2) => gl.stencilOpSeparate(1028, getValue(2964, values, cache2), getValue(2965, values, cache2), getValue(2966, values, cache2)),
  stencilOpBack: (gl, values, cache2) => gl.stencilOpSeparate(1029, getValue(34817, values, cache2), getValue(34818, values, cache2), getValue(34819, values, cache2))
};
var GL_HOOKED_SETTERS = {
  // GENERIC SETTERS
  enable: (update, capability) => update({
    [capability]: true
  }),
  disable: (update, capability) => update({
    [capability]: false
  }),
  pixelStorei: (update, pname, value) => update({
    [pname]: value
  }),
  hint: (update, pname, value) => update({
    [pname]: value
  }),
  // SPECIFIC SETTERS
  useProgram: (update, value) => update({
    [35725]: value
  }),
  bindRenderbuffer: (update, target2, value) => update({
    [36007]: value
  }),
  bindTransformFeedback: (update, target2, value) => update({
    [36389]: value
  }),
  bindVertexArray: (update, value) => update({
    [34229]: value
  }),
  bindFramebuffer: (update, target2, framebuffer) => {
    switch (target2) {
      case 36160:
        return update({
          [36006]: framebuffer,
          [36010]: framebuffer
        });
      case 36009:
        return update({ [36006]: framebuffer });
      case 36008:
        return update({ [36010]: framebuffer });
      default:
        return null;
    }
  },
  bindBuffer: (update, target2, buffer) => {
    const pname = {
      [34962]: [34964],
      [36662]: [36662],
      [36663]: [36663],
      [35051]: [35053],
      [35052]: [35055]
    }[target2];
    if (pname) {
      return update({ [pname]: buffer });
    }
    return { valueChanged: true };
  },
  blendColor: (update, r, g, b, a) => update({
    [32773]: new Float32Array([r, g, b, a])
  }),
  blendEquation: (update, mode) => update({
    [32777]: mode,
    [34877]: mode
  }),
  blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
    [32777]: modeRGB,
    [34877]: modeAlpha
  }),
  blendFunc: (update, src, dst) => update({
    [32969]: src,
    [32968]: dst,
    [32971]: src,
    [32970]: dst
  }),
  blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
    [32969]: srcRGB,
    [32968]: dstRGB,
    [32971]: srcAlpha,
    [32970]: dstAlpha
  }),
  clearColor: (update, r, g, b, a) => update({
    [3106]: new Float32Array([r, g, b, a])
  }),
  clearDepth: (update, depth) => update({
    [2931]: depth
  }),
  clearStencil: (update, s) => update({
    [2961]: s
  }),
  colorMask: (update, r, g, b, a) => update({
    [3107]: [r, g, b, a]
  }),
  cullFace: (update, mode) => update({
    [2885]: mode
  }),
  depthFunc: (update, func) => update({
    [2932]: func
  }),
  depthRange: (update, zNear, zFar) => update({
    [2928]: new Float32Array([zNear, zFar])
  }),
  depthMask: (update, mask) => update({
    [2930]: mask
  }),
  frontFace: (update, face) => update({
    [2886]: face
  }),
  lineWidth: (update, width) => update({
    [2849]: width
  }),
  polygonOffset: (update, factor, units) => update({
    [32824]: factor,
    [10752]: units
  }),
  sampleCoverage: (update, value, invert) => update({
    [32938]: value,
    [32939]: invert
  }),
  scissor: (update, x, y, width, height) => update({
    [3088]: new Int32Array([x, y, width, height])
  }),
  stencilMask: (update, mask) => update({
    [2968]: mask,
    [36005]: mask
  }),
  stencilMaskSeparate: (update, face, mask) => update({
    [face === 1028 ? 2968 : 36005]: mask
  }),
  stencilFunc: (update, func, ref, mask) => update({
    [2962]: func,
    [2967]: ref,
    [2963]: mask,
    [34816]: func,
    [36003]: ref,
    [36004]: mask
  }),
  stencilFuncSeparate: (update, face, func, ref, mask) => update({
    [face === 1028 ? 2962 : 34816]: func,
    [face === 1028 ? 2967 : 36003]: ref,
    [face === 1028 ? 2963 : 36004]: mask
  }),
  stencilOp: (update, fail, zfail, zpass) => update({
    [2964]: fail,
    [2965]: zfail,
    [2966]: zpass,
    [34817]: fail,
    [34818]: zfail,
    [34819]: zpass
  }),
  stencilOpSeparate: (update, face, fail, zfail, zpass) => update({
    [face === 1028 ? 2964 : 34817]: fail,
    [face === 1028 ? 2965 : 34818]: zfail,
    [face === 1028 ? 2966 : 34819]: zpass
  }),
  viewport: (update, x, y, width, height) => update({
    [2978]: [x, y, width, height]
  })
};
var isEnabled = (gl, key) => gl.isEnabled(key);
var GL_PARAMETER_GETTERS = {
  [3042]: isEnabled,
  [2884]: isEnabled,
  [2929]: isEnabled,
  [3024]: isEnabled,
  [32823]: isEnabled,
  [32926]: isEnabled,
  [32928]: isEnabled,
  [3089]: isEnabled,
  [2960]: isEnabled,
  [35977]: isEnabled
};
var NON_CACHE_PARAMETERS = /* @__PURE__ */ new Set([
  34016,
  36388,
  36387,
  35983,
  35368,
  34965,
  35739,
  35738,
  3074,
  34853,
  34854,
  34855,
  34856,
  34857,
  34858,
  34859,
  34860,
  34861,
  34862,
  34863,
  34864,
  34865,
  34866,
  34867,
  34868,
  35097,
  32873,
  35869,
  32874,
  34068
]);

// node_modules/@luma.gl/webgl/dist/context/parameters/unified-parameter-api.js
function setGLParameters(gl, parameters) {
  if (isObjectEmpty(parameters)) {
    return;
  }
  const compositeSetters = {};
  for (const key in parameters) {
    const glConstant = Number(key);
    const setter = GL_PARAMETER_SETTERS[key];
    if (setter) {
      if (typeof setter === "string") {
        compositeSetters[setter] = true;
      } else {
        setter(gl, parameters[key], glConstant);
      }
    }
  }
  const cache2 = gl.state && gl.state.cache;
  if (cache2) {
    for (const key in compositeSetters) {
      const compositeSetter = GL_COMPOSITE_PARAMETER_SETTERS[key];
      compositeSetter(gl, parameters, cache2);
    }
  }
}
function getGLParameters(gl, parameters = GL_PARAMETER_DEFAULTS) {
  if (typeof parameters === "number") {
    const key = parameters;
    const getter = GL_PARAMETER_GETTERS[key];
    return getter ? getter(gl, key) : gl.getParameter(key);
  }
  const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
  const state = {};
  for (const key of parameterKeys) {
    const getter = GL_PARAMETER_GETTERS[key];
    state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
  }
  return state;
}
function resetGLParameters(gl) {
  setGLParameters(gl, GL_PARAMETER_DEFAULTS);
}
function isObjectEmpty(object) {
  for (const key in object) {
    return false;
  }
  return true;
}

// node_modules/@luma.gl/webgl/dist/context/state-tracker/deep-array-equal.js
function deepArrayEqual(x, y) {
  if (x === y) {
    return true;
  }
  if (isArray2(x) && isArray2(y) && x.length === y.length) {
    for (let i = 0; i < x.length; ++i) {
      if (x[i] !== y[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function isArray2(x) {
  return Array.isArray(x) || ArrayBuffer.isView(x);
}

// node_modules/@luma.gl/webgl/dist/context/state-tracker/webgl-state-tracker.js
var WebGLStateTracker = class {
  constructor(gl, props) {
    __publicField(this, "gl");
    __publicField(this, "program", null);
    __publicField(this, "stateStack", []);
    __publicField(this, "enable", true);
    __publicField(this, "cache", null);
    __publicField(this, "log");
    __publicField(this, "initialized", false);
    this.gl = gl;
    this.log = (props == null ? void 0 : props.log) || (() => {
    });
    this._updateCache = this._updateCache.bind(this);
    Object.seal(this);
  }
  static get(gl) {
    return gl.state;
  }
  push(values = {}) {
    this.stateStack.push({});
  }
  pop() {
    const oldValues = this.stateStack[this.stateStack.length - 1];
    setGLParameters(this.gl, oldValues);
    this.stateStack.pop();
  }
  /**
   * Initialize WebGL state caching on a context
   * can be called multiple times to enable/disable
   *
   * @note After calling this function, context state will be cached
   * .push() and .pop() will be available for saving,
   * temporarily modifying, and then restoring state.
   */
  trackState(gl, options) {
    this.cache = (options == null ? void 0 : options.copyState) ? getGLParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);
    if (this.initialized) {
      throw new Error("WebGLStateTracker");
    }
    this.initialized = true;
    this.gl.state = this;
    installProgramSpy(gl);
    for (const key in GL_HOOKED_SETTERS) {
      const setter = GL_HOOKED_SETTERS[key];
      installSetterSpy(gl, key, setter);
    }
    installGetterOverride(gl, "getParameter");
    installGetterOverride(gl, "isEnabled");
  }
  /**
  // interceptor for context set functions - update our cache and our stack
  // values (Object) - the key values for this setter
   * @param values
   * @returns
   */
  _updateCache(values) {
    let valueChanged = false;
    let oldValue;
    const oldValues = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
    for (const key in values) {
      const value = values[key];
      const cached = this.cache[key];
      if (!deepArrayEqual(value, cached)) {
        valueChanged = true;
        oldValue = cached;
        if (oldValues && !(key in oldValues)) {
          oldValues[key] = cached;
        }
        this.cache[key] = value;
      }
    }
    return { valueChanged, oldValue };
  }
};
function installGetterOverride(gl, functionName) {
  const originalGetterFunc = gl[functionName].bind(gl);
  gl[functionName] = function get(pname) {
    if (pname === void 0 || NON_CACHE_PARAMETERS.has(pname)) {
      return originalGetterFunc(pname);
    }
    const glState = WebGLStateTracker.get(gl);
    if (!(pname in glState.cache)) {
      glState.cache[pname] = originalGetterFunc(pname);
    }
    return glState.enable ? (
      // Call the getter the params so that it can e.g. serve from a cache
      glState.cache[pname]
    ) : (
      // Optionally call the original function to do a "hard" query from the WebGL2RenderingContext
      originalGetterFunc(pname)
    );
  };
  Object.defineProperty(gl[functionName], "name", {
    value: `${functionName}-from-cache`,
    configurable: false
  });
}
function installSetterSpy(gl, functionName, setter) {
  if (!gl[functionName]) {
    return;
  }
  const originalSetterFunc = gl[functionName].bind(gl);
  gl[functionName] = function set(...params) {
    const glState = WebGLStateTracker.get(gl);
    const { valueChanged, oldValue } = setter(glState._updateCache, ...params);
    if (valueChanged) {
      originalSetterFunc(...params);
    }
    return oldValue;
  };
  Object.defineProperty(gl[functionName], "name", {
    value: `${functionName}-to-cache`,
    configurable: false
  });
}
function installProgramSpy(gl) {
  const originalUseProgram = gl.useProgram.bind(gl);
  gl.useProgram = function useProgramLuma(handle) {
    const glState = WebGLStateTracker.get(gl);
    if (glState.program !== handle) {
      originalUseProgram(handle);
      glState.program = handle;
    }
  };
}

// node_modules/@luma.gl/webgl/dist/context/helpers/create-browser-context.js
function createBrowserContext(canvas, props, webglContextAttributes) {
  let errorMessage = "";
  const webglProps = {
    preserveDrawingBuffer: true,
    // failIfMajorPerformanceCaveat: true,
    ...webglContextAttributes
  };
  let gl = null;
  gl || (gl = canvas.getContext("webgl2", webglProps));
  if (webglProps.failIfMajorPerformanceCaveat) {
    errorMessage || (errorMessage = "Only software GPU is available. Set `failIfMajorPerformanceCaveat: false` to allow.");
  }
  if (!gl && !webglContextAttributes.failIfMajorPerformanceCaveat) {
    webglProps.failIfMajorPerformanceCaveat = false;
    gl = canvas.getContext("webgl2", webglProps);
    gl.luma || (gl.luma = {});
    gl.luma.softwareRenderer = true;
  }
  if (!gl) {
    gl = canvas.getContext("webgl", {});
    if (gl) {
      gl = null;
      errorMessage || (errorMessage = "Your browser only supports WebGL1");
    }
  }
  if (!gl) {
    errorMessage || (errorMessage = "Your browser does not support WebGL");
    throw new Error(`Failed to create WebGL context: ${errorMessage}`);
  }
  const { onContextLost, onContextRestored } = props;
  canvas.addEventListener("webglcontextlost", (event) => onContextLost(event), false);
  canvas.addEventListener("webglcontextrestored", (event) => onContextRestored(event), false);
  gl.luma || (gl.luma = {});
  return gl;
}

// node_modules/@luma.gl/webgl/dist/context/helpers/webgl-extensions.js
function getWebGLExtension(gl, name2, extensions) {
  if (extensions[name2] === void 0) {
    extensions[name2] = gl.getExtension(name2) || null;
  }
  return extensions[name2];
}

// node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-info.js
function getDeviceInfo(gl, extensions) {
  const vendorMasked = gl.getParameter(7936);
  const rendererMasked = gl.getParameter(7937);
  getWebGLExtension(gl, "WEBGL_debug_renderer_info", extensions);
  const ext = extensions.WEBGL_debug_renderer_info;
  const vendorUnmasked = gl.getParameter(ext ? ext.UNMASKED_VENDOR_WEBGL : 7936);
  const rendererUnmasked = gl.getParameter(ext ? ext.UNMASKED_RENDERER_WEBGL : 7937);
  const vendor = vendorUnmasked || vendorMasked;
  const renderer = rendererUnmasked || rendererMasked;
  const version = gl.getParameter(7938);
  const gpu = identifyGPUVendor(vendor, renderer);
  const gpuBackend = identifyGPUBackend(vendor, renderer);
  const gpuType = identifyGPUType(vendor, renderer);
  const shadingLanguage = "glsl";
  const shadingLanguageVersion = 300;
  return {
    type: "webgl",
    gpu,
    gpuType,
    gpuBackend,
    vendor,
    renderer,
    version,
    shadingLanguage,
    shadingLanguageVersion
  };
}
function identifyGPUVendor(vendor, renderer) {
  if (/NVIDIA/i.exec(vendor) || /NVIDIA/i.exec(renderer)) {
    return "nvidia";
  }
  if (/INTEL/i.exec(vendor) || /INTEL/i.exec(renderer)) {
    return "intel";
  }
  if (/Apple/i.exec(vendor) || /Apple/i.exec(renderer)) {
    return "apple";
  }
  if (/AMD/i.exec(vendor) || /AMD/i.exec(renderer) || /ATI/i.exec(vendor) || /ATI/i.exec(renderer)) {
    return "amd";
  }
  if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {
    return "software";
  }
  return "unknown";
}
function identifyGPUBackend(vendor, renderer) {
  if (/Metal/i.exec(vendor) || /Metal/i.exec(renderer)) {
    return "metal";
  }
  if (/ANGLE/i.exec(vendor) || /ANGLE/i.exec(renderer)) {
    return "opengl";
  }
  return "unknown";
}
function identifyGPUType(vendor, renderer) {
  if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {
    return "cpu";
  }
  const gpuVendor = identifyGPUVendor(vendor, renderer);
  switch (gpuVendor) {
    case "intel":
      return "integrated";
    case "software":
      return "cpu";
    case "unknown":
      return "unknown";
    default:
      return "discrete";
  }
}

// node_modules/@luma.gl/webgl/dist/adapter/converters/webgl-vertex-formats.js
function getGLFromVertexType(dataType) {
  switch (dataType) {
    case "uint8":
      return 5121;
    case "sint8":
      return 5120;
    case "unorm8":
      return 5121;
    case "snorm8":
      return 5120;
    case "uint16":
      return 5123;
    case "sint16":
      return 5122;
    case "unorm16":
      return 5123;
    case "snorm16":
      return 5122;
    case "uint32":
      return 5125;
    case "sint32":
      return 5124;
    case "float16":
      return 5131;
    case "float32":
      return 5126;
  }
  throw new Error(String(dataType));
}

// node_modules/@luma.gl/webgl/dist/adapter/converters/webgl-texture-table.js
var X_S3TC = "WEBGL_compressed_texture_s3tc";
var X_S3TC_SRGB = "WEBGL_compressed_texture_s3tc_srgb";
var X_RGTC = "EXT_texture_compression_rgtc";
var X_BPTC = "EXT_texture_compression_bptc";
var X_ETC2 = "WEBGL_compressed_texture_etc";
var X_ASTC = "WEBGL_compressed_texture_astc";
var X_ETC1 = "WEBGL_compressed_texture_etc1";
var X_PVRTC = "WEBGL_compressed_texture_pvrtc";
var X_ATC = "WEBGL_compressed_texture_atc";
var EXT_texture_norm16 = "EXT_texture_norm16";
var EXT_render_snorm = "EXT_render_snorm";
var EXT_color_buffer_float = "EXT_color_buffer_float";
var TEXTURE_FEATURES = {
  "float32-renderable-webgl": ["EXT_color_buffer_float"],
  "float16-renderable-webgl": ["EXT_color_buffer_half_float"],
  "rgb9e5ufloat-renderable-webgl": ["WEBGL_render_shared_exponent"],
  "snorm8-renderable-webgl": [EXT_render_snorm],
  "norm16-renderable-webgl": [EXT_texture_norm16],
  "snorm16-renderable-webgl": [EXT_texture_norm16, EXT_render_snorm],
  "float32-filterable": ["OES_texture_float_linear"],
  "float16-filterable-webgl": ["OES_texture_half_float_linear"],
  "texture-filterable-anisotropic-webgl": ["EXT_texture_filter_anisotropic"],
  "texture-blend-float-webgl": ["EXT_float_blend"],
  "texture-compression-bc": [X_S3TC, X_S3TC_SRGB, X_RGTC, X_BPTC],
  // 'texture-compression-bc3-srgb-webgl': [X_S3TC_SRGB],
  // 'texture-compression-bc3-webgl': [X_S3TC],
  "texture-compression-bc5-webgl": [X_RGTC],
  "texture-compression-bc7-webgl": [X_BPTC],
  "texture-compression-etc2": [X_ETC2],
  "texture-compression-astc": [X_ASTC],
  "texture-compression-etc1-webgl": [X_ETC1],
  "texture-compression-pvrtc-webgl": [X_PVRTC],
  "texture-compression-atc-webgl": [X_ATC]
};
function isTextureFeature(feature) {
  return feature in TEXTURE_FEATURES;
}
function checkTextureFeature(gl, feature, extensions) {
  const textureExtensions = TEXTURE_FEATURES[feature] || [];
  return textureExtensions.every((extension) => getWebGLExtension(gl, extension, extensions));
}
var WEBGL_TEXTURE_FORMATS = {
  // 8-bit formats
  "r8unorm": { gl: 33321, rb: true },
  "r8snorm": { gl: 36756 },
  "r8uint": { gl: 33330, rb: true },
  "r8sint": { gl: 33329, rb: true },
  // 16-bit formats
  "rg8unorm": { gl: 33323, rb: true },
  "rg8snorm": { gl: 36757 },
  "rg8uint": { gl: 33336, rb: true },
  "rg8sint": { gl: 33335, rb: true },
  "r16uint": { gl: 33332, rb: true },
  "r16sint": { gl: 33331, rb: true },
  "r16float": { gl: 33325, rb: true },
  "r16unorm": { gl: 33322, rb: true },
  "r16snorm": { gl: 36760 },
  // Packed 16-bit formats
  "rgba4unorm-webgl": { gl: 32854, rb: true },
  "rgb565unorm-webgl": { gl: 36194, rb: true },
  "rgb5a1unorm-webgl": { gl: 32855, rb: true },
  // 24-bit formats
  "rgb8unorm-webgl": { gl: 32849 },
  "rgb8snorm-webgl": { gl: 36758 },
  // 32-bit formats
  "rgba8unorm": { gl: 32856 },
  "rgba8unorm-srgb": { gl: 35907 },
  "rgba8snorm": { gl: 36759 },
  "rgba8uint": { gl: 36220 },
  "rgba8sint": { gl: 36238 },
  // reverse colors, webgpu only
  "bgra8unorm": {},
  "bgra8unorm-srgb": {},
  "rg16uint": { gl: 33338 },
  "rg16sint": { gl: 33337 },
  "rg16float": { gl: 33327, rb: true },
  "rg16unorm": { gl: 33324 },
  "rg16snorm": { gl: 36761 },
  "r32uint": { gl: 33334, rb: true },
  "r32sint": { gl: 33333, rb: true },
  "r32float": { gl: 33326 },
  // Packed 32-bit formats
  "rgb9e5ufloat": { gl: 35901 },
  // , filter: true},
  "rg11b10ufloat": { gl: 35898, rb: true },
  "rgb10a2unorm": { gl: 32857, rb: true },
  "rgb10a2uint": { gl: 36975, rb: true },
  // 48-bit formats
  "rgb16unorm-webgl": { gl: 32852 },
  // rgb not renderable
  "rgb16snorm-webgl": { gl: 36762 },
  // rgb not renderable
  // 64-bit formats
  "rg32uint": { gl: 33340, rb: true },
  "rg32sint": { gl: 33339, rb: true },
  "rg32float": { gl: 33328, rb: true },
  "rgba16uint": { gl: 36214, rb: true },
  "rgba16sint": { gl: 36232, rb: true },
  "rgba16float": { gl: 34842 },
  "rgba16unorm": { gl: 32859, rb: true },
  "rgba16snorm": { gl: 36763 },
  // 96-bit formats (deprecated!)
  "rgb32float-webgl": { gl: 34837, x: EXT_color_buffer_float, dataFormat: 6407, types: [5126] },
  // 128-bit formats
  "rgba32uint": { gl: 36208, rb: true },
  "rgba32sint": { gl: 36226, rb: true },
  "rgba32float": { gl: 34836, rb: true },
  // Depth and stencil formats
  "stencil8": { gl: 36168, rb: true },
  // 8 stencil bits
  "depth16unorm": { gl: 33189, dataFormat: 6402, types: [5123], rb: true },
  // 16 depth bits
  "depth24plus": { gl: 33190, dataFormat: 6402, types: [5125] },
  "depth32float": { gl: 36012, dataFormat: 6402, types: [5126], rb: true },
  // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
  "depth24plus-stencil8": { gl: 35056, rb: true, depthTexture: true, dataFormat: 34041, types: [34042] },
  // "depth32float-stencil8" feature - TODO below is render buffer only?
  "depth32float-stencil8": { gl: 36013, dataFormat: 34041, types: [36269], rb: true },
  // BC compressed formats: check device.features.has("texture-compression-bc");
  "bc1-rgb-unorm-webgl": { gl: 33776, x: X_S3TC },
  "bc1-rgb-unorm-srgb-webgl": { gl: 35916, x: X_S3TC_SRGB },
  "bc1-rgba-unorm": { gl: 33777, x: X_S3TC },
  "bc1-rgba-unorm-srgb": { gl: 35916, x: X_S3TC_SRGB },
  "bc2-rgba-unorm": { gl: 33778, x: X_S3TC },
  "bc2-rgba-unorm-srgb": { gl: 35918, x: X_S3TC_SRGB },
  "bc3-rgba-unorm": { gl: 33779, x: X_S3TC },
  "bc3-rgba-unorm-srgb": { gl: 35919, x: X_S3TC_SRGB },
  "bc4-r-unorm": { gl: 36283, x: X_RGTC },
  "bc4-r-snorm": { gl: 36284, x: X_RGTC },
  "bc5-rg-unorm": { gl: 36285, x: X_RGTC },
  "bc5-rg-snorm": { gl: 36286, x: X_RGTC },
  "bc6h-rgb-ufloat": { gl: 36495, x: X_BPTC },
  "bc6h-rgb-float": { gl: 36494, x: X_BPTC },
  "bc7-rgba-unorm": { gl: 36492, x: X_BPTC },
  "bc7-rgba-unorm-srgb": { gl: 36493, x: X_BPTC },
  // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
  "etc2-rgb8unorm": { gl: 37492 },
  "etc2-rgb8unorm-srgb": { gl: 37494 },
  "etc2-rgb8a1unorm": { gl: 37496 },
  "etc2-rgb8a1unorm-srgb": { gl: 37497 },
  "etc2-rgba8unorm": { gl: 37493 },
  "etc2-rgba8unorm-srgb": { gl: 37495 },
  "eac-r11unorm": { gl: 37488 },
  "eac-r11snorm": { gl: 37489 },
  "eac-rg11unorm": { gl: 37490 },
  "eac-rg11snorm": { gl: 37491 },
  // X_ASTC compressed formats: device.features.has("texture-compression-astc")
  "astc-4x4-unorm": { gl: 37808 },
  "astc-4x4-unorm-srgb": { gl: 37840 },
  "astc-5x4-unorm": { gl: 37809 },
  "astc-5x4-unorm-srgb": { gl: 37841 },
  "astc-5x5-unorm": { gl: 37810 },
  "astc-5x5-unorm-srgb": { gl: 37842 },
  "astc-6x5-unorm": { gl: 37811 },
  "astc-6x5-unorm-srgb": { gl: 37843 },
  "astc-6x6-unorm": { gl: 37812 },
  "astc-6x6-unorm-srgb": { gl: 37844 },
  "astc-8x5-unorm": { gl: 37813 },
  "astc-8x5-unorm-srgb": { gl: 37845 },
  "astc-8x6-unorm": { gl: 37814 },
  "astc-8x6-unorm-srgb": { gl: 37846 },
  "astc-8x8-unorm": { gl: 37815 },
  "astc-8x8-unorm-srgb": { gl: 37847 },
  "astc-10x5-unorm": { gl: 37819 },
  "astc-10x5-unorm-srgb": { gl: 37851 },
  "astc-10x6-unorm": { gl: 37817 },
  "astc-10x6-unorm-srgb": { gl: 37849 },
  "astc-10x8-unorm": { gl: 37818 },
  "astc-10x8-unorm-srgb": { gl: 37850 },
  "astc-10x10-unorm": { gl: 37819 },
  "astc-10x10-unorm-srgb": { gl: 37851 },
  "astc-12x10-unorm": { gl: 37820 },
  "astc-12x10-unorm-srgb": { gl: 37852 },
  "astc-12x12-unorm": { gl: 37821 },
  "astc-12x12-unorm-srgb": { gl: 37853 },
  // WEBGL_compressed_texture_pvrtc
  "pvrtc-rgb4unorm-webgl": { gl: 35840 },
  "pvrtc-rgba4unorm-webgl": { gl: 35842 },
  "pvrtc-rbg2unorm-webgl": { gl: 35841 },
  "pvrtc-rgba2unorm-webgl": { gl: 35843 },
  // WEBGL_compressed_texture_etc1
  "etc1-rbg-unorm-webgl": { gl: 36196 },
  // WEBGL_compressed_texture_atc
  "atc-rgb-unorm-webgl": { gl: 35986 },
  "atc-rgba-unorm-webgl": { gl: 35986 },
  "atc-rgbai-unorm-webgl": { gl: 34798 }
};
function getTextureFormatCapabilitiesWebGL(gl, formatSupport, extensions) {
  let supported = formatSupport.create;
  const webglFormatInfo = WEBGL_TEXTURE_FORMATS[formatSupport.format];
  if ((webglFormatInfo == null ? void 0 : webglFormatInfo.gl) === void 0) {
    supported = false;
  }
  if (webglFormatInfo == null ? void 0 : webglFormatInfo.x) {
    supported = supported && Boolean(getWebGLExtension(gl, webglFormatInfo.x, extensions));
  }
  return {
    format: formatSupport.format,
    // @ts-ignore
    create: supported && formatSupport.create,
    // @ts-ignore
    render: supported && formatSupport.render,
    // @ts-ignore
    filter: supported && formatSupport.filter,
    // @ts-ignore
    blend: supported && formatSupport.blend,
    // @ts-ignore
    store: supported && formatSupport.store
  };
}
function getTextureFormatWebGL(format) {
  var _a;
  const formatData = WEBGL_TEXTURE_FORMATS[format];
  const webglFormat = convertTextureFormatToGL(format);
  const decoded = textureFormatDecoder.getInfo(format);
  if (decoded.compressed) {
    formatData.dataFormat = webglFormat;
  }
  return {
    internalFormat: webglFormat,
    format: (formatData == null ? void 0 : formatData.dataFormat) || getWebGLPixelDataFormat(decoded.channels, decoded.integer, decoded.normalized, webglFormat),
    // depth formats don't have a type
    type: decoded.dataType ? getGLFromVertexType(decoded.dataType) : ((_a = formatData == null ? void 0 : formatData.types) == null ? void 0 : _a[0]) || 5121,
    compressed: decoded.compressed || false
  };
}
function getDepthStencilAttachmentWebGL(format) {
  const formatInfo = textureFormatDecoder.getInfo(format);
  switch (formatInfo.attachment) {
    case "depth":
      return 36096;
    case "stencil":
      return 36128;
    case "depth-stencil":
      return 33306;
    default:
      throw new Error(`Not a depth stencil format: ${format}`);
  }
}
function getWebGLPixelDataFormat(channels, integer, normalized, format) {
  if (format === 6408 || format === 6407) {
    return format;
  }
  switch (channels) {
    case "r":
      return integer && !normalized ? 36244 : 6403;
    case "rg":
      return integer && !normalized ? 33320 : 33319;
    case "rgb":
      return integer && !normalized ? 36248 : 6407;
    case "rgba":
      return integer && !normalized ? 36249 : 6408;
    case "bgra":
      throw new Error("bgra pixels not supported by WebGL");
    default:
      return 6408;
  }
}
function convertTextureFormatToGL(format) {
  const formatInfo = WEBGL_TEXTURE_FORMATS[format];
  const webglFormat = formatInfo == null ? void 0 : formatInfo.gl;
  if (webglFormat === void 0) {
    throw new Error(`Unsupported texture format ${format}`);
  }
  return webglFormat;
}

// node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-features.js
var WEBGL_FEATURES = {
  // optional WebGPU features
  "depth-clip-control": "EXT_depth_clamp",
  // TODO these seem subtly different
  // 'timestamp-query' // GPUQueryType "timestamp-query"
  // "indirect-first-instance"
  // Textures are handled by getTextureFeatures()
  // 'depth32float-stencil8' // GPUTextureFormat 'depth32float-stencil8'
  // optional WebGL features
  "timer-query-webgl": "EXT_disjoint_timer_query_webgl2",
  "compilation-status-async-webgl": "KHR_parallel_shader_compile",
  "polygon-mode-webgl": "WEBGL_polygon_mode",
  "provoking-vertex-webgl": "WEBGL_provoking_vertex",
  "shader-clip-cull-distance-webgl": "WEBGL_clip_cull_distance",
  "shader-noperspective-interpolation-webgl": "NV_shader_noperspective_interpolation",
  "shader-conservative-depth-webgl": "EXT_conservative_depth"
  // Textures are handled by getTextureFeatures()
};
var WebGLDeviceFeatures = class extends DeviceFeatures {
  constructor(gl, extensions, disabledFeatures) {
    super([], disabledFeatures);
    __publicField(this, "gl");
    __publicField(this, "extensions");
    __publicField(this, "testedFeatures", /* @__PURE__ */ new Set());
    this.gl = gl;
    this.extensions = extensions;
    getWebGLExtension(gl, "EXT_color_buffer_float", extensions);
  }
  *[Symbol.iterator]() {
    const features = this.getFeatures();
    for (const feature of features) {
      if (this.has(feature)) {
        yield feature;
      }
    }
    return [];
  }
  has(feature) {
    var _a;
    if ((_a = this.disabledFeatures) == null ? void 0 : _a[feature]) {
      return false;
    }
    if (!this.testedFeatures.has(feature)) {
      this.testedFeatures.add(feature);
      if (isTextureFeature(feature) && checkTextureFeature(this.gl, feature, this.extensions)) {
        this.features.add(feature);
      }
      if (this.getWebGLFeature(feature)) {
        this.features.add(feature);
      }
    }
    return this.features.has(feature);
  }
  // FOR DEVICE
  initializeFeatures() {
    const features = this.getFeatures().filter((feature) => feature !== "polygon-mode-webgl");
    for (const feature of features) {
      this.has(feature);
    }
  }
  // IMPLEMENTATION
  getFeatures() {
    return [...Object.keys(WEBGL_FEATURES), ...Object.keys(TEXTURE_FEATURES)];
  }
  /** Extract all WebGL features */
  getWebGLFeature(feature) {
    const featureInfo = WEBGL_FEATURES[feature];
    const isSupported = typeof featureInfo === "string" ? Boolean(getWebGLExtension(this.gl, featureInfo, this.extensions)) : Boolean(featureInfo);
    return isSupported;
  }
};

// node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-limits.js
var WebGLDeviceLimits = class extends DeviceLimits {
  constructor(gl) {
    super();
    // WebGL does not support compute shaders
    // PRIVATE
    __publicField(this, "gl");
    __publicField(this, "limits", {});
    this.gl = gl;
  }
  get maxTextureDimension1D() {
    return 0;
  }
  // WebGL does not support 1D textures
  get maxTextureDimension2D() {
    return this.getParameter(3379);
  }
  get maxTextureDimension3D() {
    return this.getParameter(32883);
  }
  get maxTextureArrayLayers() {
    return this.getParameter(35071);
  }
  get maxBindGroups() {
    return 0;
  }
  get maxDynamicUniformBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxDynamicStorageBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxSampledTexturesPerShaderStage() {
    return this.getParameter(35660);
  }
  // ) TBD
  get maxSamplersPerShaderStage() {
    return this.getParameter(35661);
  }
  get maxStorageBuffersPerShaderStage() {
    return 0;
  }
  // TBD
  get maxStorageTexturesPerShaderStage() {
    return 0;
  }
  // TBD
  get maxUniformBuffersPerShaderStage() {
    return this.getParameter(35375);
  }
  get maxUniformBufferBindingSize() {
    return this.getParameter(35376);
  }
  get maxStorageBufferBindingSize() {
    return 0;
  }
  get minUniformBufferOffsetAlignment() {
    return this.getParameter(35380);
  }
  get minStorageBufferOffsetAlignment() {
    return 0;
  }
  get maxVertexBuffers() {
    return 16;
  }
  // WebGL 2 supports 16 buffers, see https://github.com/gpuweb/gpuweb/issues/4284
  get maxVertexAttributes() {
    return this.getParameter(34921);
  }
  get maxVertexBufferArrayStride() {
    return 2048;
  }
  // TBD, this is just the default value from WebGPU
  get maxInterStageShaderVariables() {
    return this.getParameter(35659);
  }
  get maxComputeWorkgroupStorageSize() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeInvocationsPerWorkgroup() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeX() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeY() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeZ() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupsPerDimension() {
    return 0;
  }
  getParameter(parameter) {
    if (this.limits[parameter] === void 0) {
      this.limits[parameter] = this.gl.getParameter(parameter);
    }
    return this.limits[parameter] || 0;
  }
};

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-framebuffer.js
var WEBGLFramebuffer = class extends Framebuffer {
  constructor(device, props) {
    super(device, props);
    __publicField(this, "device");
    __publicField(this, "gl");
    __publicField(this, "handle");
    __publicField(this, "colorAttachments", []);
    __publicField(this, "depthStencilAttachment", null);
    const isDefaultFramebuffer = props.handle === null;
    this.device = device;
    this.gl = device.gl;
    this.handle = this.props.handle || isDefaultFramebuffer ? this.props.handle : this.gl.createFramebuffer();
    if (!isDefaultFramebuffer) {
      device._setWebGLDebugMetadata(this.handle, this, { spector: this.props });
      this.autoCreateAttachmentTextures();
      this.updateAttachments();
    }
  }
  /** destroys any auto created resources etc. */
  destroy() {
    super.destroy();
    if (!this.destroyed && this.handle !== null) {
      this.gl.deleteFramebuffer(this.handle);
    }
  }
  updateAttachments() {
    const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
    for (let i = 0; i < this.colorAttachments.length; ++i) {
      const attachment = this.colorAttachments[i];
      if (attachment) {
        const attachmentPoint = 36064 + i;
        this._attachTextureView(attachmentPoint, attachment);
      }
    }
    if (this.depthStencilAttachment) {
      const attachmentPoint = getDepthStencilAttachmentWebGL(this.depthStencilAttachment.props.format);
      this._attachTextureView(attachmentPoint, this.depthStencilAttachment);
    }
    if (this.device.props.debug) {
      const status = this.gl.checkFramebufferStatus(36160);
      if (status !== 36053) {
        throw new Error(`Framebuffer ${_getFrameBufferStatus(status)}`);
      }
    }
    this.gl.bindFramebuffer(36160, prevHandle);
  }
  // PRIVATE
  /** In WebGL we must use renderbuffers for depth/stencil attachments (unless we have extensions) */
  // protected override createDepthStencilTexture(format: TextureFormat): Texture {
  //   // return new WEBGLRenderbuffer(this.device, {
  //   return new WEBGLTexture(this.device, {
  //     id: `${this.id}-depth-stencil`,
  //     format,
  //     width: this.width,
  //     height: this.height,
  //     mipmaps: false
  //   });
  // }
  /**
   * @param attachment
   * @param texture
   * @param layer = 0 - index into WEBGLTextureArray and Texture3D or face for `TextureCubeMap`
   * @param level = 0 - mipmapLevel
   */
  _attachTextureView(attachment, textureView) {
    const { gl } = this.device;
    const { texture } = textureView;
    const level = textureView.props.baseMipLevel;
    const layer = textureView.props.baseArrayLayer;
    gl.bindTexture(texture.glTarget, texture.handle);
    switch (texture.glTarget) {
      case 35866:
      case 32879:
        gl.framebufferTextureLayer(36160, attachment, texture.handle, level, layer);
        break;
      case 34067:
        const face = mapIndexToCubeMapFace(layer);
        gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
        break;
      case 3553:
        gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
        break;
      default:
        throw new Error("Illegal texture type");
    }
    gl.bindTexture(texture.glTarget, null);
  }
};
function mapIndexToCubeMapFace(layer) {
  return layer < 34069 ? layer + 34069 : layer;
}
function _getFrameBufferStatus(status) {
  switch (status) {
    case 36053:
      return "success";
    case 36054:
      return "Mismatched attachments";
    case 36055:
      return "No attachments";
    case 36057:
      return "Height/width mismatch";
    case 36061:
      return "Unsupported or split attachments";
    case 36182:
      return "Samples mismatch";
    default:
      return `${status}`;
  }
}

// node_modules/@luma.gl/webgl/dist/adapter/webgl-canvas-context.js
var WebGLCanvasContext = class extends CanvasContext {
  constructor(device, props) {
    super(props);
    __publicField(this, "device");
    __publicField(this, "handle", null);
    __publicField(this, "_framebuffer", null);
    this.device = device;
    this._setAutoCreatedCanvasId(`${this.device.id}-canvas`);
    this._updateDevice();
  }
  get [Symbol.toStringTag]() {
    return "WebGLCanvasContext";
  }
  getCurrentFramebuffer() {
    this._framebuffer = this._framebuffer || new WEBGLFramebuffer(this.device, { handle: null });
    return this._framebuffer;
  }
  // IMPLEMENTATION OF ABSTRACT METHODS
  _updateDevice() {
  }
};

// node_modules/@luma.gl/webgl/dist/utils/load-script.js
async function loadScript(scriptUrl, scriptId) {
  const head = document.getElementsByTagName("head")[0];
  if (!head) {
    throw new Error("loadScript");
  }
  const script = document.createElement("script");
  script.setAttribute("type", "text/javascript");
  script.setAttribute("src", scriptUrl);
  if (scriptId) {
    script.id = scriptId;
  }
  return new Promise((resolve, reject) => {
    script.onload = resolve;
    script.onerror = (error) => reject(new Error(`Unable to load script '${scriptUrl}': ${error}`));
    head.appendChild(script);
  });
}

// node_modules/@luma.gl/webgl/dist/context/debug/spector.js
var LOG_LEVEL = 1;
var spector = null;
var initialized = false;
var DEFAULT_SPECTOR_PROPS = {
  debugSpectorJS: log.get("debug-spectorjs"),
  // https://github.com/BabylonJS/Spector.js#basic-usage
  // https://forum.babylonjs.com/t/spectorcdn-is-temporarily-off/48241
  // spectorUrl: 'https://spectorcdn.babylonjs.com/spector.bundle.js';
  debugSpectorJSUrl: "https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js",
  gl: void 0
};
async function loadSpectorJS(props) {
  if (!globalThis.SPECTOR) {
    try {
      await loadScript(props.debugSpectorJSUrl || DEFAULT_SPECTOR_PROPS.debugSpectorJSUrl);
    } catch (error) {
      log.warn(String(error));
    }
  }
}
function initializeSpectorJS(props) {
  var _a;
  props = { ...DEFAULT_SPECTOR_PROPS, ...props };
  if (!props.debugSpectorJS) {
    return null;
  }
  if (!spector && globalThis.SPECTOR && !((_a = globalThis.luma) == null ? void 0 : _a.spector)) {
    log.probe(LOG_LEVEL, "SPECTOR found and initialized. Start with `luma.spector.displayUI()`")();
    const { Spector: SpectorJS } = globalThis.SPECTOR;
    spector = new SpectorJS();
    if (globalThis.luma) {
      globalThis.luma.spector = spector;
    }
  }
  if (!spector) {
    return null;
  }
  if (!initialized) {
    initialized = true;
    spector.spyCanvases();
    spector == null ? void 0 : spector.onCaptureStarted.add((capture) => log.info("Spector capture started:", capture)());
    spector == null ? void 0 : spector.onCapture.add((capture) => {
      log.info("Spector capture complete:", capture)();
      spector == null ? void 0 : spector.getResultUI();
      spector == null ? void 0 : spector.resultView.display();
      spector == null ? void 0 : spector.resultView.addCapture(capture);
    });
  }
  if (props.gl) {
    const gl = props.gl;
    const device = gl.device;
    spector == null ? void 0 : spector.startCapture(props.gl, 500);
    gl.device = device;
    new Promise((resolve) => setTimeout(resolve, 2e3)).then((_) => {
      log.info("Spector capture stopped after 2 seconds")();
      spector == null ? void 0 : spector.stopCapture();
    });
  }
  return spector;
}

// node_modules/@luma.gl/webgl/dist/context/debug/webgl-developer-tools.js
var WEBGL_DEBUG_CDN_URL = "https://unpkg.com/webgl-debug@2.0.1/index.js";
function getWebGLContextData(gl) {
  gl.luma = gl.luma || {};
  return gl.luma;
}
async function loadWebGLDeveloperTools() {
  if (isBrowser() && !globalThis.WebGLDebugUtils) {
    globalThis.global = globalThis.global || globalThis;
    globalThis.global.module = {};
    await loadScript(WEBGL_DEBUG_CDN_URL);
  }
}
function makeDebugContext(gl, props = {}) {
  return props.debugWebGL || props.traceWebGL ? getDebugContext(gl, props) : getRealContext(gl);
}
function getRealContext(gl) {
  const data = getWebGLContextData(gl);
  return data.realContext ? data.realContext : gl;
}
function getDebugContext(gl, props) {
  if (!globalThis.WebGLDebugUtils) {
    log.warn("webgl-debug not loaded")();
    return gl;
  }
  const data = getWebGLContextData(gl);
  if (data.debugContext) {
    return data.debugContext;
  }
  globalThis.WebGLDebugUtils.init({ ...GLEnum, ...gl });
  const glDebug = globalThis.WebGLDebugUtils.makeDebugContext(gl, onGLError.bind(null, props), onValidateGLFunc.bind(null, props));
  for (const key in GLEnum) {
    if (!(key in glDebug) && typeof GLEnum[key] === "number") {
      glDebug[key] = GLEnum[key];
    }
  }
  class WebGLDebugContext {
  }
  Object.setPrototypeOf(glDebug, Object.getPrototypeOf(gl));
  Object.setPrototypeOf(WebGLDebugContext, glDebug);
  const debugContext = Object.create(WebGLDebugContext);
  data.realContext = gl;
  data.debugContext = debugContext;
  debugContext.debug = true;
  return debugContext;
}
function getFunctionString(functionName, functionArgs) {
  functionArgs = Array.from(functionArgs).map((arg) => arg === void 0 ? "undefined" : arg);
  let args = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, functionArgs);
  args = `${args.slice(0, 100)}${args.length > 100 ? "..." : ""}`;
  return `gl.${functionName}(${args})`;
}
function onGLError(props, err, functionName, args) {
  args = Array.from(args).map((arg) => arg === void 0 ? "undefined" : arg);
  const errorMessage = globalThis.WebGLDebugUtils.glEnumToString(err);
  const functionArgs = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, args);
  const message2 = `${errorMessage} in gl.${functionName}(${functionArgs})`;
  log.error(message2)();
  debugger;
}
function onValidateGLFunc(props, functionName, functionArgs) {
  let functionString = "";
  if (log.level >= 1) {
    functionString = getFunctionString(functionName, functionArgs);
    if (props.traceWebGL) {
      log.log(1, functionString)();
    }
  }
  for (const arg of functionArgs) {
    if (arg === void 0) {
      functionString = functionString || getFunctionString(functionName, functionArgs);
      debugger;
    }
  }
}

// node_modules/@luma.gl/webgl/dist/utils/uid.js
var uidCounters2 = {};
function uid2(id = "id") {
  uidCounters2[id] = uidCounters2[id] || 1;
  const count = uidCounters2[id]++;
  return `${id}-${count}`;
}

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-buffer.js
var WEBGLBuffer = class extends Buffer {
  constructor(device, props = {}) {
    super(device, props);
    __publicField(this, "device");
    __publicField(this, "gl");
    __publicField(this, "handle");
    /** Target in OpenGL defines the type of buffer */
    __publicField(this, "glTarget");
    /** Usage is a hint on how frequently the buffer will be updates */
    __publicField(this, "glUsage");
    /** Index type is needed when issuing draw calls, so we pre-compute it */
    __publicField(this, "glIndexType", 5123);
    /** Number of bytes allocated on the GPU for this buffer */
    __publicField(this, "byteLength", 0);
    /** Number of bytes used */
    __publicField(this, "bytesUsed", 0);
    this.device = device;
    this.gl = this.device.gl;
    const handle = typeof props === "object" ? props.handle : void 0;
    this.handle = handle || this.gl.createBuffer();
    device._setWebGLDebugMetadata(this.handle, this, {
      spector: { ...this.props, data: typeof this.props.data }
    });
    this.glTarget = getWebGLTarget(this.props.usage);
    this.glUsage = getWebGLUsage(this.props.usage);
    this.glIndexType = this.props.indexType === "uint32" ? 5125 : 5123;
    if (props.data) {
      this._initWithData(props.data, props.byteOffset, props.byteLength);
    } else {
      this._initWithByteLength(props.byteLength || 0);
    }
  }
  destroy() {
    if (!this.destroyed && this.handle) {
      this.removeStats();
      this.trackDeallocatedMemory();
      this.gl.deleteBuffer(this.handle);
      this.destroyed = true;
      this.handle = null;
    }
  }
  /** Allocate a new buffer and initialize to contents of typed array */
  _initWithData(data, byteOffset = 0, byteLength = data.byteLength + byteOffset) {
    const glTarget = this.glTarget;
    this.gl.bindBuffer(glTarget, this.handle);
    this.gl.bufferData(glTarget, byteLength, this.glUsage);
    this.gl.bufferSubData(glTarget, byteOffset, data);
    this.gl.bindBuffer(glTarget, null);
    this.bytesUsed = byteLength;
    this.byteLength = byteLength;
    this._setDebugData(data, byteOffset, byteLength);
    this.trackAllocatedMemory(byteLength);
  }
  // Allocate a GPU buffer of specified size.
  _initWithByteLength(byteLength) {
    let data = byteLength;
    if (byteLength === 0) {
      data = new Float32Array(0);
    }
    const glTarget = this.glTarget;
    this.gl.bindBuffer(glTarget, this.handle);
    this.gl.bufferData(glTarget, data, this.glUsage);
    this.gl.bindBuffer(glTarget, null);
    this.bytesUsed = byteLength;
    this.byteLength = byteLength;
    this._setDebugData(null, 0, byteLength);
    this.trackAllocatedMemory(byteLength);
    return this;
  }
  write(data, byteOffset = 0) {
    const dataView = ArrayBuffer.isView(data) ? data : new Uint8Array(data);
    const srcOffset = 0;
    const byteLength = void 0;
    const glTarget = 36663;
    this.gl.bindBuffer(glTarget, this.handle);
    if (srcOffset !== 0 || byteLength !== void 0) {
      this.gl.bufferSubData(glTarget, byteOffset, dataView, srcOffset, byteLength);
    } else {
      this.gl.bufferSubData(glTarget, byteOffset, dataView);
    }
    this.gl.bindBuffer(glTarget, null);
    this._setDebugData(data, byteOffset, data.byteLength);
  }
  async mapAndWriteAsync(callback, byteOffset = 0, byteLength = this.byteLength - byteOffset) {
    const arrayBuffer2 = new ArrayBuffer(byteLength);
    await callback(arrayBuffer2, "copied");
    this.write(arrayBuffer2, byteOffset);
  }
  async readAsync(byteOffset = 0, byteLength) {
    return this.readSyncWebGL(byteOffset, byteLength);
  }
  async mapAndReadAsync(callback, byteOffset = 0, byteLength) {
    const data = await this.readAsync(byteOffset, byteLength);
    return await callback(data.buffer, "copied");
  }
  readSyncWebGL(byteOffset = 0, byteLength) {
    byteLength = byteLength ?? this.byteLength - byteOffset;
    const data = new Uint8Array(byteLength);
    const dstOffset = 0;
    this.gl.bindBuffer(36662, this.handle);
    this.gl.getBufferSubData(36662, byteOffset, data, dstOffset, byteLength);
    this.gl.bindBuffer(36662, null);
    this._setDebugData(data, byteOffset, byteLength);
    return data;
  }
};
function getWebGLTarget(usage) {
  if (usage & Buffer.INDEX) {
    return 34963;
  }
  if (usage & Buffer.VERTEX) {
    return 34962;
  }
  if (usage & Buffer.UNIFORM) {
    return 35345;
  }
  return 34962;
}
function getWebGLUsage(usage) {
  if (usage & Buffer.INDEX) {
    return 35044;
  }
  if (usage & Buffer.VERTEX) {
    return 35044;
  }
  if (usage & Buffer.UNIFORM) {
    return 35048;
  }
  return 35044;
}

// node_modules/@luma.gl/webgl/dist/adapter/helpers/parse-shader-compiler-log.js
function parseShaderCompilerLog(errLog) {
  const lines = errLog.split(/\r?\n/);
  const messages = [];
  for (const line of lines) {
    if (line.length <= 1) {
      continue;
    }
    const segments = line.split(":");
    if (segments.length === 2) {
      const [messageType2, message2] = segments;
      messages.push({
        message: message2.trim(),
        type: getMessageType(messageType2),
        lineNum: 0,
        linePos: 0
      });
      continue;
    }
    const [messageType, linePosition, lineNumber, ...rest] = segments;
    let lineNum = parseInt(lineNumber, 10);
    if (isNaN(lineNum)) {
      lineNum = 0;
    }
    let linePos = parseInt(linePosition, 10);
    if (isNaN(linePos)) {
      linePos = 0;
    }
    messages.push({
      message: rest.join(":").trim(),
      type: getMessageType(messageType),
      lineNum,
      linePos
      // TODO
    });
  }
  return messages;
}
function getMessageType(messageType) {
  const MESSAGE_TYPES = ["warning", "error", "info"];
  const lowerCaseType = messageType.toLowerCase();
  return MESSAGE_TYPES.includes(lowerCaseType) ? lowerCaseType : "info";
}

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-shader.js
var WEBGLShader = class extends Shader {
  constructor(device, props) {
    super(device, props);
    __publicField(this, "device");
    __publicField(this, "handle");
    this.device = device;
    switch (this.props.stage) {
      case "vertex":
        this.handle = this.props.handle || this.device.gl.createShader(35633);
        break;
      case "fragment":
        this.handle = this.props.handle || this.device.gl.createShader(35632);
        break;
      default:
        throw new Error(this.props.stage);
    }
    device._setWebGLDebugMetadata(this.handle, this, { spector: this.props });
    this._compile(this.source);
  }
  destroy() {
    if (this.handle) {
      this.removeStats();
      this.device.gl.deleteShader(this.handle);
      this.destroyed = true;
      this.handle.destroyed = true;
    }
  }
  get asyncCompilationStatus() {
    return this._waitForCompilationComplete().then(() => {
      this._getCompilationStatus();
      return this.compilationStatus;
    });
  }
  async getCompilationInfo() {
    await this._waitForCompilationComplete();
    return this.getCompilationInfoSync();
  }
  getCompilationInfoSync() {
    const shaderLog = this.device.gl.getShaderInfoLog(this.handle);
    return shaderLog ? parseShaderCompilerLog(shaderLog) : [];
  }
  getTranslatedSource() {
    const extensions = this.device.getExtension("WEBGL_debug_shaders");
    const ext = extensions.WEBGL_debug_shaders;
    return (ext == null ? void 0 : ext.getTranslatedShaderSource(this.handle)) || null;
  }
  // PRIVATE METHODS
  /** Compile a shader and get compilation status */
  async _compile(source) {
    source = source.startsWith("#version ") ? source : `#version 300 es
${source}`;
    const { gl } = this.device;
    gl.shaderSource(this.handle, source);
    gl.compileShader(this.handle);
    if (!this.device.props.debug) {
      this.compilationStatus = "pending";
      return;
    }
    if (!this.device.features.has("compilation-status-async-webgl")) {
      this._getCompilationStatus();
      this.debugShader();
      if (this.compilationStatus === "error") {
        throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
      }
      return;
    }
    log.once(1, "Shader compilation is asynchronous")();
    await this._waitForCompilationComplete();
    log.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)();
    this._getCompilationStatus();
    this.debugShader();
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForCompilationComplete() {
    const waitMs = async (ms) => await new Promise((resolve) => setTimeout(resolve, ms));
    const DELAY_MS = 10;
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await waitMs(DELAY_MS);
      return;
    }
    const { gl } = this.device;
    for (; ; ) {
      const complete = gl.getShaderParameter(this.handle, 37297);
      if (complete) {
        return;
      }
      await waitMs(DELAY_MS);
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getCompilationStatus() {
    this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713) ? "success" : "error";
  }
};

// node_modules/@luma.gl/webgl/dist/adapter/converters/device-parameters.js
function withDeviceAndGLParameters(device, parameters, glParameters, func) {
  if (isObjectEmpty2(parameters)) {
    return func(device);
  }
  const webglDevice = device;
  webglDevice.pushState();
  try {
    setDeviceParameters(device, parameters);
    setGLParameters(webglDevice.gl, glParameters);
    return func(device);
  } finally {
    webglDevice.popState();
  }
}
function setDeviceParameters(device, parameters) {
  const webglDevice = device;
  const { gl } = webglDevice;
  if (parameters.cullMode) {
    switch (parameters.cullMode) {
      case "none":
        gl.disable(2884);
        break;
      case "front":
        gl.enable(2884);
        gl.cullFace(1028);
        break;
      case "back":
        gl.enable(2884);
        gl.cullFace(1029);
        break;
    }
  }
  if (parameters.frontFace) {
    gl.frontFace(map("frontFace", parameters.frontFace, {
      ccw: 2305,
      cw: 2304
    }));
  }
  if (parameters.unclippedDepth) {
    if (device.features.has("depth-clip-control")) {
      gl.enable(34383);
    }
  }
  if (parameters.depthBias !== void 0) {
    gl.enable(32823);
    gl.polygonOffset(parameters.depthBias, parameters.depthBiasSlopeScale || 0);
  }
  if (parameters.provokingVertex) {
    if (device.features.has("provoking-vertex-webgl")) {
      const extensions = webglDevice.getExtension("WEBGL_provoking_vertex");
      const ext = extensions.WEBGL_provoking_vertex;
      const vertex = map("provokingVertex", parameters.provokingVertex, {
        first: 36429,
        last: 36430
      });
      ext == null ? void 0 : ext.provokingVertexWEBGL(vertex);
    }
  }
  if (parameters.polygonMode || parameters.polygonOffsetLine) {
    if (device.features.has("polygon-mode-webgl")) {
      if (parameters.polygonMode) {
        const extensions = webglDevice.getExtension("WEBGL_polygon_mode");
        const ext = extensions.WEBGL_polygon_mode;
        const mode = map("polygonMode", parameters.polygonMode, {
          fill: 6914,
          line: 6913
        });
        ext == null ? void 0 : ext.polygonModeWEBGL(1028, mode);
        ext == null ? void 0 : ext.polygonModeWEBGL(1029, mode);
      }
      if (parameters.polygonOffsetLine) {
        gl.enable(10754);
      }
    }
  }
  if (device.features.has("shader-clip-cull-distance-webgl")) {
    if (parameters.clipDistance0) {
      gl.enable(12288);
    }
    if (parameters.clipDistance1) {
      gl.enable(12289);
    }
    if (parameters.clipDistance2) {
      gl.enable(12290);
    }
    if (parameters.clipDistance3) {
      gl.enable(12291);
    }
    if (parameters.clipDistance4) {
      gl.enable(12292);
    }
    if (parameters.clipDistance5) {
      gl.enable(12293);
    }
    if (parameters.clipDistance6) {
      gl.enable(12294);
    }
    if (parameters.clipDistance7) {
      gl.enable(12295);
    }
  }
  if (parameters.depthWriteEnabled !== void 0) {
    gl.depthMask(mapBoolean("depthWriteEnabled", parameters.depthWriteEnabled));
  }
  if (parameters.depthCompare) {
    parameters.depthCompare !== "always" ? gl.enable(2929) : gl.disable(2929);
    gl.depthFunc(convertCompareFunction("depthCompare", parameters.depthCompare));
  }
  if (parameters.stencilWriteMask) {
    const mask = parameters.stencilWriteMask;
    gl.stencilMaskSeparate(1028, mask);
    gl.stencilMaskSeparate(1029, mask);
  }
  if (parameters.stencilReadMask) {
    log.warn("stencilReadMask not supported under WebGL");
  }
  if (parameters.stencilCompare) {
    const mask = parameters.stencilReadMask || 4294967295;
    const glValue = convertCompareFunction("depthCompare", parameters.stencilCompare);
    parameters.stencilCompare !== "always" ? gl.enable(2960) : gl.disable(2960);
    gl.stencilFuncSeparate(1028, glValue, 0, mask);
    gl.stencilFuncSeparate(1029, glValue, 0, mask);
  }
  if (parameters.stencilPassOperation && parameters.stencilFailOperation && parameters.stencilDepthFailOperation) {
    const dppass = convertStencilOperation("stencilPassOperation", parameters.stencilPassOperation);
    const sfail = convertStencilOperation("stencilFailOperation", parameters.stencilFailOperation);
    const dpfail = convertStencilOperation("stencilDepthFailOperation", parameters.stencilDepthFailOperation);
    gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
    gl.stencilOpSeparate(1029, sfail, dpfail, dppass);
  }
  switch (parameters.blend) {
    case true:
      gl.enable(3042);
      break;
    case false:
      gl.disable(3042);
      break;
    default:
  }
  if (parameters.blendColorOperation || parameters.blendAlphaOperation) {
    const colorEquation = convertBlendOperationToEquation("blendColorOperation", parameters.blendColorOperation || "add");
    const alphaEquation = convertBlendOperationToEquation("blendAlphaOperation", parameters.blendAlphaOperation || "add");
    gl.blendEquationSeparate(colorEquation, alphaEquation);
    const colorSrcFactor = convertBlendFactorToFunction("blendColorSrcFactor", parameters.blendColorSrcFactor || "one");
    const colorDstFactor = convertBlendFactorToFunction("blendColorDstFactor", parameters.blendColorDstFactor || "zero");
    const alphaSrcFactor = convertBlendFactorToFunction("blendAlphaSrcFactor", parameters.blendAlphaSrcFactor || "one");
    const alphaDstFactor = convertBlendFactorToFunction("blendAlphaDstFactor", parameters.blendAlphaDstFactor || "zero");
    gl.blendFuncSeparate(colorSrcFactor, colorDstFactor, alphaSrcFactor, alphaDstFactor);
  }
}
function convertCompareFunction(parameter, value) {
  return map(parameter, value, {
    never: 512,
    less: 513,
    equal: 514,
    "less-equal": 515,
    greater: 516,
    "not-equal": 517,
    "greater-equal": 518,
    always: 519
  });
}
function convertStencilOperation(parameter, value) {
  return map(parameter, value, {
    keep: 7680,
    zero: 0,
    replace: 7681,
    invert: 5386,
    "increment-clamp": 7682,
    "decrement-clamp": 7683,
    "increment-wrap": 34055,
    "decrement-wrap": 34056
  });
}
function convertBlendOperationToEquation(parameter, value) {
  return map(parameter, value, {
    add: 32774,
    subtract: 32778,
    "reverse-subtract": 32779,
    min: 32775,
    max: 32776
  });
}
function convertBlendFactorToFunction(parameter, value, type = "color") {
  return map(parameter, value, {
    one: 1,
    zero: 0,
    src: 768,
    "one-minus-src": 769,
    dst: 774,
    "one-minus-dst": 775,
    "src-alpha": 770,
    "one-minus-src-alpha": 771,
    "dst-alpha": 772,
    "one-minus-dst-alpha": 773,
    "src-alpha-saturated": 776,
    constant: type === "color" ? 32769 : 32771,
    "one-minus-constant": type === "color" ? 32770 : 32772,
    // 'constant-alpha': GL.CONSTANT_ALPHA,
    // 'one-minus-constant-alpha': GL.ONE_MINUS_CONSTANT_ALPHA,
    // TODO not supported in WebGL2
    src1: 768,
    "one-minus-src1": 769,
    "src1-alpha": 770,
    "one-minus-src1-alpha": 771
  });
}
function message(parameter, value) {
  return `Illegal parameter ${value} for ${parameter}`;
}
function map(parameter, value, valueMap) {
  if (!(value in valueMap)) {
    throw new Error(message(parameter, value));
  }
  return valueMap[value];
}
function mapBoolean(parameter, value) {
  return value;
}
function isObjectEmpty2(obj) {
  let isEmpty = true;
  for (const key in obj) {
    isEmpty = false;
    break;
  }
  return isEmpty;
}

// node_modules/@luma.gl/webgl/dist/adapter/converters/sampler-parameters.js
function convertSamplerParametersToWebGL(props) {
  const params = {};
  if (props.addressModeU) {
    params[10242] = convertAddressMode(props.addressModeU);
  }
  if (props.addressModeV) {
    params[10243] = convertAddressMode(props.addressModeV);
  }
  if (props.addressModeW) {
    params[32882] = convertAddressMode(props.addressModeW);
  }
  if (props.magFilter) {
    params[10240] = convertMaxFilterMode(props.magFilter);
  }
  if (props.minFilter || props.mipmapFilter) {
    params[10241] = convertMinFilterMode(props.minFilter || "linear", props.mipmapFilter);
  }
  if (props.lodMinClamp !== void 0) {
    params[33082] = props.lodMinClamp;
  }
  if (props.lodMaxClamp !== void 0) {
    params[33083] = props.lodMaxClamp;
  }
  if (props.type === "comparison-sampler") {
    params[34892] = 34894;
  }
  if (props.compare) {
    params[34893] = convertCompareFunction("compare", props.compare);
  }
  if (props.maxAnisotropy) {
    params[34046] = props.maxAnisotropy;
  }
  return params;
}
function convertAddressMode(addressMode) {
  switch (addressMode) {
    case "clamp-to-edge":
      return 33071;
    case "repeat":
      return 10497;
    case "mirror-repeat":
      return 33648;
  }
}
function convertMaxFilterMode(maxFilter) {
  switch (maxFilter) {
    case "nearest":
      return 9728;
    case "linear":
      return 9729;
  }
}
function convertMinFilterMode(minFilter, mipmapFilter = "none") {
  if (!mipmapFilter) {
    return convertMaxFilterMode(minFilter);
  }
  switch (mipmapFilter) {
    case "none":
      return convertMaxFilterMode(minFilter);
    case "nearest":
      switch (minFilter) {
        case "nearest":
          return 9984;
        case "linear":
          return 9985;
      }
      break;
    case "linear":
      switch (minFilter) {
        case "nearest":
          return 9986;
        case "linear":
          return 9987;
      }
  }
}

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-sampler.js
var WEBGLSampler = class extends Sampler {
  constructor(device, props) {
    super(device, props);
    __publicField(this, "device");
    __publicField(this, "handle");
    __publicField(this, "parameters");
    this.device = device;
    this.parameters = convertSamplerParametersToWebGL(props);
    this.handle = props.handle || this.device.gl.createSampler();
    this._setSamplerParameters(this.parameters);
  }
  destroy() {
    if (this.handle) {
      this.device.gl.deleteSampler(this.handle);
      this.handle = void 0;
    }
  }
  toString() {
    return `Sampler(${this.id},${JSON.stringify(this.props)})`;
  }
  /** Set sampler parameters on the sampler */
  _setSamplerParameters(parameters) {
    for (const [pname, value] of Object.entries(parameters)) {
      const param = Number(pname);
      switch (param) {
        case 33082:
        case 33083:
          this.device.gl.samplerParameterf(this.handle, param, value);
          break;
        default:
          this.device.gl.samplerParameteri(this.handle, param, value);
          break;
      }
    }
  }
};

// node_modules/@luma.gl/webgl/dist/context/state-tracker/with-parameters.js
function withGLParameters(gl, parameters, func) {
  if (isObjectEmpty3(parameters)) {
    return func(gl);
  }
  const { nocatch = true } = parameters;
  const webglState = WebGLStateTracker.get(gl);
  webglState.push();
  setGLParameters(gl, parameters);
  let value;
  if (nocatch) {
    value = func(gl);
    webglState.pop();
  } else {
    try {
      value = func(gl);
    } finally {
      webglState.pop();
    }
  }
  return value;
}
function isObjectEmpty3(object) {
  for (const key in object) {
    return false;
  }
  return true;
}

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-texture-view.js
var WEBGLTextureView = class extends TextureView {
  constructor(device, props) {
    super(device, { ...Texture.defaultProps, ...props });
    __publicField(this, "device");
    __publicField(this, "gl");
    __publicField(this, "handle");
    // Does not have a WebGL representation
    __publicField(this, "texture");
    this.device = device;
    this.gl = this.device.gl;
    this.handle = null;
    this.texture = props.texture;
  }
};

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-texture.js
var WEBGLTexture = class extends Texture {
  constructor(device, props) {
    super(device, props);
    // readonly MAX_ATTRIBUTES: number;
    __publicField(this, "device");
    __publicField(this, "gl");
    __publicField(this, "handle");
    // @ts-ignore TODO - currently unused in WebGL. Create dummy sampler?
    __publicField(this, "sampler");
    __publicField(this, "view");
    /**
     * The WebGL target corresponding to the texture type
     * @note `target` cannot be modified by bind:
     * textures are special because when you first bind them to a target,
     * When you first bind a texture as a GL_TEXTURE_2D, you are saying that this texture is a 2D texture.
     * And it will always be a 2D texture; this state cannot be changed ever.
     * A texture that was first bound as a GL_TEXTURE_2D, must always be bound as a GL_TEXTURE_2D;
     * attempting to bind it as GL_TEXTURE_3D will give rise to a run-time error
     */
    __publicField(this, "glTarget");
    /** The WebGL format - essentially channel structure */
    __publicField(this, "glFormat");
    /** The WebGL data format - the type of each channel */
    __publicField(this, "glType");
    /** The WebGL constant corresponding to the WebGPU style constant in format */
    __publicField(this, "glInternalFormat");
    /** Whether the internal format is compressed */
    __publicField(this, "compressed");
    // state
    /** Texture binding slot - TODO - move to texture view? */
    __publicField(this, "_textureUnit", 0);
    this.device = device;
    this.gl = this.device.gl;
    const formatInfo = getTextureFormatWebGL(this.props.format);
    this.glTarget = getWebGLTextureTarget(this.props.dimension);
    this.glInternalFormat = formatInfo.internalFormat;
    this.glFormat = formatInfo.format;
    this.glType = formatInfo.type;
    this.compressed = formatInfo.compressed;
    this.handle = this.props.handle || this.gl.createTexture();
    this.device._setWebGLDebugMetadata(this.handle, this, { spector: this.props });
    this.gl.bindTexture(this.glTarget, this.handle);
    const { dimension, width, height, depth, mipLevels, glTarget, glInternalFormat } = this;
    switch (dimension) {
      case "2d":
      case "cube":
        this.gl.texStorage2D(glTarget, mipLevels, glInternalFormat, width, height);
        break;
      case "2d-array":
      case "3d":
        this.gl.texStorage3D(glTarget, mipLevels, glInternalFormat, width, height, depth);
        break;
      default:
        throw new Error(dimension);
    }
    this.gl.bindTexture(this.glTarget, null);
    this._initializeData(props.data);
    this.setSampler(this.props.sampler);
    this.view = new WEBGLTextureView(this.device, { ...this.props, texture: this });
    Object.seal(this);
  }
  destroy() {
    if (this.handle) {
      this.gl.deleteTexture(this.handle);
      this.removeStats();
      this.trackDeallocatedMemory("Texture");
      this.destroyed = true;
    }
  }
  createView(props) {
    return new WEBGLTextureView(this.device, { ...props, texture: this });
  }
  setSampler(sampler = {}) {
    super.setSampler(sampler);
    const parameters = convertSamplerParametersToWebGL(this.sampler.props);
    this._setSamplerParameters(parameters);
  }
  copyImageData(options_) {
    const options = this._normalizeCopyImageDataOptions(options_);
    const typedArray = options.data;
    const { width, height, depth } = this;
    const { mipLevel = 0, byteOffset = 0, x = 0, y = 0, z = 0 } = options;
    const { glFormat, glType, compressed } = this;
    const glTarget = getWebGLCubeFaceTarget(this.glTarget, this.dimension, z);
    let unpackRowLength;
    if (!this.compressed) {
      const { bytesPerPixel } = this.device.getTextureFormatInfo(this.format);
      if (bytesPerPixel) {
        if (options.bytesPerRow % bytesPerPixel !== 0) {
          throw new Error(`bytesPerRow (${options.bytesPerRow}) must be a multiple of bytesPerPixel (${bytesPerPixel}) for ${this.format}`);
        }
        unpackRowLength = options.bytesPerRow / bytesPerPixel;
      }
    }
    const glParameters = !this.compressed ? {
      ...unpackRowLength !== void 0 ? { [3314]: unpackRowLength } : {},
      [32878]: options.rowsPerImage
    } : {};
    this.gl.bindTexture(glTarget, this.handle);
    withGLParameters(this.gl, glParameters, () => {
      switch (this.dimension) {
        case "2d":
        case "cube":
          if (compressed) {
            this.gl.compressedTexSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, typedArray, byteOffset);
          } else {
            this.gl.texSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, glType, typedArray, byteOffset);
          }
          break;
        case "2d-array":
        case "3d":
          if (compressed) {
            this.gl.compressedTexSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, typedArray, byteOffset);
          } else {
            this.gl.texSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, glType, typedArray, byteOffset);
          }
          break;
        default:
      }
    });
    this.gl.bindTexture(glTarget, null);
  }
  copyExternalImage(options_) {
    const options = this._normalizeCopyExternalImageOptions(options_);
    if (options.sourceX || options.sourceY) {
      throw new Error("WebGL does not support sourceX/sourceY)");
    }
    const { glFormat, glType } = this;
    const { image, depth, mipLevel, x, y, z, width, height } = options;
    const glTarget = getWebGLCubeFaceTarget(this.glTarget, this.dimension, depth);
    const glParameters = options.flipY ? { [37440]: true } : {};
    this.gl.bindTexture(this.glTarget, this.handle);
    withGLParameters(this.gl, glParameters, () => {
      switch (this.dimension) {
        case "2d":
        case "cube":
          this.gl.texSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, glType, image);
          break;
        case "2d-array":
        case "3d":
          this.gl.texSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, glType, image);
          break;
        default:
      }
    });
    this.gl.bindTexture(this.glTarget, null);
    return { width: options.width, height: options.height };
  }
  // WEBGL SPECIFIC
  generateMipmapsWebGL(options) {
    const isFilterableAndRenderable = this.device.isTextureFormatRenderable(this.props.format) && this.device.isTextureFormatFilterable(this.props.format);
    if (!isFilterableAndRenderable) {
      log.warn(`${this} is not renderable or filterable, may not be able to generate mipmaps`)();
      if (!(options == null ? void 0 : options.force)) {
        return;
      }
    }
    try {
      this.gl.bindTexture(this.glTarget, this.handle);
      this.gl.generateMipmap(this.glTarget);
    } catch (error) {
      log.warn(`Error generating mipmap for ${this}: ${error.message}`)();
    } finally {
      this.gl.bindTexture(this.glTarget, null);
    }
  }
  // INTERNAL
  /**
   * Sets sampler parameters on texture
   */
  _setSamplerParameters(parameters) {
    log.log(2, `${this.id} sampler parameters`, this.device.getGLKeys(parameters))();
    this.gl.bindTexture(this.glTarget, this.handle);
    for (const [pname, pvalue] of Object.entries(parameters)) {
      const param = Number(pname);
      const value = pvalue;
      switch (param) {
        case 33082:
        case 33083:
          this.gl.texParameterf(this.glTarget, param, value);
          break;
        case 10240:
        case 10241:
          this.gl.texParameteri(this.glTarget, param, value);
          break;
        case 10242:
        case 10243:
        case 32882:
          this.gl.texParameteri(this.glTarget, param, value);
          break;
        case 34046:
          if (this.device.features.has("texture-filterable-anisotropic-webgl")) {
            this.gl.texParameteri(this.glTarget, param, value);
          }
          break;
        case 34892:
        case 34893:
          this.gl.texParameteri(this.glTarget, param, value);
          break;
      }
    }
    this.gl.bindTexture(this.glTarget, null);
  }
  _getActiveUnit() {
    return this.gl.getParameter(34016) - 33984;
  }
  _bind(_textureUnit) {
    const { gl } = this;
    if (_textureUnit !== void 0) {
      this._textureUnit = _textureUnit;
      gl.activeTexture(33984 + _textureUnit);
    }
    gl.bindTexture(this.glTarget, this.handle);
    return _textureUnit;
  }
  _unbind(_textureUnit) {
    const { gl } = this;
    if (_textureUnit !== void 0) {
      this._textureUnit = _textureUnit;
      gl.activeTexture(33984 + _textureUnit);
    }
    gl.bindTexture(this.glTarget, null);
    return _textureUnit;
  }
};
function getWebGLTextureTarget(dimension) {
  switch (dimension) {
    case "1d":
      break;
    case "2d":
      return 3553;
    case "3d":
      return 32879;
    case "cube":
      return 34067;
    case "2d-array":
      return 35866;
    case "cube-array":
      break;
  }
  throw new Error(dimension);
}
function getWebGLCubeFaceTarget(glTarget, dimension, level) {
  return dimension === "cube" ? 34069 + level : glTarget;
}

// node_modules/@luma.gl/webgl/dist/adapter/converters/webgl-shadertypes.js
function convertDataTypeToGLDataType(normalizedType) {
  return NORMALIZED_SHADER_TYPE_TO_WEBGL[normalizedType];
}
function convertGLUniformTypeToShaderVariableType(glUniformType) {
  return WEBGL_SHADER_TYPES[glUniformType];
}
function isGLSamplerType(type) {
  return Boolean(WEBGL_SAMPLER_TO_TEXTURE_BINDINGS[type]);
}
function getTextureBindingFromGLSamplerType(glSamplerType) {
  return WEBGL_SAMPLER_TO_TEXTURE_BINDINGS[glSamplerType];
}
var WEBGL_SHADER_TYPES = {
  [5126]: "f32",
  [35664]: "vec2<f32>",
  [35665]: "vec3<f32>",
  [35666]: "vec4<f32>",
  [5124]: "i32",
  [35667]: "vec2<i32>",
  [35668]: "vec3<i32>",
  [35669]: "vec4<i32>",
  [5125]: "u32",
  [36294]: "vec2<u32>",
  [36295]: "vec3<u32>",
  [36296]: "vec4<u32>",
  [35670]: "f32",
  [35671]: "vec2<f32>",
  [35672]: "vec3<f32>",
  [35673]: "vec4<f32>",
  // TODO - are sizes/components below correct?
  [35674]: "mat2x2<f32>",
  [35685]: "mat2x3<f32>",
  [35686]: "mat2x4<f32>",
  [35687]: "mat3x2<f32>",
  [35675]: "mat3x3<f32>",
  [35688]: "mat3x4<f32>",
  [35689]: "mat4x2<f32>",
  [35690]: "mat4x3<f32>",
  [35676]: "mat4x4<f32>"
};
var WEBGL_SAMPLER_TO_TEXTURE_BINDINGS = {
  [35678]: { viewDimension: "2d", sampleType: "float" },
  [35680]: { viewDimension: "cube", sampleType: "float" },
  [35679]: { viewDimension: "3d", sampleType: "float" },
  [35682]: { viewDimension: "3d", sampleType: "depth" },
  [36289]: { viewDimension: "2d-array", sampleType: "float" },
  [36292]: { viewDimension: "2d-array", sampleType: "depth" },
  [36293]: { viewDimension: "cube", sampleType: "float" },
  [36298]: { viewDimension: "2d", sampleType: "sint" },
  [36299]: { viewDimension: "3d", sampleType: "sint" },
  [36300]: { viewDimension: "cube", sampleType: "sint" },
  [36303]: { viewDimension: "2d-array", sampleType: "uint" },
  [36306]: { viewDimension: "2d", sampleType: "uint" },
  [36307]: { viewDimension: "3d", sampleType: "uint" },
  [36308]: { viewDimension: "cube", sampleType: "uint" },
  [36311]: { viewDimension: "2d-array", sampleType: "uint" }
};
var NORMALIZED_SHADER_TYPE_TO_WEBGL = {
  uint8: 5121,
  sint8: 5120,
  unorm8: 5121,
  snorm8: 5120,
  uint16: 5123,
  sint16: 5122,
  unorm16: 5123,
  snorm16: 5122,
  uint32: 5125,
  sint32: 5124,
  // WebGPU does not support normalized 32 bit integer attributes
  //  'unorm32': GL.UNSIGNED_INT,
  //  'snorm32': GL.INT,
  float16: 5131,
  float32: 5126
};

// node_modules/@luma.gl/webgl/dist/adapter/helpers/get-shader-layout-from-glsl.js
function getShaderLayoutFromGLSL(gl, program) {
  const shaderLayout = {
    attributes: [],
    bindings: []
  };
  shaderLayout.attributes = readAttributeDeclarations(gl, program);
  const uniformBlocks = readUniformBlocks(gl, program);
  for (const uniformBlock of uniformBlocks) {
    const uniforms2 = uniformBlock.uniforms.map((uniform) => ({
      name: uniform.name,
      format: uniform.format,
      byteOffset: uniform.byteOffset,
      byteStride: uniform.byteStride,
      arrayLength: uniform.arrayLength
    }));
    shaderLayout.bindings.push({
      type: "uniform",
      name: uniformBlock.name,
      group: 0,
      location: uniformBlock.location,
      visibility: (uniformBlock.vertex ? 1 : 0) & (uniformBlock.fragment ? 2 : 0),
      minBindingSize: uniformBlock.byteLength,
      uniforms: uniforms2
    });
  }
  const uniforms = readUniformBindings(gl, program);
  let textureUnit = 0;
  for (const uniform of uniforms) {
    if (isGLSamplerType(uniform.type)) {
      const { viewDimension, sampleType } = getTextureBindingFromGLSamplerType(uniform.type);
      shaderLayout.bindings.push({
        type: "texture",
        name: uniform.name,
        group: 0,
        location: textureUnit,
        viewDimension,
        sampleType
      });
      uniform.textureUnit = textureUnit;
      textureUnit += 1;
    }
  }
  if (uniforms.length) {
    shaderLayout.uniforms = uniforms;
  }
  const varyings = readVaryings(gl, program);
  if (varyings == null ? void 0 : varyings.length) {
    shaderLayout.varyings = varyings;
  }
  return shaderLayout;
}
function readAttributeDeclarations(gl, program) {
  const attributes = [];
  const count = gl.getProgramParameter(program, 35721);
  for (let index = 0; index < count; index++) {
    const activeInfo = gl.getActiveAttrib(program, index);
    if (!activeInfo) {
      throw new Error("activeInfo");
    }
    const {
      name: name2,
      type: compositeType
      /* , size*/
    } = activeInfo;
    const location = gl.getAttribLocation(program, name2);
    if (location >= 0) {
      const attributeType = convertGLUniformTypeToShaderVariableType(compositeType);
      const stepMode = /instance/i.test(name2) ? "instance" : "vertex";
      attributes.push({
        name: name2,
        location,
        stepMode,
        type: attributeType
        // size - for arrays, size is the number of elements in the array
      });
    }
  }
  attributes.sort((a, b) => a.location - b.location);
  return attributes;
}
function readVaryings(gl, program) {
  const varyings = [];
  const count = gl.getProgramParameter(program, 35971);
  for (let location = 0; location < count; location++) {
    const activeInfo = gl.getTransformFeedbackVarying(program, location);
    if (!activeInfo) {
      throw new Error("activeInfo");
    }
    const { name: name2, type: glUniformType, size } = activeInfo;
    const uniformType = convertGLUniformTypeToShaderVariableType(glUniformType);
    const { type, components } = getVariableShaderTypeInfo(uniformType);
    varyings.push({ location, name: name2, type, size: size * components });
  }
  varyings.sort((a, b) => a.location - b.location);
  return varyings;
}
function readUniformBindings(gl, program) {
  const uniforms = [];
  const uniformCount = gl.getProgramParameter(program, 35718);
  for (let i = 0; i < uniformCount; i++) {
    const activeInfo = gl.getActiveUniform(program, i);
    if (!activeInfo) {
      throw new Error("activeInfo");
    }
    const { name: rawName, size, type } = activeInfo;
    const { name: name2, isArray: isArray3 } = parseUniformName(rawName);
    let webglLocation = gl.getUniformLocation(program, name2);
    const uniformInfo = {
      // WebGL locations are uniquely typed but just numbers
      location: webglLocation,
      name: name2,
      size,
      type,
      isArray: isArray3
    };
    uniforms.push(uniformInfo);
    if (uniformInfo.size > 1) {
      for (let j = 0; j < uniformInfo.size; j++) {
        const elementName = `${name2}[${j}]`;
        webglLocation = gl.getUniformLocation(program, elementName);
        const arrayElementUniformInfo = {
          ...uniformInfo,
          name: elementName,
          location: webglLocation
        };
        uniforms.push(arrayElementUniformInfo);
      }
    }
  }
  return uniforms;
}
function readUniformBlocks(gl, program) {
  const getBlockParameter = (blockIndex, pname) => gl.getActiveUniformBlockParameter(program, blockIndex, pname);
  const uniformBlocks = [];
  const blockCount = gl.getProgramParameter(program, 35382);
  for (let blockIndex = 0; blockIndex < blockCount; blockIndex++) {
    const blockInfo = {
      name: gl.getActiveUniformBlockName(program, blockIndex) || "",
      location: getBlockParameter(blockIndex, 35391),
      byteLength: getBlockParameter(blockIndex, 35392),
      vertex: getBlockParameter(blockIndex, 35396),
      fragment: getBlockParameter(blockIndex, 35398),
      uniformCount: getBlockParameter(blockIndex, 35394),
      uniforms: []
    };
    const uniformIndices = getBlockParameter(blockIndex, 35395) || [];
    const uniformType = gl.getActiveUniforms(program, uniformIndices, 35383);
    const uniformArrayLength = gl.getActiveUniforms(program, uniformIndices, 35384);
    const uniformOffset = gl.getActiveUniforms(program, uniformIndices, 35387);
    const uniformStride = gl.getActiveUniforms(program, uniformIndices, 35388);
    for (let i = 0; i < blockInfo.uniformCount; ++i) {
      const activeInfo = gl.getActiveUniform(program, uniformIndices[i]);
      if (!activeInfo) {
        throw new Error("activeInfo");
      }
      const format = convertGLUniformTypeToShaderVariableType(uniformType[i]);
      blockInfo.uniforms.push({
        name: activeInfo.name,
        format,
        type: uniformType[i],
        arrayLength: uniformArrayLength[i],
        byteOffset: uniformOffset[i],
        byteStride: uniformStride[i]
        // matrixStride: uniformStride[i],
        // rowMajor: uniformRowMajor[i]
      });
    }
    uniformBlocks.push(blockInfo);
  }
  uniformBlocks.sort((a, b) => a.location - b.location);
  return uniformBlocks;
}
function parseUniformName(name2) {
  if (name2[name2.length - 1] !== "]") {
    return {
      name: name2,
      length: 1,
      isArray: false
    };
  }
  const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
  const matches = UNIFORM_NAME_REGEXP.exec(name2);
  if (!matches || matches.length < 2) {
    throw new Error(`Failed to parse GLSL uniform name ${name2}`);
  }
  return {
    name: matches[1],
    length: matches[2] ? 1 : 0,
    isArray: Boolean(matches[2])
  };
}

// node_modules/@luma.gl/webgl/dist/adapter/helpers/set-uniform.js
function setUniform(gl, location, type, value) {
  const gl2 = gl;
  let uniformValue = value;
  if (uniformValue === true) {
    uniformValue = 1;
  }
  if (uniformValue === false) {
    uniformValue = 0;
  }
  const arrayValue = typeof uniformValue === "number" ? [uniformValue] : uniformValue;
  switch (type) {
    case 35678:
    case 35680:
    case 35679:
    case 35682:
    case 36289:
    case 36292:
    case 36293:
    case 36298:
    case 36299:
    case 36300:
    case 36303:
    case 36306:
    case 36307:
    case 36308:
    case 36311:
      if (typeof value !== "number") {
        throw new Error("samplers must be set to integers");
      }
      return gl.uniform1i(location, value);
    case 5126:
      return gl.uniform1fv(location, arrayValue);
    case 35664:
      return gl.uniform2fv(location, arrayValue);
    case 35665:
      return gl.uniform3fv(location, arrayValue);
    case 35666:
      return gl.uniform4fv(location, arrayValue);
    case 5124:
      return gl.uniform1iv(location, arrayValue);
    case 35667:
      return gl.uniform2iv(location, arrayValue);
    case 35668:
      return gl.uniform3iv(location, arrayValue);
    case 35669:
      return gl.uniform4iv(location, arrayValue);
    case 35670:
      return gl.uniform1iv(location, arrayValue);
    case 35671:
      return gl.uniform2iv(location, arrayValue);
    case 35672:
      return gl.uniform3iv(location, arrayValue);
    case 35673:
      return gl.uniform4iv(location, arrayValue);
    case 5125:
      return gl2.uniform1uiv(location, arrayValue, 1);
    case 36294:
      return gl2.uniform2uiv(location, arrayValue, 2);
    case 36295:
      return gl2.uniform3uiv(location, arrayValue, 3);
    case 36296:
      return gl2.uniform4uiv(location, arrayValue, 4);
    case 35674:
      return gl.uniformMatrix2fv(location, false, arrayValue);
    case 35675:
      return gl.uniformMatrix3fv(location, false, arrayValue);
    case 35676:
      return gl.uniformMatrix4fv(location, false, arrayValue);
    case 35685:
      return gl2.uniformMatrix2x3fv(location, false, arrayValue);
    case 35686:
      return gl2.uniformMatrix2x4fv(location, false, arrayValue);
    case 35687:
      return gl2.uniformMatrix3x2fv(location, false, arrayValue);
    case 35688:
      return gl2.uniformMatrix3x4fv(location, false, arrayValue);
    case 35689:
      return gl2.uniformMatrix4x2fv(location, false, arrayValue);
    case 35690:
      return gl2.uniformMatrix4x3fv(location, false, arrayValue);
  }
  throw new Error("Illegal uniform");
}

// node_modules/@luma.gl/webgl/dist/adapter/helpers/webgl-topology-utils.js
function getGLDrawMode(topology) {
  switch (topology) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 3;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 5;
    default:
      throw new Error(topology);
  }
}
function getGLPrimitive(topology) {
  switch (topology) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 1;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 4;
    default:
      throw new Error(topology);
  }
}

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-render-pipeline.js
var LOG_PROGRAM_PERF_PRIORITY = 4;
var WEBGLRenderPipeline = class extends RenderPipeline {
  constructor(device, props) {
    super(device, props);
    /** The WebGL device that created this render pipeline */
    __publicField(this, "device");
    /** Handle to underlying WebGL program */
    __publicField(this, "handle");
    /** vertex shader */
    __publicField(this, "vs");
    /** fragment shader */
    __publicField(this, "fs");
    /** The layout extracted from shader by WebGL introspection APIs */
    __publicField(this, "introspectedLayout");
    /** Uniforms set on this model */
    __publicField(this, "uniforms", {});
    /** Bindings set on this model */
    __publicField(this, "bindings", {});
    /** WebGL varyings */
    __publicField(this, "varyings", null);
    __publicField(this, "_uniformCount", 0);
    __publicField(this, "_uniformSetters", {});
    this.device = device;
    this.handle = this.props.handle || this.device.gl.createProgram();
    this.device._setWebGLDebugMetadata(this.handle, this, { spector: { id: this.props.id } });
    this.vs = props.vs;
    this.fs = props.fs;
    const { varyings, bufferMode = 35981 } = props;
    if (varyings && varyings.length > 0) {
      this.varyings = varyings;
      this.device.gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);
    }
    this._linkShaders();
    log.time(3, `RenderPipeline ${this.id} - shaderLayout introspection`)();
    this.introspectedLayout = getShaderLayoutFromGLSL(this.device.gl, this.handle);
    log.timeEnd(3, `RenderPipeline ${this.id} - shaderLayout introspection`)();
    this.shaderLayout = props.shaderLayout ? mergeShaderLayout(this.introspectedLayout, props.shaderLayout) : this.introspectedLayout;
  }
  // TODO are these used?
  get [Symbol.toStringTag]() {
    return "WEBGLRenderPipeline";
  }
  destroy() {
    if (this.handle) {
      this.device.gl.useProgram(null);
      this.device.gl.deleteProgram(this.handle);
      this.destroyed = true;
      this.handle.destroyed = true;
      this.handle = null;
    }
  }
  /**
   * Bindings include: textures, samplers and uniform buffers
   * @todo needed for portable model
   */
  setBindings(bindings, options) {
    for (const [name2, value] of Object.entries(bindings)) {
      const binding = this.shaderLayout.bindings.find((binding_) => binding_.name === name2) || this.shaderLayout.bindings.find((binding_) => binding_.name === `${name2}Uniforms`);
      if (!binding) {
        const validBindings = this.shaderLayout.bindings.map((binding_) => `"${binding_.name}"`).join(", ");
        if (!(options == null ? void 0 : options.disableWarnings)) {
          log.warn(`No binding "${name2}" in render pipeline "${this.id}", expected one of ${validBindings}`, value)();
        }
        continue;
      }
      if (!value) {
        log.warn(`Unsetting binding "${name2}" in render pipeline "${this.id}"`)();
      }
      switch (binding.type) {
        case "uniform":
          if (!(value instanceof WEBGLBuffer) && !(value.buffer instanceof WEBGLBuffer)) {
            throw new Error("buffer value");
          }
          break;
        case "texture":
          if (!(value instanceof WEBGLTextureView || value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {
            throw new Error(`${this} Bad texture binding for ${name2}`);
          }
          break;
        case "sampler":
          log.warn(`Ignoring sampler ${name2}`)();
          break;
        default:
          throw new Error(binding.type);
      }
      this.bindings[name2] = value;
    }
  }
  /** @todo needed for portable model
   * @note The WebGL API is offers many ways to draw things
   * This function unifies those ways into a single call using common parameters with sane defaults
   */
  draw(options) {
    var _a;
    const {
      renderPass,
      parameters = this.props.parameters,
      topology = this.props.topology,
      vertexArray,
      vertexCount,
      // indexCount,
      instanceCount,
      isInstanced = false,
      firstVertex = 0,
      // firstIndex,
      // firstInstance,
      // baseVertex,
      transformFeedback
    } = options;
    const glDrawMode = getGLDrawMode(topology);
    const isIndexed = Boolean(vertexArray.indexBuffer);
    const glIndexType = (_a = vertexArray.indexBuffer) == null ? void 0 : _a.glIndexType;
    if (this.linkStatus !== "success") {
      log.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)();
      return false;
    }
    if (!this._areTexturesRenderable()) {
      log.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)();
      return false;
    }
    this.device.gl.useProgram(this.handle);
    vertexArray.bindBeforeRender(renderPass);
    if (transformFeedback) {
      transformFeedback.begin(this.props.topology);
    }
    this._applyBindings();
    this._applyUniforms();
    const webglRenderPass = renderPass;
    withDeviceAndGLParameters(this.device, parameters, webglRenderPass.glParameters, () => {
      if (isIndexed && isInstanced) {
        this.device.gl.drawElementsInstanced(
          glDrawMode,
          vertexCount || 0,
          // indexCount?
          glIndexType,
          firstVertex,
          instanceCount || 0
        );
      } else if (isIndexed) {
        this.device.gl.drawElements(glDrawMode, vertexCount || 0, glIndexType, firstVertex);
      } else if (isInstanced) {
        this.device.gl.drawArraysInstanced(glDrawMode, firstVertex, vertexCount || 0, instanceCount || 0);
      } else {
        this.device.gl.drawArrays(glDrawMode, firstVertex, vertexCount || 0);
      }
      if (transformFeedback) {
        transformFeedback.end();
      }
    });
    vertexArray.unbindAfterRender(renderPass);
    return true;
  }
  // PRIVATE METHODS
  // setAttributes(attributes: Record<string, Buffer>): void {}
  // setBindings(bindings: Record<string, Binding>): void {}
  async _linkShaders() {
    const { gl } = this.device;
    gl.attachShader(this.handle, this.vs.handle);
    gl.attachShader(this.handle, this.fs.handle);
    log.time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
    gl.linkProgram(this.handle);
    log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
    if (log.level === 0) {
    }
    if (!this.device.features.has("compilation-status-async-webgl")) {
      const status2 = this._getLinkStatus();
      this._reportLinkStatus(status2);
      return;
    }
    log.once(1, "RenderPipeline linking is asynchronous")();
    await this._waitForLinkComplete();
    log.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();
    const status = this._getLinkStatus();
    this._reportLinkStatus(status);
  }
  /** Report link status. First, check for shader compilation failures if linking fails */
  async _reportLinkStatus(status) {
    var _a;
    switch (status) {
      case "success":
        return;
      default:
        const errorType = status === "link-error" ? "Link error" : "Validation error";
        switch (this.vs.compilationStatus) {
          case "error":
            this.vs.debugShader();
            throw new Error(`${this} ${errorType} during compilation of ${this.vs}`);
          case "pending":
            await this.vs.asyncCompilationStatus;
            this.vs.debugShader();
            break;
          case "success":
            break;
        }
        switch ((_a = this.fs) == null ? void 0 : _a.compilationStatus) {
          case "error":
            this.fs.debugShader();
            throw new Error(`${this} ${errorType} during compilation of ${this.fs}`);
          case "pending":
            await this.fs.asyncCompilationStatus;
            this.fs.debugShader();
            break;
          case "success":
            break;
        }
        const linkErrorLog = this.device.gl.getProgramInfoLog(this.handle);
        this.device.reportError(new Error(`${errorType} during ${status}: ${linkErrorLog}`), this)();
        this.device.debug();
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getLinkStatus() {
    const { gl } = this.device;
    const linked = gl.getProgramParameter(this.handle, 35714);
    if (!linked) {
      this.linkStatus = "error";
      return "link-error";
    }
    gl.validateProgram(this.handle);
    const validated = gl.getProgramParameter(this.handle, 35715);
    if (!validated) {
      this.linkStatus = "error";
      return "validation-error";
    }
    this.linkStatus = "success";
    return "success";
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForLinkComplete() {
    const waitMs = async (ms) => await new Promise((resolve) => setTimeout(resolve, ms));
    const DELAY_MS = 10;
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await waitMs(DELAY_MS);
      return;
    }
    const { gl } = this.device;
    for (; ; ) {
      const complete = gl.getProgramParameter(this.handle, 37297);
      if (complete) {
        return;
      }
      await waitMs(DELAY_MS);
    }
  }
  /**
   * Checks if all texture-values uniforms are renderable (i.e. loaded)
   * Update a texture if needed (e.g. from video)
   * Note: This is currently done before every draw call
   */
  _areTexturesRenderable() {
    let texturesRenderable = true;
    for (const bindingInfo of this.shaderLayout.bindings) {
      if (!this.bindings[bindingInfo.name] && !this.bindings[bindingInfo.name.replace(/Uniforms$/, "")]) {
        log.warn(`Binding ${bindingInfo.name} not found in ${this.id}`)();
        texturesRenderable = false;
      }
    }
    return texturesRenderable;
  }
  /** Apply any bindings (before each draw call) */
  _applyBindings() {
    if (this.linkStatus !== "success") {
      return;
    }
    const { gl } = this.device;
    gl.useProgram(this.handle);
    let textureUnit = 0;
    let uniformBufferIndex = 0;
    for (const binding of this.shaderLayout.bindings) {
      const value = this.bindings[binding.name] || this.bindings[binding.name.replace(/Uniforms$/, "")];
      if (!value) {
        throw new Error(`No value for binding ${binding.name} in ${this.id}`);
      }
      switch (binding.type) {
        case "uniform":
          const { name: name2 } = binding;
          const location = gl.getUniformBlockIndex(this.handle, name2);
          if (location === 4294967295) {
            throw new Error(`Invalid uniform block name ${name2}`);
          }
          gl.uniformBlockBinding(this.handle, uniformBufferIndex, location);
          if (value instanceof WEBGLBuffer) {
            gl.bindBufferBase(35345, uniformBufferIndex, value.handle);
          } else {
            gl.bindBufferRange(
              35345,
              uniformBufferIndex,
              // @ts-expect-error
              value.buffer.handle,
              // @ts-expect-error
              value.offset || 0,
              // @ts-expect-error
              value.size || value.buffer.byteLength - value.offset
            );
          }
          uniformBufferIndex += 1;
          break;
        case "texture":
          if (!(value instanceof WEBGLTextureView || value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {
            throw new Error("texture");
          }
          let texture;
          if (value instanceof WEBGLTextureView) {
            texture = value.texture;
          } else if (value instanceof WEBGLTexture) {
            texture = value;
          } else if (value instanceof WEBGLFramebuffer && value.colorAttachments[0] instanceof WEBGLTextureView) {
            log.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")();
            texture = value.colorAttachments[0].texture;
          } else {
            throw new Error("No texture");
          }
          gl.activeTexture(33984 + textureUnit);
          gl.bindTexture(texture.glTarget, texture.handle);
          textureUnit += 1;
          break;
        case "sampler":
          break;
        case "storage":
        case "read-only-storage":
          throw new Error(`binding type '${binding.type}' not supported in WebGL`);
      }
    }
  }
  /**
   * Due to program sharing, uniforms need to be reset before every draw call
   * (though caching will avoid redundant WebGL calls)
   */
  _applyUniforms() {
    for (const uniformLayout of this.shaderLayout.uniforms || []) {
      const { name: name2, location, type, textureUnit } = uniformLayout;
      const value = this.uniforms[name2] ?? textureUnit;
      if (value !== void 0) {
        setUniform(this.device.gl, location, type, value);
      }
    }
  }
};
function mergeShaderLayout(baseLayout, overrideLayout) {
  const mergedLayout = {
    ...baseLayout,
    attributes: baseLayout.attributes.map((attribute) => ({ ...attribute }))
  };
  for (const attribute of (overrideLayout == null ? void 0 : overrideLayout.attributes) || []) {
    const baseAttribute = mergedLayout.attributes.find((attr) => attr.name === attribute.name);
    if (!baseAttribute) {
      log.warn(`shader layout attribute ${attribute.name} not present in shader`);
    } else {
      baseAttribute.type = attribute.type || baseAttribute.type;
      baseAttribute.stepMode = attribute.stepMode || baseAttribute.stepMode;
    }
  }
  return mergedLayout;
}

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-command-buffer.js
var WEBGLCommandBuffer = class extends CommandBuffer {
  constructor(device) {
    super(device, {});
    __publicField(this, "device");
    __publicField(this, "handle", null);
    __publicField(this, "commands", []);
    this.device = device;
  }
  _executeCommands(commands = this.commands) {
    for (const command of commands) {
      switch (command.name) {
        case "copy-buffer-to-buffer":
          _copyBufferToBuffer(this.device, command.options);
          break;
        case "copy-buffer-to-texture":
          _copyBufferToTexture(this.device, command.options);
          break;
        case "copy-texture-to-buffer":
          _copyTextureToBuffer(this.device, command.options);
          break;
        case "copy-texture-to-texture":
          _copyTextureToTexture(this.device, command.options);
          break;
        default:
          throw new Error(command.name);
      }
    }
  }
};
function _copyBufferToBuffer(device, options) {
  const source = options.sourceBuffer;
  const destination = options.destinationBuffer;
  device.gl.bindBuffer(36662, source.handle);
  device.gl.bindBuffer(36663, destination.handle);
  device.gl.copyBufferSubData(36662, 36663, options.sourceOffset ?? 0, options.destinationOffset ?? 0, options.size);
  device.gl.bindBuffer(36662, null);
  device.gl.bindBuffer(36663, null);
}
function _copyBufferToTexture(device, options) {
  throw new Error("Not implemented");
}
function _copyTextureToBuffer(device, options) {
  const {
    /** Texture to copy to/from. */
    sourceTexture,
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    mipLevel = 0,
    /** Defines which aspects of the texture to copy to/from. */
    aspect = "all",
    /** Width to copy */
    width = options.sourceTexture.width,
    /** Height to copy */
    height = options.sourceTexture.height,
    depthOrArrayLayers = 0,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    origin = [0, 0],
    /** Destination buffer */
    destinationBuffer,
    /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */
    byteOffset = 0,
    /**
     * The stride, in bytes, between the beginning of each block row and the subsequent block row.
     * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).
     */
    bytesPerRow,
    /**
     * Number of block rows per single image of the texture.
     * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.
     * Required if there are multiple images (i.e. the copy depth is more than one).
     */
    rowsPerImage
  } = options;
  if (aspect !== "all") {
    throw new Error("aspect not supported in WebGL");
  }
  if (mipLevel !== 0 || depthOrArrayLayers !== 0 || bytesPerRow || rowsPerImage) {
    throw new Error("not implemented");
  }
  const { framebuffer, destroyFramebuffer } = getFramebuffer(sourceTexture);
  let prevHandle;
  try {
    const webglBuffer = destinationBuffer;
    const sourceWidth = width || framebuffer.width;
    const sourceHeight = height || framebuffer.height;
    const sourceParams = getTextureFormatWebGL(framebuffer.colorAttachments[0].texture.props.format);
    const sourceFormat = sourceParams.format;
    const sourceType = sourceParams.type;
    device.gl.bindBuffer(35051, webglBuffer.handle);
    prevHandle = device.gl.bindFramebuffer(36160, framebuffer.handle);
    device.gl.readPixels(origin[0], origin[1], sourceWidth, sourceHeight, sourceFormat, sourceType, byteOffset);
  } finally {
    device.gl.bindBuffer(35051, null);
    if (prevHandle !== void 0) {
      device.gl.bindFramebuffer(36160, prevHandle);
    }
    if (destroyFramebuffer) {
      framebuffer.destroy();
    }
  }
}
function _copyTextureToTexture(device, options) {
  const {
    /** Texture to copy to/from. */
    sourceTexture,
    /**  Mip-map level of the texture to copy to (Default 0) */
    destinationMipLevel = 0,
    /** Defines which aspects of the texture to copy to/from. */
    // aspect = 'all',
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */
    origin = [0, 0],
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */
    destinationOrigin = [0, 0],
    /** Texture to copy to/from. */
    destinationTexture
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    // destinationMipLevel = options.mipLevel,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    // destinationOrigin = [0, 0],
    /** Defines which aspects of the texture to copy to/from. */
    // destinationAspect = options.aspect,
  } = options;
  let {
    width = options.destinationTexture.width,
    height = options.destinationTexture.height
    // depthOrArrayLayers = 0
  } = options;
  const { framebuffer, destroyFramebuffer } = getFramebuffer(sourceTexture);
  const [sourceX, sourceY] = origin;
  const [destinationX, destinationY, destinationZ] = destinationOrigin;
  const prevHandle = device.gl.bindFramebuffer(36160, framebuffer.handle);
  let texture;
  let textureTarget;
  if (destinationTexture instanceof WEBGLTexture) {
    texture = destinationTexture;
    width = Number.isFinite(width) ? width : texture.width;
    height = Number.isFinite(height) ? height : texture.height;
    texture._bind(0);
    textureTarget = texture.glTarget;
  } else {
    throw new Error("invalid destination");
  }
  switch (textureTarget) {
    case 3553:
    case 34067:
      device.gl.copyTexSubImage2D(textureTarget, destinationMipLevel, destinationX, destinationY, sourceX, sourceY, width, height);
      break;
    case 35866:
    case 32879:
      device.gl.copyTexSubImage3D(textureTarget, destinationMipLevel, destinationX, destinationY, destinationZ, sourceX, sourceY, width, height);
      break;
    default:
  }
  if (texture) {
    texture._unbind();
  }
  device.gl.bindFramebuffer(36160, prevHandle);
  if (destroyFramebuffer) {
    framebuffer.destroy();
  }
}
function getFramebuffer(source) {
  if (source instanceof Texture) {
    const { width, height, id } = source;
    const framebuffer = source.device.createFramebuffer({
      id: `framebuffer-for-${id}`,
      width,
      height,
      colorAttachments: [source]
    });
    return { framebuffer, destroyFramebuffer: true };
  }
  return { framebuffer: source, destroyFramebuffer: false };
}

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-render-pass.js
var COLOR_CHANNELS = [1, 2, 4, 8];
var WEBGLRenderPass = class extends RenderPass {
  constructor(device, props) {
    var _a;
    super(device, props);
    __publicField(this, "device");
    __publicField(this, "handle", null);
    /** Parameters that should be applied before each draw call */
    __publicField(this, "glParameters", {});
    this.device = device;
    let viewport;
    if (!((_a = props == null ? void 0 : props.parameters) == null ? void 0 : _a.viewport)) {
      if (props == null ? void 0 : props.framebuffer) {
        const { width, height } = props.framebuffer;
        viewport = [0, 0, width, height];
      } else {
        const [width, height] = device.getDefaultCanvasContext().getDrawingBufferSize();
        viewport = [0, 0, width, height];
      }
    }
    this.device.pushState();
    this.setParameters({ viewport, ...this.props.parameters });
    const webglFramebuffer = this.props.framebuffer;
    if (this.props.framebuffer && (webglFramebuffer == null ? void 0 : webglFramebuffer.handle)) {
      const drawBuffers = this.props.framebuffer.colorAttachments.map((_, i) => 36064 + i);
      this.device.gl.drawBuffers(drawBuffers);
    } else {
      this.device.gl.drawBuffers([1029]);
    }
    this.clear();
  }
  end() {
    this.device.popState();
  }
  pushDebugGroup(groupLabel) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(markerLabel) {
  }
  // beginOcclusionQuery(queryIndex: number): void;
  // endOcclusionQuery(): void;
  // executeBundles(bundles: Iterable<GPURenderBundle>): void;
  /**
   * Maps RenderPass parameters to GL parameters
   */
  setParameters(parameters = {}) {
    const glParameters = { ...this.glParameters };
    glParameters.framebuffer = this.props.framebuffer || null;
    if (this.props.depthReadOnly) {
      glParameters.depthMask = !this.props.depthReadOnly;
    }
    glParameters.stencilMask = this.props.stencilReadOnly ? 0 : 1;
    glParameters[35977] = this.props.discard;
    if (parameters.viewport) {
      if (parameters.viewport.length >= 6) {
        glParameters.viewport = parameters.viewport.slice(0, 4);
        glParameters.depthRange = [
          parameters.viewport[4],
          parameters.viewport[5]
        ];
      } else {
        glParameters.viewport = parameters.viewport;
      }
    }
    if (parameters.scissorRect) {
      glParameters.scissorTest = true;
      glParameters.scissor = parameters.scissorRect;
    }
    if (parameters.blendConstant) {
      glParameters.blendColor = parameters.blendConstant;
    }
    if (parameters.stencilReference) {
      console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL");
      glParameters[2967] = parameters.stencilReference;
    }
    if ("colorMask" in parameters) {
      glParameters.colorMask = COLOR_CHANNELS.map((channel) => Boolean(channel & parameters.colorMask));
    }
    this.glParameters = glParameters;
    setGLParameters(this.device.gl, glParameters);
  }
  beginOcclusionQuery(queryIndex) {
    const webglQuerySet = this.props.occlusionQuerySet;
    webglQuerySet == null ? void 0 : webglQuerySet.beginOcclusionQuery();
  }
  endOcclusionQuery() {
    const webglQuerySet = this.props.occlusionQuerySet;
    webglQuerySet == null ? void 0 : webglQuerySet.endOcclusionQuery();
  }
  // PRIVATE
  /**
   * Optionally clears depth, color and stencil buffers based on parameters
   */
  clear() {
    const glParameters = { ...this.glParameters };
    let clearMask = 0;
    if (this.props.clearColors) {
      this.props.clearColors.forEach((color, drawBufferIndex) => {
        if (color) {
          this.clearColorBuffer(drawBufferIndex, color);
        }
      });
    }
    if (this.props.clearColor !== false && this.props.clearColors === void 0) {
      clearMask |= 16384;
      glParameters.clearColor = this.props.clearColor;
    }
    if (this.props.clearDepth !== false) {
      clearMask |= 256;
      glParameters.clearDepth = this.props.clearDepth;
    }
    if (this.props.clearStencil !== false) {
      clearMask |= 1024;
      glParameters.clearStencil = this.props.clearStencil;
    }
    if (clearMask !== 0) {
      withGLParameters(this.device.gl, glParameters, () => {
        this.device.gl.clear(clearMask);
      });
    }
  }
  /**
   * WebGL2 - clear a specific color buffer
   */
  clearColorBuffer(drawBuffer = 0, value = [0, 0, 0, 0]) {
    withGLParameters(this.device.gl, { framebuffer: this.props.framebuffer }, () => {
      switch (value.constructor) {
        case Int8Array:
        case Int16Array:
        case Int32Array:
          this.device.gl.clearBufferiv(6144, drawBuffer, value);
          break;
        case Uint8Array:
        case Uint8ClampedArray:
        case Uint16Array:
        case Uint32Array:
          this.device.gl.clearBufferuiv(6144, drawBuffer, value);
          break;
        case Float32Array:
          this.device.gl.clearBufferfv(6144, drawBuffer, value);
          break;
        default:
          throw new Error("clearColorBuffer: color must be typed array");
      }
    });
  }
};

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-command-encoder.js
var WEBGLCommandEncoder = class extends CommandEncoder {
  constructor(device, props) {
    super(device, props);
    __publicField(this, "device");
    __publicField(this, "handle", null);
    __publicField(this, "commandBuffer");
    this.device = device;
    this.commandBuffer = new WEBGLCommandBuffer(device);
  }
  destroy() {
  }
  finish() {
    return this.commandBuffer;
  }
  beginRenderPass(props) {
    return new WEBGLRenderPass(this.device, props);
  }
  beginComputePass(props) {
    throw new Error("ComputePass not supported in WebGL");
  }
  copyBufferToBuffer(options) {
    this.commandBuffer.commands.push({ name: "copy-buffer-to-buffer", options });
  }
  copyBufferToTexture(options) {
    this.commandBuffer.commands.push({ name: "copy-buffer-to-texture", options });
  }
  copyTextureToBuffer(options) {
    this.commandBuffer.commands.push({ name: "copy-texture-to-buffer", options });
  }
  copyTextureToTexture(options) {
    this.commandBuffer.commands.push({ name: "copy-texture-to-texture", options });
  }
  // clearTexture(options: ClearTextureOptions): void {
  //   this.commandBuffer.commands.push({name: 'copy-texture-to-texture', options});
  // }
  pushDebugGroup(groupLabel) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(markerLabel) {
  }
  resolveQuerySet(querySet, destination, options) {
  }
};

// node_modules/@luma.gl/webgl/dist/utils/fill-array.js
function fillArray(options) {
  const { target: target2, source, start = 0, count = 1 } = options;
  const length = source.length;
  const total = count * length;
  let copied = 0;
  for (let i = start; copied < length; copied++) {
    target2[i++] = source[copied];
  }
  while (copied < total) {
    if (copied < total - copied) {
      target2.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target2.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }
  return options.target;
}

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-vertex-array.js
var WEBGLVertexArray = class _WEBGLVertexArray extends VertexArray {
  // Create a VertexArray
  constructor(device, props) {
    super(device, props);
    __publicField(this, "device");
    __publicField(this, "handle");
    /** Attribute 0 buffer constant */
    __publicField(this, "buffer", null);
    __publicField(this, "bufferValue", null);
    this.device = device;
    this.handle = this.device.gl.createVertexArray();
  }
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  /** * Attribute 0 can not be disable on most desktop OpenGL based browsers */
  static isConstantAttributeZeroSupported(device) {
    return getBrowser() === "Chrome";
  }
  destroy() {
    var _a;
    super.destroy();
    if (this.buffer) {
      (_a = this.buffer) == null ? void 0 : _a.destroy();
    }
    if (this.handle) {
      this.device.gl.deleteVertexArray(this.handle);
      this.handle = void 0;
    }
  }
  /**
  // Set (bind/unbind) an elements buffer, for indexed rendering.
  // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER or null. Constants not supported
   *
   * @param elementBuffer
   */
  setIndexBuffer(indexBuffer) {
    const buffer = indexBuffer;
    if (buffer && buffer.glTarget !== 34963) {
      throw new Error("Use .setBuffer()");
    }
    this.device.gl.bindVertexArray(this.handle);
    this.device.gl.bindBuffer(34963, buffer ? buffer.handle : null);
    this.indexBuffer = buffer;
    this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a buffer, enables the location, sets divisor */
  setBuffer(location, attributeBuffer) {
    const buffer = attributeBuffer;
    if (buffer.glTarget === 34963) {
      throw new Error("Use .setIndexBuffer()");
    }
    const { size, type, stride, offset, normalized, integer, divisor } = this._getAccessor(location);
    this.device.gl.bindVertexArray(this.handle);
    this.device.gl.bindBuffer(34962, buffer.handle);
    if (integer) {
      this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
    } else {
      this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
    }
    this.device.gl.bindBuffer(34962, null);
    this.device.gl.enableVertexAttribArray(location);
    this.device.gl.vertexAttribDivisor(location, divisor || 0);
    this.attributes[location] = buffer;
    this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a constant value, disables the location */
  setConstantWebGL(location, value) {
    this._enable(location, false);
    this.attributes[location] = value;
  }
  bindBeforeRender() {
    this.device.gl.bindVertexArray(this.handle);
    this._applyConstantAttributes();
  }
  unbindAfterRender() {
    this.device.gl.bindVertexArray(null);
  }
  // Internal methods
  /**
   * Constant attributes need to be reset before every draw call
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @note Constant attributes are only supported in WebGL, not in WebGPU
   */
  _applyConstantAttributes() {
    for (let location = 0; location < this.maxVertexAttributes; ++location) {
      const constant = this.attributes[location];
      if (ArrayBuffer.isView(constant)) {
        this.device.setConstantAttributeWebGL(location, constant);
      }
    }
  }
  /**
   * Set a location in vertex attributes array to a buffer, enables the location, sets divisor
   * @note requires vertex array to be bound
   */
  // protected _setAttributeLayout(location: number): void {
  //   const {size, type, stride, offset, normalized, integer, divisor} = this._getAccessor(location);
  //   // WebGL2 supports *integer* data formats, i.e. GPU will see integer values
  //   if (integer) {
  //     this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
  //   } else {
  //     // Attaches ARRAY_BUFFER with specified buffer format to location
  //     this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
  //   }
  //   this.device.gl.vertexAttribDivisor(location, divisor || 0);
  // }
  /** Get an accessor from the  */
  _getAccessor(location) {
    const attributeInfo = this.attributeInfos[location];
    if (!attributeInfo) {
      throw new Error(`Unknown attribute location ${location}`);
    }
    const glType = getGLFromVertexType(attributeInfo.bufferDataType);
    return {
      size: attributeInfo.bufferComponents,
      type: glType,
      stride: attributeInfo.byteStride,
      offset: attributeInfo.byteOffset,
      normalized: attributeInfo.normalized,
      // it is the shader attribute declaration, not the vertex memory format,
      // that determines if the data in the buffer will be treated as integers.
      //
      // Also note that WebGL supports assigning non-normalized integer data to floating point attributes,
      // but as far as we can tell, WebGPU does not.
      integer: attributeInfo.integer,
      divisor: attributeInfo.stepMode === "instance" ? 1 : 0
    };
  }
  /**
   * Enabling an attribute location makes it reference the currently bound buffer
   * Disabling an attribute location makes it reference the global constant value
   * TODO - handle single values for size 1 attributes?
   * TODO - convert classic arrays based on known type?
   */
  _enable(location, enable2 = true) {
    const canDisableAttributeZero = _WEBGLVertexArray.isConstantAttributeZeroSupported(this.device);
    const canDisableAttribute = canDisableAttributeZero || location !== 0;
    if (enable2 || canDisableAttribute) {
      location = Number(location);
      this.device.gl.bindVertexArray(this.handle);
      if (enable2) {
        this.device.gl.enableVertexAttribArray(location);
      } else {
        this.device.gl.disableVertexAttribArray(location);
      }
      this.device.gl.bindVertexArray(null);
    }
  }
  /**
   * Provide a means to create a buffer that is equivalent to a constant.
   * NOTE: Desktop OpenGL cannot disable attribute 0.
   * https://stackoverflow.com/questions/20305231/webgl-warning-attribute-0-is-disabled-
   * this-has-significant-performance-penalty
   */
  getConstantBuffer(elementCount, value) {
    const constantValue = normalizeConstantArrayValue(value);
    const byteLength = constantValue.byteLength * elementCount;
    const length = constantValue.length * elementCount;
    if (this.buffer && byteLength !== this.buffer.byteLength) {
      throw new Error(`Buffer size is immutable, byte length ${byteLength} !== ${this.buffer.byteLength}.`);
    }
    let updateNeeded = !this.buffer;
    this.buffer = this.buffer || this.device.createBuffer({ byteLength });
    updateNeeded || (updateNeeded = !compareConstantArrayValues(constantValue, this.bufferValue));
    if (updateNeeded) {
      const typedArray = getScratchArray(value.constructor, length);
      fillArray({ target: typedArray, source: constantValue, start: 0, count: length });
      this.buffer.write(typedArray);
      this.bufferValue = value;
    }
    return this.buffer;
  }
};
function normalizeConstantArrayValue(arrayValue) {
  if (Array.isArray(arrayValue)) {
    return new Float32Array(arrayValue);
  }
  return arrayValue;
}
function compareConstantArrayValues(v1, v2) {
  if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
    return false;
  }
  for (let i = 0; i < v1.length; ++i) {
    if (v1[i] !== v2[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@luma.gl/webgl/dist/context/polyfills/polyfill-webgl1-extensions.js
var WEBGL1_STATIC_EXTENSIONS = {
  WEBGL_depth_texture: {
    UNSIGNED_INT_24_8_WEBGL: 34042
  },
  OES_element_index_uint: {},
  OES_texture_float: {},
  OES_texture_half_float: {
    // @ts-expect-error different numbers?
    HALF_FLOAT_OES: 5131
  },
  EXT_color_buffer_float: {},
  OES_standard_derivatives: {
    FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723
  },
  EXT_frag_depth: {},
  EXT_blend_minmax: {
    MIN_EXT: 32775,
    MAX_EXT: 32776
  },
  EXT_shader_texture_lod: {}
};
var getWEBGL_draw_buffers = (gl) => ({
  drawBuffersWEBGL(buffers) {
    return gl.drawBuffers(buffers);
  },
  COLOR_ATTACHMENT0_WEBGL: 36064,
  COLOR_ATTACHMENT1_WEBGL: 36065,
  COLOR_ATTACHMENT2_WEBGL: 36066,
  COLOR_ATTACHMENT3_WEBGL: 36067
});
var getOES_vertex_array_object = (gl) => ({
  VERTEX_ARRAY_BINDING_OES: 34229,
  createVertexArrayOES() {
    return gl.createVertexArray();
  },
  deleteVertexArrayOES(vertexArray) {
    return gl.deleteVertexArray(vertexArray);
  },
  isVertexArrayOES(vertexArray) {
    return gl.isVertexArray(vertexArray);
  },
  bindVertexArrayOES(vertexArray) {
    return gl.bindVertexArray(vertexArray);
  }
});
var getANGLE_instanced_arrays = (gl) => ({
  VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 35070,
  drawArraysInstancedANGLE(...args) {
    return gl.drawArraysInstanced(...args);
  },
  drawElementsInstancedANGLE(...args) {
    return gl.drawElementsInstanced(...args);
  },
  vertexAttribDivisorANGLE(...args) {
    return gl.vertexAttribDivisor(...args);
  }
});
function enforceWebGL2(enforce = true) {
  const prototype = HTMLCanvasElement.prototype;
  if (!enforce && prototype.originalGetContext) {
    prototype.getContext = prototype.originalGetContext;
    prototype.originalGetContext = void 0;
    return;
  }
  prototype.originalGetContext = prototype.getContext;
  prototype.getContext = function(contextId, options) {
    if (contextId === "webgl" || contextId === "experimental-webgl") {
      const context = this.originalGetContext("webgl2", options);
      if (context instanceof HTMLElement) {
        polyfillWebGL1Extensions(context);
      }
      return context;
    }
    return this.originalGetContext(contextId, options);
  };
}
function polyfillWebGL1Extensions(gl) {
  gl.getExtension("EXT_color_buffer_float");
  const boundExtensions = {
    ...WEBGL1_STATIC_EXTENSIONS,
    WEBGL_disjoint_timer_query: gl.getExtension("EXT_disjoint_timer_query_webgl2"),
    WEBGL_draw_buffers: getWEBGL_draw_buffers(gl),
    OES_vertex_array_object: getOES_vertex_array_object(gl),
    ANGLE_instanced_arrays: getANGLE_instanced_arrays(gl)
  };
  const originalGetExtension = gl.getExtension;
  gl.getExtension = function(extensionName) {
    const ext = originalGetExtension.call(gl, extensionName);
    if (ext) {
      return ext;
    }
    if (extensionName in boundExtensions) {
      return boundExtensions[extensionName];
    }
    return null;
  };
  const originalGetSupportedExtensions = gl.getSupportedExtensions;
  gl.getSupportedExtensions = function() {
    const extensions = originalGetSupportedExtensions.apply(gl) || [];
    return extensions == null ? void 0 : extensions.concat(Object.keys(boundExtensions));
  };
}

// node_modules/@luma.gl/webgl/dist/adapter/webgl-adapter.js
var LOG_LEVEL2 = 1;
var WebGLAdapter = class extends Adapter {
  constructor() {
    super();
    /** type of device's created by this adapter */
    __publicField(this, "type", "webgl");
    Device.defaultProps = { ...Device.defaultProps, ...DEFAULT_SPECTOR_PROPS };
  }
  /** Force any created WebGL contexts to be WebGL2 contexts, polyfilled with WebGL1 extensions */
  enforceWebGL2(enable2) {
    enforceWebGL2(enable2);
  }
  /** Check if WebGL 2 is available */
  isSupported() {
    return typeof WebGL2RenderingContext !== "undefined";
  }
  isDeviceHandle(handle) {
    if (typeof WebGL2RenderingContext !== "undefined" && handle instanceof WebGL2RenderingContext) {
      return true;
    }
    if (typeof WebGLRenderingContext !== "undefined" && handle instanceof WebGLRenderingContext) {
      log.warn("WebGL1 is not supported", handle)();
    }
    return false;
  }
  /**
   * Get a device instance from a GL context
   * Creates a WebGLCanvasContext against the contexts canvas
   * @note autoResize will be disabled, assuming that whoever created the external context will be handling resizes.
   * @param gl
   * @returns
   */
  async attach(gl, props = {}) {
    const { WebGLDevice: WebGLDevice2 } = await import("./webgl-device-GGAEDM3F.js");
    if (gl instanceof WebGLDevice2) {
      return gl;
    }
    if ((gl == null ? void 0 : gl.device) instanceof WebGLDevice2) {
      return gl.device;
    }
    if (!isWebGL(gl)) {
      throw new Error("Invalid WebGL2RenderingContext");
    }
    const createCanvasContext = props.createCanvasContext === true ? {} : props.createCanvasContext;
    return new WebGLDevice2({
      ...props,
      _handle: gl,
      createCanvasContext: { canvas: gl.canvas, autoResize: false, ...createCanvasContext }
    });
  }
  async create(props = {}) {
    const { WebGLDevice: WebGLDevice2 } = await import("./webgl-device-GGAEDM3F.js");
    log.groupCollapsed(LOG_LEVEL2, "WebGLDevice created")();
    try {
      const promises = [];
      if (props.debugWebGL || props.debug) {
        promises.push(loadWebGLDeveloperTools());
      }
      if (props.debugSpectorJS) {
        promises.push(loadSpectorJS(props));
      }
      const results = await Promise.allSettled(promises);
      for (const result of results) {
        if (result.status === "rejected") {
          log.error(`Failed to initialize debug libraries ${result.reason}`)();
        }
      }
      const device = new WebGLDevice2(props);
      const message2 = `${device._reused ? "Reusing" : "Created"} device with WebGL2 ${device.props.debug ? "debug " : ""}context: ${device.info.vendor}, ${device.info.renderer} for canvas: ${device.canvasContext.id}`;
      log.probe(LOG_LEVEL2, message2)();
      log.table(LOG_LEVEL2, device.info)();
      return device;
    } finally {
      log.groupEnd(LOG_LEVEL2)();
    }
  }
};
function isWebGL(gl) {
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && Number.isFinite(gl._version));
}
var webgl2Adapter = new WebGLAdapter();

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-transform-feedback.js
var WEBGLTransformFeedback = class extends TransformFeedback {
  constructor(device, props) {
    super(device, props);
    __publicField(this, "device");
    __publicField(this, "gl");
    __publicField(this, "handle");
    /**
     * NOTE: The Model already has this information while drawing, but
     * TransformFeedback currently needs it internally, to look up
     * varying information outside of a draw() call.
     */
    __publicField(this, "layout");
    __publicField(this, "buffers", {});
    __publicField(this, "unusedBuffers", {});
    /**
     * Allows us to avoid a Chrome bug where a buffer that is already bound to a
     * different target cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
     * This a major workaround, see: https://github.com/KhronosGroup/WebGL/issues/2346
     */
    __publicField(this, "bindOnUse", true);
    __publicField(this, "_bound", false);
    this.device = device;
    this.gl = device.gl;
    this.handle = this.props.handle || this.gl.createTransformFeedback();
    this.layout = this.props.layout;
    if (props.buffers) {
      this.setBuffers(props.buffers);
    }
    Object.seal(this);
  }
  destroy() {
    this.gl.deleteTransformFeedback(this.handle);
    super.destroy();
  }
  begin(topology = "point-list") {
    this.gl.bindTransformFeedback(36386, this.handle);
    if (this.bindOnUse) {
      this._bindBuffers();
    }
    this.gl.beginTransformFeedback(getGLPrimitive(topology));
  }
  end() {
    this.gl.endTransformFeedback();
    if (this.bindOnUse) {
      this._unbindBuffers();
    }
    this.gl.bindTransformFeedback(36386, null);
  }
  // SUBCLASS
  setBuffers(buffers) {
    this.buffers = {};
    this.unusedBuffers = {};
    this.bind(() => {
      for (const bufferName in buffers) {
        this.setBuffer(bufferName, buffers[bufferName]);
      }
    });
  }
  setBuffer(locationOrName, bufferOrRange) {
    const location = this._getVaryingIndex(locationOrName);
    const { buffer, byteLength, byteOffset } = this._getBufferRange(bufferOrRange);
    if (location < 0) {
      this.unusedBuffers[locationOrName] = buffer;
      log.warn(`${this.id} unusedBuffers varying buffer ${locationOrName}`)();
      return;
    }
    this.buffers[location] = { buffer, byteLength, byteOffset };
    if (!this.bindOnUse) {
      this._bindBuffer(location, buffer, byteOffset, byteLength);
    }
  }
  getBuffer(locationOrName) {
    if (isIndex(locationOrName)) {
      return this.buffers[locationOrName] || null;
    }
    const location = this._getVaryingIndex(locationOrName);
    return location >= 0 ? this.buffers[location] : null;
  }
  bind(funcOrHandle = this.handle) {
    if (typeof funcOrHandle !== "function") {
      this.gl.bindTransformFeedback(36386, funcOrHandle);
      return this;
    }
    let value;
    if (!this._bound) {
      this.gl.bindTransformFeedback(36386, this.handle);
      this._bound = true;
      value = funcOrHandle();
      this._bound = false;
      this.gl.bindTransformFeedback(36386, null);
    } else {
      value = funcOrHandle();
    }
    return value;
  }
  unbind() {
    this.bind(null);
  }
  // PRIVATE METHODS
  /** Extract offsets for bindBufferRange */
  _getBufferRange(bufferOrRange) {
    if (bufferOrRange instanceof WEBGLBuffer) {
      return { buffer: bufferOrRange, byteOffset: 0, byteLength: bufferOrRange.byteLength };
    }
    const { buffer, byteOffset = 0, byteLength = bufferOrRange.buffer.byteLength } = bufferOrRange;
    return { buffer, byteOffset, byteLength };
  }
  _getVaryingIndex(locationOrName) {
    if (isIndex(locationOrName)) {
      return Number(locationOrName);
    }
    for (const varying of this.layout.varyings || []) {
      if (locationOrName === varying.name) {
        return varying.location;
      }
    }
    return -1;
  }
  /**
   * Need to avoid chrome bug where buffer that is already bound to a different target
   * cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
   */
  _bindBuffers() {
    for (const bufferIndex in this.buffers) {
      const { buffer, byteLength, byteOffset } = this._getBufferRange(this.buffers[bufferIndex]);
      this._bindBuffer(Number(bufferIndex), buffer, byteOffset, byteLength);
    }
  }
  _unbindBuffers() {
    for (const bufferIndex in this.buffers) {
      this.gl.bindBufferBase(35982, Number(bufferIndex), null);
    }
  }
  _bindBuffer(index, buffer, byteOffset = 0, byteLength) {
    const handle = buffer && buffer.handle;
    if (!handle || byteLength === void 0) {
      this.gl.bindBufferBase(35982, index, handle);
    } else {
      this.gl.bindBufferRange(35982, index, handle, byteOffset, byteLength);
    }
  }
};
function isIndex(value) {
  if (typeof value === "number") {
    return Number.isInteger(value);
  }
  return /^\d+$/.test(value);
}

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-query-set.js
var WEBGLQuerySet = class extends QuerySet {
  // Create a query class
  constructor(device, props) {
    super(device, props);
    __publicField(this, "device");
    __publicField(this, "handle");
    __publicField(this, "target", null);
    __publicField(this, "_queryPending", false);
    __publicField(this, "_pollingPromise", null);
    this.device = device;
    if (props.count > 1) {
      throw new Error("WebGL QuerySet can only have one value");
    }
    const handle = this.device.gl.createQuery();
    if (!handle) {
      throw new Error("WebGL query not supported");
    }
    this.handle = handle;
    Object.seal(this);
  }
  get [Symbol.toStringTag]() {
    return "Query";
  }
  destroy() {
    this.device.gl.deleteQuery(this.handle);
  }
  // FOR RENDER PASS AND COMMAND ENCODER
  /**
   * Shortcut for timer query (dependent on extension in both WebGL1 and 2)
   * Measures GPU time delta between this call and a matching `end` call in the
   * GPU instruction stream.
   */
  beginTimestampQuery() {
    return this._begin(35007);
  }
  endTimestampQuery() {
    this._end();
  }
  // Shortcut for occlusion queries
  beginOcclusionQuery(options) {
    return this._begin((options == null ? void 0 : options.conservative) ? 36202 : 35887);
  }
  endOcclusionQuery() {
    this._end();
  }
  // Shortcut for transformFeedbackQuery
  beginTransformFeedbackQuery() {
    return this._begin(35976);
  }
  endTransformFeedbackQuery() {
    this._end();
  }
  async resolveQuery() {
    const value = await this.pollQuery();
    return [value];
  }
  // PRIVATE METHODS
  /**
   * Due to OpenGL API limitations, after calling `begin()` on one Query
   * instance, `end()` must be called on that same instance before
   * calling `begin()` on another query. While there can be multiple
   * outstanding queries representing disjoint `begin()`/`end()` intervals.
   * It is not possible to interleave or overlap `begin` and `end` calls.
   */
  _begin(target2) {
    if (this._queryPending) {
      return;
    }
    this.target = target2;
    this.device.gl.beginQuery(this.target, this.handle);
    return;
  }
  // ends the current query
  _end() {
    if (this._queryPending) {
      return;
    }
    if (this.target) {
      this.device.gl.endQuery(this.target);
      this.target = null;
      this._queryPending = true;
    }
    return;
  }
  // Returns true if the query result is available
  isResultAvailable() {
    if (!this._queryPending) {
      return false;
    }
    const resultAvailable = this.device.gl.getQueryParameter(this.handle, 34919);
    if (resultAvailable) {
      this._queryPending = false;
    }
    return resultAvailable;
  }
  // Timing query is disjoint, i.e. results are invalid
  isTimerDisjoint() {
    return this.device.gl.getParameter(36795);
  }
  // Returns query result.
  getResult() {
    return this.device.gl.getQueryParameter(this.handle, 34918);
  }
  // Returns the query result, converted to milliseconds to match JavaScript conventions.
  getTimerMilliseconds() {
    return this.getResult() / 1e6;
  }
  // Polls the query
  pollQuery(limit = Number.POSITIVE_INFINITY) {
    if (this._pollingPromise) {
      return this._pollingPromise;
    }
    let counter = 0;
    this._pollingPromise = new Promise((resolve, reject) => {
      const poll = () => {
        if (this.isResultAvailable()) {
          resolve(this.getResult());
          this._pollingPromise = null;
        } else if (counter++ > limit) {
          reject("Timed out");
          this._pollingPromise = null;
        } else {
          requestAnimationFrame(poll);
        }
      };
      requestAnimationFrame(poll);
    });
    return this._pollingPromise;
  }
};

// node_modules/@luma.gl/webgl/dist/adapter/helpers/format-utils.js
function glFormatToComponents(format) {
  switch (format) {
    case 6406:
    case 33326:
    case 6403:
    case 36244:
      return 1;
    case 33339:
    case 33340:
    case 33328:
    case 33320:
    case 33319:
      return 2;
    case 6407:
    case 36248:
    case 34837:
      return 3;
    case 6408:
    case 36249:
    case 34836:
      return 4;
    default:
      return 0;
  }
}
function glTypeToBytes(type) {
  switch (type) {
    case 5121:
      return 1;
    case 33635:
    case 32819:
    case 32820:
      return 2;
    case 5126:
      return 4;
    default:
      return 0;
  }
}

// node_modules/@luma.gl/webgl/dist/adapter/converters/shader-formats.js
function convertGLDataTypeToDataType(type) {
  return GL_DATA_TYPE_MAP[type];
}
var GL_DATA_TYPE_MAP = {
  [5124]: "sint32",
  [5125]: "uint32",
  [5122]: "sint16",
  [5123]: "uint16",
  [5120]: "sint8",
  [5121]: "uint8",
  [5126]: "float32",
  [5131]: "float16",
  [33635]: "uint16",
  [32819]: "uint16",
  [32820]: "uint16",
  [33640]: "uint32",
  [35899]: "uint32",
  [35902]: "uint32",
  [34042]: "uint32",
  [36269]: "uint32"
};

// node_modules/@luma.gl/webgl/dist/adapter/helpers/webgl-texture-utils.js
function readPixelsToArray(source, options) {
  var _a;
  const {
    sourceX = 0,
    sourceY = 0,
    sourceAttachment = 0
    // TODO - support gl.readBuffer
  } = options || {};
  let {
    target: target2 = null,
    // following parameters are auto deduced if not provided
    sourceWidth,
    sourceHeight,
    sourceDepth,
    sourceFormat,
    sourceType
  } = options || {};
  const { framebuffer, deleteFramebuffer } = getFramebuffer2(source);
  const { gl, handle } = framebuffer;
  sourceWidth || (sourceWidth = framebuffer.width);
  sourceHeight || (sourceHeight = framebuffer.height);
  const texture = (_a = framebuffer.colorAttachments[sourceAttachment]) == null ? void 0 : _a.texture;
  if (!texture) {
    throw new Error(`Invalid framebuffer attachment ${sourceAttachment}`);
  }
  sourceDepth = (texture == null ? void 0 : texture.depth) || 1;
  sourceFormat || (sourceFormat = (texture == null ? void 0 : texture.glFormat) || 6408);
  sourceType || (sourceType = (texture == null ? void 0 : texture.glType) || 5121);
  target2 = getPixelArray(target2, sourceType, sourceFormat, sourceWidth, sourceHeight, sourceDepth);
  const signedType = getDataType(target2);
  sourceType = sourceType || convertDataTypeToGLDataType(signedType);
  const prevHandle = gl.bindFramebuffer(36160, handle);
  gl.readBuffer(36064 + sourceAttachment);
  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target2);
  gl.readBuffer(36064);
  gl.bindFramebuffer(36160, prevHandle || null);
  if (deleteFramebuffer) {
    framebuffer.destroy();
  }
  return target2;
}
function readPixelsToBuffer(source, options) {
  const { target: target2, sourceX = 0, sourceY = 0, sourceFormat = 6408, targetByteOffset = 0 } = options || {};
  let { sourceWidth, sourceHeight, sourceType } = options || {};
  const { framebuffer, deleteFramebuffer } = getFramebuffer2(source);
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;
  const webglFramebuffer = framebuffer;
  sourceType = sourceType || 5121;
  let webglBufferTarget = target2;
  if (!webglBufferTarget) {
    const components = glFormatToComponents(sourceFormat);
    const byteCount = glTypeToBytes(sourceType);
    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
    webglBufferTarget = webglFramebuffer.device.createBuffer({ byteLength });
  }
  const commandEncoder = source.device.createCommandEncoder();
  commandEncoder.copyTextureToBuffer({
    sourceTexture: source,
    width: sourceWidth,
    height: sourceHeight,
    origin: [sourceX, sourceY],
    destinationBuffer: webglBufferTarget,
    byteOffset: targetByteOffset
  });
  commandEncoder.destroy();
  if (deleteFramebuffer) {
    framebuffer.destroy();
  }
  return webglBufferTarget;
}
function getFramebuffer2(source) {
  if (!(source instanceof Framebuffer)) {
    return { framebuffer: toFramebuffer(source), deleteFramebuffer: true };
  }
  return { framebuffer: source, deleteFramebuffer: false };
}
function toFramebuffer(texture, props) {
  const { device, width, height, id } = texture;
  const framebuffer = device.createFramebuffer({
    ...props,
    id: `framebuffer-for-${id}`,
    width,
    height,
    colorAttachments: [texture]
  });
  return framebuffer;
}
function getPixelArray(pixelArray, glType, glFormat, width, height, depth) {
  if (pixelArray) {
    return pixelArray;
  }
  glType || (glType = 5121);
  const shaderType = convertGLDataTypeToDataType(glType);
  const ArrayType = getTypedArrayConstructor(shaderType);
  const components = glFormatToComponents(glFormat);
  return new ArrayType(width * height * components);
}

// node_modules/@luma.gl/webgl/dist/adapter/webgl-device.js
var WebGLDevice = class extends Device {
  constructor(props) {
    var _a, _b;
    super({ ...props, id: props.id || uid2("webgl-device") });
    // Public `Device` API
    /** type of this device */
    __publicField(this, "type", "webgl");
    // Use the ! assertion to handle the case where _reuseDevices causes the constructor to return early
    /** The underlying WebGL context */
    __publicField(this, "handle");
    __publicField(this, "features");
    __publicField(this, "limits");
    __publicField(this, "info");
    __publicField(this, "canvasContext");
    __publicField(this, "preferredColorFormat", "rgba8unorm");
    __publicField(this, "preferredDepthFormat", "depth24plus");
    __publicField(this, "commandEncoder");
    __publicField(this, "lost");
    __publicField(this, "_resolveContextLost");
    /** WebGL2 context. */
    __publicField(this, "gl");
    /** Store constants */
    // @ts-ignore TODO fix
    __publicField(this, "_constants");
    /** State used by luma.gl classes - TODO - not used? */
    __publicField(this, "_extensions", {});
    __publicField(this, "_polyfilled", false);
    /** Instance of Spector.js (if initialized) */
    __publicField(this, "spectorJS");
    const canvasContextProps = Device._getCanvasContextProps(props);
    if (!canvasContextProps) {
      throw new Error("WebGLDevice requires props.createCanvasContext to be set");
    }
    let device = (_b = (_a = canvasContextProps.canvas) == null ? void 0 : _a.gl) == null ? void 0 : _b.device;
    if (device) {
      throw new Error(`WebGL context already attached to device ${device.id}`);
    }
    this.canvasContext = new WebGLCanvasContext(this, canvasContextProps);
    this.lost = new Promise((resolve) => {
      this._resolveContextLost = resolve;
    });
    const webglContextAttributes = { ...props.webgl };
    if (canvasContextProps.alphaMode === "premultiplied") {
      webglContextAttributes.premultipliedAlpha = true;
    }
    if (props.powerPreference !== void 0) {
      webglContextAttributes.powerPreference = props.powerPreference;
    }
    const externalGLContext = this.props._handle;
    const gl = externalGLContext || createBrowserContext(this.canvasContext.canvas, {
      onContextLost: (event) => {
        var _a2;
        return (_a2 = this._resolveContextLost) == null ? void 0 : _a2.call(this, {
          reason: "destroyed",
          message: "Entered sleep mode, or too many apps or browser tabs are using the GPU."
        });
      },
      // eslint-disable-next-line no-console
      onContextRestored: (event) => console.log("WebGL context restored")
    }, webglContextAttributes);
    if (!gl) {
      throw new Error("WebGL context creation failed");
    }
    device = gl.device;
    if (device) {
      if (props._reuseDevices) {
        log.log(1, `Not creating a new Device, instead returning a reference to Device ${device.id} already attached to WebGL context`, device)();
        device._reused = true;
        return device;
      }
      throw new Error(`WebGL context already attached to device ${device.id}`);
    }
    this.handle = gl;
    this.gl = gl;
    this.spectorJS = initializeSpectorJS({ ...this.props, gl: this.handle });
    this.gl.device = this;
    this.gl._version = 2;
    this.info = getDeviceInfo(this.gl, this._extensions);
    this.limits = new WebGLDeviceLimits(this.gl);
    this.features = new WebGLDeviceFeatures(this.gl, this._extensions, this.props._disabledFeatures);
    if (this.props._initializeFeatures) {
      this.features.initializeFeatures();
    }
    const glState = new WebGLStateTracker(this.gl, {
      log: (...args) => log.log(1, ...args)()
    });
    glState.trackState(this.gl, { copyState: false });
    const debugWebGL = props.debugWebGL || props.debug;
    const traceWebGL = props.debugWebGL;
    if (debugWebGL) {
      this.gl = makeDebugContext(this.gl, { debugWebGL, traceWebGL });
      log.warn("WebGL debug mode activated. Performance reduced.")();
      if (props.debugWebGL) {
        log.level = Math.max(log.level, 1);
      }
    }
    this.commandEncoder = new WEBGLCommandEncoder(this, { id: `${this}-command-encoder` });
  }
  //
  // Public API
  //
  get [Symbol.toStringTag]() {
    return "WebGLDevice";
  }
  toString() {
    return `${this[Symbol.toStringTag]}(${this.id})`;
  }
  isVertexFormatSupported(format) {
    switch (format) {
      case "unorm8x4-bgra":
        return false;
      default:
        return true;
    }
  }
  /**
   * Destroys the device
   *
   * @note "Detaches" from the WebGL context unless _reuseDevices is true.
   *
   * @note The underlying WebGL context is not immediately destroyed,
   * but may be destroyed later through normal JavaScript garbage collection.
   * This is a fundamental limitation since WebGL does not offer any
   * browser API for destroying WebGL contexts.
   */
  destroy() {
    if (!this.props._reuseDevices && !this._reused) {
      delete this.gl.device;
    }
  }
  get isLost() {
    return this.gl.isContextLost();
  }
  // IMPLEMENTATION OF ABSTRACT DEVICE
  getTextureByteAlignment() {
    return 4;
  }
  createCanvasContext(props) {
    throw new Error("WebGL only supports a single canvas");
  }
  createBuffer(props) {
    const newProps = this._normalizeBufferProps(props);
    return new WEBGLBuffer(this, newProps);
  }
  createTexture(props) {
    return new WEBGLTexture(this, props);
  }
  createExternalTexture(props) {
    throw new Error("createExternalTexture() not implemented");
  }
  createSampler(props) {
    return new WEBGLSampler(this, props);
  }
  createShader(props) {
    return new WEBGLShader(this, props);
  }
  createFramebuffer(props) {
    return new WEBGLFramebuffer(this, props);
  }
  createVertexArray(props) {
    return new WEBGLVertexArray(this, props);
  }
  createTransformFeedback(props) {
    return new WEBGLTransformFeedback(this, props);
  }
  createQuerySet(props) {
    return new WEBGLQuerySet(this, props);
  }
  createRenderPipeline(props) {
    return new WEBGLRenderPipeline(this, props);
  }
  createComputePipeline(props) {
    throw new Error("ComputePipeline not supported in WebGL");
  }
  createCommandEncoder(props = {}) {
    return new WEBGLCommandEncoder(this, props);
  }
  /**
   * Offscreen Canvas Support: Commit the frame
   * https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/commit
   * Chrome's offscreen canvas does not require gl.commit
   */
  submit(commandBuffer) {
    if (!commandBuffer) {
      commandBuffer = this.commandEncoder.finish();
      this.commandEncoder.destroy();
      this.commandEncoder = this.createCommandEncoder({ id: `${this.id}-default-encoder` });
    }
    commandBuffer._executeCommands();
  }
  //
  // TEMPORARY HACKS - will be removed in v9.1
  //
  /** @deprecated - should use command encoder */
  readPixelsToArrayWebGL(source, options) {
    return readPixelsToArray(source, options);
  }
  /** @deprecated - should use command encoder */
  readPixelsToBufferWebGL(source, options) {
    return readPixelsToBuffer(source, options);
  }
  setParametersWebGL(parameters) {
    setGLParameters(this.gl, parameters);
  }
  getParametersWebGL(parameters) {
    return getGLParameters(this.gl, parameters);
  }
  withParametersWebGL(parameters, func) {
    return withGLParameters(this.gl, parameters, func);
  }
  resetWebGL() {
    log.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")();
    resetGLParameters(this.gl);
  }
  _getDeviceSpecificTextureFormatCapabilities(capabilities) {
    return getTextureFormatCapabilitiesWebGL(this.gl, capabilities, this._extensions);
  }
  //
  // WebGL-only API (not part of `Device` API)
  //
  /**
   * Triggers device (or WebGL context) loss.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    var _a;
    let deviceLossTriggered = false;
    const extensions = this.getExtension("WEBGL_lose_context");
    const ext = extensions.WEBGL_lose_context;
    if (ext) {
      deviceLossTriggered = true;
      ext.loseContext();
    }
    (_a = this._resolveContextLost) == null ? void 0 : _a.call(this, {
      reason: "destroyed",
      message: "Application triggered context loss"
    });
    return deviceLossTriggered;
  }
  /** Save current WebGL context state onto an internal stack */
  pushState() {
    const webglState = WebGLStateTracker.get(this.gl);
    webglState.push();
  }
  /** Restores previously saved context state */
  popState() {
    const webglState = WebGLStateTracker.get(this.gl);
    webglState.pop();
  }
  /**
   * Returns the GL.<KEY> constant that corresponds to a numeric value of a GL constant
   * Be aware that there are some duplicates especially for constants that are 0,
   * so this isn't guaranteed to return the right key in all cases.
   */
  getGLKey(value, options) {
    const number = Number(value);
    for (const key in this.gl) {
      if (this.gl[key] === number) {
        return `GL.${key}`;
      }
    }
    return (options == null ? void 0 : options.emptyIfUnknown) ? "" : String(value);
  }
  /**
   * Returns a map with any GL.<KEY> constants mapped to strings, both for keys and values
   */
  getGLKeys(glParameters) {
    const opts = { emptyIfUnknown: true };
    return Object.entries(glParameters).reduce((keys, [key, value]) => {
      keys[`${key}:${this.getGLKey(key, opts)}`] = `${value}:${this.getGLKey(value, opts)}`;
      return keys;
    }, {});
  }
  /**
   * Set a constant value for a location. Disabled attributes at that location will read from this value
   * @note WebGL constants are stored globally on the WebGL context, not the VertexArray
   * so they need to be updated before every render
   * @todo - remember/cache values to avoid setting them unnecessarily?
   */
  setConstantAttributeWebGL(location, constant) {
    const maxVertexAttributes = this.limits.maxVertexAttributes;
    this._constants = this._constants || new Array(maxVertexAttributes).fill(null);
    const currentConstant = this._constants[location];
    if (currentConstant && compareConstantArrayValues2(currentConstant, constant)) {
      log.info(1, `setConstantAttributeWebGL(${location}) could have been skipped, value unchanged`)();
    }
    this._constants[location] = constant;
    switch (constant.constructor) {
      case Float32Array:
        setConstantFloatArray(this, location, constant);
        break;
      case Int32Array:
        setConstantIntArray(this, location, constant);
        break;
      case Uint32Array:
        setConstantUintArray(this, location, constant);
        break;
      default:
        throw new Error("constant");
    }
  }
  /** Ensure extensions are only requested once */
  getExtension(name2) {
    getWebGLExtension(this.gl, name2, this._extensions);
    return this._extensions;
  }
  // INTERNAL SUPPORT METHODS FOR WEBGL RESOURCES
  /**
   * Storing data on a special field on WebGLObjects makes that data visible in SPECTOR chrome debug extension
   * luma.gl ids and props can be inspected
   */
  _setWebGLDebugMetadata(handle, resource, options) {
    handle.luma = resource;
    const spectorMetadata = { props: options.spector, id: options.spector["id"] };
    handle.__SPECTOR_Metadata = spectorMetadata;
  }
};
function setConstantFloatArray(device, location, array) {
  switch (array.length) {
    case 1:
      device.gl.vertexAttrib1fv(location, array);
      break;
    case 2:
      device.gl.vertexAttrib2fv(location, array);
      break;
    case 3:
      device.gl.vertexAttrib3fv(location, array);
      break;
    case 4:
      device.gl.vertexAttrib4fv(location, array);
      break;
    default:
  }
}
function setConstantIntArray(device, location, array) {
  device.gl.vertexAttribI4iv(location, array);
}
function setConstantUintArray(device, location, array) {
  device.gl.vertexAttribI4uiv(location, array);
}
function compareConstantArrayValues2(v1, v2) {
  if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
    return false;
  }
  for (let i = 0; i < v1.length; ++i) {
    if (v1[i] !== v2[i]) {
      return false;
    }
  }
  return true;
}

export {
  Log,
  Stats,
  log,
  Buffer,
  getDataType,
  getTypedArrayConstructor,
  getVertexFormatFromAttribute,
  luma,
  Sampler,
  Texture,
  TextureView,
  Shader,
  RenderPipeline,
  ComputePipeline,
  getAttributeInfosFromLayouts,
  UniformStore,
  WebGLDevice,
  webgl2Adapter
};
//# sourceMappingURL=chunk-DMWPRPWZ.js.map
